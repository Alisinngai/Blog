{"meta":{"version":1,"warehouse":"4.0.2"},"models":{"Asset":[{"_id":"themes/butterfly/source/img/404.jpg","path":"img/404.jpg","modified":1,"renderable":1},{"_id":"themes/butterfly/source/img/favicon.png","path":"img/favicon.png","modified":1,"renderable":1},{"_id":"themes/butterfly/source/img/friend_404.gif","path":"img/friend_404.gif","modified":1,"renderable":1},{"_id":"themes/butterfly/source/js/main.js","path":"js/main.js","modified":1,"renderable":1},{"_id":"themes/butterfly/source/css/index.styl","path":"css/index.styl","modified":1,"renderable":1},{"_id":"themes/butterfly/source/css/var.styl","path":"css/var.styl","modified":1,"renderable":1},{"_id":"themes/butterfly/source/js/tw_cn.js","path":"js/tw_cn.js","modified":1,"renderable":1},{"_id":"themes/butterfly/source/js/utils.js","path":"js/utils.js","modified":1,"renderable":1},{"_id":"themes/butterfly/source/js/search/algolia.js","path":"js/search/algolia.js","modified":1,"renderable":1},{"_id":"themes/butterfly/source/js/search/local-search.js","path":"js/search/local-search.js","modified":1,"renderable":1},{"_id":"source/img/minio/minio.svg","path":"img/minio/minio.svg","modified":1,"renderable":0},{"_id":"source/img/home/Alisinngai Lynn Home page image.jpg","path":"img/home/Alisinngai Lynn Home page image.jpg","modified":1,"renderable":0},{"_id":"source/img/home/homePageImage_01.webp","path":"img/home/homePageImage_01.webp","modified":1,"renderable":0},{"_id":"source/img/Java/Thread/Thread.svg","path":"img/Java/Thread/Thread.svg","modified":1,"renderable":0}],"Cache":[{"_id":"source/_posts/2021-04-14-Java8新特性.md","hash":"f279b63a22e592a59a26b17b3158edb1174fa876","modified":1713105183956},{"_id":"source/_posts/2023-08-10-CompletableFuture的使用.md","hash":"e6370ffcdc7d67a62f192529507ddcd38d8981d0","modified":1713018352438},{"_id":"source/_posts/2024-04-21-设计模式-01.设计思想.md","hash":"cca292377c704c2063258958dc720d7f7805ad94","modified":1714541379556},{"_id":"source/_posts/2024-04-13-单节点单硬盘部署MinIO.md","hash":"5da5218b50729ff2a3eb761386921c20af52e873","modified":1713018448772},{"_id":"source/_posts/2024-05-01-设计模式-02.经典设计原则-第二节[必读].md","hash":"bd164e52b34e5209e873adecc15d48c6229ca0be","modified":1714541319562},{"_id":"source/img/minio/minio.svg","hash":"283133390bffe6ded2a4ca732b6b1f259270e7c6","modified":1713018435644},{"_id":"source/_posts/2024-06-18-设计模式-03.02-创建型-工厂&建造者&原型.md","hash":"4dfb76fd54389b78efbe0b17128aba49ac88c5d7","modified":1718688321165},{"_id":"source/_posts/2024-05-11-设计模式-03.01-创建型-单例.md","hash":"c5c62ea565ceb15aad2a3476d0e5444becccf013","modified":1715436408257},{"_id":"source/img/home/homePageImage_01.webp","hash":"f384889a2089e35f5989d2857a96a1cb7c79decf","modified":1713022157558},{"_id":"source/img/Java/Thread/Thread.svg","hash":"2d6bd166c0c268a795256d212dc0bfce6f93004a","modified":1713018282072},{"_id":"themes/butterfly/LICENSE","hash":"c8bc7df08db9dd3b39c2c2259a163a36cf2f6808","modified":1712942298256},{"_id":"themes/butterfly/README.md","hash":"20a91bea7f7ada8b8195d2abff106a7ce21bba20","modified":1712942298259},{"_id":"themes/butterfly/README_CN.md","hash":"9d729ee2ffc5e5f703ccfbfbbb7b286d59071125","modified":1712942298260},{"_id":"themes/butterfly/_config.yml","hash":"c6fab3700a6502b5790ca20d20113020544ea048","modified":1712942298263},{"_id":"themes/butterfly/package.json","hash":"2b6fb6f62b9fa6a829311ffd532ae760fbd0a7db","modified":1712942298479},{"_id":"themes/butterfly/.github/FUNDING.yml","hash":"3b572099a992e30267f5fe4cd3c582ff7ac9f083","modified":1712942298241},{"_id":"themes/butterfly/plugins.yml","hash":"7bb2c7350c0c57850aa30213cd0f26553a614702","modified":1712942298481},{"_id":"themes/butterfly/languages/default.yml","hash":"90e9e2f36dc51aa77eb7804ae048b4876035b12d","modified":1712942298266},{"_id":"themes/butterfly/languages/zh-CN.yml","hash":"2dcc70a011b37890215ae0fd6d8f8c78aa8af6b0","modified":1712942298270},{"_id":"themes/butterfly/layout/category.pug","hash":"bf979aec88d78b644fc5d31518f8679ad7625792","modified":1712942298277},{"_id":"themes/butterfly/languages/en.yml","hash":"68127be0e6b44cfc5f31353d8b275c02939b3ff9","modified":1712942298268},{"_id":"themes/butterfly/languages/zh-TW.yml","hash":"1392e7b8c678cdfb54f55523693e66abc7d80538","modified":1712942298272},{"_id":"themes/butterfly/layout/archive.pug","hash":"bc77220dfc269b8faad0930e1a4142ebf68165e5","modified":1712942298276},{"_id":"themes/butterfly/layout/index.pug","hash":"648dcbdb3d145a710de81c909e000e8664d2ac9c","modified":1712942298472},{"_id":"themes/butterfly/layout/page.pug","hash":"bf2d6c6d2d156777b55292e51be02b0b3acf0af8","modified":1712942298474},{"_id":"themes/butterfly/.github/ISSUE_TEMPLATE/bug_report.yml","hash":"eed9190301095b35081aa2658204cc3f15b9f5e1","modified":1712942298245},{"_id":"themes/butterfly/layout/tag.pug","hash":"4bb5efc6dabdf1626685bf6771aaa1467155ae86","modified":1712942298478},{"_id":"themes/butterfly/layout/post.pug","hash":"fdbb508b5e6dec30fb8753c5a7fdd494410c4fc0","modified":1712942298476},{"_id":"themes/butterfly/.github/ISSUE_TEMPLATE/config.yml","hash":"63ad2249ad09fb3fe21bd5ff9adefb304a7ab24a","modified":1712942298247},{"_id":"themes/butterfly/.github/ISSUE_TEMPLATE/feature_request.yml","hash":"6e0f9470b18bd37d4891282ac73d61676b040e8c","modified":1712942298249},{"_id":"themes/butterfly/.github/workflows/publish.yml","hash":"e320b40c051bae1549156cd5ea4a51383cf78598","modified":1712942298252},{"_id":"themes/butterfly/.github/workflows/stale.yml","hash":"4040c76547e270aaf184e9b219a44ca41bbb1b9f","modified":1712942298254},{"_id":"themes/butterfly/layout/includes/404.pug","hash":"aace9ddff469de4226e47a52ede1c81e66d66d5c","modified":1712942298280},{"_id":"themes/butterfly/layout/includes/footer.pug","hash":"8715948b93e7508b84d913be1969b28c6b067b9b","modified":1712942298283},{"_id":"themes/butterfly/layout/includes/head.pug","hash":"ea8d4e8ac6af93cd268ba8f6ffcb80417bc2501e","modified":1712942298285},{"_id":"themes/butterfly/layout/includes/layout.pug","hash":"96df62e34661d8ca4a45267286127479e5178a79","modified":1712942298313},{"_id":"themes/butterfly/layout/includes/additional-js.pug","hash":"50eea5aa78cdeb6c72dd22f0aeabc407cc0f712e","modified":1712942298281},{"_id":"themes/butterfly/layout/includes/pagination.pug","hash":"c5c58714fb3cb839653e5c32e6094784c8662935","modified":1712942298334},{"_id":"themes/butterfly/scripts/events/comment.js","hash":"95479790234c291b064d031577d71214cdd1d820","modified":1712942298489},{"_id":"themes/butterfly/scripts/events/404.js","hash":"f1d1c378356b776e9b2a8411e6dca88dc8c3245c","modified":1712942298485},{"_id":"themes/butterfly/scripts/events/cdn.js","hash":"7864ba45716c51aef8d8b04fd4bc212e0008ce3b","modified":1712942298487},{"_id":"themes/butterfly/layout/includes/rightside.pug","hash":"f448bf73103b88de4443e52d600e871cf3de3e32","modified":1712942298340},{"_id":"themes/butterfly/scripts/events/init.js","hash":"ce68e84a9ccfcf91100befbaa9afc392a0cd93bb","modified":1712942298491},{"_id":"themes/butterfly/layout/includes/sidebar.pug","hash":"9277fead4c29dbe93976f078adaa26e8f9253da3","modified":1712942298342},{"_id":"themes/butterfly/scripts/helpers/aside_archives.js","hash":"4f712b4ea383b59a3122683db1d54c04a79ccc5d","modified":1712942298506},{"_id":"themes/butterfly/scripts/events/stylus.js","hash":"0a336dfe5ed08952fa0df1532421df38a74a20d6","modified":1712942298495},{"_id":"themes/butterfly/scripts/events/merge_config.js","hash":"b1dfc3c898b886eab1241b068fc27d7a26a3b7d2","modified":1712942298493},{"_id":"themes/butterfly/scripts/filters/post_lazyload.js","hash":"5ed2d7ef240c927fe1b7a7fb5bf9e55e2bfd55a5","modified":1712942298500},{"_id":"themes/butterfly/scripts/events/welcome.js","hash":"f59e10305fef59ea3e62a7395106c0927582879d","modified":1712942298497},{"_id":"themes/butterfly/scripts/filters/random_cover.js","hash":"0df22d7dbfa766a65cb6032a1f003348f4307cfe","modified":1712942298502},{"_id":"themes/butterfly/scripts/helpers/aside_categories.js","hash":"cdd992c8577d583c237b6aac9f5077d8200879b2","modified":1712942298509},{"_id":"themes/butterfly/scripts/helpers/findArchiveLength.js","hash":"b12895e0765d596494e5526d121de0dd5a7c23d3","modified":1712942298511},{"_id":"themes/butterfly/scripts/helpers/inject_head_js.js","hash":"b55f71347d2ead097c7f98c0ec792b091433345c","modified":1712942298513},{"_id":"themes/butterfly/scripts/helpers/page.js","hash":"c74d6a9b8f71e69447f7847a5f5e81555d68b140","modified":1712942298515},{"_id":"themes/butterfly/scripts/tag/flink.js","hash":"3ba7677969ff01fab06fc6713455ddc6861f0024","modified":1712942298523},{"_id":"themes/butterfly/scripts/helpers/related_post.js","hash":"76343ac8422c9c8539082e77eda6ffee4b877eb2","modified":1712942298517},{"_id":"themes/butterfly/scripts/helpers/series.js","hash":"17c0095bc8d612a268cdcab000b1742dc4c6f811","modified":1712942298518},{"_id":"themes/butterfly/scripts/tag/gallery.js","hash":"7ec77b3093f5de67e7032f40a5b12f1389f6f6ff","modified":1712942298525},{"_id":"themes/butterfly/scripts/tag/button.js","hash":"164d5f1c2d1b4cb5a813a6fc574016743a53c019","modified":1712942298521},{"_id":"themes/butterfly/scripts/tag/mermaid.js","hash":"289f85847c58f0b2b7d98a68e370a2896edb8949","modified":1712942298531},{"_id":"themes/butterfly/scripts/tag/inlineImg.js","hash":"c863d2732ce4bdc084f2d0db92f50f80328c1007","modified":1712942298528},{"_id":"themes/butterfly/scripts/tag/label.js","hash":"b013dc0a3d57d2caa18b89263f23871da9ec456d","modified":1712942298530},{"_id":"themes/butterfly/scripts/tag/hide.js","hash":"5d08c3552f7d3c80a724ca628bff66321abe2e5a","modified":1712942298527},{"_id":"themes/butterfly/scripts/tag/note.js","hash":"e68d8d21f3a86e3646907a3685550ee20e8d4a9f","modified":1712942298533},{"_id":"themes/butterfly/scripts/tag/series.js","hash":"dc56e5182dd3813dc977c9bf8556dcc7615e467b","modified":1712942298537},{"_id":"themes/butterfly/scripts/tag/tabs.js","hash":"7c448886f230adb4f4a0208c88fff809abcb5637","modified":1712942298539},{"_id":"themes/butterfly/scripts/tag/score.js","hash":"35d54adc92e717cc32e13515122b025fd1a98ea2","modified":1712942298535},{"_id":"themes/butterfly/scripts/tag/timeline.js","hash":"e611074a5a7f489a8b04afac0a3f7f882ce26532","modified":1712942298541},{"_id":"themes/butterfly/source/img/404.jpg","hash":"fb4489bc1d30c93d28f7332158c1c6c1416148de","modified":1712942298658},{"_id":"themes/butterfly/source/js/main.js","hash":"59cd756a94ecdf3ec7b18f50691a8a6305f7a65a","modified":1712942298667},{"_id":"themes/butterfly/source/img/favicon.png","hash":"3cf89864b4f6c9b532522a4d260a2e887971c92d","modified":1712942298660},{"_id":"themes/butterfly/source/img/friend_404.gif","hash":"8d2d0ebef70a8eb07329f57e645889b0e420fa48","modified":1712942298663},{"_id":"themes/butterfly/source/css/index.styl","hash":"b13d96924a5534bff91d75566b196ac87b4fac22","modified":1712942298653},{"_id":"themes/butterfly/source/css/var.styl","hash":"950250f66faeb611a67540e0fa6cedbcf5a7a321","modified":1712942298655},{"_id":"themes/butterfly/layout/includes/head/Open_Graph.pug","hash":"c8dbdfe6145a0bc6f7691c9551be8169a2698f0a","modified":1712942298288},{"_id":"themes/butterfly/source/js/utils.js","hash":"7b871fe0c4456660cff4c7b9cc4ed089adac2caf","modified":1712942298677},{"_id":"themes/butterfly/source/js/tw_cn.js","hash":"d776c670e4076ad6049dbb64cdee7a734b51d37f","modified":1712942298676},{"_id":"themes/butterfly/layout/includes/head/analytics.pug","hash":"c7666a10448edd93f5ace37296051b7670495f1b","modified":1712942298290},{"_id":"themes/butterfly/layout/includes/head/config.pug","hash":"39e1ca0a54eb5fd3688a78737417a1aaa50914c9","modified":1712942298291},{"_id":"themes/butterfly/layout/includes/head/preconnect.pug","hash":"a7c929b90ae52b78b39b1728e3ab0e3db1cb7b9a","modified":1712942298297},{"_id":"themes/butterfly/layout/includes/head/config_site.pug","hash":"bd5dd5452e28a4fe94c3241a758ec6f4fdb7a149","modified":1712942298293},{"_id":"themes/butterfly/layout/includes/head/pwa.pug","hash":"6dc2c9b85df9ab4f5b554305339fd80a90a6cf43","modified":1712942298298},{"_id":"themes/butterfly/layout/includes/head/google_adsense.pug","hash":"f29123e603cbbcc6ce277d4e8f600ba67498077c","modified":1712942298295},{"_id":"themes/butterfly/layout/includes/header/index.pug","hash":"1bef867c799ba158c5417272fb137539951aa120","modified":1712942298304},{"_id":"themes/butterfly/layout/includes/header/menu_item.pug","hash":"ca8bcd90ad9467819330bfe7c02b76322754bccf","modified":1712942298306},{"_id":"themes/butterfly/layout/includes/head/site_verification.pug","hash":"5168caadc4cf541f5d6676a9c5e8ae47a948f9ad","modified":1712942298300},{"_id":"themes/butterfly/layout/includes/header/nav.pug","hash":"962ee70a35e60a13c31eea47d16b9f98069fe417","modified":1712942298308},{"_id":"themes/butterfly/layout/includes/loading/fullpage-loading.pug","hash":"766baca6ddce49d1724a02312387b292ff2d0bdc","modified":1712942298315},{"_id":"themes/butterfly/layout/includes/loading/index.pug","hash":"00ae419f527d8225a2dc03d4f977cec737248423","modified":1712942298317},{"_id":"themes/butterfly/layout/includes/loading/pace.pug","hash":"a6fde4835d6460ce7baf792fd5e1977fad73db25","modified":1712942298319},{"_id":"themes/butterfly/layout/includes/mixins/article-sort.pug","hash":"9155f01d4c644a2e19b2b13b2d3c6d5e34dd0abf","modified":1712942298322},{"_id":"themes/butterfly/layout/includes/page/categories.pug","hash":"5276a8d2835e05bd535fedc9f593a0ce8c3e8437","modified":1712942298327},{"_id":"themes/butterfly/layout/includes/mixins/post-ui.pug","hash":"90eb453b14f6b5c25bfd8d28aa67783603a1411d","modified":1712942298324},{"_id":"themes/butterfly/layout/includes/header/social.pug","hash":"7a641b5dd45b970e1dafd1433eb32ea149e55cf2","modified":1712942298311},{"_id":"themes/butterfly/layout/includes/header/post-info.pug","hash":"cc99b2dc5c6b1f74391b0da609853ebc11de9610","modified":1712942298309},{"_id":"themes/butterfly/layout/includes/page/default-page.pug","hash":"e9459f122af7b733398578f9f0f8ab3c5e12a217","modified":1712942298329},{"_id":"themes/butterfly/layout/includes/post/post-copyright.pug","hash":"0abad416b1974a17e5be7817931d5fe799180170","modified":1712942298337},{"_id":"themes/butterfly/layout/includes/post/reward.pug","hash":"912df10a053db3135968e92b6fd1a707ee94c968","modified":1712942298339},{"_id":"themes/butterfly/layout/includes/page/flink.pug","hash":"e37681bc9c169d4220f26ecda2b3d5c02b6b9a0f","modified":1712942298331},{"_id":"themes/butterfly/layout/includes/page/tags.pug","hash":"12be059c536490af216a397e8f2a7abbf6d4610e","modified":1712942298332},{"_id":"themes/butterfly/layout/includes/third-party/effect.pug","hash":"43014bfc63583d3ee8808d526dd165848c0ed52f","modified":1712942298399},{"_id":"themes/butterfly/layout/includes/third-party/aplayer.pug","hash":"e939344fd389aeb11864ee697d5fd9b036d8325f","modified":1712942298349},{"_id":"themes/butterfly/layout/includes/third-party/pjax.pug","hash":"9b734d99963f3e7f562597dcf60485ccbf6e961c","modified":1712942298428},{"_id":"themes/butterfly/layout/includes/third-party/pangu.pug","hash":"f0898509da70388b5c532f19e762756d74080200","modified":1712942298426},{"_id":"themes/butterfly/layout/includes/third-party/prismjs.pug","hash":"08979afbfecb4476a5ae8e360947b92624d285b8","modified":1712942298429},{"_id":"themes/butterfly/layout/includes/widget/card_ad.pug","hash":"a8312b527493dabbadbb1280760168d3bc909a3b","modified":1712942298448},{"_id":"themes/butterfly/layout/includes/third-party/subtitle.pug","hash":"dfb5e16a7e7106bb20b2ac2d0df1251d0fc79609","modified":1712942298445},{"_id":"themes/butterfly/layout/includes/widget/card_announcement.pug","hash":"21e019bdc3b1e796bb00976bb29af2d51f873624","modified":1712942298450},{"_id":"themes/butterfly/layout/includes/widget/card_archives.pug","hash":"73d33b6930e7944187a4b3403daf25d27077a2dd","modified":1712942298452},{"_id":"themes/butterfly/layout/includes/widget/card_newest_comment.pug","hash":"8e22f53886a57a68286970d8af8b4c950fd4a1d7","modified":1712942298460},{"_id":"themes/butterfly/layout/includes/widget/card_author.pug","hash":"ab037bf5794638bd30da4cf7cf106e5d03b5f696","modified":1712942298454},{"_id":"themes/butterfly/layout/includes/widget/card_bottom_self.pug","hash":"1dba77d250eeebfb6e293d504352c7e9ea31980b","modified":1712942298456},{"_id":"themes/butterfly/layout/includes/widget/card_categories.pug","hash":"66e383b4ef374951eb87dd1bf4cdb7a667193fb5","modified":1712942298458},{"_id":"themes/butterfly/layout/includes/widget/card_post_series.pug","hash":"e0bb72fa0ce15964b11b8fe421cae3432394e35f","modified":1712942298461},{"_id":"themes/butterfly/layout/includes/widget/card_recent_post.pug","hash":"bb842d2aa6469d65bf06af1372f0a19a9e4ef44c","modified":1712942298464},{"_id":"themes/butterfly/layout/includes/widget/card_post_toc.pug","hash":"d48d77af1670bd568d784794408bf524a448bfcc","modified":1712942298463},{"_id":"themes/butterfly/layout/includes/widget/card_top_self.pug","hash":"7b5ae404a1205546b7de4be42291315cf918f2b3","modified":1712942298467},{"_id":"themes/butterfly/layout/includes/widget/card_tags.pug","hash":"842b772a387b576550fa127030e1c2e9bf65716d","modified":1712942298466},{"_id":"themes/butterfly/layout/includes/widget/card_webinfo.pug","hash":"12185713f9ca08984fc74e3b69d8cd6828d23da8","modified":1712942298468},{"_id":"themes/butterfly/source/css/_global/function.styl","hash":"e920dae9ce00177922468db49240f5aca0af4f64","modified":1712942298546},{"_id":"themes/butterfly/layout/includes/widget/index.pug","hash":"8df529f71e25f1c0a00e533de7944ed3d1ba7bd8","modified":1712942298470},{"_id":"themes/butterfly/source/css/_global/index.styl","hash":"0421da07907b3d98df64239e073b23fbb3f04149","modified":1712942298548},{"_id":"themes/butterfly/source/css/_highlight/highlight.styl","hash":"41054740cfbd1357138785464f6859681ca58493","modified":1712942298550},{"_id":"themes/butterfly/source/css/_layout/aside.styl","hash":"aae70ddd126b2e40158e45036abecbfa33cbfbba","modified":1712942298570},{"_id":"themes/butterfly/source/css/_highlight/theme.styl","hash":"3c178608406c31d768af355ef1d7326da37cc75f","modified":1712942298566},{"_id":"themes/butterfly/source/css/_layout/comments.styl","hash":"fbfce4d67cacd1df22fb73d89d008693f59d9d91","modified":1712942298575},{"_id":"themes/butterfly/source/css/_layout/chat.styl","hash":"792a04d36de32f230ca3256ad87a90fe8392f333","modified":1712942298572},{"_id":"themes/butterfly/source/css/_layout/loading.styl","hash":"f0b01bbf321c2c24fdccaee367dd9fd448031a72","modified":1712942298581},{"_id":"themes/butterfly/source/css/_layout/footer.styl","hash":"5e27f7842af82ff7498d4b59787ce9ca90fa9e6f","modified":1712942298577},{"_id":"themes/butterfly/source/css/_layout/head.styl","hash":"964bda8acf4180a15c33e1d8447fc3140baa4c68","modified":1712942298579},{"_id":"themes/butterfly/source/css/_layout/post.styl","hash":"7ae27854a737a02eca89b0b92db94cb298fef59e","modified":1712942298585},{"_id":"themes/butterfly/source/css/_layout/pagination.styl","hash":"bd099f7d3adef4b7edd24c0a25a07415b156e587","modified":1712942298583},{"_id":"themes/butterfly/source/css/_layout/relatedposts.styl","hash":"6dcf19c0933c8828a439f801b0f4b256447dec07","modified":1712942298587},{"_id":"themes/butterfly/source/css/_layout/reward.styl","hash":"c0b11a1a5f52e3a6af4e312a8134c93eda18a7dd","modified":1712942298589},{"_id":"themes/butterfly/source/css/_mode/readmode.styl","hash":"a22fd15048d21452f0015d0765d295d730203308","modified":1712942298601},{"_id":"themes/butterfly/source/css/_layout/rightside.styl","hash":"0322237e762db401d7b4aa33168d0b9334a9ec26","modified":1712942298591},{"_id":"themes/butterfly/source/css/_layout/sidebar.styl","hash":"80ee9d0bfe5d38aac1f0cdcea5fc88b71d310041","modified":1712942298592},{"_id":"themes/butterfly/source/css/_layout/third-party.styl","hash":"15ea7564b2e3bf46bc91fb6e49c94d057b37caaf","modified":1712942298594},{"_id":"themes/butterfly/source/css/_mode/darkmode.styl","hash":"dbc855795a881f8c805bf5c9c5c4d5d542a648ec","modified":1712942298598},{"_id":"themes/butterfly/source/css/_page/archives.styl","hash":"5dd1ba997741d02894ff846eda939ad8051c0bb2","modified":1712942298609},{"_id":"themes/butterfly/source/css/_page/404.styl","hash":"a7223a8fcc4fa7b81e552c9a2554be7df9de312e","modified":1712942298606},{"_id":"themes/butterfly/source/css/_page/categories.styl","hash":"68bc8cbea25dbb3cdc170f09f9b43ce130547717","modified":1712942298611},{"_id":"themes/butterfly/source/css/_page/common.styl","hash":"df7a51fcabbadab5aa31770e3202a47c9599bbb7","modified":1712942298613},{"_id":"themes/butterfly/source/css/_page/homepage.styl","hash":"a977cd8161ef4d6ddd5293e81403519076657430","modified":1712942298619},{"_id":"themes/butterfly/source/css/_page/flink.styl","hash":"ecc2b2e28c179eb9406fc2c6f00e141078249cdd","modified":1712942298616},{"_id":"themes/butterfly/source/css/_page/tags.styl","hash":"9e35f91847773b915c74a78b8aa66c7bdb950ad0","modified":1712942298621},{"_id":"themes/butterfly/source/css/_search/algolia.styl","hash":"37db99299af380e9111dce2a78a5049b301b13e0","modified":1712942298624},{"_id":"themes/butterfly/source/css/_search/index.styl","hash":"0b23010154e19f37f0c4af0110f9f834d6d41a13","modified":1712942298627},{"_id":"themes/butterfly/source/css/_tags/button.styl","hash":"62da1de0d5b8453fcecbfacddb16985265638ba5","modified":1712942298632},{"_id":"themes/butterfly/source/css/_search/local-search.styl","hash":"8a53d7ba5ca2f5eb4124b684e7845b648583f658","modified":1712942298628},{"_id":"themes/butterfly/source/css/_tags/hexo.styl","hash":"985b183db7b7bfd8f9bdb60494549fb7f850348b","modified":1712942298635},{"_id":"themes/butterfly/source/css/_tags/gallery.styl","hash":"3e9355b76f87e2ee90f652855282b37ab5ae0b3e","modified":1712942298633},{"_id":"themes/butterfly/source/css/_tags/hide.styl","hash":"b7cf7753479fcf2fe07287ffdb0e568adbba4c18","modified":1712942298637},{"_id":"themes/butterfly/source/css/_tags/note.styl","hash":"4929382bd60788d34752a66e2fe764ef797a72a0","modified":1712942298643},{"_id":"themes/butterfly/source/css/_third-party/normalize.min.css","hash":"8549829fb7d3c21cd9e119884962e8c463a4a267","modified":1712942298651},{"_id":"themes/butterfly/source/css/_tags/inlineImg.styl","hash":"5a873d01fabebcf7ddf7a6b1c2e2e5e2714097f4","modified":1712942298639},{"_id":"themes/butterfly/source/css/_tags/timeline.styl","hash":"07ea7134db7a66c87658116f089fb1a2a6906563","modified":1712942298647},{"_id":"themes/butterfly/source/css/_tags/label.styl","hash":"2f83bd145b870d80d4b18b0ac603235229a5694e","modified":1712942298641},{"_id":"themes/butterfly/source/css/_tags/tabs.styl","hash":"353b95f9a6c2c1e777d978118cb61f909ccbf89c","modified":1712942298645},{"_id":"themes/butterfly/source/js/search/algolia.js","hash":"a7c2fe73cc05ad3525909b86ad0ede1a9f2d3b48","modified":1712942298671},{"_id":"themes/butterfly/source/js/search/local-search.js","hash":"ab3904451ae1d78903424b8b2ef815c8571e1749","modified":1712942298673},{"_id":"themes/butterfly/layout/includes/third-party/abcjs/index.pug","hash":"58f37823f6cd9a194fb50f7ca7c2233e49939034","modified":1712942298347},{"_id":"themes/butterfly/layout/includes/third-party/abcjs/abcjs.pug","hash":"8f95aca305b56ccd7c8c7367b03d26db816ebd5f","modified":1712942298346},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/artalk.pug","hash":"b03ee8625149191f9d5d057bbc9824b68d8dd0c4","modified":1712942298351},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/disqus.pug","hash":"d6fff5a7f84c8b09f282f9ddc0020a68a8aac9ea","modified":1712942298352},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/fb.pug","hash":"4b98145d6584d586cabf033493282afc72ae816a","modified":1712942298354},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/remark42.pug","hash":"716dc463fe4ef5112e7018ed60804125fdfa5cad","modified":1712942298357},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/index.pug","hash":"846cabae287ae31b3bbfac3da022475713dd5ecc","modified":1712942298355},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/twikoo.pug","hash":"7e233f872aea6fd6beccdc9efd86b1bf9ec9f12d","modified":1712942298359},{"_id":"themes/butterfly/layout/includes/third-party/chat/chatra.pug","hash":"08a85e52fc800d3562df869e5e2613313e76fce6","modified":1712942298364},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/valine.pug","hash":"cd4fc9c5a61608a5dedf645c1295430a1623040f","modified":1712942298360},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/waline.pug","hash":"fd2320ee25507bb8ef49f932c2d170586b44ea4d","modified":1712942298362},{"_id":"themes/butterfly/layout/includes/third-party/chat/crisp.pug","hash":"09d2ab2570b67e6f09244a898ccab5567cb82ace","modified":1712942298366},{"_id":"themes/butterfly/layout/includes/third-party/chat/daovoice.pug","hash":"0d960849d5b05d27ec87627b983ca35f2411b9e8","modified":1712942298367},{"_id":"themes/butterfly/layout/includes/third-party/comments/disqus.pug","hash":"364d1fd655baca9132038ef1e312abde2c0bc7de","modified":1712942298377},{"_id":"themes/butterfly/layout/includes/third-party/chat/messenger.pug","hash":"799da8f3015e6fe440681b21644bcb3810a5518c","modified":1712942298370},{"_id":"themes/butterfly/layout/includes/third-party/chat/index.pug","hash":"1157118db9f5d7c0c5a0fc7c346f6e934ca00d52","modified":1712942298368},{"_id":"themes/butterfly/layout/includes/third-party/comments/artalk.pug","hash":"5373b822aa72ddb96f2f1f4baf6c058b40d705d6","modified":1712942298375},{"_id":"themes/butterfly/layout/includes/third-party/chat/tidio.pug","hash":"6d40b521eec4136f6742c548a4445ed593470b1b","modified":1712942298372},{"_id":"themes/butterfly/layout/includes/third-party/comments/disqusjs.pug","hash":"f78c9c20c86d58c7cf099f6f8d6097103d7d43e5","modified":1712942298378},{"_id":"themes/butterfly/layout/includes/third-party/comments/facebook_comments.pug","hash":"11f5dca1432e59f22955aaf4ac3e9de6b286d887","modified":1712942298380},{"_id":"themes/butterfly/layout/includes/third-party/comments/giscus.pug","hash":"1eab7ca1cb16c6786f9c3ca0efef8cc15e444ab4","modified":1712942298382},{"_id":"themes/butterfly/layout/includes/third-party/comments/gitalk.pug","hash":"1c86c8fc1a28514a02a1f6a25ca9ec05eb3955b7","modified":1712942298383},{"_id":"themes/butterfly/layout/includes/third-party/comments/index.pug","hash":"db6713d2b90eb8183f86ac92c26761a8501c0ddb","modified":1712942298385},{"_id":"themes/butterfly/layout/includes/third-party/comments/js.pug","hash":"3abbaaa4ea575c45b3cebffd40bad1acc6ffce84","modified":1712942298387},{"_id":"themes/butterfly/layout/includes/third-party/comments/livere.pug","hash":"09c2ef4bc6d005f96dfa48b1d9af1ec095c5266d","modified":1712942298388},{"_id":"themes/butterfly/layout/includes/third-party/comments/twikoo.pug","hash":"9942a903227350960c1d0716e59516ae79ac24a8","modified":1712942298392},{"_id":"themes/butterfly/layout/includes/third-party/comments/remark42.pug","hash":"7f450664e6323a076ae59c393b0f22167cfa82e5","modified":1712942298390},{"_id":"themes/butterfly/layout/includes/third-party/math/index.pug","hash":"2afa4c21dd19890f47fb568cfb0d90efb676a253","modified":1712942298402},{"_id":"themes/butterfly/layout/includes/third-party/comments/utterances.pug","hash":"b65a42167df5fb07e2a63f312a58c321d3112a90","modified":1712942298393},{"_id":"themes/butterfly/layout/includes/third-party/comments/waline.pug","hash":"efb72547fc2d470a124f5636391128dc59627498","modified":1712942298397},{"_id":"themes/butterfly/layout/includes/third-party/comments/valine.pug","hash":"4ed7c74087e81c6fcaf4fca7dced58b4e19f4cb1","modified":1712942298395},{"_id":"themes/butterfly/layout/includes/third-party/math/katex.pug","hash":"f0d3eddd2bed68e5517274b3530bfe0fa5057d8e","modified":1712942298404},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/artalk.pug","hash":"2e36fac4791e99844cd56676898be0dbf5eb4e99","modified":1712942298411},{"_id":"themes/butterfly/layout/includes/third-party/math/mathjax.pug","hash":"bb944185f4bb9f9a9b9d70ee215f66ccd6d4c6cf","modified":1712942298407},{"_id":"themes/butterfly/layout/includes/third-party/math/mermaid.pug","hash":"c682e4d61017fb0dd2e837bfcc242371f1a13364","modified":1712942298408},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/disqus-comment.pug","hash":"d8898e427acd91ceb97d6a7ee3acb011ca86b9fc","modified":1712942298413},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/github-issues.pug","hash":"fc8814bd016d039874ec2fc24dcb78587892e2a6","modified":1712942298415},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/remark42.pug","hash":"a4e52188b6effeee1df2a01dcbf4105de76a61a8","modified":1712942298419},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/twikoo-comment.pug","hash":"17520a86de12ae585289463c066d3ac91b78a2ff","modified":1712942298421},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/index.pug","hash":"f8b65460c399973090c1fb7ab81e3708c252e7cc","modified":1712942298417},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/waline.pug","hash":"0544d91c0bc9e26e0fe1b5ff490f4a8540ed1ee1","modified":1712942298425},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/valine.pug","hash":"ecfff55b2c7f6d87ce4d5028fdf9f8c0bf155c73","modified":1712942298422},{"_id":"themes/butterfly/layout/includes/third-party/search/algolia.pug","hash":"90338ac4cd114d324fe1caaaeea8be9ca05d6a46","modified":1712942298432},{"_id":"themes/butterfly/layout/includes/third-party/search/docsearch.pug","hash":"52a06a2e039f44383085333cac69f3f4e7d0ad3a","modified":1712942298433},{"_id":"themes/butterfly/layout/includes/third-party/share/addtoany.pug","hash":"1f02a26730e5f36cc2dfec7ff4d5c93a099ed5ba","modified":1712942298439},{"_id":"themes/butterfly/layout/includes/third-party/share/index.pug","hash":"c16ee69b5ca8db016db0508d014ae0867c4ce929","modified":1712942298442},{"_id":"themes/butterfly/layout/includes/third-party/share/share-js.pug","hash":"8106bd031586f075a994956ee4438eb13be25d7b","modified":1712942298443},{"_id":"themes/butterfly/source/css/_highlight/highlight/diff.styl","hash":"6e77f1ca0cfb0db6b028f5c0238780e66d344f3d","modified":1712942298554},{"_id":"themes/butterfly/layout/includes/third-party/search/index.pug","hash":"3adcf28a8d205ea3ee19828eda0e668702fac07a","modified":1712942298435},{"_id":"themes/butterfly/source/css/_highlight/highlight/index.styl","hash":"fc702a4614d0562a381907b083f71ba63d301d86","modified":1712942298557},{"_id":"themes/butterfly/layout/includes/third-party/search/local-search.pug","hash":"420a86e73d0d748ac234fd00d06d9e433ca5e3f2","modified":1712942298436},{"_id":"themes/butterfly/source/css/_highlight/prismjs/diff.styl","hash":"1309292f1c8c53d96cd7333507b106bcc24ca8fc","modified":1712942298560},{"_id":"themes/butterfly/source/css/_highlight/prismjs/index.styl","hash":"01ff9e77eb1bd454bec65a6ff5972c8e219bc708","modified":1712942298562},{"_id":"themes/butterfly/source/css/_highlight/prismjs/line-number.styl","hash":"7c9cc43e1d2577f7151039d58e603c30860fd281","modified":1712942298564},{"_id":"source/img/home/Alisinngai Lynn Home page image.jpg","hash":"5fe4ce370bc4b0a479429da5f4e66af9bbd40a88","modified":1604041300796},{"_id":"public/2024/06/18/2024-06-18-设计模式-03.02-创建型-工厂&建造者&原型/index.html","hash":"7d9ad78959b53b75d02a7a39bdbfa202df34a912","modified":1718688346421},{"_id":"public/2024/05/11/2024-05-11-设计模式-03.01-创建型-单例/index.html","hash":"9f719460aae8ba02a454ebf265d402b637af2dca","modified":1718688346421},{"_id":"public/2024/05/01/2024-05-01-设计模式-02.经典设计原则-第二节[必读]/index.html","hash":"167f03477b1d94d11f9eb55e1fb0b2250c6d66ee","modified":1718688346421},{"_id":"public/2024/04/21/2024-04-21-设计模式-01.设计思想/index.html","hash":"5f4bbd143412ca25786ba55b5f22bf5bc4068684","modified":1718688346421},{"_id":"public/2024/04/14/2021-04-14-Java8新特性/index.html","hash":"fec66a29e6462a9f9f7b704ea61c91c4911b3214","modified":1718688346421},{"_id":"public/2024/04/13/2024-04-13-单节点单硬盘部署MinIO/index.html","hash":"ab906a27c75caf254286c0d956ebc74f7665f467","modified":1718688346421},{"_id":"public/2023/08/10/2023-08-10-CompletableFuture的使用/index.html","hash":"7ecb7146cea4e595ebd0859b336a940b3ee24a30","modified":1718688346421},{"_id":"public/archives/index.html","hash":"8fd2543e449bf566a5f02176ffc13d3f936a67b4","modified":1718688346421},{"_id":"public/archives/2023/index.html","hash":"0cb9a1836133109ad95314212d603680cd8f33d0","modified":1718688346421},{"_id":"public/archives/2023/08/index.html","hash":"691399666dbe432931cf05847d1cab235ba6aa6f","modified":1718688346421},{"_id":"public/archives/2024/index.html","hash":"bba3db52ab85f52cf677faace8e5fd217829d9b3","modified":1718688346421},{"_id":"public/archives/2024/04/index.html","hash":"228759b0e4b64199dabc2edd53022bff915a99df","modified":1718688346421},{"_id":"public/index.html","hash":"04aca09e5e505f6292dbbad16361bca462960deb","modified":1718688346421},{"_id":"public/archives/2024/05/index.html","hash":"20f6ec4d5fb664cd2bbdafa53bfa272081379cae","modified":1718688346421},{"_id":"public/archives/2024/06/index.html","hash":"c6448b0a9e549dd426d1f1fd0e79a56c5f4cf89d","modified":1718688346421},{"_id":"public/categories/Java/index.html","hash":"0c2e00fb7101b9041e04dc141c0647f4d03932e4","modified":1718688346421},{"_id":"public/categories/Java/新特性/index.html","hash":"4db6be847fae128e7f23e20a33ddabb45186eca9","modified":1718688346421},{"_id":"public/categories/Minio/index.html","hash":"f57cd8c6f4930cd45d863a02bf09d34773086672","modified":1718688346421},{"_id":"public/categories/设计模式/index.html","hash":"ea85446c749b6bce9ca51c79df0cb44f56385619","modified":1718688346421},{"_id":"public/categories/设计模式/01-设计思想/index.html","hash":"12425bd4ed3b9095c78bb73150b03eca97ece6cf","modified":1718688346421},{"_id":"public/categories/设计模式/03-创建型/index.html","hash":"eb4ed76a3430ba73b64a42a49408733eb6c372a9","modified":1718688346421},{"_id":"public/categories/设计模式/02-经典设计原则/index.html","hash":"6b1382410de7fbae1a283973137c718b00ad025e","modified":1718688346421},{"_id":"public/tags/Java/index.html","hash":"97ffc2a7ebac134b8d2d591e34156faa09f22698","modified":1718688346421},{"_id":"public/tags/并发/index.html","hash":"2824e234dd88c8b9106ae23d7ffe3be18ab94fee","modified":1718688346421},{"_id":"public/tags/CompletableFuture/index.html","hash":"dd2213a249714bf142875017ef4925587bb46035","modified":1718688346421},{"_id":"public/tags/Java8/index.html","hash":"3f326f8c75d7ec54345de844ceaf109236a33de9","modified":1718688346421},{"_id":"public/tags/JDK8/index.html","hash":"7cea7cffafb7e8444a74fadde4aad039db038e80","modified":1718688346421},{"_id":"public/tags/新特性/index.html","hash":"9439068ee3570b9da59a683baf8237c84484dd87","modified":1718688346421},{"_id":"public/tags/对象储存/index.html","hash":"dc46e4b4f3f6b79493dc9bd966ad130a2bc1ee50","modified":1718688346421},{"_id":"public/tags/Minio/index.html","hash":"45c336ca49efb30f3178f8c8613a0c1176d7e5b6","modified":1718688346421},{"_id":"public/tags/设计模式/index.html","hash":"f53971a4c210523d205845fbd6b8de5de5912dee","modified":1718688346421},{"_id":"public/tags/设计思想/index.html","hash":"519aae613ee142aaa7134e10b6a2f512a76e7b48","modified":1718688346421},{"_id":"public/tags/工厂/index.html","hash":"1a6eb68a08e855389e789189cff109438385c10e","modified":1718688346421},{"_id":"public/tags/建造者/index.html","hash":"60267561882d44df7ad35ea9ae076d0ad18054af","modified":1718688346421},{"_id":"public/tags/原型/index.html","hash":"8427ba5609c1895fdb20d3241faed12ac242ef46","modified":1718688346421},{"_id":"public/tags/设计原则/index.html","hash":"992c4161a47364b35833cd90f9d8642493be1ca6","modified":1718688346421},{"_id":"public/tags/单例/index.html","hash":"3eeac6d57ec011228cbddc559dd16c59426f2e3f","modified":1718688346421},{"_id":"public/img/minio/minio.svg","hash":"283133390bffe6ded2a4ca732b6b1f259270e7c6","modified":1718688346421},{"_id":"public/img/home/homePageImage_01.webp","hash":"f384889a2089e35f5989d2857a96a1cb7c79decf","modified":1718688346421},{"_id":"public/img/404.jpg","hash":"fb4489bc1d30c93d28f7332158c1c6c1416148de","modified":1718688346421},{"_id":"public/img/Java/Thread/Thread.svg","hash":"2d6bd166c0c268a795256d212dc0bfce6f93004a","modified":1718688346421},{"_id":"public/img/favicon.png","hash":"3cf89864b4f6c9b532522a4d260a2e887971c92d","modified":1718688346421},{"_id":"public/img/friend_404.gif","hash":"8d2d0ebef70a8eb07329f57e645889b0e420fa48","modified":1718688346421},{"_id":"public/css/var.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1718688346421},{"_id":"public/js/search/algolia.js","hash":"108988d046da9a4716148df43b3975217c8ceaae","modified":1718688346421},{"_id":"public/js/search/local-search.js","hash":"e1f60ebac53a3f596fd0a4769b4f9275c48c6542","modified":1718688346421},{"_id":"public/js/utils.js","hash":"8e6b48d294e7aeaba8ff6348c43b2271cf865547","modified":1718688346421},{"_id":"public/css/index.css","hash":"deae12e17dee0ddfb95c9d2ef11a29baa5d56f3d","modified":1718688346421},{"_id":"public/js/main.js","hash":"0dac585446445e0c419b86eec5580bc9b0657dc6","modified":1718688346421},{"_id":"public/js/tw_cn.js","hash":"f8d2e3f31468991a7f5171cbfdb157dfb86d3372","modified":1718688346421},{"_id":"public/img/home/Alisinngai Lynn Home page image.jpg","hash":"5fe4ce370bc4b0a479429da5f4e66af9bbd40a88","modified":1718688346421}],"Category":[{"name":"Java","_id":"clxjyo3bp0002isvdhrs32o7u"},{"name":"新特性","parent":"clxjyo3bp0002isvdhrs32o7u","_id":"clxjyo3c20008isvd05bz6o1x"},{"name":"Minio","_id":"clxjyo3cc000misvd92n20lgk"},{"name":"设计模式","_id":"clxjyo3ci000risvdane945di"},{"name":"01.设计思想","parent":"clxjyo3ci000risvdane945di","_id":"clxjyo3co0014isvd9ucobzjb"},{"name":"03.创建型","parent":"clxjyo3ci000risvdane945di","_id":"clxjyo3cr0017isvdfuou91mr"},{"name":"02.经典设计原则","parent":"clxjyo3ci000risvdane945di","_id":"clxjyo3cs001aisvd79644lhy"}],"Data":[],"Page":[],"Post":[{"title":"CompletableFuture的使用","date":"2023-08-10T04:17:39.000Z","cover":"../img/Java/Thread/Thread.svg","_content":"\n> CompletableFuture类提供了非常强大的Future的扩展功能，可以帮助我们简化异步编程的复杂性，提供了函数式编程的能力，可以通过回调的方式处理计算结果，并且提供了转换和组合CompletableFuture的方法。\n\n# 总结\n\n<table>\n    <tr>\n        <th>分类</th>\n        <th>方法名</th>\n        <th>描述</th>\n    </tr>\n    <tr>\n        <th rowspan=\"2\">创建异步任务</th>\n        <td><code>runAsync</code></td>\n        <td>不支持返回值</td>\n    </tr>\n    <tr>\n        <td><code>supplyAsync</code></td>\n        <td>支持返回值</td>\n    </tr>\n    <tr>\n        <th rowspan=\"6\">创建异步任务</th>\n        <td><code>thenRun</code>、<code>thenRunAsync</code></td>\n        <td>不接参数、无返回值</td>\n    </tr>\n    <tr>\n        <td><code>thenAccept</code>、<code>thenAcceptAsync</code></td>\n        <td>接返回值、无返回值</td>\n    </tr>\n    <tr>\n        <td><code>thenApply</code>、<code>thenApplyAsync</code></td>\n        <td>接返回值、有返回值</td>\n    </tr>\n    <tr>\n        <td><code>exceptionally</code>、<code>exceptionallyAsync</code></td>\n        <td>接异常、有返回值</td>\n    </tr>\n    <tr>\n        <td><code>whenComplete</code>、<code>whenCompleteAsync</code></td>\n        <td>接返回值和异常、无返回值</td>\n    </tr>\n    <tr>\n        <td><code>handle</code>、<code>handleAsync</code></td>\n        <td>接返回值和异常、有返回值</td>\n    </tr>\n    <tr>\n        <th rowspan=\"7\">两个任务组合</th>\n        <td><code>thenCompose</code>、<code>thenComposeAsync</code></td>\n        <td>任务转化</td>\n    </tr>\n    <tr>\n        <td><code>thenCombine</code>、<code>thenCombineAsync</code></td>\n        <td>“且”组合、接返回值、有返回值</td>\n    </tr>\n    <tr>\n        <td><code>thenAcceptBoth</code>、<code>thenAcceptBothAsync</code></td>\n        <td>“且”组合、接返回值、无返回值</td>\n    </tr>\n    <tr>\n        <td><code>runAfterBoth</code>、<code>runAfterBothAsync</code></td>\n        <td>“且”组合、不接参数、无返回值</td>\n    </tr>\n    <tr>\n        <td><code>applyToEither</code>、<code>applyToEitherAsync</code></td>\n        <td>“或”组合、接返回值、有返回值</td>\n    </tr>\n    <tr>\n        <td><code>acceptEither</code>、<code>acceptEitherAsync</code></td>\n        <td>“或”组合、接返回值、无返回值</td>\n    </tr>\n    <tr>\n        <td><code>runAfterEither</code>、<code>runAfterEitherAsync</code></td>\n        <td>“或”组合、不接参数、无返回值</td>\n    </tr>\n    <tr>\n        <th rowspan=\"2\">多个任务组合</th>\n        <td><code>anyOf</code></td>\n        <td>“任意一个”组合</td>\n    </tr>\n    <tr>\n        <td><code>allOf</code></td>\n        <td>“所有”组合</td>\n    </tr>\n</table>\n\n> 在CompletableFuture中如果使用没有指定线程池的方法，则会使用`ForkJoinPool.commonPool()`作为它的线程池执行异步代码。\n\n# 创建异步任务\n\n### 不支持返回值\n\n- 方法签名\n  ```java\n  // 使用默认线程池中的线程\n  public static CompletableFuture<Void> runAsync(Runnable runnable);\n  // 使用自定义线程池中的线程\n  public static CompletableFuture<Void> runAsync(Runnable runnable, Executor executor); \n  ```\n- 示例代码\n  ```java\n  CompletableFuture.runAsync(() -> {\n      // TODO 执行任务\n  });\n  ```\n\n### 支持返回值\n\n- 方法签名\n  ```java\n  // 使用默认线程池中的线程\n  public static <U> CompletableFuture<U> supplyAsync(Supplier<U> supplier);\n  // 使用自定义线程池中的线程\n  public static <U> CompletableFuture<U> supplyAsync(Supplier<U> supplier, Executor executor); \n  ```\n\n- 示例代码\n  ```java\n  CompletableFuture.supplyAsync(() -> {\n      // TODO 执行任务\n      return null;\n  });\n    ```\n\n# 任务完成时回调方法\n\n当CompletableFuture任务执行完成或者抛出异常的时候，可以执行特定的回调方法。\n\n### 不接参数、无返回值\n\n> 前一个任务执行完成后执行；任务之间**无参数传递**，回调方法**无返回值**\n\n- 方法签名\n  ```java\n  // 使用调用它的线程上运行（一般是主线程）\n  public CompletableFuture<Void> thenRun(Runnable action);\n  // 使用默认线程池中的线程\n  public CompletableFuture<Void> thenRunAsync(Runnable action);\n  // 使用自定义线程池中的线程\n  public CompletableFuture<Void> thenRunAsync(Runnable action, Executor executor);\n  ```\n- 示例代码\n  ```java\n  CompletableFuture.runAsync(() -> {\n  }).thenRun(() -> {\n      // TODO 执行任务\n  });\n  ```\n\n### 接返回值、无返回值\n\n> 前一个任务执行完成后执行；前一个任务会将执行结果**作为参数**，传递到回调方法中，回调方法**无返回值**\n\n- 方法签名\n  ```java\n  // 使用调用它的线程上运行（一般是主线程）\n  public CompletableFuture<Void> thenAccept(Consumer<? super T> action);\n  // 使用默认线程池中的线程\n  public CompletableFuture<Void> thenAcceptAsync(Consumer<? super T> action);\n  // 使用自定义线程池中的线程\n  public CompletableFuture<Void> thenAcceptAsync(Consumer<? super T> action, Executor executor);\n  ```\n- 示例代码\n  ```java\n  CompletableFuture.supplyAsync(() -> {\n      return \"Result\";\n  }).thenAccept((result) -> {\n      // TODO 执行任务\n  });\n  ```\n\n### 接返回值、有返回值\n\n> 前一个任务执行完成后执行；前一个任务会将执行结果**作为参数**，传递到回调方法中，并且会调方法**有返回值**\n\n- 方法签名\n  ```java\n  // 使用调用它的线程上运行（一般是主线程）\n  public <U> CompletableFuture<U> thenApply(Function<? super T,? extends U> fn);\n  // 使用默认线程池中的线程\n  public <U> CompletableFuture<U> thenApplyAsync(Function<? super T,? extends U> fn);\n  // 使用自定义线程池中的线程\n  public <U> CompletableFuture<U> thenApplyAsync(Function<? super T,? extends U> fn, Executor executor);\n  ```\n- 示例代码\n  ```java\n  CompletableFuture.supplyAsync(() -> {\n      return \"Result_1\";\n  }).thenApply(() -> {\n      // TODO 执行任务\n      return \"Result_2\";\n  });\n  ```\n\n### 接异常、有返回值\n\n> 某个任务执行异常时执行；异常任务抛出的异常**作为参数**，传递到回调方法中，并且会调方法**有返回值**\n\n- 方法签名\n  ```java\n  // 使用调用它的线程上运行（一般是主线程）\n  public CompletableFuture<T> exceptionally(Function<Throwable, ? extends T> fn);\n  // 使用默认线程池中的线程\n  public CompletableFuture<T> exceptionallyAsync(Function<Throwable, ? extends T> fn);\n  // 使用自定义线程池中的线程\n  public CompletableFuture<T> exceptionallyAsync(Function<Throwable, ? extends T> fn, Executor executor);\n  ```\n- 示例代码\n  ```java\n  CompletableFuture.runAsync(() -> {\n      throw new RuntimeException();\n  }).exceptionally((exception) -> {\n      // TODO 处理异常\n      return \"ERROR!\";\n  });\n  ```\n\n### 接返回值和异常、无返回值\n\n> 前一个任务执行完成或出现异常时执行；前一个任务会将结果或抛出的异常**作为参数**，传递到回调方法中，回调方法**无返回值**\n\n- 方法签名\n  ```java\n  // 使用调用它的线程上运行（一般是主线程）\n  public CompletableFuture<T> whenComplete(BiConsumer<? super T, ? super Throwable> action);\n  // 使用默认线程池中的线程\n  public CompletableFuture<T> whenCompleteAsync(BiConsumer<? super T, ? super Throwable> action);\n  // 使用自定义线程池中的线程\n  public CompletableFuture<T> whenCompleteAsync(BiConsumer<? super T, ? super Throwable> action, Executor executor);\n  ```\n- 示例代码\n  ```java\n  CompletableFuture.supplyAsync(() -> {\n      throw new RuntimeException();\n  }).whenCompleteAsync((result, exception) -> {\n      if (exception != null) {\n          // TODO 处理异常\n      } else {\n          // TODO 执行任务\n      }\n  });\n  ```\n\n### 接返回值和异常、有返回值\n\n> 前一个任务执行完成后执行；前一个任务会将结果或抛出的异常**作为参数**，传递到回调方法中，回调方法**有返回值**\n\n- 方法签名\n  ```java\n  // 使用调用它的线程上运行（一般是主线程）\n  public <U> CompletableFuture<U> handle(BiFunction<? super T, Throwable, ? extends U> fn);\n  // 使用默认线程池中的线程\n  public <U> CompletableFuture<U> handleAsync(BiFunction<? super T, Throwable, ? extends U> fn);\n  // 使用自定义线程池中的线程\n  public <U> CompletableFuture<U> handleAsync(BiFunction<? super T, Throwable, ? extends U> fn, Executor executor);\n  ```\n- 示例代码\n  ```java\n  CompletableFuture.supplyAsync(() -> {\n      throw new RuntimeException();\n  }).handleAsync((result, exception) -> {\n      if (exception != null) {\n          // TODO 处理异常\n          return \"ERROR!\";\n      } else {\n          // 执行任务\n          return \"SUCCESS!\";\n      }\n  });\n  ```\n\n# 两个任务组合\n\n### 任务转化\n\n> 将前一个任务的执行结果**作为参数**进行处理，处理后**返回一个新的任务**\n\n- 方法签名\n  ```java\n  // 使用调用它的线程上运行（一般是主线程）\n  public <U> CompletableFuture<U> thenCompose(Function<? super T, ? extends CompletionStage<U>> fn);\n  // 使用默认线程池中的线程\n  public <U> CompletableFuture<U> thenComposeAsync(Function<? super T, ? extends CompletionStage<U>> fn);\n  // 使用自定义线程池中的线程\n  public <U> CompletableFuture<U> thenComposeAsync(Function<? super T, ? extends CompletionStage<U>> fn, Executor executor);\n  ```\n- 示例代码\n  ```java\n  CompletableFuture<String> task = CompletableFuture.supplyAsync(() -> {\n      return \"任务一的结果\";\n  });\n  \n  CompletableFuture<String> stringCompletableFuture = CompletableFuture.supplyAsync(() -> {\n      return \"任务二的结果\";\n  }).thenComposeAsync((result) -> {\n      // TODO 执行任务\n      return task;\n  });\n  ```\n\n### “且”组合、接返回值、有返回值\n\n> 将两个任务组合，当两个任务都正常执行完了，将两个任务的结果作为参数，传递到回调方法中，回调方法有返回值\n\n- 方法签名\n  ```java\n  // 使用调用它的线程上运行（一般是主线程）\n  public <U,V> CompletableFuture<V> thenCombine(CompletionStage<? extends U> other, BiFunction<? super T,? super U,? extends V> fn);\n  // 使用默认线程池中的线程\n  public <U,V> CompletableFuture<V> thenCombineAsync(CompletionStage<? extends U> other, BiFunction<? super T,? super U,? extends V> fn);\n  // 使用自定义线程池中的线程\n  public <U,V> CompletableFuture<V> thenCombineAsync(CompletionStage<? extends U> other, BiFunction<? super T,? super U,? extends V> fn, Executor executor);\n  ```\n- 示例代码\n  ```java\n  CompletableFuture.supplyAsync(() -> {\n      // TODO 任务一\n      return \"任务一的结果\";\n  }).thenCombineAsync(CompletableFuture.supplyAsync(() -> {\n      // TODO 任务二\n      return \"任务二的结果\";\n  }), (result1, result2) -> {\n      // 任务一和任务二都完成时执行的回调方法\n      return null;\n  });\n  ```\n\n### “且”组合、接返回值、无返回值\n\n> 将两个任务组合，当两个任务都正常执行完了，将两个任务的结果作为参数，传递到回调方法中，回调方法无返回值\n\n- 方法签名\n  ```java\n  // 使用调用它的线程上运行（一般是主线程）\n  public <U> CompletableFuture<Void> thenAcceptBoth(CompletionStage<? extends U> other, BiConsumer<? super T, ? super U> action);\n  // 使用默认线程池中的线程\n  public <U> CompletableFuture<Void> thenAcceptBothAsync(CompletionStage<? extends U> other, BiConsumer<? super T, ? super U> action);\n  // 使用自定义线程池中的线程\n  public <U> CompletableFuture<Void> thenAcceptBothAsync(CompletionStage<? extends U> other, BiConsumer<? super T, ? super U> action, Executor executor);\n  ```\n- 示例代码\n  ```java\n  CompletableFuture.supplyAsync(() -> {\n      // TODO 任务一\n      return \"任务一的结果\";\n  }).thenAcceptBothAsync(CompletableFuture.supplyAsync(() -> {\n      // TODO 任务二\n      return \"任务二的结果\";\n  }), (result1, result2) -> {\n      // TODO 任务一和任务二都完成时执行的回调方法\n  });\n  ```\n\n### “且”组合、不接参数、无返回值\n\n> 将两个任务组合，当两个任务都正常执行完了，执行回调方法，回调方法无返回值\n\n- 方法签名\n  ```java\n  // 使用调用它的线程上运行（一般是主线程）\n  public CompletableFuture<Void> runAfterBoth(CompletionStage<?> other, Runnable action);\n  // 使用默认线程池中的线程\n  public CompletableFuture<Void> runAfterBothAsync(CompletionStage<?> other, Runnable action);\n  // 使用自定义线程池中的线程\n  public CompletableFuture<Void> runAfterBothAsync(CompletionStage<?> other, Runnable action, Executor executor);\n  ```\n- 示例代码\n  ```java\n  CompletableFuture.supplyAsync(() -> {\n      // TODO 任务一\n      return \"任务一的结果\";\n  }).runAfterBothAsync(CompletableFuture.supplyAsync(() -> {\n      // TODO 任务二\n      return \"任务二的结果\";\n  }), () -> {\n      // TODO 任务一和任务二都完成时执行的回调方法\n  });\n  ```\n\n### “或”组合、接返回值、有返回值\n\n> 将两个任务组合，其中任意一个任务执行完成，将该任务的结果作为参数，传递到回调方法中，回调方法有返回值\n\n- 方法签名\n  ```java\n  // 使用调用它的线程上运行（一般是主线程）\n  public <U> CompletableFuture<U> applyToEither(CompletionStage<? extends T> other, Function<? super T, U> fn);\n  // 使用默认线程池中的线程\n  public <U> CompletableFuture<U> applyToEitherAsync(CompletionStage<? extends T> other, Function<? super T, U> fn);\n  // 使用自定义线程池中的线程\n  public <U> CompletableFuture<U> applyToEitherAsync(CompletionStage<? extends T> other, Function<? super T, U> fn, Executor executor);\n  ```\n- 示例代码\n  ```java\n  CompletableFuture.supplyAsync(() -> {\n      // TODO 任务一\n      return \"任务一的结果\";\n  }).applyToEitherAsync(CompletableFuture.supplyAsync(() -> {\n      // TODO 任务二\n      return \"任务二的结果\";\n  }), (result) -> {\n      // TODO 任务一和任务二任意一个执行完成时执行的回调方法\n      return \"SUCCESS\";\n  });\n  ```\n\n### “或”组合、接返回值、无返回值\n\n> 将两个任务组合，其中任意一个任务执行完成，将该任务的结果作为参数，传递到回调方法中，回调方法无返回值\n\n- 方法签名\n  ```java\n  // 使用调用它的线程上运行（一般是主线程）\n  public CompletableFuture<Void> acceptEither(CompletionStage<? extends T> other, Consumer<? super T> action);\n  // 使用默认线程池中的线程\n  public CompletableFuture<Void> acceptEitherAsync(CompletionStage<? extends T> other, Consumer<? super T> action);\n  // 使用自定义线程池中的线程\n  public CompletableFuture<Void> acceptEitherAsync(CompletionStage<? extends T> other, Consumer<? super T> action, Executor executor);\n  ```\n- 示例代码\n  ```java\n  CompletableFuture.supplyAsync(() -> {\n      // TODO 任务一\n      try {\n          Thread.sleep(10);\n      } catch (InterruptedException e) {\n          throw new RuntimeException(e);\n      }\n      return \"任务一的结果\";\n  }).acceptEitherAsync(CompletableFuture.supplyAsync(() -> {\n      // TODO 任务二\n      return \"任务二的结果\";\n  }), (result) -> {\n      // TODO 任务一和任务二任意一个执行完成时执行的回调方法\n  });\n  ```\n\n### “或”组合、不接参数、无返回值\n\n> 将两个任务组合，其中任意一个任务执行完成，执行回调方法，回调方法无返回值\n\n- 方法签名\n  ```java\n  // 使用调用它的线程上运行（一般是主线程）\n  public CompletableFuture<Void> runAfterEither(CompletionStage<?> other, Runnable action);\n  // 使用默认线程池中的线程\n  public CompletableFuture<Void> runAfterEitherAsync(CompletionStage<?> other, Runnable action);\n  // 使用自定义线程池中的线程\n  public CompletableFuture<Void> runAfterEitherAsync(CompletionStage<?> other, Runnable action, Executor executor);\n  ```\n- 示例代码\n  ```java\n  CompletableFuture.supplyAsync(() -> {\n      // TODO 任务一\n      try {\n          Thread.sleep(10);\n      } catch (InterruptedException e) {\n          throw new RuntimeException(e);\n      }\n      return \"任务一的结果\";\n  }).runAfterEitherAsync(CompletableFuture.supplyAsync(() -> {\n      // TODO 任务二\n      return \"任务二的结果\";\n  }), () -> {\n      // TODO 任务一和任务二任意一个执行完成时执行的回调方法\n  });\n  ```\n\n# 多个任务组合\n\n### “任意一个”组合\n\n> 将多个任务组合，其中任意一个任务执行完成即可拿到该任务的执行结果（执行结果为Object类型），或执行接下来的任务\n\n- 方法签名\n  ```java\n  public static CompletableFuture<Object> anyOf(CompletableFuture<?>... cfs);\n  ```\n- 示例代码\n  ```java\n  CompletableFuture<String> task1 = CompletableFuture.supplyAsync(() -> {\n      return \"任务一的结果\";\n  });\n  \n  CompletableFuture<String> task2 = CompletableFuture.supplyAsync(() -> {\n      return \"任务二的结果\";\n  });\n  \n  Object result = CompletableFuture.anyOf(task1, task2).join();\n  ```\n\n### “所有”组合\n\n> 将多个任务组合，当所有任务都执行完成后执行接下来的任务\n\n- 方法签名\n  ```java\n  public static CompletableFuture<Void> allOf(CompletableFuture<?>... cfs);\n  ```\n- 示例代码\n  ```java\n  CompletableFuture<String> task1 = CompletableFuture.supplyAsync(() -> {\n      return \"任务一的结果\";\n  });\n  \n  CompletableFuture<String> task2 = CompletableFuture.supplyAsync(() -> {\n      return \"任务二的结果\";\n  });\n  \n  Object join = CompletableFuture.allOf(task1, task2).join();\n  ```\n","source":"_posts/2023-08-10-CompletableFuture的使用.md","raw":"---\ntitle: CompletableFuture的使用\ndate: 2023-08-10 12:17:39\ncover: ../img/Java/Thread/Thread.svg\ntags: [ Java,并发,CompletableFuture ]\ncategories:\n  - Java\n---\n\n> CompletableFuture类提供了非常强大的Future的扩展功能，可以帮助我们简化异步编程的复杂性，提供了函数式编程的能力，可以通过回调的方式处理计算结果，并且提供了转换和组合CompletableFuture的方法。\n\n# 总结\n\n<table>\n    <tr>\n        <th>分类</th>\n        <th>方法名</th>\n        <th>描述</th>\n    </tr>\n    <tr>\n        <th rowspan=\"2\">创建异步任务</th>\n        <td><code>runAsync</code></td>\n        <td>不支持返回值</td>\n    </tr>\n    <tr>\n        <td><code>supplyAsync</code></td>\n        <td>支持返回值</td>\n    </tr>\n    <tr>\n        <th rowspan=\"6\">创建异步任务</th>\n        <td><code>thenRun</code>、<code>thenRunAsync</code></td>\n        <td>不接参数、无返回值</td>\n    </tr>\n    <tr>\n        <td><code>thenAccept</code>、<code>thenAcceptAsync</code></td>\n        <td>接返回值、无返回值</td>\n    </tr>\n    <tr>\n        <td><code>thenApply</code>、<code>thenApplyAsync</code></td>\n        <td>接返回值、有返回值</td>\n    </tr>\n    <tr>\n        <td><code>exceptionally</code>、<code>exceptionallyAsync</code></td>\n        <td>接异常、有返回值</td>\n    </tr>\n    <tr>\n        <td><code>whenComplete</code>、<code>whenCompleteAsync</code></td>\n        <td>接返回值和异常、无返回值</td>\n    </tr>\n    <tr>\n        <td><code>handle</code>、<code>handleAsync</code></td>\n        <td>接返回值和异常、有返回值</td>\n    </tr>\n    <tr>\n        <th rowspan=\"7\">两个任务组合</th>\n        <td><code>thenCompose</code>、<code>thenComposeAsync</code></td>\n        <td>任务转化</td>\n    </tr>\n    <tr>\n        <td><code>thenCombine</code>、<code>thenCombineAsync</code></td>\n        <td>“且”组合、接返回值、有返回值</td>\n    </tr>\n    <tr>\n        <td><code>thenAcceptBoth</code>、<code>thenAcceptBothAsync</code></td>\n        <td>“且”组合、接返回值、无返回值</td>\n    </tr>\n    <tr>\n        <td><code>runAfterBoth</code>、<code>runAfterBothAsync</code></td>\n        <td>“且”组合、不接参数、无返回值</td>\n    </tr>\n    <tr>\n        <td><code>applyToEither</code>、<code>applyToEitherAsync</code></td>\n        <td>“或”组合、接返回值、有返回值</td>\n    </tr>\n    <tr>\n        <td><code>acceptEither</code>、<code>acceptEitherAsync</code></td>\n        <td>“或”组合、接返回值、无返回值</td>\n    </tr>\n    <tr>\n        <td><code>runAfterEither</code>、<code>runAfterEitherAsync</code></td>\n        <td>“或”组合、不接参数、无返回值</td>\n    </tr>\n    <tr>\n        <th rowspan=\"2\">多个任务组合</th>\n        <td><code>anyOf</code></td>\n        <td>“任意一个”组合</td>\n    </tr>\n    <tr>\n        <td><code>allOf</code></td>\n        <td>“所有”组合</td>\n    </tr>\n</table>\n\n> 在CompletableFuture中如果使用没有指定线程池的方法，则会使用`ForkJoinPool.commonPool()`作为它的线程池执行异步代码。\n\n# 创建异步任务\n\n### 不支持返回值\n\n- 方法签名\n  ```java\n  // 使用默认线程池中的线程\n  public static CompletableFuture<Void> runAsync(Runnable runnable);\n  // 使用自定义线程池中的线程\n  public static CompletableFuture<Void> runAsync(Runnable runnable, Executor executor); \n  ```\n- 示例代码\n  ```java\n  CompletableFuture.runAsync(() -> {\n      // TODO 执行任务\n  });\n  ```\n\n### 支持返回值\n\n- 方法签名\n  ```java\n  // 使用默认线程池中的线程\n  public static <U> CompletableFuture<U> supplyAsync(Supplier<U> supplier);\n  // 使用自定义线程池中的线程\n  public static <U> CompletableFuture<U> supplyAsync(Supplier<U> supplier, Executor executor); \n  ```\n\n- 示例代码\n  ```java\n  CompletableFuture.supplyAsync(() -> {\n      // TODO 执行任务\n      return null;\n  });\n    ```\n\n# 任务完成时回调方法\n\n当CompletableFuture任务执行完成或者抛出异常的时候，可以执行特定的回调方法。\n\n### 不接参数、无返回值\n\n> 前一个任务执行完成后执行；任务之间**无参数传递**，回调方法**无返回值**\n\n- 方法签名\n  ```java\n  // 使用调用它的线程上运行（一般是主线程）\n  public CompletableFuture<Void> thenRun(Runnable action);\n  // 使用默认线程池中的线程\n  public CompletableFuture<Void> thenRunAsync(Runnable action);\n  // 使用自定义线程池中的线程\n  public CompletableFuture<Void> thenRunAsync(Runnable action, Executor executor);\n  ```\n- 示例代码\n  ```java\n  CompletableFuture.runAsync(() -> {\n  }).thenRun(() -> {\n      // TODO 执行任务\n  });\n  ```\n\n### 接返回值、无返回值\n\n> 前一个任务执行完成后执行；前一个任务会将执行结果**作为参数**，传递到回调方法中，回调方法**无返回值**\n\n- 方法签名\n  ```java\n  // 使用调用它的线程上运行（一般是主线程）\n  public CompletableFuture<Void> thenAccept(Consumer<? super T> action);\n  // 使用默认线程池中的线程\n  public CompletableFuture<Void> thenAcceptAsync(Consumer<? super T> action);\n  // 使用自定义线程池中的线程\n  public CompletableFuture<Void> thenAcceptAsync(Consumer<? super T> action, Executor executor);\n  ```\n- 示例代码\n  ```java\n  CompletableFuture.supplyAsync(() -> {\n      return \"Result\";\n  }).thenAccept((result) -> {\n      // TODO 执行任务\n  });\n  ```\n\n### 接返回值、有返回值\n\n> 前一个任务执行完成后执行；前一个任务会将执行结果**作为参数**，传递到回调方法中，并且会调方法**有返回值**\n\n- 方法签名\n  ```java\n  // 使用调用它的线程上运行（一般是主线程）\n  public <U> CompletableFuture<U> thenApply(Function<? super T,? extends U> fn);\n  // 使用默认线程池中的线程\n  public <U> CompletableFuture<U> thenApplyAsync(Function<? super T,? extends U> fn);\n  // 使用自定义线程池中的线程\n  public <U> CompletableFuture<U> thenApplyAsync(Function<? super T,? extends U> fn, Executor executor);\n  ```\n- 示例代码\n  ```java\n  CompletableFuture.supplyAsync(() -> {\n      return \"Result_1\";\n  }).thenApply(() -> {\n      // TODO 执行任务\n      return \"Result_2\";\n  });\n  ```\n\n### 接异常、有返回值\n\n> 某个任务执行异常时执行；异常任务抛出的异常**作为参数**，传递到回调方法中，并且会调方法**有返回值**\n\n- 方法签名\n  ```java\n  // 使用调用它的线程上运行（一般是主线程）\n  public CompletableFuture<T> exceptionally(Function<Throwable, ? extends T> fn);\n  // 使用默认线程池中的线程\n  public CompletableFuture<T> exceptionallyAsync(Function<Throwable, ? extends T> fn);\n  // 使用自定义线程池中的线程\n  public CompletableFuture<T> exceptionallyAsync(Function<Throwable, ? extends T> fn, Executor executor);\n  ```\n- 示例代码\n  ```java\n  CompletableFuture.runAsync(() -> {\n      throw new RuntimeException();\n  }).exceptionally((exception) -> {\n      // TODO 处理异常\n      return \"ERROR!\";\n  });\n  ```\n\n### 接返回值和异常、无返回值\n\n> 前一个任务执行完成或出现异常时执行；前一个任务会将结果或抛出的异常**作为参数**，传递到回调方法中，回调方法**无返回值**\n\n- 方法签名\n  ```java\n  // 使用调用它的线程上运行（一般是主线程）\n  public CompletableFuture<T> whenComplete(BiConsumer<? super T, ? super Throwable> action);\n  // 使用默认线程池中的线程\n  public CompletableFuture<T> whenCompleteAsync(BiConsumer<? super T, ? super Throwable> action);\n  // 使用自定义线程池中的线程\n  public CompletableFuture<T> whenCompleteAsync(BiConsumer<? super T, ? super Throwable> action, Executor executor);\n  ```\n- 示例代码\n  ```java\n  CompletableFuture.supplyAsync(() -> {\n      throw new RuntimeException();\n  }).whenCompleteAsync((result, exception) -> {\n      if (exception != null) {\n          // TODO 处理异常\n      } else {\n          // TODO 执行任务\n      }\n  });\n  ```\n\n### 接返回值和异常、有返回值\n\n> 前一个任务执行完成后执行；前一个任务会将结果或抛出的异常**作为参数**，传递到回调方法中，回调方法**有返回值**\n\n- 方法签名\n  ```java\n  // 使用调用它的线程上运行（一般是主线程）\n  public <U> CompletableFuture<U> handle(BiFunction<? super T, Throwable, ? extends U> fn);\n  // 使用默认线程池中的线程\n  public <U> CompletableFuture<U> handleAsync(BiFunction<? super T, Throwable, ? extends U> fn);\n  // 使用自定义线程池中的线程\n  public <U> CompletableFuture<U> handleAsync(BiFunction<? super T, Throwable, ? extends U> fn, Executor executor);\n  ```\n- 示例代码\n  ```java\n  CompletableFuture.supplyAsync(() -> {\n      throw new RuntimeException();\n  }).handleAsync((result, exception) -> {\n      if (exception != null) {\n          // TODO 处理异常\n          return \"ERROR!\";\n      } else {\n          // 执行任务\n          return \"SUCCESS!\";\n      }\n  });\n  ```\n\n# 两个任务组合\n\n### 任务转化\n\n> 将前一个任务的执行结果**作为参数**进行处理，处理后**返回一个新的任务**\n\n- 方法签名\n  ```java\n  // 使用调用它的线程上运行（一般是主线程）\n  public <U> CompletableFuture<U> thenCompose(Function<? super T, ? extends CompletionStage<U>> fn);\n  // 使用默认线程池中的线程\n  public <U> CompletableFuture<U> thenComposeAsync(Function<? super T, ? extends CompletionStage<U>> fn);\n  // 使用自定义线程池中的线程\n  public <U> CompletableFuture<U> thenComposeAsync(Function<? super T, ? extends CompletionStage<U>> fn, Executor executor);\n  ```\n- 示例代码\n  ```java\n  CompletableFuture<String> task = CompletableFuture.supplyAsync(() -> {\n      return \"任务一的结果\";\n  });\n  \n  CompletableFuture<String> stringCompletableFuture = CompletableFuture.supplyAsync(() -> {\n      return \"任务二的结果\";\n  }).thenComposeAsync((result) -> {\n      // TODO 执行任务\n      return task;\n  });\n  ```\n\n### “且”组合、接返回值、有返回值\n\n> 将两个任务组合，当两个任务都正常执行完了，将两个任务的结果作为参数，传递到回调方法中，回调方法有返回值\n\n- 方法签名\n  ```java\n  // 使用调用它的线程上运行（一般是主线程）\n  public <U,V> CompletableFuture<V> thenCombine(CompletionStage<? extends U> other, BiFunction<? super T,? super U,? extends V> fn);\n  // 使用默认线程池中的线程\n  public <U,V> CompletableFuture<V> thenCombineAsync(CompletionStage<? extends U> other, BiFunction<? super T,? super U,? extends V> fn);\n  // 使用自定义线程池中的线程\n  public <U,V> CompletableFuture<V> thenCombineAsync(CompletionStage<? extends U> other, BiFunction<? super T,? super U,? extends V> fn, Executor executor);\n  ```\n- 示例代码\n  ```java\n  CompletableFuture.supplyAsync(() -> {\n      // TODO 任务一\n      return \"任务一的结果\";\n  }).thenCombineAsync(CompletableFuture.supplyAsync(() -> {\n      // TODO 任务二\n      return \"任务二的结果\";\n  }), (result1, result2) -> {\n      // 任务一和任务二都完成时执行的回调方法\n      return null;\n  });\n  ```\n\n### “且”组合、接返回值、无返回值\n\n> 将两个任务组合，当两个任务都正常执行完了，将两个任务的结果作为参数，传递到回调方法中，回调方法无返回值\n\n- 方法签名\n  ```java\n  // 使用调用它的线程上运行（一般是主线程）\n  public <U> CompletableFuture<Void> thenAcceptBoth(CompletionStage<? extends U> other, BiConsumer<? super T, ? super U> action);\n  // 使用默认线程池中的线程\n  public <U> CompletableFuture<Void> thenAcceptBothAsync(CompletionStage<? extends U> other, BiConsumer<? super T, ? super U> action);\n  // 使用自定义线程池中的线程\n  public <U> CompletableFuture<Void> thenAcceptBothAsync(CompletionStage<? extends U> other, BiConsumer<? super T, ? super U> action, Executor executor);\n  ```\n- 示例代码\n  ```java\n  CompletableFuture.supplyAsync(() -> {\n      // TODO 任务一\n      return \"任务一的结果\";\n  }).thenAcceptBothAsync(CompletableFuture.supplyAsync(() -> {\n      // TODO 任务二\n      return \"任务二的结果\";\n  }), (result1, result2) -> {\n      // TODO 任务一和任务二都完成时执行的回调方法\n  });\n  ```\n\n### “且”组合、不接参数、无返回值\n\n> 将两个任务组合，当两个任务都正常执行完了，执行回调方法，回调方法无返回值\n\n- 方法签名\n  ```java\n  // 使用调用它的线程上运行（一般是主线程）\n  public CompletableFuture<Void> runAfterBoth(CompletionStage<?> other, Runnable action);\n  // 使用默认线程池中的线程\n  public CompletableFuture<Void> runAfterBothAsync(CompletionStage<?> other, Runnable action);\n  // 使用自定义线程池中的线程\n  public CompletableFuture<Void> runAfterBothAsync(CompletionStage<?> other, Runnable action, Executor executor);\n  ```\n- 示例代码\n  ```java\n  CompletableFuture.supplyAsync(() -> {\n      // TODO 任务一\n      return \"任务一的结果\";\n  }).runAfterBothAsync(CompletableFuture.supplyAsync(() -> {\n      // TODO 任务二\n      return \"任务二的结果\";\n  }), () -> {\n      // TODO 任务一和任务二都完成时执行的回调方法\n  });\n  ```\n\n### “或”组合、接返回值、有返回值\n\n> 将两个任务组合，其中任意一个任务执行完成，将该任务的结果作为参数，传递到回调方法中，回调方法有返回值\n\n- 方法签名\n  ```java\n  // 使用调用它的线程上运行（一般是主线程）\n  public <U> CompletableFuture<U> applyToEither(CompletionStage<? extends T> other, Function<? super T, U> fn);\n  // 使用默认线程池中的线程\n  public <U> CompletableFuture<U> applyToEitherAsync(CompletionStage<? extends T> other, Function<? super T, U> fn);\n  // 使用自定义线程池中的线程\n  public <U> CompletableFuture<U> applyToEitherAsync(CompletionStage<? extends T> other, Function<? super T, U> fn, Executor executor);\n  ```\n- 示例代码\n  ```java\n  CompletableFuture.supplyAsync(() -> {\n      // TODO 任务一\n      return \"任务一的结果\";\n  }).applyToEitherAsync(CompletableFuture.supplyAsync(() -> {\n      // TODO 任务二\n      return \"任务二的结果\";\n  }), (result) -> {\n      // TODO 任务一和任务二任意一个执行完成时执行的回调方法\n      return \"SUCCESS\";\n  });\n  ```\n\n### “或”组合、接返回值、无返回值\n\n> 将两个任务组合，其中任意一个任务执行完成，将该任务的结果作为参数，传递到回调方法中，回调方法无返回值\n\n- 方法签名\n  ```java\n  // 使用调用它的线程上运行（一般是主线程）\n  public CompletableFuture<Void> acceptEither(CompletionStage<? extends T> other, Consumer<? super T> action);\n  // 使用默认线程池中的线程\n  public CompletableFuture<Void> acceptEitherAsync(CompletionStage<? extends T> other, Consumer<? super T> action);\n  // 使用自定义线程池中的线程\n  public CompletableFuture<Void> acceptEitherAsync(CompletionStage<? extends T> other, Consumer<? super T> action, Executor executor);\n  ```\n- 示例代码\n  ```java\n  CompletableFuture.supplyAsync(() -> {\n      // TODO 任务一\n      try {\n          Thread.sleep(10);\n      } catch (InterruptedException e) {\n          throw new RuntimeException(e);\n      }\n      return \"任务一的结果\";\n  }).acceptEitherAsync(CompletableFuture.supplyAsync(() -> {\n      // TODO 任务二\n      return \"任务二的结果\";\n  }), (result) -> {\n      // TODO 任务一和任务二任意一个执行完成时执行的回调方法\n  });\n  ```\n\n### “或”组合、不接参数、无返回值\n\n> 将两个任务组合，其中任意一个任务执行完成，执行回调方法，回调方法无返回值\n\n- 方法签名\n  ```java\n  // 使用调用它的线程上运行（一般是主线程）\n  public CompletableFuture<Void> runAfterEither(CompletionStage<?> other, Runnable action);\n  // 使用默认线程池中的线程\n  public CompletableFuture<Void> runAfterEitherAsync(CompletionStage<?> other, Runnable action);\n  // 使用自定义线程池中的线程\n  public CompletableFuture<Void> runAfterEitherAsync(CompletionStage<?> other, Runnable action, Executor executor);\n  ```\n- 示例代码\n  ```java\n  CompletableFuture.supplyAsync(() -> {\n      // TODO 任务一\n      try {\n          Thread.sleep(10);\n      } catch (InterruptedException e) {\n          throw new RuntimeException(e);\n      }\n      return \"任务一的结果\";\n  }).runAfterEitherAsync(CompletableFuture.supplyAsync(() -> {\n      // TODO 任务二\n      return \"任务二的结果\";\n  }), () -> {\n      // TODO 任务一和任务二任意一个执行完成时执行的回调方法\n  });\n  ```\n\n# 多个任务组合\n\n### “任意一个”组合\n\n> 将多个任务组合，其中任意一个任务执行完成即可拿到该任务的执行结果（执行结果为Object类型），或执行接下来的任务\n\n- 方法签名\n  ```java\n  public static CompletableFuture<Object> anyOf(CompletableFuture<?>... cfs);\n  ```\n- 示例代码\n  ```java\n  CompletableFuture<String> task1 = CompletableFuture.supplyAsync(() -> {\n      return \"任务一的结果\";\n  });\n  \n  CompletableFuture<String> task2 = CompletableFuture.supplyAsync(() -> {\n      return \"任务二的结果\";\n  });\n  \n  Object result = CompletableFuture.anyOf(task1, task2).join();\n  ```\n\n### “所有”组合\n\n> 将多个任务组合，当所有任务都执行完成后执行接下来的任务\n\n- 方法签名\n  ```java\n  public static CompletableFuture<Void> allOf(CompletableFuture<?>... cfs);\n  ```\n- 示例代码\n  ```java\n  CompletableFuture<String> task1 = CompletableFuture.supplyAsync(() -> {\n      return \"任务一的结果\";\n  });\n  \n  CompletableFuture<String> task2 = CompletableFuture.supplyAsync(() -> {\n      return \"任务二的结果\";\n  });\n  \n  Object join = CompletableFuture.allOf(task1, task2).join();\n  ```\n","slug":"2023-08-10-CompletableFuture的使用","published":1,"updated":"2024-04-13T14:25:52.438Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clxjyo3b80000isvd9uo99zq7","content":"<blockquote>\n<p>CompletableFuture类提供了非常强大的Future的扩展功能，可以帮助我们简化异步编程的复杂性，提供了函数式编程的能力，可以通过回调的方式处理计算结果，并且提供了转换和组合CompletableFuture的方法。</p>\n</blockquote>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><table>\n    <tr>\n        <th>分类</th>\n        <th>方法名</th>\n        <th>描述</th>\n    </tr>\n    <tr>\n        <th rowspan=\"2\">创建异步任务</th>\n        <td><code>runAsync</code></td>\n        <td>不支持返回值</td>\n    </tr>\n    <tr>\n        <td><code>supplyAsync</code></td>\n        <td>支持返回值</td>\n    </tr>\n    <tr>\n        <th rowspan=\"6\">创建异步任务</th>\n        <td><code>thenRun</code>、<code>thenRunAsync</code></td>\n        <td>不接参数、无返回值</td>\n    </tr>\n    <tr>\n        <td><code>thenAccept</code>、<code>thenAcceptAsync</code></td>\n        <td>接返回值、无返回值</td>\n    </tr>\n    <tr>\n        <td><code>thenApply</code>、<code>thenApplyAsync</code></td>\n        <td>接返回值、有返回值</td>\n    </tr>\n    <tr>\n        <td><code>exceptionally</code>、<code>exceptionallyAsync</code></td>\n        <td>接异常、有返回值</td>\n    </tr>\n    <tr>\n        <td><code>whenComplete</code>、<code>whenCompleteAsync</code></td>\n        <td>接返回值和异常、无返回值</td>\n    </tr>\n    <tr>\n        <td><code>handle</code>、<code>handleAsync</code></td>\n        <td>接返回值和异常、有返回值</td>\n    </tr>\n    <tr>\n        <th rowspan=\"7\">两个任务组合</th>\n        <td><code>thenCompose</code>、<code>thenComposeAsync</code></td>\n        <td>任务转化</td>\n    </tr>\n    <tr>\n        <td><code>thenCombine</code>、<code>thenCombineAsync</code></td>\n        <td>“且”组合、接返回值、有返回值</td>\n    </tr>\n    <tr>\n        <td><code>thenAcceptBoth</code>、<code>thenAcceptBothAsync</code></td>\n        <td>“且”组合、接返回值、无返回值</td>\n    </tr>\n    <tr>\n        <td><code>runAfterBoth</code>、<code>runAfterBothAsync</code></td>\n        <td>“且”组合、不接参数、无返回值</td>\n    </tr>\n    <tr>\n        <td><code>applyToEither</code>、<code>applyToEitherAsync</code></td>\n        <td>“或”组合、接返回值、有返回值</td>\n    </tr>\n    <tr>\n        <td><code>acceptEither</code>、<code>acceptEitherAsync</code></td>\n        <td>“或”组合、接返回值、无返回值</td>\n    </tr>\n    <tr>\n        <td><code>runAfterEither</code>、<code>runAfterEitherAsync</code></td>\n        <td>“或”组合、不接参数、无返回值</td>\n    </tr>\n    <tr>\n        <th rowspan=\"2\">多个任务组合</th>\n        <td><code>anyOf</code></td>\n        <td>“任意一个”组合</td>\n    </tr>\n    <tr>\n        <td><code>allOf</code></td>\n        <td>“所有”组合</td>\n    </tr>\n</table>\n\n<blockquote>\n<p>在CompletableFuture中如果使用没有指定线程池的方法，则会使用<code>ForkJoinPool.commonPool()</code>作为它的线程池执行异步代码。</p>\n</blockquote>\n<h1 id=\"创建异步任务\"><a href=\"#创建异步任务\" class=\"headerlink\" title=\"创建异步任务\"></a>创建异步任务</h1><h3 id=\"不支持返回值\"><a href=\"#不支持返回值\" class=\"headerlink\" title=\"不支持返回值\"></a>不支持返回值</h3><ul>\n<li>方法签名<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用默认线程池中的线程</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> CompletableFuture&lt;Void&gt; <span class=\"title function_\">runAsync</span><span class=\"params\">(Runnable runnable)</span>;</span><br><span class=\"line\"><span class=\"comment\">// 使用自定义线程池中的线程</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> CompletableFuture&lt;Void&gt; <span class=\"title function_\">runAsync</span><span class=\"params\">(Runnable runnable, Executor executor)</span>; </span><br></pre></td></tr></table></figure></li>\n<li>示例代码<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">// TODO 执行任务</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"支持返回值\"><a href=\"#支持返回值\" class=\"headerlink\" title=\"支持返回值\"></a>支持返回值</h3><ul>\n<li><p>方法签名</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用默认线程池中的线程</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class=\"title function_\">supplyAsync</span><span class=\"params\">(Supplier&lt;U&gt; supplier)</span>;</span><br><span class=\"line\"><span class=\"comment\">// 使用自定义线程池中的线程</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class=\"title function_\">supplyAsync</span><span class=\"params\">(Supplier&lt;U&gt; supplier, Executor executor)</span>; </span><br></pre></td></tr></table></figure>\n</li>\n<li><p>示例代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">// TODO 执行任务</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h1 id=\"任务完成时回调方法\"><a href=\"#任务完成时回调方法\" class=\"headerlink\" title=\"任务完成时回调方法\"></a>任务完成时回调方法</h1><p>当CompletableFuture任务执行完成或者抛出异常的时候，可以执行特定的回调方法。</p>\n<h3 id=\"不接参数、无返回值\"><a href=\"#不接参数、无返回值\" class=\"headerlink\" title=\"不接参数、无返回值\"></a>不接参数、无返回值</h3><blockquote>\n<p>前一个任务执行完成后执行；任务之间<strong>无参数传递</strong>，回调方法<strong>无返回值</strong></p>\n</blockquote>\n<ul>\n<li>方法签名<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用调用它的线程上运行（一般是主线程）</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> CompletableFuture&lt;Void&gt; <span class=\"title function_\">thenRun</span><span class=\"params\">(Runnable action)</span>;</span><br><span class=\"line\"><span class=\"comment\">// 使用默认线程池中的线程</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> CompletableFuture&lt;Void&gt; <span class=\"title function_\">thenRunAsync</span><span class=\"params\">(Runnable action)</span>;</span><br><span class=\"line\"><span class=\"comment\">// 使用自定义线程池中的线程</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> CompletableFuture&lt;Void&gt; <span class=\"title function_\">thenRunAsync</span><span class=\"params\">(Runnable action, Executor executor)</span>;</span><br></pre></td></tr></table></figure></li>\n<li>示例代码<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class=\"line\">&#125;).thenRun(() -&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">// TODO 执行任务</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"接返回值、无返回值\"><a href=\"#接返回值、无返回值\" class=\"headerlink\" title=\"接返回值、无返回值\"></a>接返回值、无返回值</h3><blockquote>\n<p>前一个任务执行完成后执行；前一个任务会将执行结果<strong>作为参数</strong>，传递到回调方法中，回调方法<strong>无返回值</strong></p>\n</blockquote>\n<ul>\n<li>方法签名<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用调用它的线程上运行（一般是主线程）</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> CompletableFuture&lt;Void&gt; <span class=\"title function_\">thenAccept</span><span class=\"params\">(Consumer&lt;? <span class=\"built_in\">super</span> T&gt; action)</span>;</span><br><span class=\"line\"><span class=\"comment\">// 使用默认线程池中的线程</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> CompletableFuture&lt;Void&gt; <span class=\"title function_\">thenAcceptAsync</span><span class=\"params\">(Consumer&lt;? <span class=\"built_in\">super</span> T&gt; action)</span>;</span><br><span class=\"line\"><span class=\"comment\">// 使用自定义线程池中的线程</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> CompletableFuture&lt;Void&gt; <span class=\"title function_\">thenAcceptAsync</span><span class=\"params\">(Consumer&lt;? <span class=\"built_in\">super</span> T&gt; action, Executor executor)</span>;</span><br></pre></td></tr></table></figure></li>\n<li>示例代码<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;Result&quot;</span>;</span><br><span class=\"line\">&#125;).thenAccept((result) -&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">// TODO 执行任务</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"接返回值、有返回值\"><a href=\"#接返回值、有返回值\" class=\"headerlink\" title=\"接返回值、有返回值\"></a>接返回值、有返回值</h3><blockquote>\n<p>前一个任务执行完成后执行；前一个任务会将执行结果<strong>作为参数</strong>，传递到回调方法中，并且会调方法<strong>有返回值</strong></p>\n</blockquote>\n<ul>\n<li>方法签名<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用调用它的线程上运行（一般是主线程）</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class=\"title function_\">thenApply</span><span class=\"params\">(Function&lt;? <span class=\"built_in\">super</span> T,? extends U&gt; fn)</span>;</span><br><span class=\"line\"><span class=\"comment\">// 使用默认线程池中的线程</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class=\"title function_\">thenApplyAsync</span><span class=\"params\">(Function&lt;? <span class=\"built_in\">super</span> T,? extends U&gt; fn)</span>;</span><br><span class=\"line\"><span class=\"comment\">// 使用自定义线程池中的线程</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class=\"title function_\">thenApplyAsync</span><span class=\"params\">(Function&lt;? <span class=\"built_in\">super</span> T,? extends U&gt; fn, Executor executor)</span>;</span><br></pre></td></tr></table></figure></li>\n<li>示例代码<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;Result_1&quot;</span>;</span><br><span class=\"line\">&#125;).thenApply(() -&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">// TODO 执行任务</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;Result_2&quot;</span>;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"接异常、有返回值\"><a href=\"#接异常、有返回值\" class=\"headerlink\" title=\"接异常、有返回值\"></a>接异常、有返回值</h3><blockquote>\n<p>某个任务执行异常时执行；异常任务抛出的异常<strong>作为参数</strong>，传递到回调方法中，并且会调方法<strong>有返回值</strong></p>\n</blockquote>\n<ul>\n<li>方法签名<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用调用它的线程上运行（一般是主线程）</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> CompletableFuture&lt;T&gt; <span class=\"title function_\">exceptionally</span><span class=\"params\">(Function&lt;Throwable, ? extends T&gt; fn)</span>;</span><br><span class=\"line\"><span class=\"comment\">// 使用默认线程池中的线程</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> CompletableFuture&lt;T&gt; <span class=\"title function_\">exceptionallyAsync</span><span class=\"params\">(Function&lt;Throwable, ? extends T&gt; fn)</span>;</span><br><span class=\"line\"><span class=\"comment\">// 使用自定义线程池中的线程</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> CompletableFuture&lt;T&gt; <span class=\"title function_\">exceptionallyAsync</span><span class=\"params\">(Function&lt;Throwable, ? extends T&gt; fn, Executor executor)</span>;</span><br></pre></td></tr></table></figure></li>\n<li>示例代码<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RuntimeException</span>();</span><br><span class=\"line\">&#125;).exceptionally((exception) -&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">// TODO 处理异常</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;ERROR!&quot;</span>;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"接返回值和异常、无返回值\"><a href=\"#接返回值和异常、无返回值\" class=\"headerlink\" title=\"接返回值和异常、无返回值\"></a>接返回值和异常、无返回值</h3><blockquote>\n<p>前一个任务执行完成或出现异常时执行；前一个任务会将结果或抛出的异常<strong>作为参数</strong>，传递到回调方法中，回调方法<strong>无返回值</strong></p>\n</blockquote>\n<ul>\n<li>方法签名<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用调用它的线程上运行（一般是主线程）</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> CompletableFuture&lt;T&gt; <span class=\"title function_\">whenComplete</span><span class=\"params\">(BiConsumer&lt;? <span class=\"built_in\">super</span> T, ? <span class=\"built_in\">super</span> Throwable&gt; action)</span>;</span><br><span class=\"line\"><span class=\"comment\">// 使用默认线程池中的线程</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> CompletableFuture&lt;T&gt; <span class=\"title function_\">whenCompleteAsync</span><span class=\"params\">(BiConsumer&lt;? <span class=\"built_in\">super</span> T, ? <span class=\"built_in\">super</span> Throwable&gt; action)</span>;</span><br><span class=\"line\"><span class=\"comment\">// 使用自定义线程池中的线程</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> CompletableFuture&lt;T&gt; <span class=\"title function_\">whenCompleteAsync</span><span class=\"params\">(BiConsumer&lt;? <span class=\"built_in\">super</span> T, ? <span class=\"built_in\">super</span> Throwable&gt; action, Executor executor)</span>;</span><br></pre></td></tr></table></figure></li>\n<li>示例代码<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RuntimeException</span>();</span><br><span class=\"line\">&#125;).whenCompleteAsync((result, exception) -&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (exception != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// TODO 处理异常</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// TODO 执行任务</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"接返回值和异常、有返回值\"><a href=\"#接返回值和异常、有返回值\" class=\"headerlink\" title=\"接返回值和异常、有返回值\"></a>接返回值和异常、有返回值</h3><blockquote>\n<p>前一个任务执行完成后执行；前一个任务会将结果或抛出的异常<strong>作为参数</strong>，传递到回调方法中，回调方法<strong>有返回值</strong></p>\n</blockquote>\n<ul>\n<li>方法签名<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用调用它的线程上运行（一般是主线程）</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class=\"title function_\">handle</span><span class=\"params\">(BiFunction&lt;? <span class=\"built_in\">super</span> T, Throwable, ? extends U&gt; fn)</span>;</span><br><span class=\"line\"><span class=\"comment\">// 使用默认线程池中的线程</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class=\"title function_\">handleAsync</span><span class=\"params\">(BiFunction&lt;? <span class=\"built_in\">super</span> T, Throwable, ? extends U&gt; fn)</span>;</span><br><span class=\"line\"><span class=\"comment\">// 使用自定义线程池中的线程</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class=\"title function_\">handleAsync</span><span class=\"params\">(BiFunction&lt;? <span class=\"built_in\">super</span> T, Throwable, ? extends U&gt; fn, Executor executor)</span>;</span><br></pre></td></tr></table></figure></li>\n<li>示例代码<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RuntimeException</span>();</span><br><span class=\"line\">&#125;).handleAsync((result, exception) -&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (exception != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// TODO 处理异常</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;ERROR!&quot;</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 执行任务</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;SUCCESS!&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h1 id=\"两个任务组合\"><a href=\"#两个任务组合\" class=\"headerlink\" title=\"两个任务组合\"></a>两个任务组合</h1><h3 id=\"任务转化\"><a href=\"#任务转化\" class=\"headerlink\" title=\"任务转化\"></a>任务转化</h3><blockquote>\n<p>将前一个任务的执行结果<strong>作为参数</strong>进行处理，处理后<strong>返回一个新的任务</strong></p>\n</blockquote>\n<ul>\n<li>方法签名<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用调用它的线程上运行（一般是主线程）</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class=\"title function_\">thenCompose</span><span class=\"params\">(Function&lt;? <span class=\"built_in\">super</span> T, ? extends CompletionStage&lt;U&gt;&gt; fn)</span>;</span><br><span class=\"line\"><span class=\"comment\">// 使用默认线程池中的线程</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class=\"title function_\">thenComposeAsync</span><span class=\"params\">(Function&lt;? <span class=\"built_in\">super</span> T, ? extends CompletionStage&lt;U&gt;&gt; fn)</span>;</span><br><span class=\"line\"><span class=\"comment\">// 使用自定义线程池中的线程</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class=\"title function_\">thenComposeAsync</span><span class=\"params\">(Function&lt;? <span class=\"built_in\">super</span> T, ? extends CompletionStage&lt;U&gt;&gt; fn, Executor executor)</span>;</span><br></pre></td></tr></table></figure></li>\n<li>示例代码<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CompletableFuture&lt;String&gt; task = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;任务一的结果&quot;</span>;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">CompletableFuture&lt;String&gt; stringCompletableFuture = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;任务二的结果&quot;</span>;</span><br><span class=\"line\">&#125;).thenComposeAsync((result) -&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">// TODO 执行任务</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> task;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"“且”组合、接返回值、有返回值\"><a href=\"#“且”组合、接返回值、有返回值\" class=\"headerlink\" title=\"“且”组合、接返回值、有返回值\"></a>“且”组合、接返回值、有返回值</h3><blockquote>\n<p>将两个任务组合，当两个任务都正常执行完了，将两个任务的结果作为参数，传递到回调方法中，回调方法有返回值</p>\n</blockquote>\n<ul>\n<li>方法签名<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用调用它的线程上运行（一般是主线程）</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> &lt;U,V&gt; CompletableFuture&lt;V&gt; <span class=\"title function_\">thenCombine</span><span class=\"params\">(CompletionStage&lt;? extends U&gt; other, BiFunction&lt;? <span class=\"built_in\">super</span> T,? <span class=\"built_in\">super</span> U,? extends V&gt; fn)</span>;</span><br><span class=\"line\"><span class=\"comment\">// 使用默认线程池中的线程</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> &lt;U,V&gt; CompletableFuture&lt;V&gt; <span class=\"title function_\">thenCombineAsync</span><span class=\"params\">(CompletionStage&lt;? extends U&gt; other, BiFunction&lt;? <span class=\"built_in\">super</span> T,? <span class=\"built_in\">super</span> U,? extends V&gt; fn)</span>;</span><br><span class=\"line\"><span class=\"comment\">// 使用自定义线程池中的线程</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> &lt;U,V&gt; CompletableFuture&lt;V&gt; <span class=\"title function_\">thenCombineAsync</span><span class=\"params\">(CompletionStage&lt;? extends U&gt; other, BiFunction&lt;? <span class=\"built_in\">super</span> T,? <span class=\"built_in\">super</span> U,? extends V&gt; fn, Executor executor)</span>;</span><br></pre></td></tr></table></figure></li>\n<li>示例代码<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">// TODO 任务一</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;任务一的结果&quot;</span>;</span><br><span class=\"line\">&#125;).thenCombineAsync(CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">// TODO 任务二</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;任务二的结果&quot;</span>;</span><br><span class=\"line\">&#125;), (result1, result2) -&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 任务一和任务二都完成时执行的回调方法</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"“且”组合、接返回值、无返回值\"><a href=\"#“且”组合、接返回值、无返回值\" class=\"headerlink\" title=\"“且”组合、接返回值、无返回值\"></a>“且”组合、接返回值、无返回值</h3><blockquote>\n<p>将两个任务组合，当两个任务都正常执行完了，将两个任务的结果作为参数，传递到回调方法中，回调方法无返回值</p>\n</blockquote>\n<ul>\n<li>方法签名<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用调用它的线程上运行（一般是主线程）</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> &lt;U&gt; CompletableFuture&lt;Void&gt; <span class=\"title function_\">thenAcceptBoth</span><span class=\"params\">(CompletionStage&lt;? extends U&gt; other, BiConsumer&lt;? <span class=\"built_in\">super</span> T, ? <span class=\"built_in\">super</span> U&gt; action)</span>;</span><br><span class=\"line\"><span class=\"comment\">// 使用默认线程池中的线程</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> &lt;U&gt; CompletableFuture&lt;Void&gt; <span class=\"title function_\">thenAcceptBothAsync</span><span class=\"params\">(CompletionStage&lt;? extends U&gt; other, BiConsumer&lt;? <span class=\"built_in\">super</span> T, ? <span class=\"built_in\">super</span> U&gt; action)</span>;</span><br><span class=\"line\"><span class=\"comment\">// 使用自定义线程池中的线程</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> &lt;U&gt; CompletableFuture&lt;Void&gt; <span class=\"title function_\">thenAcceptBothAsync</span><span class=\"params\">(CompletionStage&lt;? extends U&gt; other, BiConsumer&lt;? <span class=\"built_in\">super</span> T, ? <span class=\"built_in\">super</span> U&gt; action, Executor executor)</span>;</span><br></pre></td></tr></table></figure></li>\n<li>示例代码<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">// TODO 任务一</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;任务一的结果&quot;</span>;</span><br><span class=\"line\">&#125;).thenAcceptBothAsync(CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">// TODO 任务二</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;任务二的结果&quot;</span>;</span><br><span class=\"line\">&#125;), (result1, result2) -&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">// TODO 任务一和任务二都完成时执行的回调方法</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"“且”组合、不接参数、无返回值\"><a href=\"#“且”组合、不接参数、无返回值\" class=\"headerlink\" title=\"“且”组合、不接参数、无返回值\"></a>“且”组合、不接参数、无返回值</h3><blockquote>\n<p>将两个任务组合，当两个任务都正常执行完了，执行回调方法，回调方法无返回值</p>\n</blockquote>\n<ul>\n<li>方法签名<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用调用它的线程上运行（一般是主线程）</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> CompletableFuture&lt;Void&gt; <span class=\"title function_\">runAfterBoth</span><span class=\"params\">(CompletionStage&lt;?&gt; other, Runnable action)</span>;</span><br><span class=\"line\"><span class=\"comment\">// 使用默认线程池中的线程</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> CompletableFuture&lt;Void&gt; <span class=\"title function_\">runAfterBothAsync</span><span class=\"params\">(CompletionStage&lt;?&gt; other, Runnable action)</span>;</span><br><span class=\"line\"><span class=\"comment\">// 使用自定义线程池中的线程</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> CompletableFuture&lt;Void&gt; <span class=\"title function_\">runAfterBothAsync</span><span class=\"params\">(CompletionStage&lt;?&gt; other, Runnable action, Executor executor)</span>;</span><br></pre></td></tr></table></figure></li>\n<li>示例代码<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">// TODO 任务一</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;任务一的结果&quot;</span>;</span><br><span class=\"line\">&#125;).runAfterBothAsync(CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">// TODO 任务二</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;任务二的结果&quot;</span>;</span><br><span class=\"line\">&#125;), () -&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">// TODO 任务一和任务二都完成时执行的回调方法</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"“或”组合、接返回值、有返回值\"><a href=\"#“或”组合、接返回值、有返回值\" class=\"headerlink\" title=\"“或”组合、接返回值、有返回值\"></a>“或”组合、接返回值、有返回值</h3><blockquote>\n<p>将两个任务组合，其中任意一个任务执行完成，将该任务的结果作为参数，传递到回调方法中，回调方法有返回值</p>\n</blockquote>\n<ul>\n<li>方法签名<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用调用它的线程上运行（一般是主线程）</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class=\"title function_\">applyToEither</span><span class=\"params\">(CompletionStage&lt;? extends T&gt; other, Function&lt;? <span class=\"built_in\">super</span> T, U&gt; fn)</span>;</span><br><span class=\"line\"><span class=\"comment\">// 使用默认线程池中的线程</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class=\"title function_\">applyToEitherAsync</span><span class=\"params\">(CompletionStage&lt;? extends T&gt; other, Function&lt;? <span class=\"built_in\">super</span> T, U&gt; fn)</span>;</span><br><span class=\"line\"><span class=\"comment\">// 使用自定义线程池中的线程</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class=\"title function_\">applyToEitherAsync</span><span class=\"params\">(CompletionStage&lt;? extends T&gt; other, Function&lt;? <span class=\"built_in\">super</span> T, U&gt; fn, Executor executor)</span>;</span><br></pre></td></tr></table></figure></li>\n<li>示例代码<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">// TODO 任务一</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;任务一的结果&quot;</span>;</span><br><span class=\"line\">&#125;).applyToEitherAsync(CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">// TODO 任务二</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;任务二的结果&quot;</span>;</span><br><span class=\"line\">&#125;), (result) -&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">// TODO 任务一和任务二任意一个执行完成时执行的回调方法</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;SUCCESS&quot;</span>;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"“或”组合、接返回值、无返回值\"><a href=\"#“或”组合、接返回值、无返回值\" class=\"headerlink\" title=\"“或”组合、接返回值、无返回值\"></a>“或”组合、接返回值、无返回值</h3><blockquote>\n<p>将两个任务组合，其中任意一个任务执行完成，将该任务的结果作为参数，传递到回调方法中，回调方法无返回值</p>\n</blockquote>\n<ul>\n<li>方法签名<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用调用它的线程上运行（一般是主线程）</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> CompletableFuture&lt;Void&gt; <span class=\"title function_\">acceptEither</span><span class=\"params\">(CompletionStage&lt;? extends T&gt; other, Consumer&lt;? <span class=\"built_in\">super</span> T&gt; action)</span>;</span><br><span class=\"line\"><span class=\"comment\">// 使用默认线程池中的线程</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> CompletableFuture&lt;Void&gt; <span class=\"title function_\">acceptEitherAsync</span><span class=\"params\">(CompletionStage&lt;? extends T&gt; other, Consumer&lt;? <span class=\"built_in\">super</span> T&gt; action)</span>;</span><br><span class=\"line\"><span class=\"comment\">// 使用自定义线程池中的线程</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> CompletableFuture&lt;Void&gt; <span class=\"title function_\">acceptEitherAsync</span><span class=\"params\">(CompletionStage&lt;? extends T&gt; other, Consumer&lt;? <span class=\"built_in\">super</span> T&gt; action, Executor executor)</span>;</span><br></pre></td></tr></table></figure></li>\n<li>示例代码<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">// TODO 任务一</span></span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        Thread.sleep(<span class=\"number\">10</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RuntimeException</span>(e);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;任务一的结果&quot;</span>;</span><br><span class=\"line\">&#125;).acceptEitherAsync(CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">// TODO 任务二</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;任务二的结果&quot;</span>;</span><br><span class=\"line\">&#125;), (result) -&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">// TODO 任务一和任务二任意一个执行完成时执行的回调方法</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"“或”组合、不接参数、无返回值\"><a href=\"#“或”组合、不接参数、无返回值\" class=\"headerlink\" title=\"“或”组合、不接参数、无返回值\"></a>“或”组合、不接参数、无返回值</h3><blockquote>\n<p>将两个任务组合，其中任意一个任务执行完成，执行回调方法，回调方法无返回值</p>\n</blockquote>\n<ul>\n<li>方法签名<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用调用它的线程上运行（一般是主线程）</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> CompletableFuture&lt;Void&gt; <span class=\"title function_\">runAfterEither</span><span class=\"params\">(CompletionStage&lt;?&gt; other, Runnable action)</span>;</span><br><span class=\"line\"><span class=\"comment\">// 使用默认线程池中的线程</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> CompletableFuture&lt;Void&gt; <span class=\"title function_\">runAfterEitherAsync</span><span class=\"params\">(CompletionStage&lt;?&gt; other, Runnable action)</span>;</span><br><span class=\"line\"><span class=\"comment\">// 使用自定义线程池中的线程</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> CompletableFuture&lt;Void&gt; <span class=\"title function_\">runAfterEitherAsync</span><span class=\"params\">(CompletionStage&lt;?&gt; other, Runnable action, Executor executor)</span>;</span><br></pre></td></tr></table></figure></li>\n<li>示例代码<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">// TODO 任务一</span></span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        Thread.sleep(<span class=\"number\">10</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RuntimeException</span>(e);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;任务一的结果&quot;</span>;</span><br><span class=\"line\">&#125;).runAfterEitherAsync(CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">// TODO 任务二</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;任务二的结果&quot;</span>;</span><br><span class=\"line\">&#125;), () -&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">// TODO 任务一和任务二任意一个执行完成时执行的回调方法</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h1 id=\"多个任务组合\"><a href=\"#多个任务组合\" class=\"headerlink\" title=\"多个任务组合\"></a>多个任务组合</h1><h3 id=\"“任意一个”组合\"><a href=\"#“任意一个”组合\" class=\"headerlink\" title=\"“任意一个”组合\"></a>“任意一个”组合</h3><blockquote>\n<p>将多个任务组合，其中任意一个任务执行完成即可拿到该任务的执行结果（执行结果为Object类型），或执行接下来的任务</p>\n</blockquote>\n<ul>\n<li>方法签名<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> CompletableFuture&lt;Object&gt; <span class=\"title function_\">anyOf</span><span class=\"params\">(CompletableFuture&lt;?&gt;... cfs)</span>;</span><br></pre></td></tr></table></figure></li>\n<li>示例代码<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CompletableFuture&lt;String&gt; task1 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;任务一的结果&quot;</span>;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">CompletableFuture&lt;String&gt; task2 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;任务二的结果&quot;</span>;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">Object</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> CompletableFuture.anyOf(task1, task2).join();</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"“所有”组合\"><a href=\"#“所有”组合\" class=\"headerlink\" title=\"“所有”组合\"></a>“所有”组合</h3><blockquote>\n<p>将多个任务组合，当所有任务都执行完成后执行接下来的任务</p>\n</blockquote>\n<ul>\n<li>方法签名<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> CompletableFuture&lt;Void&gt; <span class=\"title function_\">allOf</span><span class=\"params\">(CompletableFuture&lt;?&gt;... cfs)</span>;</span><br></pre></td></tr></table></figure></li>\n<li>示例代码<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CompletableFuture&lt;String&gt; task1 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;任务一的结果&quot;</span>;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">CompletableFuture&lt;String&gt; task2 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;任务二的结果&quot;</span>;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">Object</span> <span class=\"variable\">join</span> <span class=\"operator\">=</span> CompletableFuture.allOf(task1, task2).join();</span><br></pre></td></tr></table></figure></li>\n</ul>\n","site":{"data":{}},"cover_type":"img","excerpt":"","more":"<blockquote>\n<p>CompletableFuture类提供了非常强大的Future的扩展功能，可以帮助我们简化异步编程的复杂性，提供了函数式编程的能力，可以通过回调的方式处理计算结果，并且提供了转换和组合CompletableFuture的方法。</p>\n</blockquote>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><table>\n    <tr>\n        <th>分类</th>\n        <th>方法名</th>\n        <th>描述</th>\n    </tr>\n    <tr>\n        <th rowspan=\"2\">创建异步任务</th>\n        <td><code>runAsync</code></td>\n        <td>不支持返回值</td>\n    </tr>\n    <tr>\n        <td><code>supplyAsync</code></td>\n        <td>支持返回值</td>\n    </tr>\n    <tr>\n        <th rowspan=\"6\">创建异步任务</th>\n        <td><code>thenRun</code>、<code>thenRunAsync</code></td>\n        <td>不接参数、无返回值</td>\n    </tr>\n    <tr>\n        <td><code>thenAccept</code>、<code>thenAcceptAsync</code></td>\n        <td>接返回值、无返回值</td>\n    </tr>\n    <tr>\n        <td><code>thenApply</code>、<code>thenApplyAsync</code></td>\n        <td>接返回值、有返回值</td>\n    </tr>\n    <tr>\n        <td><code>exceptionally</code>、<code>exceptionallyAsync</code></td>\n        <td>接异常、有返回值</td>\n    </tr>\n    <tr>\n        <td><code>whenComplete</code>、<code>whenCompleteAsync</code></td>\n        <td>接返回值和异常、无返回值</td>\n    </tr>\n    <tr>\n        <td><code>handle</code>、<code>handleAsync</code></td>\n        <td>接返回值和异常、有返回值</td>\n    </tr>\n    <tr>\n        <th rowspan=\"7\">两个任务组合</th>\n        <td><code>thenCompose</code>、<code>thenComposeAsync</code></td>\n        <td>任务转化</td>\n    </tr>\n    <tr>\n        <td><code>thenCombine</code>、<code>thenCombineAsync</code></td>\n        <td>“且”组合、接返回值、有返回值</td>\n    </tr>\n    <tr>\n        <td><code>thenAcceptBoth</code>、<code>thenAcceptBothAsync</code></td>\n        <td>“且”组合、接返回值、无返回值</td>\n    </tr>\n    <tr>\n        <td><code>runAfterBoth</code>、<code>runAfterBothAsync</code></td>\n        <td>“且”组合、不接参数、无返回值</td>\n    </tr>\n    <tr>\n        <td><code>applyToEither</code>、<code>applyToEitherAsync</code></td>\n        <td>“或”组合、接返回值、有返回值</td>\n    </tr>\n    <tr>\n        <td><code>acceptEither</code>、<code>acceptEitherAsync</code></td>\n        <td>“或”组合、接返回值、无返回值</td>\n    </tr>\n    <tr>\n        <td><code>runAfterEither</code>、<code>runAfterEitherAsync</code></td>\n        <td>“或”组合、不接参数、无返回值</td>\n    </tr>\n    <tr>\n        <th rowspan=\"2\">多个任务组合</th>\n        <td><code>anyOf</code></td>\n        <td>“任意一个”组合</td>\n    </tr>\n    <tr>\n        <td><code>allOf</code></td>\n        <td>“所有”组合</td>\n    </tr>\n</table>\n\n<blockquote>\n<p>在CompletableFuture中如果使用没有指定线程池的方法，则会使用<code>ForkJoinPool.commonPool()</code>作为它的线程池执行异步代码。</p>\n</blockquote>\n<h1 id=\"创建异步任务\"><a href=\"#创建异步任务\" class=\"headerlink\" title=\"创建异步任务\"></a>创建异步任务</h1><h3 id=\"不支持返回值\"><a href=\"#不支持返回值\" class=\"headerlink\" title=\"不支持返回值\"></a>不支持返回值</h3><ul>\n<li>方法签名<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用默认线程池中的线程</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> CompletableFuture&lt;Void&gt; <span class=\"title function_\">runAsync</span><span class=\"params\">(Runnable runnable)</span>;</span><br><span class=\"line\"><span class=\"comment\">// 使用自定义线程池中的线程</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> CompletableFuture&lt;Void&gt; <span class=\"title function_\">runAsync</span><span class=\"params\">(Runnable runnable, Executor executor)</span>; </span><br></pre></td></tr></table></figure></li>\n<li>示例代码<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">// TODO 执行任务</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"支持返回值\"><a href=\"#支持返回值\" class=\"headerlink\" title=\"支持返回值\"></a>支持返回值</h3><ul>\n<li><p>方法签名</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用默认线程池中的线程</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class=\"title function_\">supplyAsync</span><span class=\"params\">(Supplier&lt;U&gt; supplier)</span>;</span><br><span class=\"line\"><span class=\"comment\">// 使用自定义线程池中的线程</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class=\"title function_\">supplyAsync</span><span class=\"params\">(Supplier&lt;U&gt; supplier, Executor executor)</span>; </span><br></pre></td></tr></table></figure>\n</li>\n<li><p>示例代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">// TODO 执行任务</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h1 id=\"任务完成时回调方法\"><a href=\"#任务完成时回调方法\" class=\"headerlink\" title=\"任务完成时回调方法\"></a>任务完成时回调方法</h1><p>当CompletableFuture任务执行完成或者抛出异常的时候，可以执行特定的回调方法。</p>\n<h3 id=\"不接参数、无返回值\"><a href=\"#不接参数、无返回值\" class=\"headerlink\" title=\"不接参数、无返回值\"></a>不接参数、无返回值</h3><blockquote>\n<p>前一个任务执行完成后执行；任务之间<strong>无参数传递</strong>，回调方法<strong>无返回值</strong></p>\n</blockquote>\n<ul>\n<li>方法签名<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用调用它的线程上运行（一般是主线程）</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> CompletableFuture&lt;Void&gt; <span class=\"title function_\">thenRun</span><span class=\"params\">(Runnable action)</span>;</span><br><span class=\"line\"><span class=\"comment\">// 使用默认线程池中的线程</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> CompletableFuture&lt;Void&gt; <span class=\"title function_\">thenRunAsync</span><span class=\"params\">(Runnable action)</span>;</span><br><span class=\"line\"><span class=\"comment\">// 使用自定义线程池中的线程</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> CompletableFuture&lt;Void&gt; <span class=\"title function_\">thenRunAsync</span><span class=\"params\">(Runnable action, Executor executor)</span>;</span><br></pre></td></tr></table></figure></li>\n<li>示例代码<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class=\"line\">&#125;).thenRun(() -&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">// TODO 执行任务</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"接返回值、无返回值\"><a href=\"#接返回值、无返回值\" class=\"headerlink\" title=\"接返回值、无返回值\"></a>接返回值、无返回值</h3><blockquote>\n<p>前一个任务执行完成后执行；前一个任务会将执行结果<strong>作为参数</strong>，传递到回调方法中，回调方法<strong>无返回值</strong></p>\n</blockquote>\n<ul>\n<li>方法签名<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用调用它的线程上运行（一般是主线程）</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> CompletableFuture&lt;Void&gt; <span class=\"title function_\">thenAccept</span><span class=\"params\">(Consumer&lt;? <span class=\"built_in\">super</span> T&gt; action)</span>;</span><br><span class=\"line\"><span class=\"comment\">// 使用默认线程池中的线程</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> CompletableFuture&lt;Void&gt; <span class=\"title function_\">thenAcceptAsync</span><span class=\"params\">(Consumer&lt;? <span class=\"built_in\">super</span> T&gt; action)</span>;</span><br><span class=\"line\"><span class=\"comment\">// 使用自定义线程池中的线程</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> CompletableFuture&lt;Void&gt; <span class=\"title function_\">thenAcceptAsync</span><span class=\"params\">(Consumer&lt;? <span class=\"built_in\">super</span> T&gt; action, Executor executor)</span>;</span><br></pre></td></tr></table></figure></li>\n<li>示例代码<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;Result&quot;</span>;</span><br><span class=\"line\">&#125;).thenAccept((result) -&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">// TODO 执行任务</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"接返回值、有返回值\"><a href=\"#接返回值、有返回值\" class=\"headerlink\" title=\"接返回值、有返回值\"></a>接返回值、有返回值</h3><blockquote>\n<p>前一个任务执行完成后执行；前一个任务会将执行结果<strong>作为参数</strong>，传递到回调方法中，并且会调方法<strong>有返回值</strong></p>\n</blockquote>\n<ul>\n<li>方法签名<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用调用它的线程上运行（一般是主线程）</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class=\"title function_\">thenApply</span><span class=\"params\">(Function&lt;? <span class=\"built_in\">super</span> T,? extends U&gt; fn)</span>;</span><br><span class=\"line\"><span class=\"comment\">// 使用默认线程池中的线程</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class=\"title function_\">thenApplyAsync</span><span class=\"params\">(Function&lt;? <span class=\"built_in\">super</span> T,? extends U&gt; fn)</span>;</span><br><span class=\"line\"><span class=\"comment\">// 使用自定义线程池中的线程</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class=\"title function_\">thenApplyAsync</span><span class=\"params\">(Function&lt;? <span class=\"built_in\">super</span> T,? extends U&gt; fn, Executor executor)</span>;</span><br></pre></td></tr></table></figure></li>\n<li>示例代码<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;Result_1&quot;</span>;</span><br><span class=\"line\">&#125;).thenApply(() -&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">// TODO 执行任务</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;Result_2&quot;</span>;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"接异常、有返回值\"><a href=\"#接异常、有返回值\" class=\"headerlink\" title=\"接异常、有返回值\"></a>接异常、有返回值</h3><blockquote>\n<p>某个任务执行异常时执行；异常任务抛出的异常<strong>作为参数</strong>，传递到回调方法中，并且会调方法<strong>有返回值</strong></p>\n</blockquote>\n<ul>\n<li>方法签名<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用调用它的线程上运行（一般是主线程）</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> CompletableFuture&lt;T&gt; <span class=\"title function_\">exceptionally</span><span class=\"params\">(Function&lt;Throwable, ? extends T&gt; fn)</span>;</span><br><span class=\"line\"><span class=\"comment\">// 使用默认线程池中的线程</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> CompletableFuture&lt;T&gt; <span class=\"title function_\">exceptionallyAsync</span><span class=\"params\">(Function&lt;Throwable, ? extends T&gt; fn)</span>;</span><br><span class=\"line\"><span class=\"comment\">// 使用自定义线程池中的线程</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> CompletableFuture&lt;T&gt; <span class=\"title function_\">exceptionallyAsync</span><span class=\"params\">(Function&lt;Throwable, ? extends T&gt; fn, Executor executor)</span>;</span><br></pre></td></tr></table></figure></li>\n<li>示例代码<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RuntimeException</span>();</span><br><span class=\"line\">&#125;).exceptionally((exception) -&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">// TODO 处理异常</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;ERROR!&quot;</span>;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"接返回值和异常、无返回值\"><a href=\"#接返回值和异常、无返回值\" class=\"headerlink\" title=\"接返回值和异常、无返回值\"></a>接返回值和异常、无返回值</h3><blockquote>\n<p>前一个任务执行完成或出现异常时执行；前一个任务会将结果或抛出的异常<strong>作为参数</strong>，传递到回调方法中，回调方法<strong>无返回值</strong></p>\n</blockquote>\n<ul>\n<li>方法签名<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用调用它的线程上运行（一般是主线程）</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> CompletableFuture&lt;T&gt; <span class=\"title function_\">whenComplete</span><span class=\"params\">(BiConsumer&lt;? <span class=\"built_in\">super</span> T, ? <span class=\"built_in\">super</span> Throwable&gt; action)</span>;</span><br><span class=\"line\"><span class=\"comment\">// 使用默认线程池中的线程</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> CompletableFuture&lt;T&gt; <span class=\"title function_\">whenCompleteAsync</span><span class=\"params\">(BiConsumer&lt;? <span class=\"built_in\">super</span> T, ? <span class=\"built_in\">super</span> Throwable&gt; action)</span>;</span><br><span class=\"line\"><span class=\"comment\">// 使用自定义线程池中的线程</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> CompletableFuture&lt;T&gt; <span class=\"title function_\">whenCompleteAsync</span><span class=\"params\">(BiConsumer&lt;? <span class=\"built_in\">super</span> T, ? <span class=\"built_in\">super</span> Throwable&gt; action, Executor executor)</span>;</span><br></pre></td></tr></table></figure></li>\n<li>示例代码<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RuntimeException</span>();</span><br><span class=\"line\">&#125;).whenCompleteAsync((result, exception) -&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (exception != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// TODO 处理异常</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// TODO 执行任务</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"接返回值和异常、有返回值\"><a href=\"#接返回值和异常、有返回值\" class=\"headerlink\" title=\"接返回值和异常、有返回值\"></a>接返回值和异常、有返回值</h3><blockquote>\n<p>前一个任务执行完成后执行；前一个任务会将结果或抛出的异常<strong>作为参数</strong>，传递到回调方法中，回调方法<strong>有返回值</strong></p>\n</blockquote>\n<ul>\n<li>方法签名<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用调用它的线程上运行（一般是主线程）</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class=\"title function_\">handle</span><span class=\"params\">(BiFunction&lt;? <span class=\"built_in\">super</span> T, Throwable, ? extends U&gt; fn)</span>;</span><br><span class=\"line\"><span class=\"comment\">// 使用默认线程池中的线程</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class=\"title function_\">handleAsync</span><span class=\"params\">(BiFunction&lt;? <span class=\"built_in\">super</span> T, Throwable, ? extends U&gt; fn)</span>;</span><br><span class=\"line\"><span class=\"comment\">// 使用自定义线程池中的线程</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class=\"title function_\">handleAsync</span><span class=\"params\">(BiFunction&lt;? <span class=\"built_in\">super</span> T, Throwable, ? extends U&gt; fn, Executor executor)</span>;</span><br></pre></td></tr></table></figure></li>\n<li>示例代码<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RuntimeException</span>();</span><br><span class=\"line\">&#125;).handleAsync((result, exception) -&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (exception != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// TODO 处理异常</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;ERROR!&quot;</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 执行任务</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;SUCCESS!&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h1 id=\"两个任务组合\"><a href=\"#两个任务组合\" class=\"headerlink\" title=\"两个任务组合\"></a>两个任务组合</h1><h3 id=\"任务转化\"><a href=\"#任务转化\" class=\"headerlink\" title=\"任务转化\"></a>任务转化</h3><blockquote>\n<p>将前一个任务的执行结果<strong>作为参数</strong>进行处理，处理后<strong>返回一个新的任务</strong></p>\n</blockquote>\n<ul>\n<li>方法签名<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用调用它的线程上运行（一般是主线程）</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class=\"title function_\">thenCompose</span><span class=\"params\">(Function&lt;? <span class=\"built_in\">super</span> T, ? extends CompletionStage&lt;U&gt;&gt; fn)</span>;</span><br><span class=\"line\"><span class=\"comment\">// 使用默认线程池中的线程</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class=\"title function_\">thenComposeAsync</span><span class=\"params\">(Function&lt;? <span class=\"built_in\">super</span> T, ? extends CompletionStage&lt;U&gt;&gt; fn)</span>;</span><br><span class=\"line\"><span class=\"comment\">// 使用自定义线程池中的线程</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class=\"title function_\">thenComposeAsync</span><span class=\"params\">(Function&lt;? <span class=\"built_in\">super</span> T, ? extends CompletionStage&lt;U&gt;&gt; fn, Executor executor)</span>;</span><br></pre></td></tr></table></figure></li>\n<li>示例代码<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CompletableFuture&lt;String&gt; task = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;任务一的结果&quot;</span>;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">CompletableFuture&lt;String&gt; stringCompletableFuture = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;任务二的结果&quot;</span>;</span><br><span class=\"line\">&#125;).thenComposeAsync((result) -&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">// TODO 执行任务</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> task;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"“且”组合、接返回值、有返回值\"><a href=\"#“且”组合、接返回值、有返回值\" class=\"headerlink\" title=\"“且”组合、接返回值、有返回值\"></a>“且”组合、接返回值、有返回值</h3><blockquote>\n<p>将两个任务组合，当两个任务都正常执行完了，将两个任务的结果作为参数，传递到回调方法中，回调方法有返回值</p>\n</blockquote>\n<ul>\n<li>方法签名<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用调用它的线程上运行（一般是主线程）</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> &lt;U,V&gt; CompletableFuture&lt;V&gt; <span class=\"title function_\">thenCombine</span><span class=\"params\">(CompletionStage&lt;? extends U&gt; other, BiFunction&lt;? <span class=\"built_in\">super</span> T,? <span class=\"built_in\">super</span> U,? extends V&gt; fn)</span>;</span><br><span class=\"line\"><span class=\"comment\">// 使用默认线程池中的线程</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> &lt;U,V&gt; CompletableFuture&lt;V&gt; <span class=\"title function_\">thenCombineAsync</span><span class=\"params\">(CompletionStage&lt;? extends U&gt; other, BiFunction&lt;? <span class=\"built_in\">super</span> T,? <span class=\"built_in\">super</span> U,? extends V&gt; fn)</span>;</span><br><span class=\"line\"><span class=\"comment\">// 使用自定义线程池中的线程</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> &lt;U,V&gt; CompletableFuture&lt;V&gt; <span class=\"title function_\">thenCombineAsync</span><span class=\"params\">(CompletionStage&lt;? extends U&gt; other, BiFunction&lt;? <span class=\"built_in\">super</span> T,? <span class=\"built_in\">super</span> U,? extends V&gt; fn, Executor executor)</span>;</span><br></pre></td></tr></table></figure></li>\n<li>示例代码<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">// TODO 任务一</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;任务一的结果&quot;</span>;</span><br><span class=\"line\">&#125;).thenCombineAsync(CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">// TODO 任务二</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;任务二的结果&quot;</span>;</span><br><span class=\"line\">&#125;), (result1, result2) -&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 任务一和任务二都完成时执行的回调方法</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"“且”组合、接返回值、无返回值\"><a href=\"#“且”组合、接返回值、无返回值\" class=\"headerlink\" title=\"“且”组合、接返回值、无返回值\"></a>“且”组合、接返回值、无返回值</h3><blockquote>\n<p>将两个任务组合，当两个任务都正常执行完了，将两个任务的结果作为参数，传递到回调方法中，回调方法无返回值</p>\n</blockquote>\n<ul>\n<li>方法签名<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用调用它的线程上运行（一般是主线程）</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> &lt;U&gt; CompletableFuture&lt;Void&gt; <span class=\"title function_\">thenAcceptBoth</span><span class=\"params\">(CompletionStage&lt;? extends U&gt; other, BiConsumer&lt;? <span class=\"built_in\">super</span> T, ? <span class=\"built_in\">super</span> U&gt; action)</span>;</span><br><span class=\"line\"><span class=\"comment\">// 使用默认线程池中的线程</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> &lt;U&gt; CompletableFuture&lt;Void&gt; <span class=\"title function_\">thenAcceptBothAsync</span><span class=\"params\">(CompletionStage&lt;? extends U&gt; other, BiConsumer&lt;? <span class=\"built_in\">super</span> T, ? <span class=\"built_in\">super</span> U&gt; action)</span>;</span><br><span class=\"line\"><span class=\"comment\">// 使用自定义线程池中的线程</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> &lt;U&gt; CompletableFuture&lt;Void&gt; <span class=\"title function_\">thenAcceptBothAsync</span><span class=\"params\">(CompletionStage&lt;? extends U&gt; other, BiConsumer&lt;? <span class=\"built_in\">super</span> T, ? <span class=\"built_in\">super</span> U&gt; action, Executor executor)</span>;</span><br></pre></td></tr></table></figure></li>\n<li>示例代码<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">// TODO 任务一</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;任务一的结果&quot;</span>;</span><br><span class=\"line\">&#125;).thenAcceptBothAsync(CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">// TODO 任务二</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;任务二的结果&quot;</span>;</span><br><span class=\"line\">&#125;), (result1, result2) -&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">// TODO 任务一和任务二都完成时执行的回调方法</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"“且”组合、不接参数、无返回值\"><a href=\"#“且”组合、不接参数、无返回值\" class=\"headerlink\" title=\"“且”组合、不接参数、无返回值\"></a>“且”组合、不接参数、无返回值</h3><blockquote>\n<p>将两个任务组合，当两个任务都正常执行完了，执行回调方法，回调方法无返回值</p>\n</blockquote>\n<ul>\n<li>方法签名<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用调用它的线程上运行（一般是主线程）</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> CompletableFuture&lt;Void&gt; <span class=\"title function_\">runAfterBoth</span><span class=\"params\">(CompletionStage&lt;?&gt; other, Runnable action)</span>;</span><br><span class=\"line\"><span class=\"comment\">// 使用默认线程池中的线程</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> CompletableFuture&lt;Void&gt; <span class=\"title function_\">runAfterBothAsync</span><span class=\"params\">(CompletionStage&lt;?&gt; other, Runnable action)</span>;</span><br><span class=\"line\"><span class=\"comment\">// 使用自定义线程池中的线程</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> CompletableFuture&lt;Void&gt; <span class=\"title function_\">runAfterBothAsync</span><span class=\"params\">(CompletionStage&lt;?&gt; other, Runnable action, Executor executor)</span>;</span><br></pre></td></tr></table></figure></li>\n<li>示例代码<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">// TODO 任务一</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;任务一的结果&quot;</span>;</span><br><span class=\"line\">&#125;).runAfterBothAsync(CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">// TODO 任务二</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;任务二的结果&quot;</span>;</span><br><span class=\"line\">&#125;), () -&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">// TODO 任务一和任务二都完成时执行的回调方法</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"“或”组合、接返回值、有返回值\"><a href=\"#“或”组合、接返回值、有返回值\" class=\"headerlink\" title=\"“或”组合、接返回值、有返回值\"></a>“或”组合、接返回值、有返回值</h3><blockquote>\n<p>将两个任务组合，其中任意一个任务执行完成，将该任务的结果作为参数，传递到回调方法中，回调方法有返回值</p>\n</blockquote>\n<ul>\n<li>方法签名<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用调用它的线程上运行（一般是主线程）</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class=\"title function_\">applyToEither</span><span class=\"params\">(CompletionStage&lt;? extends T&gt; other, Function&lt;? <span class=\"built_in\">super</span> T, U&gt; fn)</span>;</span><br><span class=\"line\"><span class=\"comment\">// 使用默认线程池中的线程</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class=\"title function_\">applyToEitherAsync</span><span class=\"params\">(CompletionStage&lt;? extends T&gt; other, Function&lt;? <span class=\"built_in\">super</span> T, U&gt; fn)</span>;</span><br><span class=\"line\"><span class=\"comment\">// 使用自定义线程池中的线程</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class=\"title function_\">applyToEitherAsync</span><span class=\"params\">(CompletionStage&lt;? extends T&gt; other, Function&lt;? <span class=\"built_in\">super</span> T, U&gt; fn, Executor executor)</span>;</span><br></pre></td></tr></table></figure></li>\n<li>示例代码<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">// TODO 任务一</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;任务一的结果&quot;</span>;</span><br><span class=\"line\">&#125;).applyToEitherAsync(CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">// TODO 任务二</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;任务二的结果&quot;</span>;</span><br><span class=\"line\">&#125;), (result) -&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">// TODO 任务一和任务二任意一个执行完成时执行的回调方法</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;SUCCESS&quot;</span>;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"“或”组合、接返回值、无返回值\"><a href=\"#“或”组合、接返回值、无返回值\" class=\"headerlink\" title=\"“或”组合、接返回值、无返回值\"></a>“或”组合、接返回值、无返回值</h3><blockquote>\n<p>将两个任务组合，其中任意一个任务执行完成，将该任务的结果作为参数，传递到回调方法中，回调方法无返回值</p>\n</blockquote>\n<ul>\n<li>方法签名<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用调用它的线程上运行（一般是主线程）</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> CompletableFuture&lt;Void&gt; <span class=\"title function_\">acceptEither</span><span class=\"params\">(CompletionStage&lt;? extends T&gt; other, Consumer&lt;? <span class=\"built_in\">super</span> T&gt; action)</span>;</span><br><span class=\"line\"><span class=\"comment\">// 使用默认线程池中的线程</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> CompletableFuture&lt;Void&gt; <span class=\"title function_\">acceptEitherAsync</span><span class=\"params\">(CompletionStage&lt;? extends T&gt; other, Consumer&lt;? <span class=\"built_in\">super</span> T&gt; action)</span>;</span><br><span class=\"line\"><span class=\"comment\">// 使用自定义线程池中的线程</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> CompletableFuture&lt;Void&gt; <span class=\"title function_\">acceptEitherAsync</span><span class=\"params\">(CompletionStage&lt;? extends T&gt; other, Consumer&lt;? <span class=\"built_in\">super</span> T&gt; action, Executor executor)</span>;</span><br></pre></td></tr></table></figure></li>\n<li>示例代码<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">// TODO 任务一</span></span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        Thread.sleep(<span class=\"number\">10</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RuntimeException</span>(e);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;任务一的结果&quot;</span>;</span><br><span class=\"line\">&#125;).acceptEitherAsync(CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">// TODO 任务二</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;任务二的结果&quot;</span>;</span><br><span class=\"line\">&#125;), (result) -&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">// TODO 任务一和任务二任意一个执行完成时执行的回调方法</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"“或”组合、不接参数、无返回值\"><a href=\"#“或”组合、不接参数、无返回值\" class=\"headerlink\" title=\"“或”组合、不接参数、无返回值\"></a>“或”组合、不接参数、无返回值</h3><blockquote>\n<p>将两个任务组合，其中任意一个任务执行完成，执行回调方法，回调方法无返回值</p>\n</blockquote>\n<ul>\n<li>方法签名<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用调用它的线程上运行（一般是主线程）</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> CompletableFuture&lt;Void&gt; <span class=\"title function_\">runAfterEither</span><span class=\"params\">(CompletionStage&lt;?&gt; other, Runnable action)</span>;</span><br><span class=\"line\"><span class=\"comment\">// 使用默认线程池中的线程</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> CompletableFuture&lt;Void&gt; <span class=\"title function_\">runAfterEitherAsync</span><span class=\"params\">(CompletionStage&lt;?&gt; other, Runnable action)</span>;</span><br><span class=\"line\"><span class=\"comment\">// 使用自定义线程池中的线程</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> CompletableFuture&lt;Void&gt; <span class=\"title function_\">runAfterEitherAsync</span><span class=\"params\">(CompletionStage&lt;?&gt; other, Runnable action, Executor executor)</span>;</span><br></pre></td></tr></table></figure></li>\n<li>示例代码<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">// TODO 任务一</span></span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        Thread.sleep(<span class=\"number\">10</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RuntimeException</span>(e);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;任务一的结果&quot;</span>;</span><br><span class=\"line\">&#125;).runAfterEitherAsync(CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">// TODO 任务二</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;任务二的结果&quot;</span>;</span><br><span class=\"line\">&#125;), () -&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">// TODO 任务一和任务二任意一个执行完成时执行的回调方法</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h1 id=\"多个任务组合\"><a href=\"#多个任务组合\" class=\"headerlink\" title=\"多个任务组合\"></a>多个任务组合</h1><h3 id=\"“任意一个”组合\"><a href=\"#“任意一个”组合\" class=\"headerlink\" title=\"“任意一个”组合\"></a>“任意一个”组合</h3><blockquote>\n<p>将多个任务组合，其中任意一个任务执行完成即可拿到该任务的执行结果（执行结果为Object类型），或执行接下来的任务</p>\n</blockquote>\n<ul>\n<li>方法签名<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> CompletableFuture&lt;Object&gt; <span class=\"title function_\">anyOf</span><span class=\"params\">(CompletableFuture&lt;?&gt;... cfs)</span>;</span><br></pre></td></tr></table></figure></li>\n<li>示例代码<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CompletableFuture&lt;String&gt; task1 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;任务一的结果&quot;</span>;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">CompletableFuture&lt;String&gt; task2 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;任务二的结果&quot;</span>;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">Object</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> CompletableFuture.anyOf(task1, task2).join();</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"“所有”组合\"><a href=\"#“所有”组合\" class=\"headerlink\" title=\"“所有”组合\"></a>“所有”组合</h3><blockquote>\n<p>将多个任务组合，当所有任务都执行完成后执行接下来的任务</p>\n</blockquote>\n<ul>\n<li>方法签名<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> CompletableFuture&lt;Void&gt; <span class=\"title function_\">allOf</span><span class=\"params\">(CompletableFuture&lt;?&gt;... cfs)</span>;</span><br></pre></td></tr></table></figure></li>\n<li>示例代码<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CompletableFuture&lt;String&gt; task1 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;任务一的结果&quot;</span>;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">CompletableFuture&lt;String&gt; task2 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;任务二的结果&quot;</span>;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">Object</span> <span class=\"variable\">join</span> <span class=\"operator\">=</span> CompletableFuture.allOf(task1, task2).join();</span><br></pre></td></tr></table></figure></li>\n</ul>\n"},{"title":"详解JDK8新特性","date":"2024-04-14T14:32:58.000Z","keywords":"Java8，新特性，JDK8","description":"详解JDK8出现的新特性。","cover":"https://npm.elemecdn.com/lql_static@latest/logo/java.png","_content":"\n\n\n# Java8新特性纵览\n\n> 关于Java8新特性的学习与记录，资料来源于互联网。\n\n\n# Lambda表达式\n\n## 为什么使用Lambda表达式？\n\n- Lambda 是一个**匿名函数**，我们可以把 Lambda 表达式理解为是**一段可以传递的代码**（将代码像数据一样进行传递）。使用它可以写出更简洁、更灵活的代码。作为一种更紧凑的代码风格，使Java的语言表达能力得到了提升。\n- 在Java8之后的很多源码里用到了Lambda表达式，不学的话可能看不懂源码。\n\n\n\n## 简单使用\n\n```java\n @Test\n    public void test1(){\n        //原始写法\n        Runnable r1 = new Runnable() {\n            @Override\n            public void run() {\n                System.out.println(\"我爱北京天安门\");\n            }\n        };\n\n        r1.run();\n\n        System.out.println(\"***********************\");\n\n        //lambda表达式，可以表达一样的意思\n        Runnable r2 = () -> System.out.println(\"我爱北京故宫\");\n\n        r2.run();\n    }\n\n\n    @Test\n    public void test2(){\n\n        Comparator<Integer> com1 = new Comparator<Integer>() {\n            @Override\n            public int compare(Integer o1, Integer o2) {\n                return Integer.compare(o1,o2);\n            }\n        };\n\n        int compare1 = com1.compare(12,21);\n        System.out.println(compare1);\n\n        System.out.println(\"***********************\");\n        \n        //Lambda表达式的写法\n        Comparator<Integer> com2 = (o1,o2) -> Integer.compare(o1,o2);\n\n        int compare2 = com2.compare(32,21);\n        System.out.println(compare2);\n\n\n        System.out.println(\"***********************\");\n        //方法引用\n        Comparator<Integer> com3 = Integer :: compare;\n\n        int compare3 = com3.compare(32,21);\n        System.out.println(compare3);\n    }\n```\n\n\n\n## Lambda语法规则\n\n```Java\nimport org.junit.Test;\n\nimport java.util.ArrayList;\nimport java.util.Comparator;\nimport java.util.function.Consumer;\n\n/**\n * Lambda表达式的使用\n * <p>\n * 1.举例： (o1,o2) -> Integer.compare(o1,o2);\n * 2.格式：\n * -> :lambda操作符 或 箭头操作符\n * ->左边：lambda形参列表 （其实就是接口中的抽象方法的形参列表）\n * ->右边：lambda体 （其实就是重写的抽象方法的方法体）\n * <p>\n * 3. Lambda表达式的使用：（分为6种情况介绍）\n * <p>\n * 总结：\n * ->左边：lambda形参列表的参数类型可以省略(类型推断)；如果lambda形参列表只有一个参数，其一对()也\n * 可以省略\n * ->右边：lambda体应该使用一对{}包裹；如果lambda体只有一条执行语句（可能是return语句），省略这一\n 对{}和return关键字\n * <p>\n * 4.Lambda表达式的本质：作为函数式接口的实例\n * <p>\n * 5. 如果一个接口中，只声明了一个抽象方法，则此接口就称为函数式接口。我们可以在一个接口上\n 使用 @FunctionalInterface 注解，\n * 这样做可以检查它是否是一个函数式接口。\n * <p>\n * 6. 所以以前用匿名实现类表示的现在都可以用Lambda表达式来写。\n */\npublic class LambdaTest1 {\n    //语法格式一：无参，无返回值\n    @Test\n    public void test1() {\n        Runnable r1 = new Runnable() {\n            @Override\n            public void run() {\n                System.out.println(\"我爱北京天安门\");\n            }\n        };\n\n        r1.run();\n\n        System.out.println(\"***********************\");\n\n        Runnable r2 = () -> {\n            System.out.println(\"我爱北京故宫\");\n        };\n\n        r2.run();\n    }\n\n    //语法格式二：Lambda 需要一个参数，但是没有返回值。\n    @Test\n    public void test2() {\n\n        Consumer<String> con = new Consumer<String>() {\n            @Override\n            public void accept(String s) {\n                System.out.println(s);\n            }\n        };\n        con.accept(\"谎言和誓言的区别是什么？\");\n\n        System.out.println(\"*******************\");\n\n        Consumer<String> con1 = (String s) -> {\n            System.out.println(s);\n        };\n        con1.accept(\"一个是听得人当真了，一个是说的人当真了\");\n\n    }\n\n    //语法格式三：数据类型可以省略，因为可由编译器推断得出，称为“类型推断”\n    @Test\n    public void test3() {\n\n        Consumer<String> con1 = (String s) -> {\n            System.out.println(s);\n        };\n        con1.accept(\"一个是听得人当真了，一个是说的人当真了\");\n\n        System.out.println(\"*******************\");\n\n        Consumer<String> con2 = (s) -> {\n            System.out.println(s);\n        };\n        con2.accept(\"一个是听得人当真了，一个是说的人当真了\");\n\n    }\n\n    @Test\n    public void test4() {\n\n        ArrayList<String> list = new ArrayList<>();//类型推断\n\n        int[] arr = {1, 2, 3};//类型推断\n\n    }\n\n    //语法格式四：Lambda 若只需要一个参数时，参数的小括号可以省略\n    @Test\n    public void test5() {\n        Consumer<String> con1 = (s) -> {\n            System.out.println(s);\n        };\n        con1.accept(\"一个是听得人当真了，一个是说的人当真了\");\n\n        System.out.println(\"*******************\");\n\n        Consumer<String> con2 = s -> {\n            System.out.println(s);\n        };\n        con2.accept(\"一个是听得人当真了，一个是说的人当真了\");\n\n\n    }\n\n    //语法格式五：Lambda 需要两个或以上的参数，多条执行语句，并且可以有返回值\n    @Test\n    public void test6() {\n\n        Comparator<Integer> com1 = new Comparator<Integer>() {\n            @Override\n            public int compare(Integer o1, Integer o2) {\n                System.out.println(o1);\n                System.out.println(o2);\n                return o1.compareTo(o2);\n            }\n        };\n\n        System.out.println(com1.compare(12, 21));\n\n        System.out.println(\"*****************************\");\n        Comparator<Integer> com2 = (o1, o2) -> {\n            System.out.println(o1);\n            System.out.println(o2);\n            return o1.compareTo(o2);\n        };\n\n        System.out.println(com2.compare(12, 6));\n\n\n    }\n\n    //语法格式六：当 Lambda 体只有一条语句时，return 与大括号若有，都可以省略\n    @Test\n    public void test7() {\n\n        Comparator<Integer> com1 = (o1, o2) -> {\n            return o1.compareTo(o2);\n        };\n\n        System.out.println(com1.compare(12, 6));\n\n        System.out.println(\"*****************************\");\n\n        Comparator<Integer> com2 = (o1, o2) -> o1.compareTo(o2);\n\n        System.out.println(com2.compare(12, 21));\n\n    }\n\n    @Test\n    public void test8() {\n        Consumer<String> con1 = s -> {\n            System.out.println(s);\n        };\n        con1.accept(\"一个是听得人当真了，一个是说的人当真了\");\n\n        System.out.println(\"*****************************\");\n\n        Consumer<String> con2 = s -> System.out.println(s);\n\n        con2.accept(\"一个是听得人当真了，一个是说的人当真了\");\n\n    }\n\n}\n```\n\n\n\n# 函数式接口\n\n\n\n## 什么是函数式(Functional)接口\n\n- 只包含一个抽象方法的接口，称为**函数式接口**。 \n\n- 你可以通过 Lambda 表达式来创建该接口的对象。（若 Lambda 表达式抛出一个受检异常(即：非运行时异常)，那么该异常需要在目标接口的抽象方法上进行声明）。\n\n- 我们可以在一个接口上使用 **@FunctionalInterface** 注解，这样做可以检查它是否是一个函数式接口。同时 javadoc 也会包含一条声明，说明这个接口是一个函数式接口。\n\n- 在java.util.function包下定义了Java 8 的丰富的函数式接口\n\n\n\n## 如何理解函数式接口\n\n- Java从诞生日起就是一直倡导“一切皆对象”，在Java里面面向对象(OOP)编程是一切。但是随着python、scala等语言的兴起和新技术的挑战，Java不得不做出调整以便支持更加广泛的技术要求，也即java不但可以支持OOP还可以支持OOF（面向函数编程） \n- 在函数式编程语言当中，函数被当做一等公民对待。在将函数作为一等公民的编程语言中，Lambda表达式的类型是函数。但是在Java8中，有所不同。在Java8中，Lambda表达式是对象，而不是函数，它们必须依附于一类特别的对象类型——函数式接口。 \n- 简单的说，在Java8中，Lambda表达式就是一个函数式接口的实例。这就是Lambda表达式和函数式接口的关系。也就是说，只要一个对象是函数式接口的实例，那么该对象就可以用Lambda表达式来表示。\n- 所以以前用匿名实现类表示的现在都可以用Lambda表达式来写。\n\n\n\n## Java内置函数式接口\n\n\n\n**核心函数式接口**\n\n<img src=\"https://npm.elemecdn.com/youthlql@1.0.8/Java_Basis/Java8_New_Features/0002.png\">\n\n\n\n**其它函数式接口**\n\n<img src=\"https://npm.elemecdn.com/youthlql@1.0.8/Java_Basis/Java8_New_Features/0003.png\">\n\n\n\n\n\n**Consumer**\n\n```java\n @Test\n    public void test1(){\n\n        happyTime(500, new Consumer<Double>() {\n            @Override\n            public void accept(Double aDouble) {\n                System.out.println(\"学习太累了，去天上人间买了瓶矿泉水，价格为：\" + aDouble);\n            }\n        });\n\n        System.out.println(\"********************\");\n\n        happyTime(400,money -> System.out.println(\"学习太累了，去天上人间喝了口水，价格为：\" + money));\n    }\n\n    public void happyTime(double money, Consumer<Double> con){\n        con.accept(money);\n    }\n```\n\n\n\n**结果：**\n\n```Java\n学习太累了，去天上人间买了瓶矿泉水，价格为：500.0\n********************\n学习太累了，去天上人间喝了口水，价格为：400.0\n\nProcess finished with exit code 0\n```\n\n\n\n**Predicate**\n\n```java\n@Test\n    public void test2(){\n        List<String> list = Arrays.asList(\"北京\",\"南京\",\"天津\",\"东京\",\"西京\",\"普京\");\n\n        List<String> filterStrs = filterString(list, new Predicate<String>() {\n            @Override\n            public boolean test(String s) {//这里是定义一个校验规则\n                return s.contains(\"京\");\n            }\n        });\n\n        System.out.println(filterStrs);\n\n        //用lambda表达式会很简单\n        List<String> filterStrs1 = filterString(list,s -> s.contains(\"京\"));\n        System.out.println(filterStrs1);\n    }\n\n    //根据给定的规则，过滤集合中的字符串。此规则由Predicate的方法决定\n    public List<String> filterString(List<String> list, Predicate<String> pre){\n\n        ArrayList<String> filterList = new ArrayList<>();\n\n        for(String s : list){\n            if(pre.test(s)){\n                filterList.add(s);\n            }\n        }\n\n        return filterList;\n\n    }\n\n```\n\n\n\n**结果：**\n\n```\n[北京, 南京, 东京, 西京, 普京]\n[北京, 南京, 东京, 西京, 普京]\n\nProcess finished with exit code 0\n```\n\n\n\n## 自定义函数式接口\n\n```java\n/**\n * 自定义函数式接口\n * 只是说加上@FunctionalInterface之后可以校验\n */\n@FunctionalInterface\npublic interface MyFunInterface<T> {\n\n    public T getValue(T t);\n\n}\n```\n\n\n\n```java\npublic class Test {\n\n    public static void main(String[] args) {\n        //这个方法的第一个参数是lambda表达式，相当于是实例化了那个函数式接口\n        String s = toUpperString(str -> str.toUpperCase(), \"abcd\");\n        System.out.println(s);\n    }\n\n    public static String toUpperString(MyFunInterface<String> mf,String str){\n        return mf.getValue(str);\n    }\n}\n```\n\n\n\n# 方法引用\n\n- 当要传递给Lambda体的操作，已经有实现的方法了，可以使用方法引用！\n\n- 方法引用可以看做是Lambda表达式深层次的表达。换句话说，方法引用就是Lambda表达式，也就是函数式接口的一个实例，通过方法的名字来指向一个方法，可以认为是Lambda表达式的一个语法糖。\n\n- 要求：实现接口的抽象方法的参数列表和返回值类型，必须与方法引用的方法的参数列表和返回值类型保持一致！\n\n- 格式：使用操作符 “::” 将类(或对象) 与 方法名分隔开来。\n\n- 如下三种主要使用情况： \n\n  - 对象 :: 实例方法名\n\n  - 类 :: 静态方法名\n\n  - 类 :: 实例方法名\n\n\n\n我们直接拿例子来说明情况，先提前准备两个类：\n\n```Java\n\npublic class Employee {\n\n\tprivate int id;\n\tprivate String name;\n\tprivate int age;\n\tprivate double salary;\n\n\tpublic int getId() {\n\t\treturn id;\n\t}\n\n\tpublic void setId(int id) {\n\t\tthis.id = id;\n\t}\n\n\tpublic String getName() {\n\t\treturn name;\n\t}\n\n\tpublic void setName(String name) {\n\t\tthis.name = name;\n\t}\n\n\tpublic int getAge() {\n\t\treturn age;\n\t}\n\n\tpublic void setAge(int age) {\n\t\tthis.age = age;\n\t}\n\n\tpublic double getSalary() {\n\t\treturn salary;\n\t}\n\n\tpublic void setSalary(double salary) {\n\t\tthis.salary = salary;\n\t}\n\n\tpublic Employee() {\n\t\tSystem.out.println(\"Employee().....\");\n\t}\n\n\tpublic Employee(int id) {\n\t\tthis.id = id;\n\t\tSystem.out.println(\"Employee(int id).....\");\n\t}\n\n\tpublic Employee(int id, String name) {\n\t\tthis.id = id;\n\t\tthis.name = name;\n\t}\n\n\tpublic Employee(int id, String name, int age, double salary) {\n\n\t\tthis.id = id;\n\t\tthis.name = name;\n\t\tthis.age = age;\n\t\tthis.salary = salary;\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn \"Employee{\" + \"id=\" + id + \", name='\" + name + '\\'' + \", age=\" + age + \", salary=\" + salary + '}';\n\t}\n\n\t@Override\n\tpublic boolean equals(Object o) {\n\t\tif (this == o)\n\t\t\treturn true;\n\t\tif (o == null || getClass() != o.getClass())\n\t\t\treturn false;\n\n\t\tEmployee employee = (Employee) o;\n\n\t\tif (id != employee.id)\n\t\t\treturn false;\n\t\tif (age != employee.age)\n\t\t\treturn false;\n\t\tif (Double.compare(employee.salary, salary) != 0)\n\t\t\treturn false;\n\t\treturn name != null ? name.equals(employee.name) : employee.name == null;\n\t}\n\n\t@Override\n\tpublic int hashCode() {\n\t\tint result;\n\t\tlong temp;\n\t\tresult = id;\n\t\tresult = 31 * result + (name != null ? name.hashCode() : 0);\n\t\tresult = 31 * result + age;\n\t\ttemp = Double.doubleToLongBits(salary);\n\t\tresult = 31 * result + (int) (temp ^ (temp >>> 32));\n\t\treturn result;\n\t}\n}\n\n```\n\n\n\n```Java\n/**\n * 提供用于测试的数据\n */\npublic class EmployeeData {\n   \n   public static List<Employee> getEmployees(){\n      List<Employee> list = new ArrayList<>();\n      \n      list.add(new Employee(1001, \"马化腾\", 34, 6000.38));\n      list.add(new Employee(1002, \"马云\", 12, 9876.12));\n      list.add(new Employee(1003, \"刘强东\", 33, 3000.82));\n      list.add(new Employee(1004, \"雷军\", 26, 7657.37));\n      list.add(new Employee(1005, \"李彦宏\", 65, 5555.32));\n      list.add(new Employee(1006, \"比尔盖茨\", 42, 9500.43));\n      list.add(new Employee(1007, \"任正非\", 26, 4333.32));\n      list.add(new Employee(1008, \"扎克伯格\", 35, 2500.32));\n      \n      return list;\n   }\n   \n}\n```\n\n\n\n**下面来通过实际例子讲解方法引用：**\n\n```java\n\n\n/**\n * 方法引用的使用\n *\n * 1.使用情境：当要传递给Lambda体的操作，已经有实现的方法了，可以使用方法引用！\n *\n * 2.方法引用，本质上就是Lambda表达式，而Lambda表达式作为函数式接口的实例。所以\n *   方法引用，也是函数式接口的实例。\n *\n * 3. 使用格式：  类(或对象) :: 方法名\n *\n * 4. 具体分为如下的三种情况：\n *    情况1     对象 :: 非静态方法\n *    情况2     类 :: 静态方法\n *\n *    情况3     类 :: 非静态方法\n *\n * 5. 方法引用使用的要求：\n * \t接口中的抽象方法的形参列表和返回值类型\n * \t与\n * \t方法引用的方法的形参列表和返回值类型相同！（针对于情况1和情况2）\n *\n */\npublic class MethodRefTest {\n\n\t// 情况一：对象 :: 实例方法\n\t//Consumer中的void accept(T t)\n\t//PrintStream中的void println(T t)\n\t@Test\n\tpublic void test1() {\n\t\tConsumer<String> con1 = str -> System.out.println(str);\n\t\tcon1.accept(\"北京\");\n\n\t\tSystem.out.println(\"*******************\");\n\t\tPrintStream ps = System.out;\n\t\tConsumer<String> con2 = ps::println;\n\t\tcon2.accept(\"beijing\");\n\t}\n\t\n\t//Supplier中的T get()\n\t//Employee中的String getName()\n\t@Test\n\tpublic void test2() {\n\t\tEmployee emp = new Employee(1001,\"Tom\",23,5600);\n\n\t\tSupplier<String> sup1 = () -> emp.getName();\n\t\tSystem.out.println(sup1.get());\n\n\t\tSystem.out.println(\"*******************\");\n\t\tSupplier<String> sup2 = emp::getName;\n\t\tSystem.out.println(sup2.get());\n\n\t}\n\n\t// 情况二：类 :: 静态方法\n\t//Comparator中的int compare(T t1,T t2)\n\t//Integer中的int compare(T t1,T t2)\n\t@Test\n\tpublic void test3() {\n\t\tComparator<Integer> com1 = (t1,t2) -> Integer.compare(t1,t2);\n\t\tSystem.out.println(com1.compare(12,21));\n\n\t\tSystem.out.println(\"*******************\");\n\n\t\tComparator<Integer> com2 = Integer::compare;\n\t\tSystem.out.println(com2.compare(12,3));\n\n\t}\n\t\n\t//Function中的R apply(T t)\n\t//Math中的Long round(Double d)\n\t@Test\n\tpublic void test4() {\n\t\tFunction<Double,Long> func = new Function<Double, Long>() {\n\t\t\t@Override\n\t\t\tpublic Long apply(Double d) {\n\t\t\t\treturn Math.round(d);\n\t\t\t}\n\t\t};\n\n\t\tSystem.out.println(\"*******************\");\n\n\t\tFunction<Double,Long> func1 = d -> Math.round(d);\n\t\tSystem.out.println(func1.apply(12.3));\n\n\t\tSystem.out.println(\"*******************\");\n\n\t\tFunction<Double,Long> func2 = Math::round;\n\t\tSystem.out.println(func2.apply(12.6));\n\t}\n\n\t// 情况三：类 :: 实例方法  (有难度)\n\t// Comparator中的int comapre(T t1,T t2)  第一个参数T t1,也可以变成方法的调用者\n\t// String中的int t1.compareTo(t2)        看上面说的，t1变成了调用者等价于第一个参数T t1\n\t@Test\n\tpublic void test5() {\n\t\tComparator<String> com1 = (s1,s2) -> s1.compareTo(s2);\n\t\tSystem.out.println(com1.compare(\"abc\",\"abd\"));\n\n\t\tSystem.out.println(\"*******************\");\n\n\t\tComparator<String> com2 = String :: compareTo;\n\t\tSystem.out.println(com2.compare(\"abd\",\"abm\"));\n\t}\n\n\t//BiPredicate中的boolean test(T t1, T t2);\n\t//String中的boolean t1.equals(t2)\n\t@Test\n\tpublic void test6() {\n\t\tBiPredicate<String,String> pre1 = (s1,s2) -> s1.equals(s2);\n\t\tSystem.out.println(pre1.test(\"abc\",\"abc\"));\n\n\t\tSystem.out.println(\"*******************\");\n\t\tBiPredicate<String,String> pre2 = String :: equals;\n\t\tSystem.out.println(pre2.test(\"abc\",\"abd\"));\n\t}\n\t\n\t// Function中的R apply(T t)\n\t// Employee中的String getName();   第一个参数T t相当于方法调用者emp，返回值R和String对应\n\t@Test\n\tpublic void test7() {\n\t\tEmployee employee = new Employee(1001, \"Jerry\", 23, 6000);\n\n\n\t\tFunction<Employee,String> func1 = e -> e.getName();\n\t\tSystem.out.println(func1.apply(employee));\n\n\t\tSystem.out.println(\"*******************\");\n\n\n\t\tFunction<Employee,String> func2 = Employee::getName;\n\t\tSystem.out.println(func2.apply(employee));\n\n\n\t}\n\n}\n\n```\n\n\n\n\n\n# 构造器引用\n\n格式：ClassName :: new\n\n与函数式接口相结合，自动与函数式接口中方法兼容。可以把构造器引用赋值给定义的方法，要求构造器参数列表要与接口中抽象方法的参数列表一致！且方法的返回值即为构造器对应类的对象。\n\n\n\n```Java\n\nimport org.junit.Test;\n\nimport java.util.Arrays;\nimport java.util.function.BiFunction;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\n\n/**\n * 一、构造器引用\n *      和方法引用类似，函数式接口的抽象方法的形参列表和构造器的形参列表一致。\n *      抽象方法的返回值类型即为构造器所属的类的类型\n *\n * 二、数组引用\n *     大家可以把数组看做是一个特殊的类，则写法与构造器引用一致。\n *\n */\npublic class ConstructorRefTest {\n\n    /**\n     * 构造器引用\n     * Supplier中的T get()\n     * Employee的空参构造器：Employee()\n     * 1、和方法引用一样的理解方法，你的get()方法没有参数，我的Employee()也没有参数。\n     * 2、你的get()方法有返回值T，我的Employee()方法返回值也是一个对象\n     * 3、所以刚好可以用  \n     */\n    @Test\n    public void test1(){\n\n        Supplier<Employee> sup = new Supplier<Employee>() {\n            @Override\n            public Employee get() {\n                return new Employee();\n            }\n        };\n        System.out.println(\"*******************\");\n\n        Supplier<Employee>  sup1 = () -> new Employee();\n        System.out.println(sup1.get());\n\n        System.out.println(\"*******************\");\n\n        Supplier<Employee>  sup2 = Employee :: new;\n        System.out.println(sup2.get());\n    }\n\n\t//Function中的R apply(T t)\n    @Test\n    public void test2(){\n        Function<Integer,Employee> func1 = id -> new Employee(id);\n        Employee employee = func1.apply(1001);\n        System.out.println(employee);\n\n        System.out.println(\"*******************\");\n\n        Function<Integer,Employee> func2 = Employee :: new;\n        Employee employee1 = func2.apply(1002);\n        System.out.println(employee1);\n\n    }\n\n\t//BiFunction中的R apply(T t,U u)\n    @Test\n    public void test3(){\n        BiFunction<Integer,String,Employee> func1 = (id,name) -> new Employee(id,name);\n        System.out.println(func1.apply(1001,\"Tom\"));\n\n        System.out.println(\"*******************\");\n\n        BiFunction<Integer,String,Employee> func2 = Employee :: new;\n        System.out.println(func2.apply(1002,\"Tom\"));\n\n    }\n\n\t//数组引用\n    //Function中的R apply(T t)\n    @Test\n    public void test4(){\n        Function<Integer,String[]> func1 = length -> new String[length];\n        String[] arr1 = func1.apply(5);\n        System.out.println(Arrays.toString(arr1));\n\n        System.out.println(\"*******************\");\n\n        Function<Integer,String[]> func2 = String[] :: new;\n        String[] arr2 = func2.apply(10);\n        System.out.println(Arrays.toString(arr2));\n\n    }\n}\n\n```\n\n\n\n# 强大的Stream API\n\n## Stream API说明\n\n- Java8中有两大最为重要的改变。第一个是 **Lambda** **表达式**；另外一个则是 **Stream API**。 \n\n- Stream API ( java.util.stream) 把真正的函数式编程风格引入到Java中。这是目前为止对Java类库最好的补充，因为Stream API可以极大提供Java程序员的生产力，让程序员写出高效率、干净、简洁的代码。\n\n- Stream 是 Java8 中处理集合的关键抽象概念，它可以指定你希望对集合进行的操作，可以执行非常复杂的查找、过滤和映射数据等操作。 **使用Stream API 对集合数据进行操作，就类似于使用 SQL 执行的数据库查询。**也可以使用 Stream API 来并行执行操作。简言之，Stream API 提供了一种高效且易于使用的处理数据的方式\n\n\n\n## 为什么要使用Stream API\n\n- 实际开发中，项目中多数数据源都来自于Mysql，Oracle等，很多一些复杂的数据获取可以直接在sql层面去解决。但现在数据源可以更多了，有MongDB，Radis等，而这些NoSQL的数据本身不支持一些复杂的数据计算，这个时候就需要Java层面去处理。 \n\n- Stream 和 Collection 集合的区别：Collection 是一种静态的内存数据结构，而 Stream 是有关计算的。前者是主要面向内存，存储在内存中，后者主要是面向 CPU，通过 CPU 实现计算。\n\n\n\n## 什么是Stream\n\nStream到底是什么呢？\n\n是数据渠道，用于操作数据源（集合、数组等）所生成的元素序列。\n\n**“集合讲的是数据，Stream讲的是计算！”**\n\n**注意：**\n\n①Stream 自己不会存储元素。\n\n②Stream 不会改变源对象。相反，他们会返回一个持有结果的新Stream。 \n\n③Stream 操作是延迟执行的。这意味着他们会等到需要结果的时候才执行\n\n\n\n\n\n**Stream** **的操作三个步骤**\n\n1、创建Stream\n\n一个数据源（如：集合、数组），获取一个流\n\n2、中间操作\n\n一个中间操作链，对数据源的数据进行处理\n\n3、终止操作(终端操作) \n\n一旦执行终止操作，就执行中间操作链，才产生结果【也就是所谓的延迟执行】。之后，不会再被使用\n\n\n\n<img src=\"https://npm.elemecdn.com/youthlql@1.0.8/Java_Basis/Java8_New_Features/0004.png\">\n\n\n\n\n\n## 创建Stream\n\n\n\n```java\n\npublic class StreamAPITest {\n\n    //创建 Stream方式一：通过集合\n    @Test\n    public void test1(){\n        List<Employee> employees = EmployeeData.getEmployees();\n\n//        default Stream<E> stream() : 返回一个顺序流，顺序流等会中间操作拿数据的时候按顺序拿\n        Stream<Employee> stream = employees.stream();\n\n//        default Stream<E> parallelStream() : 返回一个并行流\n        Stream<Employee> parallelStream = employees.parallelStream();\n\n    }\n\n    //创建 Stream方式二：通过数组\n    @Test\n    public void test2(){\n        int[] arr = new int[]{1,2,3,4,5,6};\n        //调用Arrays类的static <T> Stream<T> stream(T[] array): 返回一个流\n        IntStream stream = Arrays.stream(arr);\n\n        Employee e1 = new Employee(1001,\"Tom\");\n        Employee e2 = new Employee(1002,\"Jerry\");\n        Employee[] arr1 = new Employee[]{e1,e2};\n        Stream<Employee> stream1 = Arrays.stream(arr1);\n\n    }\n    //创建 Stream方式三：通过Stream的of()，通过显示值创建一个流。它可以接收任意数量的参数\n    @Test\n    public void test3(){\n\n        Stream<Integer> stream = Stream.of(1, 2, 3, 4, 5, 6);\n\n    }\n\n    //创建 Stream方式四：创建无限流【用的少，了解下就行】\n    @Test\n    public void test4(){\n\n//      迭代\n//      public static<T> Stream<T> iterate(final T seed, final UnaryOperator<T> f)\n        //遍历前10个偶数\n        Stream.iterate(0, t -> t + 2).limit(10).forEach(System.out::println);\n\n\n//      生成\n//      public static<T> Stream<T> generate(Supplier<T> s)\n        Stream.generate(Math::random).limit(10).forEach(System.out::println);\n\n    }\n\n}\n\n```\n\n\n\n\n\n## 中间操作\n\n```Java\n\n/**\n * 测试Stream的中间操作\n */\npublic class StreamAPITest1 {\n\n    //1-筛选与切片\n    @Test\n    public void test1(){\n        List<Employee> list = EmployeeData.getEmployees();\n//        filter(Predicate p)——过滤   接收 Lambda ， 从流中排除某些元素。\n        Stream<Employee> stream = list.stream();\n        //练习：查询员工表中薪资大于7000的员工信息\n        /**\n         * List<String> filterStrs1 = filterString(list,s -> s.contains(\"京\"));\n         * 跟之前的这个lambda表达式代码是一个意思\n         */\n        stream.filter(e -> e.getSalary() > 7000).forEach(System.out::println);\n\n        System.out.println();\n//        limit(n)——截断流，使其元素不超过给定数量。\n        list.stream().limit(3).forEach(System.out::println);\n        System.out.println();\n\n        /*\n        skip(n) —— 跳过元素，返回一个扔掉了前 n 个元素的流。若流中元素不足 n 个，\n        则返回一个空流。与 limit(n) 互补\n        */\n        list.stream().skip(3).forEach(System.out::println);\n\n        System.out.println();\n//        distinct()——筛选，通过流所生成元素的 hashCode() 和 equals() 去除重复元素\n\n        list.add(new Employee(1010,\"刘强东\",40,8000));\n        list.add(new Employee(1010,\"刘强东\",41,8000));\n        list.add(new Employee(1010,\"刘强东\",40,8000));\n        list.add(new Employee(1010,\"刘强东\",40,8000));\n        list.add(new Employee(1010,\"刘强东\",40,8000));\n\n//        System.out.println(list);\n\n        list.stream().distinct().forEach(System.out::println);\n    }\n\n    //映射\n    @Test\n    public void test2(){\n        /*\n        map(Function f)——接收一个函数作为参数，将元素转换成其他形式或提取信息，该函数会被应\n        用到每个元素上，并将其映射成一个新的元素。\n        */\n        List<String> list = Arrays.asList(\"aa\", \"bb\", \"cc\", \"dd\");\n        list.stream().map(str -> str.toUpperCase()).forEach(System.out::println);\n\n//        练习1：获取员工姓名长度大于3的员工的姓名。\n        List<Employee> employees = EmployeeData.getEmployees();\n        Stream<String> namesStream = employees.stream().map(Employee::getName);\n        namesStream.filter(name -> name.length() > 3).forEach(System.out::println);\n        System.out.println();\n        //练习2：\n        Stream<Stream<Character>> streamStream = list.stream().map(StreamAPITest1::fromStringToStream);\n        //这个还需要两层遍历\n        streamStream.forEach(s ->{\n            s.forEach(System.out::println);\n        });\n        System.out.println();\n        /*\n        flatMap(Function f)——接收一个函数作为参数，将流中的每个值都换成另一个流，然后把所有流连\n        接成一个流。flatMap一层遍历即可拿到想要的结果\n        */\n        Stream<Character> characterStream = list.stream().flatMap(StreamAPITest1::fromStringToStream);\n        characterStream.forEach(System.out::println);\n\n    }\n\n    //将字符串中的多个字符构成的集合转换为对应的Stream的实例\n    public static Stream<Character> fromStringToStream(String str){//aa\n        ArrayList<Character> list = new ArrayList<>();\n        for(Character c : str.toCharArray()){\n            list.add(c);\n        }\n       return list.stream();\n\n    }\n\n\n    //3-排序\n    @Test\n    public void test4(){\n//        sorted()——自然排序\n        List<Integer> list = Arrays.asList(12, 43, 65, 34, 87, 0, -98, 7);\n        list.stream().sorted().forEach(System.out::println);\n        //抛异常，原因:Employee没有实现Comparable接口\n//        List<Employee> employees = EmployeeData.getEmployees();\n//        employees.stream().sorted().forEach(System.out::println);\n\n\n//        sorted(Comparator com)——定制排序\n\n        List<Employee> employees = EmployeeData.getEmployees();\n        employees.stream().sorted( (e1,e2) -> {\n\n           int ageValue = Integer.compare(e1.getAge(),e2.getAge());\n           if(ageValue != 0){\n               return ageValue;\n           }else{\n               return -Double.compare(e1.getSalary(),e2.getSalary());\n           }\n\n        }).forEach(System.out::println);\n    }\n\n}\n\n```\n\n\n\n## 终止操作\n\n\n\n```Java\n\n/**\n * 测试Stream的终止操作\n *\n */\npublic class StreamAPITest2 {\n\n    //1-匹配与查找\n    @Test\n    public void test1(){\n        List<Employee> employees = EmployeeData.getEmployees();\n\n//        allMatch(Predicate p)——检查是否匹配所有元素。\n//          练习：是否所有的员工的年龄都大于18\n        boolean allMatch = employees.stream().allMatch(e -> e.getAge() > 18);\n        System.out.println(allMatch);\n\n//        anyMatch(Predicate p)——检查是否至少匹配一个元素。\n//         练习：是否存在员工的工资大于 10000\n        boolean anyMatch = employees.stream().anyMatch(e -> e.getSalary() > 10000);\n        System.out.println(anyMatch);\n\n//        noneMatch(Predicate p)——检查是否没有匹配的元素。\n//          练习：是否存在员工姓“雷”\n        boolean noneMatch = employees.stream().noneMatch(e -> e.getName().startsWith(\"雷\"));\n        System.out.println(noneMatch);\n//        findFirst——返回第一个元素\n        Optional<Employee> employee = employees.stream().findFirst();\n        System.out.println(employee);\n//        findAny——返回当前流中的任意元素\n        Optional<Employee> employee1 = employees.parallelStream().findAny();\n        System.out.println(employee1);\n\n    }\n\n    @Test\n    public void test2(){\n        List<Employee> employees = EmployeeData.getEmployees();\n        // count——返回流中元素的总个数\n        long count = employees.stream().filter(e -> e.getSalary() > 5000).count();\n        System.out.println(count);\n//        max(Comparator c)——返回流中最大值\n//        练习：返回最高的工资：\n        Stream<Double> salaryStream = employees.stream().map(e -> e.getSalary());\n        Optional<Double> maxSalary = salaryStream.max(Double::compare);\n        System.out.println(maxSalary);\n//        min(Comparator c)——返回流中最小值\n//        练习：返回最低工资的员工\n        Optional<Employee> employee = employees.stream().min((e1, e2) -> Double.compare(e1.getSalary(), e2.getSalary()));\n        System.out.println(employee);\n        System.out.println();\n//        forEach(Consumer c)——内部迭代\n        employees.stream().forEach(System.out::println);\n\n        //使用集合的遍历操作\n        employees.forEach(System.out::println);\n    }\n\n    //2-归约\n    @Test\n    public void test3(){\n//        reduce(T identity, BinaryOperator)——可以将流中元素反复结合起来，得到一个值。返回 T\n//        练习1：计算1-10的自然数的和\n        List<Integer> list = Arrays.asList(1,2,3,4,5,6,7,8,9,10);\n        Integer sum = list.stream().reduce(0, Integer::sum);\n        System.out.println(sum);\n\n\n//        reduce(BinaryOperator) ——可以将流中元素反复结合起来，得到一个值。返回 Optional<T>\n//        练习2：计算公司所有员工工资的总和\n        List<Employee> employees = EmployeeData.getEmployees();\n        Stream<Double> salaryStream = employees.stream().map(Employee::getSalary);\n//        Optional<Double> sumMoney = salaryStream.reduce(Double::sum);\n        Optional<Double> sumMoney = salaryStream.reduce((d1,d2) -> d1 + d2);\n        System.out.println(sumMoney.get());\n\n    }\n\n    //3-收集\n    @Test\n    public void test4(){\n// collect(Collector c)——将流转换为其他形式。接收一个 Collector接口的实现，用于给Stream中元素做汇总的方法\n//        练习1：查找工资大于6000的员工，结果返回为一个List或Set\n\n        List<Employee> employees = EmployeeData.getEmployees();\n        List<Employee> employeeList = employees.stream().filter(e -> e.getSalary() > 6000).collect(Collectors.toList());\n\n        employeeList.forEach(System.out::println);\n        System.out.println();\n        Set<Employee> employeeSet = employees.stream().filter(e -> e.getSalary() > 6000).collect(Collectors.toSet());\n\n        employeeSet.forEach(System.out::println);\n\n\n\n\n    }\n}\n\n```\n\n\n\n# Optional类\n\n## 什么是Optional？\n\n\n\n- 到目前为止，臭名昭著的空指针异常是导致Java应用程序失败的最常见原因。以前，为了解决空指针异常，Google公司著名的Guava项目引入了Optional类，Guava通过使用检查空值的方式来防止代码污染，它鼓励程序员写更干净的代码。受到Google Guava的启发，Optional类已经成为Java 8类库的一部分。\n\n- Optional<T> 类(java.util.Optional) 是一个容器类，它可以保存类型T的值，代表这个值存在。或者仅仅保存null，表示这个值不存在。原来用 null 表示一个值不存在，现在 Optional 可以更好的表达这个概念。并且可以避免空指针异常。 \n\n- Optional类的Javadoc描述如下：这是一个可以为null的容器对象。如果值存在则isPresent()方法会返回true，调用get()方法会返回该对象。\n\n\n\n## 常用API\n\n<img src=\"https://npm.elemecdn.com/youthlql@1.0.8/Java_Basis/Java8_New_Features/0005.png\">\n\n\n\n\n\n## 举例\n\n首先准备两个类\n\n```java\n\npublic class Boy {\n    private Girl girl;\n\n    @Override\n    public String toString() {\n        return \"Boy{\" +\n                \"girl=\" + girl +\n                '}';\n    }\n\n    public Girl getGirl() {\n        return girl;\n    }\n\n    public void setGirl(Girl girl) {\n        this.girl = girl;\n    }\n\n    public Boy() {\n\n    }\n\n    public Boy(Girl girl) {\n\n        this.girl = girl;\n    }\n}\n```\n\n\n\n```java\npublic class Girl {\n\n    private String name;\n\n    @Override\n    public String toString() {\n        return \"Girl{\" +\n                \"name='\" + name + '\\'' +\n                '}';\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public Girl() {\n\n    }\n\n    public Girl(String name) {\n\n        this.name = name;\n    }\n}\n```\n\n\n\n这里只是简单的测试两个API\n\n```Java\n/**\n * Optional类：为了在程序中避免出现空指针异常而创建的。\n *\n * 常用的方法：ofNullable(T t)\n *            orElse(T t)\n *\n */\npublic class OptionalTest {\n\n/*\nOptional.of(T t) : 创建一个 Optional 实例，t必须非空；\nOptional.empty() : 创建一个空的 Optional 实例\nOptional.ofNullable(T t)：t可以为null\n\n */\n    @Test\n    public void test1(){\n        Girl girl = new Girl();\n//        girl = null;\n        //of(T t):保证t是非空的\n        Optional<Girl> optionalGirl = Optional.of(girl);\n\n    }\n\n    @Test\n    public void test2(){\n        Girl girl = new Girl();\n//        girl = null;\n        //ofNullable(T t)：t可以为null\n        Optional<Girl> optionalGirl = Optional.ofNullable(girl);\n        System.out.println(optionalGirl);\n        //orElse(T t1):如果单前的Optional内部封装的t是非空的，则返回内部的t.\n        //如果内部的t是空的，则返回orElse()方法中的参数t1.\n        Girl girl1 = optionalGirl.orElse(new Girl(\"赵丽颖\"));\n        System.out.println(girl1);\n\n    }\n}\n```\n\n\n\n**实际场景使用**\n\n可能出现空指针的例子：\n\n```java\npublic String getGirlName(Boy boy){\n        return boy.getGirl().getName();\n    }\n\n    @Test\n    public void test3(){\n        Boy boy = new Boy();\n        boy = null;\n        String girlName = getGirlName(boy);\n        System.out.println(girlName);\n\n    }\n```\n\n\n\n结果：\n\n```\njava.lang.NullPointerException\n\tat com.atguigu.java4.OptionalTest.getGirlName(OptionalTest.java:47)\n\tat com.atguigu.java4.OptionalTest.test3(OptionalTest.java:54)\n...\n...\n\nProcess finished with exit code -1\n```\n\n\n\n没有Optional的解决办法，但是如果调用层数过多，就得一层一层判断是否为null，写起来很麻烦。\n\n```Java\n//优化以后的getGirlName():\n    public String getGirlName1(Boy boy){\n        if(boy != null){\n            Girl girl = boy.getGirl();\n            if(girl != null){\n                return girl.getName();\n            }\n        }\n\n        return null;\n\n    }\n@Test\n    public void test4(){\n        Boy boy = new Boy();\n        boy = null;\n        String girlName = getGirlName1(boy);\n        System.out.println(girlName);\n\n    }\n```\n\n\n\n使用Optional解决问题：\n\n```Java\n //使用Optional类的getGirlName():\n    public String getGirlName2(Boy boy){\n\n        Optional<Boy> boyOptional = Optional.ofNullable(boy);\n        //此时的boy1一定非空\n        Boy boy1 = boyOptional.orElse(new Boy(new Girl(\"迪丽热巴\")));\n\n        Girl girl = boy1.getGirl();\n\n        Optional<Girl> girlOptional = Optional.ofNullable(girl);\n        //girl1一定非空\n        Girl girl1 = girlOptional.orElse(new Girl(\"古力娜扎\"));\n\n        return girl1.getName();\n    }\n\n    @Test\n    public void test5(){\n        Boy boy = null;\n        boy = new Boy();\n        boy = new Boy(new Girl(\"苍老师\"));\n        String girlName = getGirlName2(boy);\n        System.out.println(girlName);\n\n    }\n```\n\n这种是绝对不会出现空指针的。\n\n\n\n# 接口的增强\n\n```\nJDK7及以前：只能定义全局常量和抽象方法\n  >全局常量：public static final的.但是书写时，可以省略不写\n  >抽象方法：public abstract的\n  \t\t\t\nJDK8：除了定义全局常量和抽象方法之外，还可以定义静态方法、默认方法\n```\n\n\n\n```java\n/*\n * JDK8：除了定义全局常量和抽象方法之外，还可以定义静态方法、默认方法\n */\npublic interface CompareA {\n\n    //静态方法\n    public static void method1() {\n\n        System.out.println(\"CompareA:北京\");\n    }\n\n    //默认方法\n    public default void method2() {\n        System.out.println(\"CompareA：上海\");\n    }\n    //接口中的public 可以省略，自动就是public\n    default void method3() {\n        System.out.println(\"CompareA：上海\");\n    }\n}\n```\n\n\n\n```java\npublic class SuperClass {\n\t\n\tpublic void method3(){\n\t\tSystem.out.println(\"SuperClass:北京\");\n\t}\n\t\n}\n```\n\n\n\n```java\npublic interface CompareB {\n\t\n\tdefault void method3(){\n\t\tSystem.out.println(\"CompareB：上海\");\n\t}\n\t\n}\n```\n\n\n\n\n\n```java\npublic class SubClassTest {\n\t\n\tpublic static void main(String[] args) {\n\t\tSubClass s = new SubClass();\n\t\t\n//\t\ts.method1();\n//\t\tSubClass.method1();\n\t\t//知识点1：接口中定义的静态方法，只能通过接口来调用。实现类用不了\n\t\tCompareA.method1();\n\t\t//知识点2：通过实现类的对象，可以调用接口中的默认方法。\n\t\t//如果实现类重写了接口中的默认方法，调用时，仍然调用的是重写以后的方法\n\t\ts.method2();\n\t\t//知识点3：如果子类(或实现类)继承的父类和实现的接口中声明了同名同参数的默认方法，\n\t\t//那么子类在没有重写此方法的情况下，默认调用的是父类中的同名同参数的方法。-->类优先原则\n\t\t//知识点4：如果实现类实现了多个接口，而这多个接口中定义了同名同参数的默认方法，\n\t\t//那么在实现类没有重写此方法的情况下，报错。-->接口冲突。\n\t\t//这就需要我们必须在实现类中重写此方法\n\t\ts.method3();\n\t\t\n\t}\n\t\n}\n\nclass SubClass extends SuperClass implements CompareA,CompareB{\n\t\n\tpublic void method2(){\n\t\tSystem.out.println(\"SubClass：上海\");\n\t}\n\t\n\tpublic void method3(){\n\t\tSystem.out.println(\"SubClass：深圳\");\n\t}\n\t\n\t//知识点5：如何在子类(或实现类)的方法中调用父类、接口中被重写的方法\n\tpublic void myMethod(){\n\t\tmethod3();//调用自己定义的重写的方法\n\t\tsuper.method3();//调用的是父类中声明的\n\t\t//调用接口中的默认方法\n\t\tCompareA.super.method3();\n\t\tCompareB.super.method3();\n\t}\n}\n```\n","source":"_posts/2021-04-14-Java8新特性.md","raw":"---\ntitle: 详解JDK8新特性\ndate: 2024-04-14 22:32:58\ntags:\n  - Java8\n  - JDK8\n  - 新特性\ncategories:\n  - Java\n  - 新特性\nkeywords: Java8，新特性，JDK8\ndescription: 详解JDK8出现的新特性。\ncover: 'https://npm.elemecdn.com/lql_static@latest/logo/java.png'\n---\n\n\n\n# Java8新特性纵览\n\n> 关于Java8新特性的学习与记录，资料来源于互联网。\n\n\n# Lambda表达式\n\n## 为什么使用Lambda表达式？\n\n- Lambda 是一个**匿名函数**，我们可以把 Lambda 表达式理解为是**一段可以传递的代码**（将代码像数据一样进行传递）。使用它可以写出更简洁、更灵活的代码。作为一种更紧凑的代码风格，使Java的语言表达能力得到了提升。\n- 在Java8之后的很多源码里用到了Lambda表达式，不学的话可能看不懂源码。\n\n\n\n## 简单使用\n\n```java\n @Test\n    public void test1(){\n        //原始写法\n        Runnable r1 = new Runnable() {\n            @Override\n            public void run() {\n                System.out.println(\"我爱北京天安门\");\n            }\n        };\n\n        r1.run();\n\n        System.out.println(\"***********************\");\n\n        //lambda表达式，可以表达一样的意思\n        Runnable r2 = () -> System.out.println(\"我爱北京故宫\");\n\n        r2.run();\n    }\n\n\n    @Test\n    public void test2(){\n\n        Comparator<Integer> com1 = new Comparator<Integer>() {\n            @Override\n            public int compare(Integer o1, Integer o2) {\n                return Integer.compare(o1,o2);\n            }\n        };\n\n        int compare1 = com1.compare(12,21);\n        System.out.println(compare1);\n\n        System.out.println(\"***********************\");\n        \n        //Lambda表达式的写法\n        Comparator<Integer> com2 = (o1,o2) -> Integer.compare(o1,o2);\n\n        int compare2 = com2.compare(32,21);\n        System.out.println(compare2);\n\n\n        System.out.println(\"***********************\");\n        //方法引用\n        Comparator<Integer> com3 = Integer :: compare;\n\n        int compare3 = com3.compare(32,21);\n        System.out.println(compare3);\n    }\n```\n\n\n\n## Lambda语法规则\n\n```Java\nimport org.junit.Test;\n\nimport java.util.ArrayList;\nimport java.util.Comparator;\nimport java.util.function.Consumer;\n\n/**\n * Lambda表达式的使用\n * <p>\n * 1.举例： (o1,o2) -> Integer.compare(o1,o2);\n * 2.格式：\n * -> :lambda操作符 或 箭头操作符\n * ->左边：lambda形参列表 （其实就是接口中的抽象方法的形参列表）\n * ->右边：lambda体 （其实就是重写的抽象方法的方法体）\n * <p>\n * 3. Lambda表达式的使用：（分为6种情况介绍）\n * <p>\n * 总结：\n * ->左边：lambda形参列表的参数类型可以省略(类型推断)；如果lambda形参列表只有一个参数，其一对()也\n * 可以省略\n * ->右边：lambda体应该使用一对{}包裹；如果lambda体只有一条执行语句（可能是return语句），省略这一\n 对{}和return关键字\n * <p>\n * 4.Lambda表达式的本质：作为函数式接口的实例\n * <p>\n * 5. 如果一个接口中，只声明了一个抽象方法，则此接口就称为函数式接口。我们可以在一个接口上\n 使用 @FunctionalInterface 注解，\n * 这样做可以检查它是否是一个函数式接口。\n * <p>\n * 6. 所以以前用匿名实现类表示的现在都可以用Lambda表达式来写。\n */\npublic class LambdaTest1 {\n    //语法格式一：无参，无返回值\n    @Test\n    public void test1() {\n        Runnable r1 = new Runnable() {\n            @Override\n            public void run() {\n                System.out.println(\"我爱北京天安门\");\n            }\n        };\n\n        r1.run();\n\n        System.out.println(\"***********************\");\n\n        Runnable r2 = () -> {\n            System.out.println(\"我爱北京故宫\");\n        };\n\n        r2.run();\n    }\n\n    //语法格式二：Lambda 需要一个参数，但是没有返回值。\n    @Test\n    public void test2() {\n\n        Consumer<String> con = new Consumer<String>() {\n            @Override\n            public void accept(String s) {\n                System.out.println(s);\n            }\n        };\n        con.accept(\"谎言和誓言的区别是什么？\");\n\n        System.out.println(\"*******************\");\n\n        Consumer<String> con1 = (String s) -> {\n            System.out.println(s);\n        };\n        con1.accept(\"一个是听得人当真了，一个是说的人当真了\");\n\n    }\n\n    //语法格式三：数据类型可以省略，因为可由编译器推断得出，称为“类型推断”\n    @Test\n    public void test3() {\n\n        Consumer<String> con1 = (String s) -> {\n            System.out.println(s);\n        };\n        con1.accept(\"一个是听得人当真了，一个是说的人当真了\");\n\n        System.out.println(\"*******************\");\n\n        Consumer<String> con2 = (s) -> {\n            System.out.println(s);\n        };\n        con2.accept(\"一个是听得人当真了，一个是说的人当真了\");\n\n    }\n\n    @Test\n    public void test4() {\n\n        ArrayList<String> list = new ArrayList<>();//类型推断\n\n        int[] arr = {1, 2, 3};//类型推断\n\n    }\n\n    //语法格式四：Lambda 若只需要一个参数时，参数的小括号可以省略\n    @Test\n    public void test5() {\n        Consumer<String> con1 = (s) -> {\n            System.out.println(s);\n        };\n        con1.accept(\"一个是听得人当真了，一个是说的人当真了\");\n\n        System.out.println(\"*******************\");\n\n        Consumer<String> con2 = s -> {\n            System.out.println(s);\n        };\n        con2.accept(\"一个是听得人当真了，一个是说的人当真了\");\n\n\n    }\n\n    //语法格式五：Lambda 需要两个或以上的参数，多条执行语句，并且可以有返回值\n    @Test\n    public void test6() {\n\n        Comparator<Integer> com1 = new Comparator<Integer>() {\n            @Override\n            public int compare(Integer o1, Integer o2) {\n                System.out.println(o1);\n                System.out.println(o2);\n                return o1.compareTo(o2);\n            }\n        };\n\n        System.out.println(com1.compare(12, 21));\n\n        System.out.println(\"*****************************\");\n        Comparator<Integer> com2 = (o1, o2) -> {\n            System.out.println(o1);\n            System.out.println(o2);\n            return o1.compareTo(o2);\n        };\n\n        System.out.println(com2.compare(12, 6));\n\n\n    }\n\n    //语法格式六：当 Lambda 体只有一条语句时，return 与大括号若有，都可以省略\n    @Test\n    public void test7() {\n\n        Comparator<Integer> com1 = (o1, o2) -> {\n            return o1.compareTo(o2);\n        };\n\n        System.out.println(com1.compare(12, 6));\n\n        System.out.println(\"*****************************\");\n\n        Comparator<Integer> com2 = (o1, o2) -> o1.compareTo(o2);\n\n        System.out.println(com2.compare(12, 21));\n\n    }\n\n    @Test\n    public void test8() {\n        Consumer<String> con1 = s -> {\n            System.out.println(s);\n        };\n        con1.accept(\"一个是听得人当真了，一个是说的人当真了\");\n\n        System.out.println(\"*****************************\");\n\n        Consumer<String> con2 = s -> System.out.println(s);\n\n        con2.accept(\"一个是听得人当真了，一个是说的人当真了\");\n\n    }\n\n}\n```\n\n\n\n# 函数式接口\n\n\n\n## 什么是函数式(Functional)接口\n\n- 只包含一个抽象方法的接口，称为**函数式接口**。 \n\n- 你可以通过 Lambda 表达式来创建该接口的对象。（若 Lambda 表达式抛出一个受检异常(即：非运行时异常)，那么该异常需要在目标接口的抽象方法上进行声明）。\n\n- 我们可以在一个接口上使用 **@FunctionalInterface** 注解，这样做可以检查它是否是一个函数式接口。同时 javadoc 也会包含一条声明，说明这个接口是一个函数式接口。\n\n- 在java.util.function包下定义了Java 8 的丰富的函数式接口\n\n\n\n## 如何理解函数式接口\n\n- Java从诞生日起就是一直倡导“一切皆对象”，在Java里面面向对象(OOP)编程是一切。但是随着python、scala等语言的兴起和新技术的挑战，Java不得不做出调整以便支持更加广泛的技术要求，也即java不但可以支持OOP还可以支持OOF（面向函数编程） \n- 在函数式编程语言当中，函数被当做一等公民对待。在将函数作为一等公民的编程语言中，Lambda表达式的类型是函数。但是在Java8中，有所不同。在Java8中，Lambda表达式是对象，而不是函数，它们必须依附于一类特别的对象类型——函数式接口。 \n- 简单的说，在Java8中，Lambda表达式就是一个函数式接口的实例。这就是Lambda表达式和函数式接口的关系。也就是说，只要一个对象是函数式接口的实例，那么该对象就可以用Lambda表达式来表示。\n- 所以以前用匿名实现类表示的现在都可以用Lambda表达式来写。\n\n\n\n## Java内置函数式接口\n\n\n\n**核心函数式接口**\n\n<img src=\"https://npm.elemecdn.com/youthlql@1.0.8/Java_Basis/Java8_New_Features/0002.png\">\n\n\n\n**其它函数式接口**\n\n<img src=\"https://npm.elemecdn.com/youthlql@1.0.8/Java_Basis/Java8_New_Features/0003.png\">\n\n\n\n\n\n**Consumer**\n\n```java\n @Test\n    public void test1(){\n\n        happyTime(500, new Consumer<Double>() {\n            @Override\n            public void accept(Double aDouble) {\n                System.out.println(\"学习太累了，去天上人间买了瓶矿泉水，价格为：\" + aDouble);\n            }\n        });\n\n        System.out.println(\"********************\");\n\n        happyTime(400,money -> System.out.println(\"学习太累了，去天上人间喝了口水，价格为：\" + money));\n    }\n\n    public void happyTime(double money, Consumer<Double> con){\n        con.accept(money);\n    }\n```\n\n\n\n**结果：**\n\n```Java\n学习太累了，去天上人间买了瓶矿泉水，价格为：500.0\n********************\n学习太累了，去天上人间喝了口水，价格为：400.0\n\nProcess finished with exit code 0\n```\n\n\n\n**Predicate**\n\n```java\n@Test\n    public void test2(){\n        List<String> list = Arrays.asList(\"北京\",\"南京\",\"天津\",\"东京\",\"西京\",\"普京\");\n\n        List<String> filterStrs = filterString(list, new Predicate<String>() {\n            @Override\n            public boolean test(String s) {//这里是定义一个校验规则\n                return s.contains(\"京\");\n            }\n        });\n\n        System.out.println(filterStrs);\n\n        //用lambda表达式会很简单\n        List<String> filterStrs1 = filterString(list,s -> s.contains(\"京\"));\n        System.out.println(filterStrs1);\n    }\n\n    //根据给定的规则，过滤集合中的字符串。此规则由Predicate的方法决定\n    public List<String> filterString(List<String> list, Predicate<String> pre){\n\n        ArrayList<String> filterList = new ArrayList<>();\n\n        for(String s : list){\n            if(pre.test(s)){\n                filterList.add(s);\n            }\n        }\n\n        return filterList;\n\n    }\n\n```\n\n\n\n**结果：**\n\n```\n[北京, 南京, 东京, 西京, 普京]\n[北京, 南京, 东京, 西京, 普京]\n\nProcess finished with exit code 0\n```\n\n\n\n## 自定义函数式接口\n\n```java\n/**\n * 自定义函数式接口\n * 只是说加上@FunctionalInterface之后可以校验\n */\n@FunctionalInterface\npublic interface MyFunInterface<T> {\n\n    public T getValue(T t);\n\n}\n```\n\n\n\n```java\npublic class Test {\n\n    public static void main(String[] args) {\n        //这个方法的第一个参数是lambda表达式，相当于是实例化了那个函数式接口\n        String s = toUpperString(str -> str.toUpperCase(), \"abcd\");\n        System.out.println(s);\n    }\n\n    public static String toUpperString(MyFunInterface<String> mf,String str){\n        return mf.getValue(str);\n    }\n}\n```\n\n\n\n# 方法引用\n\n- 当要传递给Lambda体的操作，已经有实现的方法了，可以使用方法引用！\n\n- 方法引用可以看做是Lambda表达式深层次的表达。换句话说，方法引用就是Lambda表达式，也就是函数式接口的一个实例，通过方法的名字来指向一个方法，可以认为是Lambda表达式的一个语法糖。\n\n- 要求：实现接口的抽象方法的参数列表和返回值类型，必须与方法引用的方法的参数列表和返回值类型保持一致！\n\n- 格式：使用操作符 “::” 将类(或对象) 与 方法名分隔开来。\n\n- 如下三种主要使用情况： \n\n  - 对象 :: 实例方法名\n\n  - 类 :: 静态方法名\n\n  - 类 :: 实例方法名\n\n\n\n我们直接拿例子来说明情况，先提前准备两个类：\n\n```Java\n\npublic class Employee {\n\n\tprivate int id;\n\tprivate String name;\n\tprivate int age;\n\tprivate double salary;\n\n\tpublic int getId() {\n\t\treturn id;\n\t}\n\n\tpublic void setId(int id) {\n\t\tthis.id = id;\n\t}\n\n\tpublic String getName() {\n\t\treturn name;\n\t}\n\n\tpublic void setName(String name) {\n\t\tthis.name = name;\n\t}\n\n\tpublic int getAge() {\n\t\treturn age;\n\t}\n\n\tpublic void setAge(int age) {\n\t\tthis.age = age;\n\t}\n\n\tpublic double getSalary() {\n\t\treturn salary;\n\t}\n\n\tpublic void setSalary(double salary) {\n\t\tthis.salary = salary;\n\t}\n\n\tpublic Employee() {\n\t\tSystem.out.println(\"Employee().....\");\n\t}\n\n\tpublic Employee(int id) {\n\t\tthis.id = id;\n\t\tSystem.out.println(\"Employee(int id).....\");\n\t}\n\n\tpublic Employee(int id, String name) {\n\t\tthis.id = id;\n\t\tthis.name = name;\n\t}\n\n\tpublic Employee(int id, String name, int age, double salary) {\n\n\t\tthis.id = id;\n\t\tthis.name = name;\n\t\tthis.age = age;\n\t\tthis.salary = salary;\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn \"Employee{\" + \"id=\" + id + \", name='\" + name + '\\'' + \", age=\" + age + \", salary=\" + salary + '}';\n\t}\n\n\t@Override\n\tpublic boolean equals(Object o) {\n\t\tif (this == o)\n\t\t\treturn true;\n\t\tif (o == null || getClass() != o.getClass())\n\t\t\treturn false;\n\n\t\tEmployee employee = (Employee) o;\n\n\t\tif (id != employee.id)\n\t\t\treturn false;\n\t\tif (age != employee.age)\n\t\t\treturn false;\n\t\tif (Double.compare(employee.salary, salary) != 0)\n\t\t\treturn false;\n\t\treturn name != null ? name.equals(employee.name) : employee.name == null;\n\t}\n\n\t@Override\n\tpublic int hashCode() {\n\t\tint result;\n\t\tlong temp;\n\t\tresult = id;\n\t\tresult = 31 * result + (name != null ? name.hashCode() : 0);\n\t\tresult = 31 * result + age;\n\t\ttemp = Double.doubleToLongBits(salary);\n\t\tresult = 31 * result + (int) (temp ^ (temp >>> 32));\n\t\treturn result;\n\t}\n}\n\n```\n\n\n\n```Java\n/**\n * 提供用于测试的数据\n */\npublic class EmployeeData {\n   \n   public static List<Employee> getEmployees(){\n      List<Employee> list = new ArrayList<>();\n      \n      list.add(new Employee(1001, \"马化腾\", 34, 6000.38));\n      list.add(new Employee(1002, \"马云\", 12, 9876.12));\n      list.add(new Employee(1003, \"刘强东\", 33, 3000.82));\n      list.add(new Employee(1004, \"雷军\", 26, 7657.37));\n      list.add(new Employee(1005, \"李彦宏\", 65, 5555.32));\n      list.add(new Employee(1006, \"比尔盖茨\", 42, 9500.43));\n      list.add(new Employee(1007, \"任正非\", 26, 4333.32));\n      list.add(new Employee(1008, \"扎克伯格\", 35, 2500.32));\n      \n      return list;\n   }\n   \n}\n```\n\n\n\n**下面来通过实际例子讲解方法引用：**\n\n```java\n\n\n/**\n * 方法引用的使用\n *\n * 1.使用情境：当要传递给Lambda体的操作，已经有实现的方法了，可以使用方法引用！\n *\n * 2.方法引用，本质上就是Lambda表达式，而Lambda表达式作为函数式接口的实例。所以\n *   方法引用，也是函数式接口的实例。\n *\n * 3. 使用格式：  类(或对象) :: 方法名\n *\n * 4. 具体分为如下的三种情况：\n *    情况1     对象 :: 非静态方法\n *    情况2     类 :: 静态方法\n *\n *    情况3     类 :: 非静态方法\n *\n * 5. 方法引用使用的要求：\n * \t接口中的抽象方法的形参列表和返回值类型\n * \t与\n * \t方法引用的方法的形参列表和返回值类型相同！（针对于情况1和情况2）\n *\n */\npublic class MethodRefTest {\n\n\t// 情况一：对象 :: 实例方法\n\t//Consumer中的void accept(T t)\n\t//PrintStream中的void println(T t)\n\t@Test\n\tpublic void test1() {\n\t\tConsumer<String> con1 = str -> System.out.println(str);\n\t\tcon1.accept(\"北京\");\n\n\t\tSystem.out.println(\"*******************\");\n\t\tPrintStream ps = System.out;\n\t\tConsumer<String> con2 = ps::println;\n\t\tcon2.accept(\"beijing\");\n\t}\n\t\n\t//Supplier中的T get()\n\t//Employee中的String getName()\n\t@Test\n\tpublic void test2() {\n\t\tEmployee emp = new Employee(1001,\"Tom\",23,5600);\n\n\t\tSupplier<String> sup1 = () -> emp.getName();\n\t\tSystem.out.println(sup1.get());\n\n\t\tSystem.out.println(\"*******************\");\n\t\tSupplier<String> sup2 = emp::getName;\n\t\tSystem.out.println(sup2.get());\n\n\t}\n\n\t// 情况二：类 :: 静态方法\n\t//Comparator中的int compare(T t1,T t2)\n\t//Integer中的int compare(T t1,T t2)\n\t@Test\n\tpublic void test3() {\n\t\tComparator<Integer> com1 = (t1,t2) -> Integer.compare(t1,t2);\n\t\tSystem.out.println(com1.compare(12,21));\n\n\t\tSystem.out.println(\"*******************\");\n\n\t\tComparator<Integer> com2 = Integer::compare;\n\t\tSystem.out.println(com2.compare(12,3));\n\n\t}\n\t\n\t//Function中的R apply(T t)\n\t//Math中的Long round(Double d)\n\t@Test\n\tpublic void test4() {\n\t\tFunction<Double,Long> func = new Function<Double, Long>() {\n\t\t\t@Override\n\t\t\tpublic Long apply(Double d) {\n\t\t\t\treturn Math.round(d);\n\t\t\t}\n\t\t};\n\n\t\tSystem.out.println(\"*******************\");\n\n\t\tFunction<Double,Long> func1 = d -> Math.round(d);\n\t\tSystem.out.println(func1.apply(12.3));\n\n\t\tSystem.out.println(\"*******************\");\n\n\t\tFunction<Double,Long> func2 = Math::round;\n\t\tSystem.out.println(func2.apply(12.6));\n\t}\n\n\t// 情况三：类 :: 实例方法  (有难度)\n\t// Comparator中的int comapre(T t1,T t2)  第一个参数T t1,也可以变成方法的调用者\n\t// String中的int t1.compareTo(t2)        看上面说的，t1变成了调用者等价于第一个参数T t1\n\t@Test\n\tpublic void test5() {\n\t\tComparator<String> com1 = (s1,s2) -> s1.compareTo(s2);\n\t\tSystem.out.println(com1.compare(\"abc\",\"abd\"));\n\n\t\tSystem.out.println(\"*******************\");\n\n\t\tComparator<String> com2 = String :: compareTo;\n\t\tSystem.out.println(com2.compare(\"abd\",\"abm\"));\n\t}\n\n\t//BiPredicate中的boolean test(T t1, T t2);\n\t//String中的boolean t1.equals(t2)\n\t@Test\n\tpublic void test6() {\n\t\tBiPredicate<String,String> pre1 = (s1,s2) -> s1.equals(s2);\n\t\tSystem.out.println(pre1.test(\"abc\",\"abc\"));\n\n\t\tSystem.out.println(\"*******************\");\n\t\tBiPredicate<String,String> pre2 = String :: equals;\n\t\tSystem.out.println(pre2.test(\"abc\",\"abd\"));\n\t}\n\t\n\t// Function中的R apply(T t)\n\t// Employee中的String getName();   第一个参数T t相当于方法调用者emp，返回值R和String对应\n\t@Test\n\tpublic void test7() {\n\t\tEmployee employee = new Employee(1001, \"Jerry\", 23, 6000);\n\n\n\t\tFunction<Employee,String> func1 = e -> e.getName();\n\t\tSystem.out.println(func1.apply(employee));\n\n\t\tSystem.out.println(\"*******************\");\n\n\n\t\tFunction<Employee,String> func2 = Employee::getName;\n\t\tSystem.out.println(func2.apply(employee));\n\n\n\t}\n\n}\n\n```\n\n\n\n\n\n# 构造器引用\n\n格式：ClassName :: new\n\n与函数式接口相结合，自动与函数式接口中方法兼容。可以把构造器引用赋值给定义的方法，要求构造器参数列表要与接口中抽象方法的参数列表一致！且方法的返回值即为构造器对应类的对象。\n\n\n\n```Java\n\nimport org.junit.Test;\n\nimport java.util.Arrays;\nimport java.util.function.BiFunction;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\n\n/**\n * 一、构造器引用\n *      和方法引用类似，函数式接口的抽象方法的形参列表和构造器的形参列表一致。\n *      抽象方法的返回值类型即为构造器所属的类的类型\n *\n * 二、数组引用\n *     大家可以把数组看做是一个特殊的类，则写法与构造器引用一致。\n *\n */\npublic class ConstructorRefTest {\n\n    /**\n     * 构造器引用\n     * Supplier中的T get()\n     * Employee的空参构造器：Employee()\n     * 1、和方法引用一样的理解方法，你的get()方法没有参数，我的Employee()也没有参数。\n     * 2、你的get()方法有返回值T，我的Employee()方法返回值也是一个对象\n     * 3、所以刚好可以用  \n     */\n    @Test\n    public void test1(){\n\n        Supplier<Employee> sup = new Supplier<Employee>() {\n            @Override\n            public Employee get() {\n                return new Employee();\n            }\n        };\n        System.out.println(\"*******************\");\n\n        Supplier<Employee>  sup1 = () -> new Employee();\n        System.out.println(sup1.get());\n\n        System.out.println(\"*******************\");\n\n        Supplier<Employee>  sup2 = Employee :: new;\n        System.out.println(sup2.get());\n    }\n\n\t//Function中的R apply(T t)\n    @Test\n    public void test2(){\n        Function<Integer,Employee> func1 = id -> new Employee(id);\n        Employee employee = func1.apply(1001);\n        System.out.println(employee);\n\n        System.out.println(\"*******************\");\n\n        Function<Integer,Employee> func2 = Employee :: new;\n        Employee employee1 = func2.apply(1002);\n        System.out.println(employee1);\n\n    }\n\n\t//BiFunction中的R apply(T t,U u)\n    @Test\n    public void test3(){\n        BiFunction<Integer,String,Employee> func1 = (id,name) -> new Employee(id,name);\n        System.out.println(func1.apply(1001,\"Tom\"));\n\n        System.out.println(\"*******************\");\n\n        BiFunction<Integer,String,Employee> func2 = Employee :: new;\n        System.out.println(func2.apply(1002,\"Tom\"));\n\n    }\n\n\t//数组引用\n    //Function中的R apply(T t)\n    @Test\n    public void test4(){\n        Function<Integer,String[]> func1 = length -> new String[length];\n        String[] arr1 = func1.apply(5);\n        System.out.println(Arrays.toString(arr1));\n\n        System.out.println(\"*******************\");\n\n        Function<Integer,String[]> func2 = String[] :: new;\n        String[] arr2 = func2.apply(10);\n        System.out.println(Arrays.toString(arr2));\n\n    }\n}\n\n```\n\n\n\n# 强大的Stream API\n\n## Stream API说明\n\n- Java8中有两大最为重要的改变。第一个是 **Lambda** **表达式**；另外一个则是 **Stream API**。 \n\n- Stream API ( java.util.stream) 把真正的函数式编程风格引入到Java中。这是目前为止对Java类库最好的补充，因为Stream API可以极大提供Java程序员的生产力，让程序员写出高效率、干净、简洁的代码。\n\n- Stream 是 Java8 中处理集合的关键抽象概念，它可以指定你希望对集合进行的操作，可以执行非常复杂的查找、过滤和映射数据等操作。 **使用Stream API 对集合数据进行操作，就类似于使用 SQL 执行的数据库查询。**也可以使用 Stream API 来并行执行操作。简言之，Stream API 提供了一种高效且易于使用的处理数据的方式\n\n\n\n## 为什么要使用Stream API\n\n- 实际开发中，项目中多数数据源都来自于Mysql，Oracle等，很多一些复杂的数据获取可以直接在sql层面去解决。但现在数据源可以更多了，有MongDB，Radis等，而这些NoSQL的数据本身不支持一些复杂的数据计算，这个时候就需要Java层面去处理。 \n\n- Stream 和 Collection 集合的区别：Collection 是一种静态的内存数据结构，而 Stream 是有关计算的。前者是主要面向内存，存储在内存中，后者主要是面向 CPU，通过 CPU 实现计算。\n\n\n\n## 什么是Stream\n\nStream到底是什么呢？\n\n是数据渠道，用于操作数据源（集合、数组等）所生成的元素序列。\n\n**“集合讲的是数据，Stream讲的是计算！”**\n\n**注意：**\n\n①Stream 自己不会存储元素。\n\n②Stream 不会改变源对象。相反，他们会返回一个持有结果的新Stream。 \n\n③Stream 操作是延迟执行的。这意味着他们会等到需要结果的时候才执行\n\n\n\n\n\n**Stream** **的操作三个步骤**\n\n1、创建Stream\n\n一个数据源（如：集合、数组），获取一个流\n\n2、中间操作\n\n一个中间操作链，对数据源的数据进行处理\n\n3、终止操作(终端操作) \n\n一旦执行终止操作，就执行中间操作链，才产生结果【也就是所谓的延迟执行】。之后，不会再被使用\n\n\n\n<img src=\"https://npm.elemecdn.com/youthlql@1.0.8/Java_Basis/Java8_New_Features/0004.png\">\n\n\n\n\n\n## 创建Stream\n\n\n\n```java\n\npublic class StreamAPITest {\n\n    //创建 Stream方式一：通过集合\n    @Test\n    public void test1(){\n        List<Employee> employees = EmployeeData.getEmployees();\n\n//        default Stream<E> stream() : 返回一个顺序流，顺序流等会中间操作拿数据的时候按顺序拿\n        Stream<Employee> stream = employees.stream();\n\n//        default Stream<E> parallelStream() : 返回一个并行流\n        Stream<Employee> parallelStream = employees.parallelStream();\n\n    }\n\n    //创建 Stream方式二：通过数组\n    @Test\n    public void test2(){\n        int[] arr = new int[]{1,2,3,4,5,6};\n        //调用Arrays类的static <T> Stream<T> stream(T[] array): 返回一个流\n        IntStream stream = Arrays.stream(arr);\n\n        Employee e1 = new Employee(1001,\"Tom\");\n        Employee e2 = new Employee(1002,\"Jerry\");\n        Employee[] arr1 = new Employee[]{e1,e2};\n        Stream<Employee> stream1 = Arrays.stream(arr1);\n\n    }\n    //创建 Stream方式三：通过Stream的of()，通过显示值创建一个流。它可以接收任意数量的参数\n    @Test\n    public void test3(){\n\n        Stream<Integer> stream = Stream.of(1, 2, 3, 4, 5, 6);\n\n    }\n\n    //创建 Stream方式四：创建无限流【用的少，了解下就行】\n    @Test\n    public void test4(){\n\n//      迭代\n//      public static<T> Stream<T> iterate(final T seed, final UnaryOperator<T> f)\n        //遍历前10个偶数\n        Stream.iterate(0, t -> t + 2).limit(10).forEach(System.out::println);\n\n\n//      生成\n//      public static<T> Stream<T> generate(Supplier<T> s)\n        Stream.generate(Math::random).limit(10).forEach(System.out::println);\n\n    }\n\n}\n\n```\n\n\n\n\n\n## 中间操作\n\n```Java\n\n/**\n * 测试Stream的中间操作\n */\npublic class StreamAPITest1 {\n\n    //1-筛选与切片\n    @Test\n    public void test1(){\n        List<Employee> list = EmployeeData.getEmployees();\n//        filter(Predicate p)——过滤   接收 Lambda ， 从流中排除某些元素。\n        Stream<Employee> stream = list.stream();\n        //练习：查询员工表中薪资大于7000的员工信息\n        /**\n         * List<String> filterStrs1 = filterString(list,s -> s.contains(\"京\"));\n         * 跟之前的这个lambda表达式代码是一个意思\n         */\n        stream.filter(e -> e.getSalary() > 7000).forEach(System.out::println);\n\n        System.out.println();\n//        limit(n)——截断流，使其元素不超过给定数量。\n        list.stream().limit(3).forEach(System.out::println);\n        System.out.println();\n\n        /*\n        skip(n) —— 跳过元素，返回一个扔掉了前 n 个元素的流。若流中元素不足 n 个，\n        则返回一个空流。与 limit(n) 互补\n        */\n        list.stream().skip(3).forEach(System.out::println);\n\n        System.out.println();\n//        distinct()——筛选，通过流所生成元素的 hashCode() 和 equals() 去除重复元素\n\n        list.add(new Employee(1010,\"刘强东\",40,8000));\n        list.add(new Employee(1010,\"刘强东\",41,8000));\n        list.add(new Employee(1010,\"刘强东\",40,8000));\n        list.add(new Employee(1010,\"刘强东\",40,8000));\n        list.add(new Employee(1010,\"刘强东\",40,8000));\n\n//        System.out.println(list);\n\n        list.stream().distinct().forEach(System.out::println);\n    }\n\n    //映射\n    @Test\n    public void test2(){\n        /*\n        map(Function f)——接收一个函数作为参数，将元素转换成其他形式或提取信息，该函数会被应\n        用到每个元素上，并将其映射成一个新的元素。\n        */\n        List<String> list = Arrays.asList(\"aa\", \"bb\", \"cc\", \"dd\");\n        list.stream().map(str -> str.toUpperCase()).forEach(System.out::println);\n\n//        练习1：获取员工姓名长度大于3的员工的姓名。\n        List<Employee> employees = EmployeeData.getEmployees();\n        Stream<String> namesStream = employees.stream().map(Employee::getName);\n        namesStream.filter(name -> name.length() > 3).forEach(System.out::println);\n        System.out.println();\n        //练习2：\n        Stream<Stream<Character>> streamStream = list.stream().map(StreamAPITest1::fromStringToStream);\n        //这个还需要两层遍历\n        streamStream.forEach(s ->{\n            s.forEach(System.out::println);\n        });\n        System.out.println();\n        /*\n        flatMap(Function f)——接收一个函数作为参数，将流中的每个值都换成另一个流，然后把所有流连\n        接成一个流。flatMap一层遍历即可拿到想要的结果\n        */\n        Stream<Character> characterStream = list.stream().flatMap(StreamAPITest1::fromStringToStream);\n        characterStream.forEach(System.out::println);\n\n    }\n\n    //将字符串中的多个字符构成的集合转换为对应的Stream的实例\n    public static Stream<Character> fromStringToStream(String str){//aa\n        ArrayList<Character> list = new ArrayList<>();\n        for(Character c : str.toCharArray()){\n            list.add(c);\n        }\n       return list.stream();\n\n    }\n\n\n    //3-排序\n    @Test\n    public void test4(){\n//        sorted()——自然排序\n        List<Integer> list = Arrays.asList(12, 43, 65, 34, 87, 0, -98, 7);\n        list.stream().sorted().forEach(System.out::println);\n        //抛异常，原因:Employee没有实现Comparable接口\n//        List<Employee> employees = EmployeeData.getEmployees();\n//        employees.stream().sorted().forEach(System.out::println);\n\n\n//        sorted(Comparator com)——定制排序\n\n        List<Employee> employees = EmployeeData.getEmployees();\n        employees.stream().sorted( (e1,e2) -> {\n\n           int ageValue = Integer.compare(e1.getAge(),e2.getAge());\n           if(ageValue != 0){\n               return ageValue;\n           }else{\n               return -Double.compare(e1.getSalary(),e2.getSalary());\n           }\n\n        }).forEach(System.out::println);\n    }\n\n}\n\n```\n\n\n\n## 终止操作\n\n\n\n```Java\n\n/**\n * 测试Stream的终止操作\n *\n */\npublic class StreamAPITest2 {\n\n    //1-匹配与查找\n    @Test\n    public void test1(){\n        List<Employee> employees = EmployeeData.getEmployees();\n\n//        allMatch(Predicate p)——检查是否匹配所有元素。\n//          练习：是否所有的员工的年龄都大于18\n        boolean allMatch = employees.stream().allMatch(e -> e.getAge() > 18);\n        System.out.println(allMatch);\n\n//        anyMatch(Predicate p)——检查是否至少匹配一个元素。\n//         练习：是否存在员工的工资大于 10000\n        boolean anyMatch = employees.stream().anyMatch(e -> e.getSalary() > 10000);\n        System.out.println(anyMatch);\n\n//        noneMatch(Predicate p)——检查是否没有匹配的元素。\n//          练习：是否存在员工姓“雷”\n        boolean noneMatch = employees.stream().noneMatch(e -> e.getName().startsWith(\"雷\"));\n        System.out.println(noneMatch);\n//        findFirst——返回第一个元素\n        Optional<Employee> employee = employees.stream().findFirst();\n        System.out.println(employee);\n//        findAny——返回当前流中的任意元素\n        Optional<Employee> employee1 = employees.parallelStream().findAny();\n        System.out.println(employee1);\n\n    }\n\n    @Test\n    public void test2(){\n        List<Employee> employees = EmployeeData.getEmployees();\n        // count——返回流中元素的总个数\n        long count = employees.stream().filter(e -> e.getSalary() > 5000).count();\n        System.out.println(count);\n//        max(Comparator c)——返回流中最大值\n//        练习：返回最高的工资：\n        Stream<Double> salaryStream = employees.stream().map(e -> e.getSalary());\n        Optional<Double> maxSalary = salaryStream.max(Double::compare);\n        System.out.println(maxSalary);\n//        min(Comparator c)——返回流中最小值\n//        练习：返回最低工资的员工\n        Optional<Employee> employee = employees.stream().min((e1, e2) -> Double.compare(e1.getSalary(), e2.getSalary()));\n        System.out.println(employee);\n        System.out.println();\n//        forEach(Consumer c)——内部迭代\n        employees.stream().forEach(System.out::println);\n\n        //使用集合的遍历操作\n        employees.forEach(System.out::println);\n    }\n\n    //2-归约\n    @Test\n    public void test3(){\n//        reduce(T identity, BinaryOperator)——可以将流中元素反复结合起来，得到一个值。返回 T\n//        练习1：计算1-10的自然数的和\n        List<Integer> list = Arrays.asList(1,2,3,4,5,6,7,8,9,10);\n        Integer sum = list.stream().reduce(0, Integer::sum);\n        System.out.println(sum);\n\n\n//        reduce(BinaryOperator) ——可以将流中元素反复结合起来，得到一个值。返回 Optional<T>\n//        练习2：计算公司所有员工工资的总和\n        List<Employee> employees = EmployeeData.getEmployees();\n        Stream<Double> salaryStream = employees.stream().map(Employee::getSalary);\n//        Optional<Double> sumMoney = salaryStream.reduce(Double::sum);\n        Optional<Double> sumMoney = salaryStream.reduce((d1,d2) -> d1 + d2);\n        System.out.println(sumMoney.get());\n\n    }\n\n    //3-收集\n    @Test\n    public void test4(){\n// collect(Collector c)——将流转换为其他形式。接收一个 Collector接口的实现，用于给Stream中元素做汇总的方法\n//        练习1：查找工资大于6000的员工，结果返回为一个List或Set\n\n        List<Employee> employees = EmployeeData.getEmployees();\n        List<Employee> employeeList = employees.stream().filter(e -> e.getSalary() > 6000).collect(Collectors.toList());\n\n        employeeList.forEach(System.out::println);\n        System.out.println();\n        Set<Employee> employeeSet = employees.stream().filter(e -> e.getSalary() > 6000).collect(Collectors.toSet());\n\n        employeeSet.forEach(System.out::println);\n\n\n\n\n    }\n}\n\n```\n\n\n\n# Optional类\n\n## 什么是Optional？\n\n\n\n- 到目前为止，臭名昭著的空指针异常是导致Java应用程序失败的最常见原因。以前，为了解决空指针异常，Google公司著名的Guava项目引入了Optional类，Guava通过使用检查空值的方式来防止代码污染，它鼓励程序员写更干净的代码。受到Google Guava的启发，Optional类已经成为Java 8类库的一部分。\n\n- Optional<T> 类(java.util.Optional) 是一个容器类，它可以保存类型T的值，代表这个值存在。或者仅仅保存null，表示这个值不存在。原来用 null 表示一个值不存在，现在 Optional 可以更好的表达这个概念。并且可以避免空指针异常。 \n\n- Optional类的Javadoc描述如下：这是一个可以为null的容器对象。如果值存在则isPresent()方法会返回true，调用get()方法会返回该对象。\n\n\n\n## 常用API\n\n<img src=\"https://npm.elemecdn.com/youthlql@1.0.8/Java_Basis/Java8_New_Features/0005.png\">\n\n\n\n\n\n## 举例\n\n首先准备两个类\n\n```java\n\npublic class Boy {\n    private Girl girl;\n\n    @Override\n    public String toString() {\n        return \"Boy{\" +\n                \"girl=\" + girl +\n                '}';\n    }\n\n    public Girl getGirl() {\n        return girl;\n    }\n\n    public void setGirl(Girl girl) {\n        this.girl = girl;\n    }\n\n    public Boy() {\n\n    }\n\n    public Boy(Girl girl) {\n\n        this.girl = girl;\n    }\n}\n```\n\n\n\n```java\npublic class Girl {\n\n    private String name;\n\n    @Override\n    public String toString() {\n        return \"Girl{\" +\n                \"name='\" + name + '\\'' +\n                '}';\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public Girl() {\n\n    }\n\n    public Girl(String name) {\n\n        this.name = name;\n    }\n}\n```\n\n\n\n这里只是简单的测试两个API\n\n```Java\n/**\n * Optional类：为了在程序中避免出现空指针异常而创建的。\n *\n * 常用的方法：ofNullable(T t)\n *            orElse(T t)\n *\n */\npublic class OptionalTest {\n\n/*\nOptional.of(T t) : 创建一个 Optional 实例，t必须非空；\nOptional.empty() : 创建一个空的 Optional 实例\nOptional.ofNullable(T t)：t可以为null\n\n */\n    @Test\n    public void test1(){\n        Girl girl = new Girl();\n//        girl = null;\n        //of(T t):保证t是非空的\n        Optional<Girl> optionalGirl = Optional.of(girl);\n\n    }\n\n    @Test\n    public void test2(){\n        Girl girl = new Girl();\n//        girl = null;\n        //ofNullable(T t)：t可以为null\n        Optional<Girl> optionalGirl = Optional.ofNullable(girl);\n        System.out.println(optionalGirl);\n        //orElse(T t1):如果单前的Optional内部封装的t是非空的，则返回内部的t.\n        //如果内部的t是空的，则返回orElse()方法中的参数t1.\n        Girl girl1 = optionalGirl.orElse(new Girl(\"赵丽颖\"));\n        System.out.println(girl1);\n\n    }\n}\n```\n\n\n\n**实际场景使用**\n\n可能出现空指针的例子：\n\n```java\npublic String getGirlName(Boy boy){\n        return boy.getGirl().getName();\n    }\n\n    @Test\n    public void test3(){\n        Boy boy = new Boy();\n        boy = null;\n        String girlName = getGirlName(boy);\n        System.out.println(girlName);\n\n    }\n```\n\n\n\n结果：\n\n```\njava.lang.NullPointerException\n\tat com.atguigu.java4.OptionalTest.getGirlName(OptionalTest.java:47)\n\tat com.atguigu.java4.OptionalTest.test3(OptionalTest.java:54)\n...\n...\n\nProcess finished with exit code -1\n```\n\n\n\n没有Optional的解决办法，但是如果调用层数过多，就得一层一层判断是否为null，写起来很麻烦。\n\n```Java\n//优化以后的getGirlName():\n    public String getGirlName1(Boy boy){\n        if(boy != null){\n            Girl girl = boy.getGirl();\n            if(girl != null){\n                return girl.getName();\n            }\n        }\n\n        return null;\n\n    }\n@Test\n    public void test4(){\n        Boy boy = new Boy();\n        boy = null;\n        String girlName = getGirlName1(boy);\n        System.out.println(girlName);\n\n    }\n```\n\n\n\n使用Optional解决问题：\n\n```Java\n //使用Optional类的getGirlName():\n    public String getGirlName2(Boy boy){\n\n        Optional<Boy> boyOptional = Optional.ofNullable(boy);\n        //此时的boy1一定非空\n        Boy boy1 = boyOptional.orElse(new Boy(new Girl(\"迪丽热巴\")));\n\n        Girl girl = boy1.getGirl();\n\n        Optional<Girl> girlOptional = Optional.ofNullable(girl);\n        //girl1一定非空\n        Girl girl1 = girlOptional.orElse(new Girl(\"古力娜扎\"));\n\n        return girl1.getName();\n    }\n\n    @Test\n    public void test5(){\n        Boy boy = null;\n        boy = new Boy();\n        boy = new Boy(new Girl(\"苍老师\"));\n        String girlName = getGirlName2(boy);\n        System.out.println(girlName);\n\n    }\n```\n\n这种是绝对不会出现空指针的。\n\n\n\n# 接口的增强\n\n```\nJDK7及以前：只能定义全局常量和抽象方法\n  >全局常量：public static final的.但是书写时，可以省略不写\n  >抽象方法：public abstract的\n  \t\t\t\nJDK8：除了定义全局常量和抽象方法之外，还可以定义静态方法、默认方法\n```\n\n\n\n```java\n/*\n * JDK8：除了定义全局常量和抽象方法之外，还可以定义静态方法、默认方法\n */\npublic interface CompareA {\n\n    //静态方法\n    public static void method1() {\n\n        System.out.println(\"CompareA:北京\");\n    }\n\n    //默认方法\n    public default void method2() {\n        System.out.println(\"CompareA：上海\");\n    }\n    //接口中的public 可以省略，自动就是public\n    default void method3() {\n        System.out.println(\"CompareA：上海\");\n    }\n}\n```\n\n\n\n```java\npublic class SuperClass {\n\t\n\tpublic void method3(){\n\t\tSystem.out.println(\"SuperClass:北京\");\n\t}\n\t\n}\n```\n\n\n\n```java\npublic interface CompareB {\n\t\n\tdefault void method3(){\n\t\tSystem.out.println(\"CompareB：上海\");\n\t}\n\t\n}\n```\n\n\n\n\n\n```java\npublic class SubClassTest {\n\t\n\tpublic static void main(String[] args) {\n\t\tSubClass s = new SubClass();\n\t\t\n//\t\ts.method1();\n//\t\tSubClass.method1();\n\t\t//知识点1：接口中定义的静态方法，只能通过接口来调用。实现类用不了\n\t\tCompareA.method1();\n\t\t//知识点2：通过实现类的对象，可以调用接口中的默认方法。\n\t\t//如果实现类重写了接口中的默认方法，调用时，仍然调用的是重写以后的方法\n\t\ts.method2();\n\t\t//知识点3：如果子类(或实现类)继承的父类和实现的接口中声明了同名同参数的默认方法，\n\t\t//那么子类在没有重写此方法的情况下，默认调用的是父类中的同名同参数的方法。-->类优先原则\n\t\t//知识点4：如果实现类实现了多个接口，而这多个接口中定义了同名同参数的默认方法，\n\t\t//那么在实现类没有重写此方法的情况下，报错。-->接口冲突。\n\t\t//这就需要我们必须在实现类中重写此方法\n\t\ts.method3();\n\t\t\n\t}\n\t\n}\n\nclass SubClass extends SuperClass implements CompareA,CompareB{\n\t\n\tpublic void method2(){\n\t\tSystem.out.println(\"SubClass：上海\");\n\t}\n\t\n\tpublic void method3(){\n\t\tSystem.out.println(\"SubClass：深圳\");\n\t}\n\t\n\t//知识点5：如何在子类(或实现类)的方法中调用父类、接口中被重写的方法\n\tpublic void myMethod(){\n\t\tmethod3();//调用自己定义的重写的方法\n\t\tsuper.method3();//调用的是父类中声明的\n\t\t//调用接口中的默认方法\n\t\tCompareA.super.method3();\n\t\tCompareB.super.method3();\n\t}\n}\n```\n","slug":"2021-04-14-Java8新特性","published":1,"updated":"2024-04-14T14:33:03.956Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clxjyo3bm0001isvd8jyu0twj","content":"<h1 id=\"Java8新特性纵览\"><a href=\"#Java8新特性纵览\" class=\"headerlink\" title=\"Java8新特性纵览\"></a>Java8新特性纵览</h1><blockquote>\n<p>关于Java8新特性的学习与记录，资料来源于互联网。</p>\n</blockquote>\n<h1 id=\"Lambda表达式\"><a href=\"#Lambda表达式\" class=\"headerlink\" title=\"Lambda表达式\"></a>Lambda表达式</h1><h2 id=\"为什么使用Lambda表达式？\"><a href=\"#为什么使用Lambda表达式？\" class=\"headerlink\" title=\"为什么使用Lambda表达式？\"></a>为什么使用Lambda表达式？</h2><ul>\n<li>Lambda 是一个<strong>匿名函数</strong>，我们可以把 Lambda 表达式理解为是<strong>一段可以传递的代码</strong>（将代码像数据一样进行传递）。使用它可以写出更简洁、更灵活的代码。作为一种更紧凑的代码风格，使Java的语言表达能力得到了提升。</li>\n<li>在Java8之后的很多源码里用到了Lambda表达式，不学的话可能看不懂源码。</li>\n</ul>\n<h2 id=\"简单使用\"><a href=\"#简单使用\" class=\"headerlink\" title=\"简单使用\"></a>简单使用</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\">   <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test1</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">       <span class=\"comment\">//原始写法</span></span><br><span class=\"line\">       <span class=\"type\">Runnable</span> <span class=\"variable\">r1</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Runnable</span>() &#123;</span><br><span class=\"line\">           <span class=\"meta\">@Override</span></span><br><span class=\"line\">           <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">               System.out.println(<span class=\"string\">&quot;我爱北京天安门&quot;</span>);</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">       r1.run();</span><br><span class=\"line\"></span><br><span class=\"line\">       System.out.println(<span class=\"string\">&quot;***********************&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"comment\">//lambda表达式，可以表达一样的意思</span></span><br><span class=\"line\">       <span class=\"type\">Runnable</span> <span class=\"variable\">r2</span> <span class=\"operator\">=</span> () -&gt; System.out.println(<span class=\"string\">&quot;我爱北京故宫&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">       r2.run();</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"meta\">@Test</span></span><br><span class=\"line\">   <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test2</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">       Comparator&lt;Integer&gt; com1 = <span class=\"keyword\">new</span> <span class=\"title class_\">Comparator</span>&lt;Integer&gt;() &#123;</span><br><span class=\"line\">           <span class=\"meta\">@Override</span></span><br><span class=\"line\">           <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">compare</span><span class=\"params\">(Integer o1, Integer o2)</span> &#123;</span><br><span class=\"line\">               <span class=\"keyword\">return</span> Integer.compare(o1,o2);</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"type\">int</span> <span class=\"variable\">compare1</span> <span class=\"operator\">=</span> com1.compare(<span class=\"number\">12</span>,<span class=\"number\">21</span>);</span><br><span class=\"line\">       System.out.println(compare1);</span><br><span class=\"line\"></span><br><span class=\"line\">       System.out.println(<span class=\"string\">&quot;***********************&quot;</span>);</span><br><span class=\"line\">       </span><br><span class=\"line\">       <span class=\"comment\">//Lambda表达式的写法</span></span><br><span class=\"line\">       Comparator&lt;Integer&gt; com2 = (o1,o2) -&gt; Integer.compare(o1,o2);</span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"type\">int</span> <span class=\"variable\">compare2</span> <span class=\"operator\">=</span> com2.compare(<span class=\"number\">32</span>,<span class=\"number\">21</span>);</span><br><span class=\"line\">       System.out.println(compare2);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">       System.out.println(<span class=\"string\">&quot;***********************&quot;</span>);</span><br><span class=\"line\">       <span class=\"comment\">//方法引用</span></span><br><span class=\"line\">       Comparator&lt;Integer&gt; com3 = Integer :: compare;</span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"type\">int</span> <span class=\"variable\">compare3</span> <span class=\"operator\">=</span> com3.compare(<span class=\"number\">32</span>,<span class=\"number\">21</span>);</span><br><span class=\"line\">       System.out.println(compare3);</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"Lambda语法规则\"><a href=\"#Lambda语法规则\" class=\"headerlink\" title=\"Lambda语法规则\"></a>Lambda语法规则</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> org.junit.Test;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.ArrayList;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Comparator;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.function.Consumer;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Lambda表达式的使用</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;p&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> * 1.举例： (o1,o2) -&gt; Integer.compare(o1,o2);</span></span><br><span class=\"line\"><span class=\"comment\"> * 2.格式：</span></span><br><span class=\"line\"><span class=\"comment\"> * -&gt; :lambda操作符 或 箭头操作符</span></span><br><span class=\"line\"><span class=\"comment\"> * -&gt;左边：lambda形参列表 （其实就是接口中的抽象方法的形参列表）</span></span><br><span class=\"line\"><span class=\"comment\"> * -&gt;右边：lambda体 （其实就是重写的抽象方法的方法体）</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;p&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> * 3. Lambda表达式的使用：（分为6种情况介绍）</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;p&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> * 总结：</span></span><br><span class=\"line\"><span class=\"comment\"> * -&gt;左边：lambda形参列表的参数类型可以省略(类型推断)；如果lambda形参列表只有一个参数，其一对()也</span></span><br><span class=\"line\"><span class=\"comment\"> * 可以省略</span></span><br><span class=\"line\"><span class=\"comment\"> * -&gt;右边：lambda体应该使用一对&#123;&#125;包裹；如果lambda体只有一条执行语句（可能是return语句），省略这一</span></span><br><span class=\"line\"><span class=\"comment\"> 对&#123;&#125;和return关键字</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;p&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> * 4.Lambda表达式的本质：作为函数式接口的实例</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;p&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> * 5. 如果一个接口中，只声明了一个抽象方法，则此接口就称为函数式接口。我们可以在一个接口上</span></span><br><span class=\"line\"><span class=\"comment\"> 使用 <span class=\"doctag\">@FunctionalInterface</span> 注解，</span></span><br><span class=\"line\"><span class=\"comment\"> * 这样做可以检查它是否是一个函数式接口。</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;p&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> * 6. 所以以前用匿名实现类表示的现在都可以用Lambda表达式来写。</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">LambdaTest1</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//语法格式一：无参，无返回值</span></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test1</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Runnable</span> <span class=\"variable\">r1</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Runnable</span>() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;我爱北京天安门&quot;</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        r1.run();</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;***********************&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">Runnable</span> <span class=\"variable\">r2</span> <span class=\"operator\">=</span> () -&gt; &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;我爱北京故宫&quot;</span>);</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        r2.run();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//语法格式二：Lambda 需要一个参数，但是没有返回值。</span></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test2</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        Consumer&lt;String&gt; con = <span class=\"keyword\">new</span> <span class=\"title class_\">Consumer</span>&lt;String&gt;() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">accept</span><span class=\"params\">(String s)</span> &#123;</span><br><span class=\"line\">                System.out.println(s);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        con.accept(<span class=\"string\">&quot;谎言和誓言的区别是什么？&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;*******************&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        Consumer&lt;String&gt; con1 = (String s) -&gt; &#123;</span><br><span class=\"line\">            System.out.println(s);</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        con1.accept(<span class=\"string\">&quot;一个是听得人当真了，一个是说的人当真了&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//语法格式三：数据类型可以省略，因为可由编译器推断得出，称为“类型推断”</span></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test3</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        Consumer&lt;String&gt; con1 = (String s) -&gt; &#123;</span><br><span class=\"line\">            System.out.println(s);</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        con1.accept(<span class=\"string\">&quot;一个是听得人当真了，一个是说的人当真了&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;*******************&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        Consumer&lt;String&gt; con2 = (s) -&gt; &#123;</span><br><span class=\"line\">            System.out.println(s);</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        con2.accept(<span class=\"string\">&quot;一个是听得人当真了，一个是说的人当真了&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test4</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        ArrayList&lt;String&gt; list = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();<span class=\"comment\">//类型推断</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">int</span>[] arr = &#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>&#125;;<span class=\"comment\">//类型推断</span></span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//语法格式四：Lambda 若只需要一个参数时，参数的小括号可以省略</span></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test5</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        Consumer&lt;String&gt; con1 = (s) -&gt; &#123;</span><br><span class=\"line\">            System.out.println(s);</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        con1.accept(<span class=\"string\">&quot;一个是听得人当真了，一个是说的人当真了&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;*******************&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        Consumer&lt;String&gt; con2 = s -&gt; &#123;</span><br><span class=\"line\">            System.out.println(s);</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        con2.accept(<span class=\"string\">&quot;一个是听得人当真了，一个是说的人当真了&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//语法格式五：Lambda 需要两个或以上的参数，多条执行语句，并且可以有返回值</span></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test6</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        Comparator&lt;Integer&gt; com1 = <span class=\"keyword\">new</span> <span class=\"title class_\">Comparator</span>&lt;Integer&gt;() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">compare</span><span class=\"params\">(Integer o1, Integer o2)</span> &#123;</span><br><span class=\"line\">                System.out.println(o1);</span><br><span class=\"line\">                System.out.println(o2);</span><br><span class=\"line\">                <span class=\"keyword\">return</span> o1.compareTo(o2);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(com1.compare(<span class=\"number\">12</span>, <span class=\"number\">21</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;*****************************&quot;</span>);</span><br><span class=\"line\">        Comparator&lt;Integer&gt; com2 = (o1, o2) -&gt; &#123;</span><br><span class=\"line\">            System.out.println(o1);</span><br><span class=\"line\">            System.out.println(o2);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> o1.compareTo(o2);</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(com2.compare(<span class=\"number\">12</span>, <span class=\"number\">6</span>));</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//语法格式六：当 Lambda 体只有一条语句时，return 与大括号若有，都可以省略</span></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test7</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        Comparator&lt;Integer&gt; com1 = (o1, o2) -&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> o1.compareTo(o2);</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(com1.compare(<span class=\"number\">12</span>, <span class=\"number\">6</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;*****************************&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        Comparator&lt;Integer&gt; com2 = (o1, o2) -&gt; o1.compareTo(o2);</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(com2.compare(<span class=\"number\">12</span>, <span class=\"number\">21</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test8</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        Consumer&lt;String&gt; con1 = s -&gt; &#123;</span><br><span class=\"line\">            System.out.println(s);</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        con1.accept(<span class=\"string\">&quot;一个是听得人当真了，一个是说的人当真了&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;*****************************&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        Consumer&lt;String&gt; con2 = s -&gt; System.out.println(s);</span><br><span class=\"line\"></span><br><span class=\"line\">        con2.accept(<span class=\"string\">&quot;一个是听得人当真了，一个是说的人当真了&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"函数式接口\"><a href=\"#函数式接口\" class=\"headerlink\" title=\"函数式接口\"></a>函数式接口</h1><h2 id=\"什么是函数式-Functional-接口\"><a href=\"#什么是函数式-Functional-接口\" class=\"headerlink\" title=\"什么是函数式(Functional)接口\"></a>什么是函数式(Functional)接口</h2><ul>\n<li><p>只包含一个抽象方法的接口，称为<strong>函数式接口</strong>。 </p>\n</li>\n<li><p>你可以通过 Lambda 表达式来创建该接口的对象。（若 Lambda 表达式抛出一个受检异常(即：非运行时异常)，那么该异常需要在目标接口的抽象方法上进行声明）。</p>\n</li>\n<li><p>我们可以在一个接口上使用 <strong>@FunctionalInterface</strong> 注解，这样做可以检查它是否是一个函数式接口。同时 javadoc 也会包含一条声明，说明这个接口是一个函数式接口。</p>\n</li>\n<li><p>在java.util.function包下定义了Java 8 的丰富的函数式接口</p>\n</li>\n</ul>\n<h2 id=\"如何理解函数式接口\"><a href=\"#如何理解函数式接口\" class=\"headerlink\" title=\"如何理解函数式接口\"></a>如何理解函数式接口</h2><ul>\n<li>Java从诞生日起就是一直倡导“一切皆对象”，在Java里面面向对象(OOP)编程是一切。但是随着python、scala等语言的兴起和新技术的挑战，Java不得不做出调整以便支持更加广泛的技术要求，也即java不但可以支持OOP还可以支持OOF（面向函数编程） </li>\n<li>在函数式编程语言当中，函数被当做一等公民对待。在将函数作为一等公民的编程语言中，Lambda表达式的类型是函数。但是在Java8中，有所不同。在Java8中，Lambda表达式是对象，而不是函数，它们必须依附于一类特别的对象类型——函数式接口。 </li>\n<li>简单的说，在Java8中，Lambda表达式就是一个函数式接口的实例。这就是Lambda表达式和函数式接口的关系。也就是说，只要一个对象是函数式接口的实例，那么该对象就可以用Lambda表达式来表示。</li>\n<li>所以以前用匿名实现类表示的现在都可以用Lambda表达式来写。</li>\n</ul>\n<h2 id=\"Java内置函数式接口\"><a href=\"#Java内置函数式接口\" class=\"headerlink\" title=\"Java内置函数式接口\"></a>Java内置函数式接口</h2><p><strong>核心函数式接口</strong></p>\n<img src=\"https://npm.elemecdn.com/youthlql@1.0.8/Java_Basis/Java8_New_Features/0002.png\">\n\n\n\n<p><strong>其它函数式接口</strong></p>\n<img src=\"https://npm.elemecdn.com/youthlql@1.0.8/Java_Basis/Java8_New_Features/0003.png\">\n\n\n\n\n\n<p><strong>Consumer</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\">   <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test1</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">       happyTime(<span class=\"number\">500</span>, <span class=\"keyword\">new</span> <span class=\"title class_\">Consumer</span>&lt;Double&gt;() &#123;</span><br><span class=\"line\">           <span class=\"meta\">@Override</span></span><br><span class=\"line\">           <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">accept</span><span class=\"params\">(Double aDouble)</span> &#123;</span><br><span class=\"line\">               System.out.println(<span class=\"string\">&quot;学习太累了，去天上人间买了瓶矿泉水，价格为：&quot;</span> + aDouble);</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">       System.out.println(<span class=\"string\">&quot;********************&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">       happyTime(<span class=\"number\">400</span>,money -&gt; System.out.println(<span class=\"string\">&quot;学习太累了，去天上人间喝了口水，价格为：&quot;</span> + money));</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">happyTime</span><span class=\"params\">(<span class=\"type\">double</span> money, Consumer&lt;Double&gt; con)</span>&#123;</span><br><span class=\"line\">       con.accept(money);</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>结果：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">学习太累了，去天上人间买了瓶矿泉水，价格为：<span class=\"number\">500.0</span></span><br><span class=\"line\">********************</span><br><span class=\"line\">学习太累了，去天上人间喝了口水，价格为：<span class=\"number\">400.0</span></span><br><span class=\"line\"></span><br><span class=\"line\">Process finished with exit code <span class=\"number\">0</span></span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>Predicate</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test2</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        List&lt;String&gt; list = Arrays.asList(<span class=\"string\">&quot;北京&quot;</span>,<span class=\"string\">&quot;南京&quot;</span>,<span class=\"string\">&quot;天津&quot;</span>,<span class=\"string\">&quot;东京&quot;</span>,<span class=\"string\">&quot;西京&quot;</span>,<span class=\"string\">&quot;普京&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        List&lt;String&gt; filterStrs = filterString(list, <span class=\"keyword\">new</span> <span class=\"title class_\">Predicate</span>&lt;String&gt;() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">test</span><span class=\"params\">(String s)</span> &#123;<span class=\"comment\">//这里是定义一个校验规则</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span> s.contains(<span class=\"string\">&quot;京&quot;</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(filterStrs);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//用lambda表达式会很简单</span></span><br><span class=\"line\">        List&lt;String&gt; filterStrs1 = filterString(list,s -&gt; s.contains(<span class=\"string\">&quot;京&quot;</span>));</span><br><span class=\"line\">        System.out.println(filterStrs1);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//根据给定的规则，过滤集合中的字符串。此规则由Predicate的方法决定</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;String&gt; <span class=\"title function_\">filterString</span><span class=\"params\">(List&lt;String&gt; list, Predicate&lt;String&gt; pre)</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        ArrayList&lt;String&gt; filterList = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(String s : list)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(pre.test(s))&#123;</span><br><span class=\"line\">                filterList.add(s);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> filterList;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>结果：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[北京, 南京, 东京, 西京, 普京]</span><br><span class=\"line\">[北京, 南京, 东京, 西京, 普京]</span><br><span class=\"line\"></span><br><span class=\"line\">Process finished with exit code 0</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"自定义函数式接口\"><a href=\"#自定义函数式接口\" class=\"headerlink\" title=\"自定义函数式接口\"></a>自定义函数式接口</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 自定义函数式接口</span></span><br><span class=\"line\"><span class=\"comment\"> * 只是说加上<span class=\"doctag\">@FunctionalInterface</span>之后可以校验</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@FunctionalInterface</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">MyFunInterface</span>&lt;T&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> T <span class=\"title function_\">getValue</span><span class=\"params\">(T t)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Test</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//这个方法的第一个参数是lambda表达式，相当于是实例化了那个函数式接口</span></span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">s</span> <span class=\"operator\">=</span> toUpperString(str -&gt; str.toUpperCase(), <span class=\"string\">&quot;abcd&quot;</span>);</span><br><span class=\"line\">        System.out.println(s);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String <span class=\"title function_\">toUpperString</span><span class=\"params\">(MyFunInterface&lt;String&gt; mf,String str)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> mf.getValue(str);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"方法引用\"><a href=\"#方法引用\" class=\"headerlink\" title=\"方法引用\"></a>方法引用</h1><ul>\n<li><p>当要传递给Lambda体的操作，已经有实现的方法了，可以使用方法引用！</p>\n</li>\n<li><p>方法引用可以看做是Lambda表达式深层次的表达。换句话说，方法引用就是Lambda表达式，也就是函数式接口的一个实例，通过方法的名字来指向一个方法，可以认为是Lambda表达式的一个语法糖。</p>\n</li>\n<li><p>要求：实现接口的抽象方法的参数列表和返回值类型，必须与方法引用的方法的参数列表和返回值类型保持一致！</p>\n</li>\n<li><p>格式：使用操作符 “::” 将类(或对象) 与 方法名分隔开来。</p>\n</li>\n<li><p>如下三种主要使用情况： </p>\n<ul>\n<li><p>对象 :: 实例方法名</p>\n</li>\n<li><p>类 :: 静态方法名</p>\n</li>\n<li><p>类 :: 实例方法名</p>\n</li>\n</ul>\n</li>\n</ul>\n<p>我们直接拿例子来说明情况，先提前准备两个类：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Employee</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"type\">int</span> id;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"type\">int</span> age;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"type\">double</span> salary;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">getId</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> id;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setId</span><span class=\"params\">(<span class=\"type\">int</span> id)</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">this</span>.id = id;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> String <span class=\"title function_\">getName</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> name;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setName</span><span class=\"params\">(String name)</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">this</span>.name = name;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">getAge</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> age;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setAge</span><span class=\"params\">(<span class=\"type\">int</span> age)</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">this</span>.age = age;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"type\">double</span> <span class=\"title function_\">getSalary</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> salary;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setSalary</span><span class=\"params\">(<span class=\"type\">double</span> salary)</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">this</span>.salary = salary;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"title function_\">Employee</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;Employee().....&quot;</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"title function_\">Employee</span><span class=\"params\">(<span class=\"type\">int</span> id)</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">this</span>.id = id;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;Employee(int id).....&quot;</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"title function_\">Employee</span><span class=\"params\">(<span class=\"type\">int</span> id, String name)</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">this</span>.id = id;</span><br><span class=\"line\">\t\t<span class=\"built_in\">this</span>.name = name;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"title function_\">Employee</span><span class=\"params\">(<span class=\"type\">int</span> id, String name, <span class=\"type\">int</span> age, <span class=\"type\">double</span> salary)</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"built_in\">this</span>.id = id;</span><br><span class=\"line\">\t\t<span class=\"built_in\">this</span>.name = name;</span><br><span class=\"line\">\t\t<span class=\"built_in\">this</span>.age = age;</span><br><span class=\"line\">\t\t<span class=\"built_in\">this</span>.salary = salary;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> String <span class=\"title function_\">toString</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"string\">&quot;Employee&#123;&quot;</span> + <span class=\"string\">&quot;id=&quot;</span> + id + <span class=\"string\">&quot;, name=&#x27;&quot;</span> + name + <span class=\"string\">&#x27;\\&#x27;&#x27;</span> + <span class=\"string\">&quot;, age=&quot;</span> + age + <span class=\"string\">&quot;, salary=&quot;</span> + salary + <span class=\"string\">&#x27;&#125;&#x27;</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">equals</span><span class=\"params\">(Object o)</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (<span class=\"built_in\">this</span> == o)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (o == <span class=\"literal\">null</span> || getClass() != o.getClass())</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"type\">Employee</span> <span class=\"variable\">employee</span> <span class=\"operator\">=</span> (Employee) o;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (id != employee.id)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (age != employee.age)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (Double.compare(employee.salary, salary) != <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> name != <span class=\"literal\">null</span> ? name.equals(employee.name) : employee.name == <span class=\"literal\">null</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">hashCode</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> result;</span><br><span class=\"line\">\t\t<span class=\"type\">long</span> temp;</span><br><span class=\"line\">\t\tresult = id;</span><br><span class=\"line\">\t\tresult = <span class=\"number\">31</span> * result + (name != <span class=\"literal\">null</span> ? name.hashCode() : <span class=\"number\">0</span>);</span><br><span class=\"line\">\t\tresult = <span class=\"number\">31</span> * result + age;</span><br><span class=\"line\">\t\ttemp = Double.doubleToLongBits(salary);</span><br><span class=\"line\">\t\tresult = <span class=\"number\">31</span> * result + (<span class=\"type\">int</span>) (temp ^ (temp &gt;&gt;&gt; <span class=\"number\">32</span>));</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> result;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 提供用于测试的数据</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">EmployeeData</span> &#123;</span><br><span class=\"line\">   </span><br><span class=\"line\">   <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> List&lt;Employee&gt; <span class=\"title function_\">getEmployees</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">      List&lt;Employee&gt; list = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">      </span><br><span class=\"line\">      list.add(<span class=\"keyword\">new</span> <span class=\"title class_\">Employee</span>(<span class=\"number\">1001</span>, <span class=\"string\">&quot;马化腾&quot;</span>, <span class=\"number\">34</span>, <span class=\"number\">6000.38</span>));</span><br><span class=\"line\">      list.add(<span class=\"keyword\">new</span> <span class=\"title class_\">Employee</span>(<span class=\"number\">1002</span>, <span class=\"string\">&quot;马云&quot;</span>, <span class=\"number\">12</span>, <span class=\"number\">9876.12</span>));</span><br><span class=\"line\">      list.add(<span class=\"keyword\">new</span> <span class=\"title class_\">Employee</span>(<span class=\"number\">1003</span>, <span class=\"string\">&quot;刘强东&quot;</span>, <span class=\"number\">33</span>, <span class=\"number\">3000.82</span>));</span><br><span class=\"line\">      list.add(<span class=\"keyword\">new</span> <span class=\"title class_\">Employee</span>(<span class=\"number\">1004</span>, <span class=\"string\">&quot;雷军&quot;</span>, <span class=\"number\">26</span>, <span class=\"number\">7657.37</span>));</span><br><span class=\"line\">      list.add(<span class=\"keyword\">new</span> <span class=\"title class_\">Employee</span>(<span class=\"number\">1005</span>, <span class=\"string\">&quot;李彦宏&quot;</span>, <span class=\"number\">65</span>, <span class=\"number\">5555.32</span>));</span><br><span class=\"line\">      list.add(<span class=\"keyword\">new</span> <span class=\"title class_\">Employee</span>(<span class=\"number\">1006</span>, <span class=\"string\">&quot;比尔盖茨&quot;</span>, <span class=\"number\">42</span>, <span class=\"number\">9500.43</span>));</span><br><span class=\"line\">      list.add(<span class=\"keyword\">new</span> <span class=\"title class_\">Employee</span>(<span class=\"number\">1007</span>, <span class=\"string\">&quot;任正非&quot;</span>, <span class=\"number\">26</span>, <span class=\"number\">4333.32</span>));</span><br><span class=\"line\">      list.add(<span class=\"keyword\">new</span> <span class=\"title class_\">Employee</span>(<span class=\"number\">1008</span>, <span class=\"string\">&quot;扎克伯格&quot;</span>, <span class=\"number\">35</span>, <span class=\"number\">2500.32</span>));</span><br><span class=\"line\">      </span><br><span class=\"line\">      <span class=\"keyword\">return</span> list;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>下面来通过实际例子讲解方法引用：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 方法引用的使用</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * 1.使用情境：当要传递给Lambda体的操作，已经有实现的方法了，可以使用方法引用！</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * 2.方法引用，本质上就是Lambda表达式，而Lambda表达式作为函数式接口的实例。所以</span></span><br><span class=\"line\"><span class=\"comment\"> *   方法引用，也是函数式接口的实例。</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * 3. 使用格式：  类(或对象) :: 方法名</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * 4. 具体分为如下的三种情况：</span></span><br><span class=\"line\"><span class=\"comment\"> *    情况1     对象 :: 非静态方法</span></span><br><span class=\"line\"><span class=\"comment\"> *    情况2     类 :: 静态方法</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> *    情况3     类 :: 非静态方法</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * 5. 方法引用使用的要求：</span></span><br><span class=\"line\"><span class=\"comment\"> * \t接口中的抽象方法的形参列表和返回值类型</span></span><br><span class=\"line\"><span class=\"comment\"> * \t与</span></span><br><span class=\"line\"><span class=\"comment\"> * \t方法引用的方法的形参列表和返回值类型相同！（针对于情况1和情况2）</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">MethodRefTest</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 情况一：对象 :: 实例方法</span></span><br><span class=\"line\">\t<span class=\"comment\">//Consumer中的void accept(T t)</span></span><br><span class=\"line\">\t<span class=\"comment\">//PrintStream中的void println(T t)</span></span><br><span class=\"line\">\t<span class=\"meta\">@Test</span></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test1</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t\tConsumer&lt;String&gt; con1 = str -&gt; System.out.println(str);</span><br><span class=\"line\">\t\tcon1.accept(<span class=\"string\">&quot;北京&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;*******************&quot;</span>);</span><br><span class=\"line\">\t\t<span class=\"type\">PrintStream</span> <span class=\"variable\">ps</span> <span class=\"operator\">=</span> System.out;</span><br><span class=\"line\">\t\tConsumer&lt;String&gt; con2 = ps::println;</span><br><span class=\"line\">\t\tcon2.accept(<span class=\"string\">&quot;beijing&quot;</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">//Supplier中的T get()</span></span><br><span class=\"line\">\t<span class=\"comment\">//Employee中的String getName()</span></span><br><span class=\"line\">\t<span class=\"meta\">@Test</span></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test2</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"type\">Employee</span> <span class=\"variable\">emp</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Employee</span>(<span class=\"number\">1001</span>,<span class=\"string\">&quot;Tom&quot;</span>,<span class=\"number\">23</span>,<span class=\"number\">5600</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tSupplier&lt;String&gt; sup1 = () -&gt; emp.getName();</span><br><span class=\"line\">\t\tSystem.out.println(sup1.get());</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;*******************&quot;</span>);</span><br><span class=\"line\">\t\tSupplier&lt;String&gt; sup2 = emp::getName;</span><br><span class=\"line\">\t\tSystem.out.println(sup2.get());</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 情况二：类 :: 静态方法</span></span><br><span class=\"line\">\t<span class=\"comment\">//Comparator中的int compare(T t1,T t2)</span></span><br><span class=\"line\">\t<span class=\"comment\">//Integer中的int compare(T t1,T t2)</span></span><br><span class=\"line\">\t<span class=\"meta\">@Test</span></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test3</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t\tComparator&lt;Integer&gt; com1 = (t1,t2) -&gt; Integer.compare(t1,t2);</span><br><span class=\"line\">\t\tSystem.out.println(com1.compare(<span class=\"number\">12</span>,<span class=\"number\">21</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;*******************&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tComparator&lt;Integer&gt; com2 = Integer::compare;</span><br><span class=\"line\">\t\tSystem.out.println(com2.compare(<span class=\"number\">12</span>,<span class=\"number\">3</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">//Function中的R apply(T t)</span></span><br><span class=\"line\">\t<span class=\"comment\">//Math中的Long round(Double d)</span></span><br><span class=\"line\">\t<span class=\"meta\">@Test</span></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test4</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t\tFunction&lt;Double,Long&gt; func = <span class=\"keyword\">new</span> <span class=\"title class_\">Function</span>&lt;Double, Long&gt;() &#123;</span><br><span class=\"line\">\t\t\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">public</span> Long <span class=\"title function_\">apply</span><span class=\"params\">(Double d)</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> Math.round(d);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;*******************&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tFunction&lt;Double,Long&gt; func1 = d -&gt; Math.round(d);</span><br><span class=\"line\">\t\tSystem.out.println(func1.apply(<span class=\"number\">12.3</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;*******************&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tFunction&lt;Double,Long&gt; func2 = Math::round;</span><br><span class=\"line\">\t\tSystem.out.println(func2.apply(<span class=\"number\">12.6</span>));</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 情况三：类 :: 实例方法  (有难度)</span></span><br><span class=\"line\">\t<span class=\"comment\">// Comparator中的int comapre(T t1,T t2)  第一个参数T t1,也可以变成方法的调用者</span></span><br><span class=\"line\">\t<span class=\"comment\">// String中的int t1.compareTo(t2)        看上面说的，t1变成了调用者等价于第一个参数T t1</span></span><br><span class=\"line\">\t<span class=\"meta\">@Test</span></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test5</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t\tComparator&lt;String&gt; com1 = (s1,s2) -&gt; s1.compareTo(s2);</span><br><span class=\"line\">\t\tSystem.out.println(com1.compare(<span class=\"string\">&quot;abc&quot;</span>,<span class=\"string\">&quot;abd&quot;</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;*******************&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tComparator&lt;String&gt; com2 = String :: compareTo;</span><br><span class=\"line\">\t\tSystem.out.println(com2.compare(<span class=\"string\">&quot;abd&quot;</span>,<span class=\"string\">&quot;abm&quot;</span>));</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//BiPredicate中的boolean test(T t1, T t2);</span></span><br><span class=\"line\">\t<span class=\"comment\">//String中的boolean t1.equals(t2)</span></span><br><span class=\"line\">\t<span class=\"meta\">@Test</span></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test6</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t\tBiPredicate&lt;String,String&gt; pre1 = (s1,s2) -&gt; s1.equals(s2);</span><br><span class=\"line\">\t\tSystem.out.println(pre1.test(<span class=\"string\">&quot;abc&quot;</span>,<span class=\"string\">&quot;abc&quot;</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;*******************&quot;</span>);</span><br><span class=\"line\">\t\tBiPredicate&lt;String,String&gt; pre2 = String :: equals;</span><br><span class=\"line\">\t\tSystem.out.println(pre2.test(<span class=\"string\">&quot;abc&quot;</span>,<span class=\"string\">&quot;abd&quot;</span>));</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">// Function中的R apply(T t)</span></span><br><span class=\"line\">\t<span class=\"comment\">// Employee中的String getName();   第一个参数T t相当于方法调用者emp，返回值R和String对应</span></span><br><span class=\"line\">\t<span class=\"meta\">@Test</span></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test7</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"type\">Employee</span> <span class=\"variable\">employee</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Employee</span>(<span class=\"number\">1001</span>, <span class=\"string\">&quot;Jerry&quot;</span>, <span class=\"number\">23</span>, <span class=\"number\">6000</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">\t\tFunction&lt;Employee,String&gt; func1 = e -&gt; e.getName();</span><br><span class=\"line\">\t\tSystem.out.println(func1.apply(employee));</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;*******************&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">\t\tFunction&lt;Employee,String&gt; func2 = Employee::getName;</span><br><span class=\"line\">\t\tSystem.out.println(func2.apply(employee));</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h1 id=\"构造器引用\"><a href=\"#构造器引用\" class=\"headerlink\" title=\"构造器引用\"></a>构造器引用</h1><p>格式：ClassName :: new</p>\n<p>与函数式接口相结合，自动与函数式接口中方法兼容。可以把构造器引用赋值给定义的方法，要求构造器参数列表要与接口中抽象方法的参数列表一致！且方法的返回值即为构造器对应类的对象。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.junit.Test;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Arrays;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.function.BiFunction;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.function.Function;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.function.Supplier;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 一、构造器引用</span></span><br><span class=\"line\"><span class=\"comment\"> *      和方法引用类似，函数式接口的抽象方法的形参列表和构造器的形参列表一致。</span></span><br><span class=\"line\"><span class=\"comment\"> *      抽象方法的返回值类型即为构造器所属的类的类型</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * 二、数组引用</span></span><br><span class=\"line\"><span class=\"comment\"> *     大家可以把数组看做是一个特殊的类，则写法与构造器引用一致。</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ConstructorRefTest</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 构造器引用</span></span><br><span class=\"line\"><span class=\"comment\">     * Supplier中的T get()</span></span><br><span class=\"line\"><span class=\"comment\">     * Employee的空参构造器：Employee()</span></span><br><span class=\"line\"><span class=\"comment\">     * 1、和方法引用一样的理解方法，你的get()方法没有参数，我的Employee()也没有参数。</span></span><br><span class=\"line\"><span class=\"comment\">     * 2、你的get()方法有返回值T，我的Employee()方法返回值也是一个对象</span></span><br><span class=\"line\"><span class=\"comment\">     * 3、所以刚好可以用  </span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test1</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        Supplier&lt;Employee&gt; sup = <span class=\"keyword\">new</span> <span class=\"title class_\">Supplier</span>&lt;Employee&gt;() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"keyword\">public</span> Employee <span class=\"title function_\">get</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Employee</span>();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;*******************&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        Supplier&lt;Employee&gt;  sup1 = () -&gt; <span class=\"keyword\">new</span> <span class=\"title class_\">Employee</span>();</span><br><span class=\"line\">        System.out.println(sup1.get());</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;*******************&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        Supplier&lt;Employee&gt;  sup2 = Employee :: <span class=\"keyword\">new</span>;</span><br><span class=\"line\">        System.out.println(sup2.get());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//Function中的R apply(T t)</span></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test2</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        Function&lt;Integer,Employee&gt; func1 = id -&gt; <span class=\"keyword\">new</span> <span class=\"title class_\">Employee</span>(id);</span><br><span class=\"line\">        <span class=\"type\">Employee</span> <span class=\"variable\">employee</span> <span class=\"operator\">=</span> func1.apply(<span class=\"number\">1001</span>);</span><br><span class=\"line\">        System.out.println(employee);</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;*******************&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        Function&lt;Integer,Employee&gt; func2 = Employee :: <span class=\"keyword\">new</span>;</span><br><span class=\"line\">        <span class=\"type\">Employee</span> <span class=\"variable\">employee1</span> <span class=\"operator\">=</span> func2.apply(<span class=\"number\">1002</span>);</span><br><span class=\"line\">        System.out.println(employee1);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//BiFunction中的R apply(T t,U u)</span></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test3</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        BiFunction&lt;Integer,String,Employee&gt; func1 = (id,name) -&gt; <span class=\"keyword\">new</span> <span class=\"title class_\">Employee</span>(id,name);</span><br><span class=\"line\">        System.out.println(func1.apply(<span class=\"number\">1001</span>,<span class=\"string\">&quot;Tom&quot;</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;*******************&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        BiFunction&lt;Integer,String,Employee&gt; func2 = Employee :: <span class=\"keyword\">new</span>;</span><br><span class=\"line\">        System.out.println(func2.apply(<span class=\"number\">1002</span>,<span class=\"string\">&quot;Tom&quot;</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//数组引用</span></span><br><span class=\"line\">    <span class=\"comment\">//Function中的R apply(T t)</span></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test4</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        Function&lt;Integer,String[]&gt; func1 = length -&gt; <span class=\"keyword\">new</span> <span class=\"title class_\">String</span>[length];</span><br><span class=\"line\">        String[] arr1 = func1.apply(<span class=\"number\">5</span>);</span><br><span class=\"line\">        System.out.println(Arrays.toString(arr1));</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;*******************&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        Function&lt;Integer,String[]&gt; func2 = String[] :: <span class=\"keyword\">new</span>;</span><br><span class=\"line\">        String[] arr2 = func2.apply(<span class=\"number\">10</span>);</span><br><span class=\"line\">        System.out.println(Arrays.toString(arr2));</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"强大的Stream-API\"><a href=\"#强大的Stream-API\" class=\"headerlink\" title=\"强大的Stream API\"></a>强大的Stream API</h1><h2 id=\"Stream-API说明\"><a href=\"#Stream-API说明\" class=\"headerlink\" title=\"Stream API说明\"></a>Stream API说明</h2><ul>\n<li><p>Java8中有两大最为重要的改变。第一个是 <strong>Lambda</strong> <strong>表达式</strong>；另外一个则是 <strong>Stream API</strong>。 </p>\n</li>\n<li><p>Stream API ( java.util.stream) 把真正的函数式编程风格引入到Java中。这是目前为止对Java类库最好的补充，因为Stream API可以极大提供Java程序员的生产力，让程序员写出高效率、干净、简洁的代码。</p>\n</li>\n<li><p>Stream 是 Java8 中处理集合的关键抽象概念，它可以指定你希望对集合进行的操作，可以执行非常复杂的查找、过滤和映射数据等操作。 <strong>使用Stream API 对集合数据进行操作，就类似于使用 SQL 执行的数据库查询。</strong>也可以使用 Stream API 来并行执行操作。简言之，Stream API 提供了一种高效且易于使用的处理数据的方式</p>\n</li>\n</ul>\n<h2 id=\"为什么要使用Stream-API\"><a href=\"#为什么要使用Stream-API\" class=\"headerlink\" title=\"为什么要使用Stream API\"></a>为什么要使用Stream API</h2><ul>\n<li><p>实际开发中，项目中多数数据源都来自于Mysql，Oracle等，很多一些复杂的数据获取可以直接在sql层面去解决。但现在数据源可以更多了，有MongDB，Radis等，而这些NoSQL的数据本身不支持一些复杂的数据计算，这个时候就需要Java层面去处理。 </p>\n</li>\n<li><p>Stream 和 Collection 集合的区别：Collection 是一种静态的内存数据结构，而 Stream 是有关计算的。前者是主要面向内存，存储在内存中，后者主要是面向 CPU，通过 CPU 实现计算。</p>\n</li>\n</ul>\n<h2 id=\"什么是Stream\"><a href=\"#什么是Stream\" class=\"headerlink\" title=\"什么是Stream\"></a>什么是Stream</h2><p>Stream到底是什么呢？</p>\n<p>是数据渠道，用于操作数据源（集合、数组等）所生成的元素序列。</p>\n<p><strong>“集合讲的是数据，Stream讲的是计算！”</strong></p>\n<p><strong>注意：</strong></p>\n<p>①Stream 自己不会存储元素。</p>\n<p>②Stream 不会改变源对象。相反，他们会返回一个持有结果的新Stream。 </p>\n<p>③Stream 操作是延迟执行的。这意味着他们会等到需要结果的时候才执行</p>\n<p><strong>Stream</strong> <strong>的操作三个步骤</strong></p>\n<p>1、创建Stream</p>\n<p>一个数据源（如：集合、数组），获取一个流</p>\n<p>2、中间操作</p>\n<p>一个中间操作链，对数据源的数据进行处理</p>\n<p>3、终止操作(终端操作) </p>\n<p>一旦执行终止操作，就执行中间操作链，才产生结果【也就是所谓的延迟执行】。之后，不会再被使用</p>\n<img src=\"https://npm.elemecdn.com/youthlql@1.0.8/Java_Basis/Java8_New_Features/0004.png\">\n\n\n\n\n\n<h2 id=\"创建Stream\"><a href=\"#创建Stream\" class=\"headerlink\" title=\"创建Stream\"></a>创建Stream</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">StreamAPITest</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//创建 Stream方式一：通过集合</span></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test1</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        List&lt;Employee&gt; employees = EmployeeData.getEmployees();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//        default Stream&lt;E&gt; stream() : 返回一个顺序流，顺序流等会中间操作拿数据的时候按顺序拿</span></span><br><span class=\"line\">        Stream&lt;Employee&gt; stream = employees.stream();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//        default Stream&lt;E&gt; parallelStream() : 返回一个并行流</span></span><br><span class=\"line\">        Stream&lt;Employee&gt; parallelStream = employees.parallelStream();</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//创建 Stream方式二：通过数组</span></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test2</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span>[] arr = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[]&#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>&#125;;</span><br><span class=\"line\">        <span class=\"comment\">//调用Arrays类的static &lt;T&gt; Stream&lt;T&gt; stream(T[] array): 返回一个流</span></span><br><span class=\"line\">        <span class=\"type\">IntStream</span> <span class=\"variable\">stream</span> <span class=\"operator\">=</span> Arrays.stream(arr);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">Employee</span> <span class=\"variable\">e1</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Employee</span>(<span class=\"number\">1001</span>,<span class=\"string\">&quot;Tom&quot;</span>);</span><br><span class=\"line\">        <span class=\"type\">Employee</span> <span class=\"variable\">e2</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Employee</span>(<span class=\"number\">1002</span>,<span class=\"string\">&quot;Jerry&quot;</span>);</span><br><span class=\"line\">        Employee[] arr1 = <span class=\"keyword\">new</span> <span class=\"title class_\">Employee</span>[]&#123;e1,e2&#125;;</span><br><span class=\"line\">        Stream&lt;Employee&gt; stream1 = Arrays.stream(arr1);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//创建 Stream方式三：通过Stream的of()，通过显示值创建一个流。它可以接收任意数量的参数</span></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test3</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        Stream&lt;Integer&gt; stream = Stream.of(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//创建 Stream方式四：创建无限流【用的少，了解下就行】</span></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test4</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//      迭代</span></span><br><span class=\"line\"><span class=\"comment\">//      public static&lt;T&gt; Stream&lt;T&gt; iterate(final T seed, final UnaryOperator&lt;T&gt; f)</span></span><br><span class=\"line\">        <span class=\"comment\">//遍历前10个偶数</span></span><br><span class=\"line\">        Stream.iterate(<span class=\"number\">0</span>, t -&gt; t + <span class=\"number\">2</span>).limit(<span class=\"number\">10</span>).forEach(System.out::println);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//      生成</span></span><br><span class=\"line\"><span class=\"comment\">//      public static&lt;T&gt; Stream&lt;T&gt; generate(Supplier&lt;T&gt; s)</span></span><br><span class=\"line\">        Stream.generate(Math::random).limit(<span class=\"number\">10</span>).forEach(System.out::println);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h2 id=\"中间操作\"><a href=\"#中间操作\" class=\"headerlink\" title=\"中间操作\"></a>中间操作</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 测试Stream的中间操作</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">StreamAPITest1</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//1-筛选与切片</span></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test1</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        List&lt;Employee&gt; list = EmployeeData.getEmployees();</span><br><span class=\"line\"><span class=\"comment\">//        filter(Predicate p)——过滤   接收 Lambda ， 从流中排除某些元素。</span></span><br><span class=\"line\">        Stream&lt;Employee&gt; stream = list.stream();</span><br><span class=\"line\">        <span class=\"comment\">//练习：查询员工表中薪资大于7000的员工信息</span></span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">         * List&lt;String&gt; filterStrs1 = filterString(list,s -&gt; s.contains(&quot;京&quot;));</span></span><br><span class=\"line\"><span class=\"comment\">         * 跟之前的这个lambda表达式代码是一个意思</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        stream.filter(e -&gt; e.getSalary() &gt; <span class=\"number\">7000</span>).forEach(System.out::println);</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println();</span><br><span class=\"line\"><span class=\"comment\">//        limit(n)——截断流，使其元素不超过给定数量。</span></span><br><span class=\"line\">        list.stream().limit(<span class=\"number\">3</span>).forEach(System.out::println);</span><br><span class=\"line\">        System.out.println();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">        skip(n) —— 跳过元素，返回一个扔掉了前 n 个元素的流。若流中元素不足 n 个，</span></span><br><span class=\"line\"><span class=\"comment\">        则返回一个空流。与 limit(n) 互补</span></span><br><span class=\"line\"><span class=\"comment\">        */</span></span><br><span class=\"line\">        list.stream().skip(<span class=\"number\">3</span>).forEach(System.out::println);</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println();</span><br><span class=\"line\"><span class=\"comment\">//        distinct()——筛选，通过流所生成元素的 hashCode() 和 equals() 去除重复元素</span></span><br><span class=\"line\"></span><br><span class=\"line\">        list.add(<span class=\"keyword\">new</span> <span class=\"title class_\">Employee</span>(<span class=\"number\">1010</span>,<span class=\"string\">&quot;刘强东&quot;</span>,<span class=\"number\">40</span>,<span class=\"number\">8000</span>));</span><br><span class=\"line\">        list.add(<span class=\"keyword\">new</span> <span class=\"title class_\">Employee</span>(<span class=\"number\">1010</span>,<span class=\"string\">&quot;刘强东&quot;</span>,<span class=\"number\">41</span>,<span class=\"number\">8000</span>));</span><br><span class=\"line\">        list.add(<span class=\"keyword\">new</span> <span class=\"title class_\">Employee</span>(<span class=\"number\">1010</span>,<span class=\"string\">&quot;刘强东&quot;</span>,<span class=\"number\">40</span>,<span class=\"number\">8000</span>));</span><br><span class=\"line\">        list.add(<span class=\"keyword\">new</span> <span class=\"title class_\">Employee</span>(<span class=\"number\">1010</span>,<span class=\"string\">&quot;刘强东&quot;</span>,<span class=\"number\">40</span>,<span class=\"number\">8000</span>));</span><br><span class=\"line\">        list.add(<span class=\"keyword\">new</span> <span class=\"title class_\">Employee</span>(<span class=\"number\">1010</span>,<span class=\"string\">&quot;刘强东&quot;</span>,<span class=\"number\">40</span>,<span class=\"number\">8000</span>));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//        System.out.println(list);</span></span><br><span class=\"line\"></span><br><span class=\"line\">        list.stream().distinct().forEach(System.out::println);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//映射</span></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test2</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">        map(Function f)——接收一个函数作为参数，将元素转换成其他形式或提取信息，该函数会被应</span></span><br><span class=\"line\"><span class=\"comment\">        用到每个元素上，并将其映射成一个新的元素。</span></span><br><span class=\"line\"><span class=\"comment\">        */</span></span><br><span class=\"line\">        List&lt;String&gt; list = Arrays.asList(<span class=\"string\">&quot;aa&quot;</span>, <span class=\"string\">&quot;bb&quot;</span>, <span class=\"string\">&quot;cc&quot;</span>, <span class=\"string\">&quot;dd&quot;</span>);</span><br><span class=\"line\">        list.stream().map(str -&gt; str.toUpperCase()).forEach(System.out::println);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//        练习1：获取员工姓名长度大于3的员工的姓名。</span></span><br><span class=\"line\">        List&lt;Employee&gt; employees = EmployeeData.getEmployees();</span><br><span class=\"line\">        Stream&lt;String&gt; namesStream = employees.stream().map(Employee::getName);</span><br><span class=\"line\">        namesStream.filter(name -&gt; name.length() &gt; <span class=\"number\">3</span>).forEach(System.out::println);</span><br><span class=\"line\">        System.out.println();</span><br><span class=\"line\">        <span class=\"comment\">//练习2：</span></span><br><span class=\"line\">        Stream&lt;Stream&lt;Character&gt;&gt; streamStream = list.stream().map(StreamAPITest1::fromStringToStream);</span><br><span class=\"line\">        <span class=\"comment\">//这个还需要两层遍历</span></span><br><span class=\"line\">        streamStream.forEach(s -&gt;&#123;</span><br><span class=\"line\">            s.forEach(System.out::println);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        System.out.println();</span><br><span class=\"line\">        <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">        flatMap(Function f)——接收一个函数作为参数，将流中的每个值都换成另一个流，然后把所有流连</span></span><br><span class=\"line\"><span class=\"comment\">        接成一个流。flatMap一层遍历即可拿到想要的结果</span></span><br><span class=\"line\"><span class=\"comment\">        */</span></span><br><span class=\"line\">        Stream&lt;Character&gt; characterStream = list.stream().flatMap(StreamAPITest1::fromStringToStream);</span><br><span class=\"line\">        characterStream.forEach(System.out::println);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//将字符串中的多个字符构成的集合转换为对应的Stream的实例</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Stream&lt;Character&gt; <span class=\"title function_\">fromStringToStream</span><span class=\"params\">(String str)</span>&#123;<span class=\"comment\">//aa</span></span><br><span class=\"line\">        ArrayList&lt;Character&gt; list = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(Character c : str.toCharArray())&#123;</span><br><span class=\"line\">            list.add(c);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> list.stream();</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//3-排序</span></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test4</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\"><span class=\"comment\">//        sorted()——自然排序</span></span><br><span class=\"line\">        List&lt;Integer&gt; list = Arrays.asList(<span class=\"number\">12</span>, <span class=\"number\">43</span>, <span class=\"number\">65</span>, <span class=\"number\">34</span>, <span class=\"number\">87</span>, <span class=\"number\">0</span>, -<span class=\"number\">98</span>, <span class=\"number\">7</span>);</span><br><span class=\"line\">        list.stream().sorted().forEach(System.out::println);</span><br><span class=\"line\">        <span class=\"comment\">//抛异常，原因:Employee没有实现Comparable接口</span></span><br><span class=\"line\"><span class=\"comment\">//        List&lt;Employee&gt; employees = EmployeeData.getEmployees();</span></span><br><span class=\"line\"><span class=\"comment\">//        employees.stream().sorted().forEach(System.out::println);</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//        sorted(Comparator com)——定制排序</span></span><br><span class=\"line\"></span><br><span class=\"line\">        List&lt;Employee&gt; employees = EmployeeData.getEmployees();</span><br><span class=\"line\">        employees.stream().sorted( (e1,e2) -&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">           <span class=\"type\">int</span> <span class=\"variable\">ageValue</span> <span class=\"operator\">=</span> Integer.compare(e1.getAge(),e2.getAge());</span><br><span class=\"line\">           <span class=\"keyword\">if</span>(ageValue != <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">               <span class=\"keyword\">return</span> ageValue;</span><br><span class=\"line\">           &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">               <span class=\"keyword\">return</span> -Double.compare(e1.getSalary(),e2.getSalary());</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;).forEach(System.out::println);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"终止操作\"><a href=\"#终止操作\" class=\"headerlink\" title=\"终止操作\"></a>终止操作</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 测试Stream的终止操作</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">StreamAPITest2</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//1-匹配与查找</span></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test1</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        List&lt;Employee&gt; employees = EmployeeData.getEmployees();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//        allMatch(Predicate p)——检查是否匹配所有元素。</span></span><br><span class=\"line\"><span class=\"comment\">//          练习：是否所有的员工的年龄都大于18</span></span><br><span class=\"line\">        <span class=\"type\">boolean</span> <span class=\"variable\">allMatch</span> <span class=\"operator\">=</span> employees.stream().allMatch(e -&gt; e.getAge() &gt; <span class=\"number\">18</span>);</span><br><span class=\"line\">        System.out.println(allMatch);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//        anyMatch(Predicate p)——检查是否至少匹配一个元素。</span></span><br><span class=\"line\"><span class=\"comment\">//         练习：是否存在员工的工资大于 10000</span></span><br><span class=\"line\">        <span class=\"type\">boolean</span> <span class=\"variable\">anyMatch</span> <span class=\"operator\">=</span> employees.stream().anyMatch(e -&gt; e.getSalary() &gt; <span class=\"number\">10000</span>);</span><br><span class=\"line\">        System.out.println(anyMatch);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//        noneMatch(Predicate p)——检查是否没有匹配的元素。</span></span><br><span class=\"line\"><span class=\"comment\">//          练习：是否存在员工姓“雷”</span></span><br><span class=\"line\">        <span class=\"type\">boolean</span> <span class=\"variable\">noneMatch</span> <span class=\"operator\">=</span> employees.stream().noneMatch(e -&gt; e.getName().startsWith(<span class=\"string\">&quot;雷&quot;</span>));</span><br><span class=\"line\">        System.out.println(noneMatch);</span><br><span class=\"line\"><span class=\"comment\">//        findFirst——返回第一个元素</span></span><br><span class=\"line\">        Optional&lt;Employee&gt; employee = employees.stream().findFirst();</span><br><span class=\"line\">        System.out.println(employee);</span><br><span class=\"line\"><span class=\"comment\">//        findAny——返回当前流中的任意元素</span></span><br><span class=\"line\">        Optional&lt;Employee&gt; employee1 = employees.parallelStream().findAny();</span><br><span class=\"line\">        System.out.println(employee1);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test2</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        List&lt;Employee&gt; employees = EmployeeData.getEmployees();</span><br><span class=\"line\">        <span class=\"comment\">// count——返回流中元素的总个数</span></span><br><span class=\"line\">        <span class=\"type\">long</span> <span class=\"variable\">count</span> <span class=\"operator\">=</span> employees.stream().filter(e -&gt; e.getSalary() &gt; <span class=\"number\">5000</span>).count();</span><br><span class=\"line\">        System.out.println(count);</span><br><span class=\"line\"><span class=\"comment\">//        max(Comparator c)——返回流中最大值</span></span><br><span class=\"line\"><span class=\"comment\">//        练习：返回最高的工资：</span></span><br><span class=\"line\">        Stream&lt;Double&gt; salaryStream = employees.stream().map(e -&gt; e.getSalary());</span><br><span class=\"line\">        Optional&lt;Double&gt; maxSalary = salaryStream.max(Double::compare);</span><br><span class=\"line\">        System.out.println(maxSalary);</span><br><span class=\"line\"><span class=\"comment\">//        min(Comparator c)——返回流中最小值</span></span><br><span class=\"line\"><span class=\"comment\">//        练习：返回最低工资的员工</span></span><br><span class=\"line\">        Optional&lt;Employee&gt; employee = employees.stream().min((e1, e2) -&gt; Double.compare(e1.getSalary(), e2.getSalary()));</span><br><span class=\"line\">        System.out.println(employee);</span><br><span class=\"line\">        System.out.println();</span><br><span class=\"line\"><span class=\"comment\">//        forEach(Consumer c)——内部迭代</span></span><br><span class=\"line\">        employees.stream().forEach(System.out::println);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//使用集合的遍历操作</span></span><br><span class=\"line\">        employees.forEach(System.out::println);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//2-归约</span></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test3</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\"><span class=\"comment\">//        reduce(T identity, BinaryOperator)——可以将流中元素反复结合起来，得到一个值。返回 T</span></span><br><span class=\"line\"><span class=\"comment\">//        练习1：计算1-10的自然数的和</span></span><br><span class=\"line\">        List&lt;Integer&gt; list = Arrays.asList(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">7</span>,<span class=\"number\">8</span>,<span class=\"number\">9</span>,<span class=\"number\">10</span>);</span><br><span class=\"line\">        <span class=\"type\">Integer</span> <span class=\"variable\">sum</span> <span class=\"operator\">=</span> list.stream().reduce(<span class=\"number\">0</span>, Integer::sum);</span><br><span class=\"line\">        System.out.println(sum);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//        reduce(BinaryOperator) ——可以将流中元素反复结合起来，得到一个值。返回 Optional&lt;T&gt;</span></span><br><span class=\"line\"><span class=\"comment\">//        练习2：计算公司所有员工工资的总和</span></span><br><span class=\"line\">        List&lt;Employee&gt; employees = EmployeeData.getEmployees();</span><br><span class=\"line\">        Stream&lt;Double&gt; salaryStream = employees.stream().map(Employee::getSalary);</span><br><span class=\"line\"><span class=\"comment\">//        Optional&lt;Double&gt; sumMoney = salaryStream.reduce(Double::sum);</span></span><br><span class=\"line\">        Optional&lt;Double&gt; sumMoney = salaryStream.reduce((d1,d2) -&gt; d1 + d2);</span><br><span class=\"line\">        System.out.println(sumMoney.get());</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//3-收集</span></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test4</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\"><span class=\"comment\">// collect(Collector c)——将流转换为其他形式。接收一个 Collector接口的实现，用于给Stream中元素做汇总的方法</span></span><br><span class=\"line\"><span class=\"comment\">//        练习1：查找工资大于6000的员工，结果返回为一个List或Set</span></span><br><span class=\"line\"></span><br><span class=\"line\">        List&lt;Employee&gt; employees = EmployeeData.getEmployees();</span><br><span class=\"line\">        List&lt;Employee&gt; employeeList = employees.stream().filter(e -&gt; e.getSalary() &gt; <span class=\"number\">6000</span>).collect(Collectors.toList());</span><br><span class=\"line\"></span><br><span class=\"line\">        employeeList.forEach(System.out::println);</span><br><span class=\"line\">        System.out.println();</span><br><span class=\"line\">        Set&lt;Employee&gt; employeeSet = employees.stream().filter(e -&gt; e.getSalary() &gt; <span class=\"number\">6000</span>).collect(Collectors.toSet());</span><br><span class=\"line\"></span><br><span class=\"line\">        employeeSet.forEach(System.out::println);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"Optional类\"><a href=\"#Optional类\" class=\"headerlink\" title=\"Optional类\"></a>Optional类</h1><h2 id=\"什么是Optional？\"><a href=\"#什么是Optional？\" class=\"headerlink\" title=\"什么是Optional？\"></a>什么是Optional？</h2><ul>\n<li><p>到目前为止，臭名昭著的空指针异常是导致Java应用程序失败的最常见原因。以前，为了解决空指针异常，Google公司著名的Guava项目引入了Optional类，Guava通过使用检查空值的方式来防止代码污染，它鼓励程序员写更干净的代码。受到Google Guava的启发，Optional类已经成为Java 8类库的一部分。</p>\n</li>\n<li><p>Optional<T> 类(java.util.Optional) 是一个容器类，它可以保存类型T的值，代表这个值存在。或者仅仅保存null，表示这个值不存在。原来用 null 表示一个值不存在，现在 Optional 可以更好的表达这个概念。并且可以避免空指针异常。 </p>\n</li>\n<li><p>Optional类的Javadoc描述如下：这是一个可以为null的容器对象。如果值存在则isPresent()方法会返回true，调用get()方法会返回该对象。</p>\n</li>\n</ul>\n<h2 id=\"常用API\"><a href=\"#常用API\" class=\"headerlink\" title=\"常用API\"></a>常用API</h2><img src=\"https://npm.elemecdn.com/youthlql@1.0.8/Java_Basis/Java8_New_Features/0005.png\">\n\n\n\n\n\n<h2 id=\"举例\"><a href=\"#举例\" class=\"headerlink\" title=\"举例\"></a>举例</h2><p>首先准备两个类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Boy</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Girl girl;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">toString</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;Boy&#123;&quot;</span> +</span><br><span class=\"line\">                <span class=\"string\">&quot;girl=&quot;</span> + girl +</span><br><span class=\"line\">                <span class=\"string\">&#x27;&#125;&#x27;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Girl <span class=\"title function_\">getGirl</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> girl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setGirl</span><span class=\"params\">(Girl girl)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.girl = girl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">Boy</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">Boy</span><span class=\"params\">(Girl girl)</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">this</span>.girl = girl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Girl</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">toString</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;Girl&#123;&quot;</span> +</span><br><span class=\"line\">                <span class=\"string\">&quot;name=&#x27;&quot;</span> + name + <span class=\"string\">&#x27;\\&#x27;&#x27;</span> +</span><br><span class=\"line\">                <span class=\"string\">&#x27;&#125;&#x27;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">getName</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setName</span><span class=\"params\">(String name)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.name = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">Girl</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">Girl</span><span class=\"params\">(String name)</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">this</span>.name = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>这里只是简单的测试两个API</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Optional类：为了在程序中避免出现空指针异常而创建的。</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * 常用的方法：ofNullable(T t)</span></span><br><span class=\"line\"><span class=\"comment\"> *            orElse(T t)</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">OptionalTest</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">Optional.of(T t) : 创建一个 Optional 实例，t必须非空；</span></span><br><span class=\"line\"><span class=\"comment\">Optional.empty() : 创建一个空的 Optional 实例</span></span><br><span class=\"line\"><span class=\"comment\">Optional.ofNullable(T t)：t可以为null</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test1</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        <span class=\"type\">Girl</span> <span class=\"variable\">girl</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Girl</span>();</span><br><span class=\"line\"><span class=\"comment\">//        girl = null;</span></span><br><span class=\"line\">        <span class=\"comment\">//of(T t):保证t是非空的</span></span><br><span class=\"line\">        Optional&lt;Girl&gt; optionalGirl = Optional.of(girl);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test2</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        <span class=\"type\">Girl</span> <span class=\"variable\">girl</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Girl</span>();</span><br><span class=\"line\"><span class=\"comment\">//        girl = null;</span></span><br><span class=\"line\">        <span class=\"comment\">//ofNullable(T t)：t可以为null</span></span><br><span class=\"line\">        Optional&lt;Girl&gt; optionalGirl = Optional.ofNullable(girl);</span><br><span class=\"line\">        System.out.println(optionalGirl);</span><br><span class=\"line\">        <span class=\"comment\">//orElse(T t1):如果单前的Optional内部封装的t是非空的，则返回内部的t.</span></span><br><span class=\"line\">        <span class=\"comment\">//如果内部的t是空的，则返回orElse()方法中的参数t1.</span></span><br><span class=\"line\">        <span class=\"type\">Girl</span> <span class=\"variable\">girl1</span> <span class=\"operator\">=</span> optionalGirl.orElse(<span class=\"keyword\">new</span> <span class=\"title class_\">Girl</span>(<span class=\"string\">&quot;赵丽颖&quot;</span>));</span><br><span class=\"line\">        System.out.println(girl1);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>实际场景使用</strong></p>\n<p>可能出现空指针的例子：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> String <span class=\"title function_\">getGirlName</span><span class=\"params\">(Boy boy)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> boy.getGirl().getName();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test3</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        <span class=\"type\">Boy</span> <span class=\"variable\">boy</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Boy</span>();</span><br><span class=\"line\">        boy = <span class=\"literal\">null</span>;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">girlName</span> <span class=\"operator\">=</span> getGirlName(boy);</span><br><span class=\"line\">        System.out.println(girlName);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>结果：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">java.lang.NullPointerException</span><br><span class=\"line\">\tat com.atguigu.java4.OptionalTest.getGirlName(OptionalTest.java:47)</span><br><span class=\"line\">\tat com.atguigu.java4.OptionalTest.test3(OptionalTest.java:54)</span><br><span class=\"line\">...</span><br><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\">Process finished with exit code -1</span><br></pre></td></tr></table></figure>\n\n\n\n<p>没有Optional的解决办法，但是如果调用层数过多，就得一层一层判断是否为null，写起来很麻烦。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//优化以后的getGirlName():</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">getGirlName1</span><span class=\"params\">(Boy boy)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(boy != <span class=\"literal\">null</span>)&#123;</span><br><span class=\"line\">            <span class=\"type\">Girl</span> <span class=\"variable\">girl</span> <span class=\"operator\">=</span> boy.getGirl();</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(girl != <span class=\"literal\">null</span>)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> girl.getName();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test4</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        <span class=\"type\">Boy</span> <span class=\"variable\">boy</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Boy</span>();</span><br><span class=\"line\">        boy = <span class=\"literal\">null</span>;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">girlName</span> <span class=\"operator\">=</span> getGirlName1(boy);</span><br><span class=\"line\">        System.out.println(girlName);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>使用Optional解决问题：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//使用Optional类的getGirlName():</span></span><br><span class=\"line\">   <span class=\"keyword\">public</span> String <span class=\"title function_\">getGirlName2</span><span class=\"params\">(Boy boy)</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">       Optional&lt;Boy&gt; boyOptional = Optional.ofNullable(boy);</span><br><span class=\"line\">       <span class=\"comment\">//此时的boy1一定非空</span></span><br><span class=\"line\">       <span class=\"type\">Boy</span> <span class=\"variable\">boy1</span> <span class=\"operator\">=</span> boyOptional.orElse(<span class=\"keyword\">new</span> <span class=\"title class_\">Boy</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">Girl</span>(<span class=\"string\">&quot;迪丽热巴&quot;</span>)));</span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"type\">Girl</span> <span class=\"variable\">girl</span> <span class=\"operator\">=</span> boy1.getGirl();</span><br><span class=\"line\"></span><br><span class=\"line\">       Optional&lt;Girl&gt; girlOptional = Optional.ofNullable(girl);</span><br><span class=\"line\">       <span class=\"comment\">//girl1一定非空</span></span><br><span class=\"line\">       <span class=\"type\">Girl</span> <span class=\"variable\">girl1</span> <span class=\"operator\">=</span> girlOptional.orElse(<span class=\"keyword\">new</span> <span class=\"title class_\">Girl</span>(<span class=\"string\">&quot;古力娜扎&quot;</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"keyword\">return</span> girl1.getName();</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"meta\">@Test</span></span><br><span class=\"line\">   <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test5</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">       <span class=\"type\">Boy</span> <span class=\"variable\">boy</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">       boy = <span class=\"keyword\">new</span> <span class=\"title class_\">Boy</span>();</span><br><span class=\"line\">       boy = <span class=\"keyword\">new</span> <span class=\"title class_\">Boy</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">Girl</span>(<span class=\"string\">&quot;苍老师&quot;</span>));</span><br><span class=\"line\">       <span class=\"type\">String</span> <span class=\"variable\">girlName</span> <span class=\"operator\">=</span> getGirlName2(boy);</span><br><span class=\"line\">       System.out.println(girlName);</span><br><span class=\"line\"></span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n\n<p>这种是绝对不会出现空指针的。</p>\n<h1 id=\"接口的增强\"><a href=\"#接口的增强\" class=\"headerlink\" title=\"接口的增强\"></a>接口的增强</h1><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JDK7及以前：只能定义全局常量和抽象方法</span><br><span class=\"line\">  &gt;全局常量：public static final的.但是书写时，可以省略不写</span><br><span class=\"line\">  &gt;抽象方法：public abstract的</span><br><span class=\"line\">  \t\t\t</span><br><span class=\"line\">JDK8：除了定义全局常量和抽象方法之外，还可以定义静态方法、默认方法</span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * JDK8：除了定义全局常量和抽象方法之外，还可以定义静态方法、默认方法</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">CompareA</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//静态方法</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">method1</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;CompareA:北京&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//默认方法</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">default</span> <span class=\"keyword\">void</span> <span class=\"title function_\">method2</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;CompareA：上海&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//接口中的public 可以省略，自动就是public</span></span><br><span class=\"line\">    <span class=\"keyword\">default</span> <span class=\"keyword\">void</span> <span class=\"title function_\">method3</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;CompareA：上海&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">SuperClass</span> &#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">method3</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;SuperClass:北京&quot;</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">CompareB</span> &#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">default</span> <span class=\"keyword\">void</span> <span class=\"title function_\">method3</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;CompareB：上海&quot;</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">SubClassTest</span> &#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"type\">SubClass</span> <span class=\"variable\">s</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">SubClass</span>();</span><br><span class=\"line\">\t\t</span><br><span class=\"line\"><span class=\"comment\">//\t\ts.method1();</span></span><br><span class=\"line\"><span class=\"comment\">//\t\tSubClass.method1();</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//知识点1：接口中定义的静态方法，只能通过接口来调用。实现类用不了</span></span><br><span class=\"line\">\t\tCompareA.method1();</span><br><span class=\"line\">\t\t<span class=\"comment\">//知识点2：通过实现类的对象，可以调用接口中的默认方法。</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//如果实现类重写了接口中的默认方法，调用时，仍然调用的是重写以后的方法</span></span><br><span class=\"line\">\t\ts.method2();</span><br><span class=\"line\">\t\t<span class=\"comment\">//知识点3：如果子类(或实现类)继承的父类和实现的接口中声明了同名同参数的默认方法，</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//那么子类在没有重写此方法的情况下，默认调用的是父类中的同名同参数的方法。--&gt;类优先原则</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//知识点4：如果实现类实现了多个接口，而这多个接口中定义了同名同参数的默认方法，</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//那么在实现类没有重写此方法的情况下，报错。--&gt;接口冲突。</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//这就需要我们必须在实现类中重写此方法</span></span><br><span class=\"line\">\t\ts.method3();</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">SubClass</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">SuperClass</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">CompareA</span>,CompareB&#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">method2</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;SubClass：上海&quot;</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">method3</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;SubClass：深圳&quot;</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">//知识点5：如何在子类(或实现类)的方法中调用父类、接口中被重写的方法</span></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">myMethod</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">\t\tmethod3();<span class=\"comment\">//调用自己定义的重写的方法</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">super</span>.method3();<span class=\"comment\">//调用的是父类中声明的</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//调用接口中的默认方法</span></span><br><span class=\"line\">\t\tCompareA.<span class=\"built_in\">super</span>.method3();</span><br><span class=\"line\">\t\tCompareB.<span class=\"built_in\">super</span>.method3();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"cover_type":"img","excerpt":"","more":"<h1 id=\"Java8新特性纵览\"><a href=\"#Java8新特性纵览\" class=\"headerlink\" title=\"Java8新特性纵览\"></a>Java8新特性纵览</h1><blockquote>\n<p>关于Java8新特性的学习与记录，资料来源于互联网。</p>\n</blockquote>\n<h1 id=\"Lambda表达式\"><a href=\"#Lambda表达式\" class=\"headerlink\" title=\"Lambda表达式\"></a>Lambda表达式</h1><h2 id=\"为什么使用Lambda表达式？\"><a href=\"#为什么使用Lambda表达式？\" class=\"headerlink\" title=\"为什么使用Lambda表达式？\"></a>为什么使用Lambda表达式？</h2><ul>\n<li>Lambda 是一个<strong>匿名函数</strong>，我们可以把 Lambda 表达式理解为是<strong>一段可以传递的代码</strong>（将代码像数据一样进行传递）。使用它可以写出更简洁、更灵活的代码。作为一种更紧凑的代码风格，使Java的语言表达能力得到了提升。</li>\n<li>在Java8之后的很多源码里用到了Lambda表达式，不学的话可能看不懂源码。</li>\n</ul>\n<h2 id=\"简单使用\"><a href=\"#简单使用\" class=\"headerlink\" title=\"简单使用\"></a>简单使用</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\">   <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test1</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">       <span class=\"comment\">//原始写法</span></span><br><span class=\"line\">       <span class=\"type\">Runnable</span> <span class=\"variable\">r1</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Runnable</span>() &#123;</span><br><span class=\"line\">           <span class=\"meta\">@Override</span></span><br><span class=\"line\">           <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">               System.out.println(<span class=\"string\">&quot;我爱北京天安门&quot;</span>);</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">       r1.run();</span><br><span class=\"line\"></span><br><span class=\"line\">       System.out.println(<span class=\"string\">&quot;***********************&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"comment\">//lambda表达式，可以表达一样的意思</span></span><br><span class=\"line\">       <span class=\"type\">Runnable</span> <span class=\"variable\">r2</span> <span class=\"operator\">=</span> () -&gt; System.out.println(<span class=\"string\">&quot;我爱北京故宫&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">       r2.run();</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"meta\">@Test</span></span><br><span class=\"line\">   <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test2</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">       Comparator&lt;Integer&gt; com1 = <span class=\"keyword\">new</span> <span class=\"title class_\">Comparator</span>&lt;Integer&gt;() &#123;</span><br><span class=\"line\">           <span class=\"meta\">@Override</span></span><br><span class=\"line\">           <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">compare</span><span class=\"params\">(Integer o1, Integer o2)</span> &#123;</span><br><span class=\"line\">               <span class=\"keyword\">return</span> Integer.compare(o1,o2);</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"type\">int</span> <span class=\"variable\">compare1</span> <span class=\"operator\">=</span> com1.compare(<span class=\"number\">12</span>,<span class=\"number\">21</span>);</span><br><span class=\"line\">       System.out.println(compare1);</span><br><span class=\"line\"></span><br><span class=\"line\">       System.out.println(<span class=\"string\">&quot;***********************&quot;</span>);</span><br><span class=\"line\">       </span><br><span class=\"line\">       <span class=\"comment\">//Lambda表达式的写法</span></span><br><span class=\"line\">       Comparator&lt;Integer&gt; com2 = (o1,o2) -&gt; Integer.compare(o1,o2);</span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"type\">int</span> <span class=\"variable\">compare2</span> <span class=\"operator\">=</span> com2.compare(<span class=\"number\">32</span>,<span class=\"number\">21</span>);</span><br><span class=\"line\">       System.out.println(compare2);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">       System.out.println(<span class=\"string\">&quot;***********************&quot;</span>);</span><br><span class=\"line\">       <span class=\"comment\">//方法引用</span></span><br><span class=\"line\">       Comparator&lt;Integer&gt; com3 = Integer :: compare;</span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"type\">int</span> <span class=\"variable\">compare3</span> <span class=\"operator\">=</span> com3.compare(<span class=\"number\">32</span>,<span class=\"number\">21</span>);</span><br><span class=\"line\">       System.out.println(compare3);</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"Lambda语法规则\"><a href=\"#Lambda语法规则\" class=\"headerlink\" title=\"Lambda语法规则\"></a>Lambda语法规则</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> org.junit.Test;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.ArrayList;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Comparator;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.function.Consumer;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Lambda表达式的使用</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;p&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> * 1.举例： (o1,o2) -&gt; Integer.compare(o1,o2);</span></span><br><span class=\"line\"><span class=\"comment\"> * 2.格式：</span></span><br><span class=\"line\"><span class=\"comment\"> * -&gt; :lambda操作符 或 箭头操作符</span></span><br><span class=\"line\"><span class=\"comment\"> * -&gt;左边：lambda形参列表 （其实就是接口中的抽象方法的形参列表）</span></span><br><span class=\"line\"><span class=\"comment\"> * -&gt;右边：lambda体 （其实就是重写的抽象方法的方法体）</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;p&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> * 3. Lambda表达式的使用：（分为6种情况介绍）</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;p&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> * 总结：</span></span><br><span class=\"line\"><span class=\"comment\"> * -&gt;左边：lambda形参列表的参数类型可以省略(类型推断)；如果lambda形参列表只有一个参数，其一对()也</span></span><br><span class=\"line\"><span class=\"comment\"> * 可以省略</span></span><br><span class=\"line\"><span class=\"comment\"> * -&gt;右边：lambda体应该使用一对&#123;&#125;包裹；如果lambda体只有一条执行语句（可能是return语句），省略这一</span></span><br><span class=\"line\"><span class=\"comment\"> 对&#123;&#125;和return关键字</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;p&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> * 4.Lambda表达式的本质：作为函数式接口的实例</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;p&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> * 5. 如果一个接口中，只声明了一个抽象方法，则此接口就称为函数式接口。我们可以在一个接口上</span></span><br><span class=\"line\"><span class=\"comment\"> 使用 <span class=\"doctag\">@FunctionalInterface</span> 注解，</span></span><br><span class=\"line\"><span class=\"comment\"> * 这样做可以检查它是否是一个函数式接口。</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;p&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> * 6. 所以以前用匿名实现类表示的现在都可以用Lambda表达式来写。</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">LambdaTest1</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//语法格式一：无参，无返回值</span></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test1</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Runnable</span> <span class=\"variable\">r1</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Runnable</span>() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;我爱北京天安门&quot;</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        r1.run();</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;***********************&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">Runnable</span> <span class=\"variable\">r2</span> <span class=\"operator\">=</span> () -&gt; &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;我爱北京故宫&quot;</span>);</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        r2.run();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//语法格式二：Lambda 需要一个参数，但是没有返回值。</span></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test2</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        Consumer&lt;String&gt; con = <span class=\"keyword\">new</span> <span class=\"title class_\">Consumer</span>&lt;String&gt;() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">accept</span><span class=\"params\">(String s)</span> &#123;</span><br><span class=\"line\">                System.out.println(s);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        con.accept(<span class=\"string\">&quot;谎言和誓言的区别是什么？&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;*******************&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        Consumer&lt;String&gt; con1 = (String s) -&gt; &#123;</span><br><span class=\"line\">            System.out.println(s);</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        con1.accept(<span class=\"string\">&quot;一个是听得人当真了，一个是说的人当真了&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//语法格式三：数据类型可以省略，因为可由编译器推断得出，称为“类型推断”</span></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test3</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        Consumer&lt;String&gt; con1 = (String s) -&gt; &#123;</span><br><span class=\"line\">            System.out.println(s);</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        con1.accept(<span class=\"string\">&quot;一个是听得人当真了，一个是说的人当真了&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;*******************&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        Consumer&lt;String&gt; con2 = (s) -&gt; &#123;</span><br><span class=\"line\">            System.out.println(s);</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        con2.accept(<span class=\"string\">&quot;一个是听得人当真了，一个是说的人当真了&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test4</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        ArrayList&lt;String&gt; list = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();<span class=\"comment\">//类型推断</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">int</span>[] arr = &#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>&#125;;<span class=\"comment\">//类型推断</span></span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//语法格式四：Lambda 若只需要一个参数时，参数的小括号可以省略</span></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test5</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        Consumer&lt;String&gt; con1 = (s) -&gt; &#123;</span><br><span class=\"line\">            System.out.println(s);</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        con1.accept(<span class=\"string\">&quot;一个是听得人当真了，一个是说的人当真了&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;*******************&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        Consumer&lt;String&gt; con2 = s -&gt; &#123;</span><br><span class=\"line\">            System.out.println(s);</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        con2.accept(<span class=\"string\">&quot;一个是听得人当真了，一个是说的人当真了&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//语法格式五：Lambda 需要两个或以上的参数，多条执行语句，并且可以有返回值</span></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test6</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        Comparator&lt;Integer&gt; com1 = <span class=\"keyword\">new</span> <span class=\"title class_\">Comparator</span>&lt;Integer&gt;() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">compare</span><span class=\"params\">(Integer o1, Integer o2)</span> &#123;</span><br><span class=\"line\">                System.out.println(o1);</span><br><span class=\"line\">                System.out.println(o2);</span><br><span class=\"line\">                <span class=\"keyword\">return</span> o1.compareTo(o2);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(com1.compare(<span class=\"number\">12</span>, <span class=\"number\">21</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;*****************************&quot;</span>);</span><br><span class=\"line\">        Comparator&lt;Integer&gt; com2 = (o1, o2) -&gt; &#123;</span><br><span class=\"line\">            System.out.println(o1);</span><br><span class=\"line\">            System.out.println(o2);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> o1.compareTo(o2);</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(com2.compare(<span class=\"number\">12</span>, <span class=\"number\">6</span>));</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//语法格式六：当 Lambda 体只有一条语句时，return 与大括号若有，都可以省略</span></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test7</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        Comparator&lt;Integer&gt; com1 = (o1, o2) -&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> o1.compareTo(o2);</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(com1.compare(<span class=\"number\">12</span>, <span class=\"number\">6</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;*****************************&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        Comparator&lt;Integer&gt; com2 = (o1, o2) -&gt; o1.compareTo(o2);</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(com2.compare(<span class=\"number\">12</span>, <span class=\"number\">21</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test8</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        Consumer&lt;String&gt; con1 = s -&gt; &#123;</span><br><span class=\"line\">            System.out.println(s);</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        con1.accept(<span class=\"string\">&quot;一个是听得人当真了，一个是说的人当真了&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;*****************************&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        Consumer&lt;String&gt; con2 = s -&gt; System.out.println(s);</span><br><span class=\"line\"></span><br><span class=\"line\">        con2.accept(<span class=\"string\">&quot;一个是听得人当真了，一个是说的人当真了&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"函数式接口\"><a href=\"#函数式接口\" class=\"headerlink\" title=\"函数式接口\"></a>函数式接口</h1><h2 id=\"什么是函数式-Functional-接口\"><a href=\"#什么是函数式-Functional-接口\" class=\"headerlink\" title=\"什么是函数式(Functional)接口\"></a>什么是函数式(Functional)接口</h2><ul>\n<li><p>只包含一个抽象方法的接口，称为<strong>函数式接口</strong>。 </p>\n</li>\n<li><p>你可以通过 Lambda 表达式来创建该接口的对象。（若 Lambda 表达式抛出一个受检异常(即：非运行时异常)，那么该异常需要在目标接口的抽象方法上进行声明）。</p>\n</li>\n<li><p>我们可以在一个接口上使用 <strong>@FunctionalInterface</strong> 注解，这样做可以检查它是否是一个函数式接口。同时 javadoc 也会包含一条声明，说明这个接口是一个函数式接口。</p>\n</li>\n<li><p>在java.util.function包下定义了Java 8 的丰富的函数式接口</p>\n</li>\n</ul>\n<h2 id=\"如何理解函数式接口\"><a href=\"#如何理解函数式接口\" class=\"headerlink\" title=\"如何理解函数式接口\"></a>如何理解函数式接口</h2><ul>\n<li>Java从诞生日起就是一直倡导“一切皆对象”，在Java里面面向对象(OOP)编程是一切。但是随着python、scala等语言的兴起和新技术的挑战，Java不得不做出调整以便支持更加广泛的技术要求，也即java不但可以支持OOP还可以支持OOF（面向函数编程） </li>\n<li>在函数式编程语言当中，函数被当做一等公民对待。在将函数作为一等公民的编程语言中，Lambda表达式的类型是函数。但是在Java8中，有所不同。在Java8中，Lambda表达式是对象，而不是函数，它们必须依附于一类特别的对象类型——函数式接口。 </li>\n<li>简单的说，在Java8中，Lambda表达式就是一个函数式接口的实例。这就是Lambda表达式和函数式接口的关系。也就是说，只要一个对象是函数式接口的实例，那么该对象就可以用Lambda表达式来表示。</li>\n<li>所以以前用匿名实现类表示的现在都可以用Lambda表达式来写。</li>\n</ul>\n<h2 id=\"Java内置函数式接口\"><a href=\"#Java内置函数式接口\" class=\"headerlink\" title=\"Java内置函数式接口\"></a>Java内置函数式接口</h2><p><strong>核心函数式接口</strong></p>\n<img src=\"https://npm.elemecdn.com/youthlql@1.0.8/Java_Basis/Java8_New_Features/0002.png\">\n\n\n\n<p><strong>其它函数式接口</strong></p>\n<img src=\"https://npm.elemecdn.com/youthlql@1.0.8/Java_Basis/Java8_New_Features/0003.png\">\n\n\n\n\n\n<p><strong>Consumer</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\">   <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test1</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">       happyTime(<span class=\"number\">500</span>, <span class=\"keyword\">new</span> <span class=\"title class_\">Consumer</span>&lt;Double&gt;() &#123;</span><br><span class=\"line\">           <span class=\"meta\">@Override</span></span><br><span class=\"line\">           <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">accept</span><span class=\"params\">(Double aDouble)</span> &#123;</span><br><span class=\"line\">               System.out.println(<span class=\"string\">&quot;学习太累了，去天上人间买了瓶矿泉水，价格为：&quot;</span> + aDouble);</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">       System.out.println(<span class=\"string\">&quot;********************&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">       happyTime(<span class=\"number\">400</span>,money -&gt; System.out.println(<span class=\"string\">&quot;学习太累了，去天上人间喝了口水，价格为：&quot;</span> + money));</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">happyTime</span><span class=\"params\">(<span class=\"type\">double</span> money, Consumer&lt;Double&gt; con)</span>&#123;</span><br><span class=\"line\">       con.accept(money);</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>结果：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">学习太累了，去天上人间买了瓶矿泉水，价格为：<span class=\"number\">500.0</span></span><br><span class=\"line\">********************</span><br><span class=\"line\">学习太累了，去天上人间喝了口水，价格为：<span class=\"number\">400.0</span></span><br><span class=\"line\"></span><br><span class=\"line\">Process finished with exit code <span class=\"number\">0</span></span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>Predicate</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test2</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        List&lt;String&gt; list = Arrays.asList(<span class=\"string\">&quot;北京&quot;</span>,<span class=\"string\">&quot;南京&quot;</span>,<span class=\"string\">&quot;天津&quot;</span>,<span class=\"string\">&quot;东京&quot;</span>,<span class=\"string\">&quot;西京&quot;</span>,<span class=\"string\">&quot;普京&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        List&lt;String&gt; filterStrs = filterString(list, <span class=\"keyword\">new</span> <span class=\"title class_\">Predicate</span>&lt;String&gt;() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">test</span><span class=\"params\">(String s)</span> &#123;<span class=\"comment\">//这里是定义一个校验规则</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span> s.contains(<span class=\"string\">&quot;京&quot;</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(filterStrs);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//用lambda表达式会很简单</span></span><br><span class=\"line\">        List&lt;String&gt; filterStrs1 = filterString(list,s -&gt; s.contains(<span class=\"string\">&quot;京&quot;</span>));</span><br><span class=\"line\">        System.out.println(filterStrs1);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//根据给定的规则，过滤集合中的字符串。此规则由Predicate的方法决定</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;String&gt; <span class=\"title function_\">filterString</span><span class=\"params\">(List&lt;String&gt; list, Predicate&lt;String&gt; pre)</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        ArrayList&lt;String&gt; filterList = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(String s : list)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(pre.test(s))&#123;</span><br><span class=\"line\">                filterList.add(s);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> filterList;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>结果：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[北京, 南京, 东京, 西京, 普京]</span><br><span class=\"line\">[北京, 南京, 东京, 西京, 普京]</span><br><span class=\"line\"></span><br><span class=\"line\">Process finished with exit code 0</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"自定义函数式接口\"><a href=\"#自定义函数式接口\" class=\"headerlink\" title=\"自定义函数式接口\"></a>自定义函数式接口</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 自定义函数式接口</span></span><br><span class=\"line\"><span class=\"comment\"> * 只是说加上<span class=\"doctag\">@FunctionalInterface</span>之后可以校验</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@FunctionalInterface</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">MyFunInterface</span>&lt;T&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> T <span class=\"title function_\">getValue</span><span class=\"params\">(T t)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Test</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//这个方法的第一个参数是lambda表达式，相当于是实例化了那个函数式接口</span></span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">s</span> <span class=\"operator\">=</span> toUpperString(str -&gt; str.toUpperCase(), <span class=\"string\">&quot;abcd&quot;</span>);</span><br><span class=\"line\">        System.out.println(s);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String <span class=\"title function_\">toUpperString</span><span class=\"params\">(MyFunInterface&lt;String&gt; mf,String str)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> mf.getValue(str);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"方法引用\"><a href=\"#方法引用\" class=\"headerlink\" title=\"方法引用\"></a>方法引用</h1><ul>\n<li><p>当要传递给Lambda体的操作，已经有实现的方法了，可以使用方法引用！</p>\n</li>\n<li><p>方法引用可以看做是Lambda表达式深层次的表达。换句话说，方法引用就是Lambda表达式，也就是函数式接口的一个实例，通过方法的名字来指向一个方法，可以认为是Lambda表达式的一个语法糖。</p>\n</li>\n<li><p>要求：实现接口的抽象方法的参数列表和返回值类型，必须与方法引用的方法的参数列表和返回值类型保持一致！</p>\n</li>\n<li><p>格式：使用操作符 “::” 将类(或对象) 与 方法名分隔开来。</p>\n</li>\n<li><p>如下三种主要使用情况： </p>\n<ul>\n<li><p>对象 :: 实例方法名</p>\n</li>\n<li><p>类 :: 静态方法名</p>\n</li>\n<li><p>类 :: 实例方法名</p>\n</li>\n</ul>\n</li>\n</ul>\n<p>我们直接拿例子来说明情况，先提前准备两个类：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Employee</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"type\">int</span> id;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"type\">int</span> age;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"type\">double</span> salary;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">getId</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> id;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setId</span><span class=\"params\">(<span class=\"type\">int</span> id)</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">this</span>.id = id;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> String <span class=\"title function_\">getName</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> name;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setName</span><span class=\"params\">(String name)</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">this</span>.name = name;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">getAge</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> age;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setAge</span><span class=\"params\">(<span class=\"type\">int</span> age)</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">this</span>.age = age;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"type\">double</span> <span class=\"title function_\">getSalary</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> salary;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setSalary</span><span class=\"params\">(<span class=\"type\">double</span> salary)</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">this</span>.salary = salary;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"title function_\">Employee</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;Employee().....&quot;</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"title function_\">Employee</span><span class=\"params\">(<span class=\"type\">int</span> id)</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">this</span>.id = id;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;Employee(int id).....&quot;</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"title function_\">Employee</span><span class=\"params\">(<span class=\"type\">int</span> id, String name)</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">this</span>.id = id;</span><br><span class=\"line\">\t\t<span class=\"built_in\">this</span>.name = name;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"title function_\">Employee</span><span class=\"params\">(<span class=\"type\">int</span> id, String name, <span class=\"type\">int</span> age, <span class=\"type\">double</span> salary)</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"built_in\">this</span>.id = id;</span><br><span class=\"line\">\t\t<span class=\"built_in\">this</span>.name = name;</span><br><span class=\"line\">\t\t<span class=\"built_in\">this</span>.age = age;</span><br><span class=\"line\">\t\t<span class=\"built_in\">this</span>.salary = salary;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> String <span class=\"title function_\">toString</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"string\">&quot;Employee&#123;&quot;</span> + <span class=\"string\">&quot;id=&quot;</span> + id + <span class=\"string\">&quot;, name=&#x27;&quot;</span> + name + <span class=\"string\">&#x27;\\&#x27;&#x27;</span> + <span class=\"string\">&quot;, age=&quot;</span> + age + <span class=\"string\">&quot;, salary=&quot;</span> + salary + <span class=\"string\">&#x27;&#125;&#x27;</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">equals</span><span class=\"params\">(Object o)</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (<span class=\"built_in\">this</span> == o)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (o == <span class=\"literal\">null</span> || getClass() != o.getClass())</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"type\">Employee</span> <span class=\"variable\">employee</span> <span class=\"operator\">=</span> (Employee) o;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (id != employee.id)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (age != employee.age)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (Double.compare(employee.salary, salary) != <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> name != <span class=\"literal\">null</span> ? name.equals(employee.name) : employee.name == <span class=\"literal\">null</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">hashCode</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> result;</span><br><span class=\"line\">\t\t<span class=\"type\">long</span> temp;</span><br><span class=\"line\">\t\tresult = id;</span><br><span class=\"line\">\t\tresult = <span class=\"number\">31</span> * result + (name != <span class=\"literal\">null</span> ? name.hashCode() : <span class=\"number\">0</span>);</span><br><span class=\"line\">\t\tresult = <span class=\"number\">31</span> * result + age;</span><br><span class=\"line\">\t\ttemp = Double.doubleToLongBits(salary);</span><br><span class=\"line\">\t\tresult = <span class=\"number\">31</span> * result + (<span class=\"type\">int</span>) (temp ^ (temp &gt;&gt;&gt; <span class=\"number\">32</span>));</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> result;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 提供用于测试的数据</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">EmployeeData</span> &#123;</span><br><span class=\"line\">   </span><br><span class=\"line\">   <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> List&lt;Employee&gt; <span class=\"title function_\">getEmployees</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">      List&lt;Employee&gt; list = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">      </span><br><span class=\"line\">      list.add(<span class=\"keyword\">new</span> <span class=\"title class_\">Employee</span>(<span class=\"number\">1001</span>, <span class=\"string\">&quot;马化腾&quot;</span>, <span class=\"number\">34</span>, <span class=\"number\">6000.38</span>));</span><br><span class=\"line\">      list.add(<span class=\"keyword\">new</span> <span class=\"title class_\">Employee</span>(<span class=\"number\">1002</span>, <span class=\"string\">&quot;马云&quot;</span>, <span class=\"number\">12</span>, <span class=\"number\">9876.12</span>));</span><br><span class=\"line\">      list.add(<span class=\"keyword\">new</span> <span class=\"title class_\">Employee</span>(<span class=\"number\">1003</span>, <span class=\"string\">&quot;刘强东&quot;</span>, <span class=\"number\">33</span>, <span class=\"number\">3000.82</span>));</span><br><span class=\"line\">      list.add(<span class=\"keyword\">new</span> <span class=\"title class_\">Employee</span>(<span class=\"number\">1004</span>, <span class=\"string\">&quot;雷军&quot;</span>, <span class=\"number\">26</span>, <span class=\"number\">7657.37</span>));</span><br><span class=\"line\">      list.add(<span class=\"keyword\">new</span> <span class=\"title class_\">Employee</span>(<span class=\"number\">1005</span>, <span class=\"string\">&quot;李彦宏&quot;</span>, <span class=\"number\">65</span>, <span class=\"number\">5555.32</span>));</span><br><span class=\"line\">      list.add(<span class=\"keyword\">new</span> <span class=\"title class_\">Employee</span>(<span class=\"number\">1006</span>, <span class=\"string\">&quot;比尔盖茨&quot;</span>, <span class=\"number\">42</span>, <span class=\"number\">9500.43</span>));</span><br><span class=\"line\">      list.add(<span class=\"keyword\">new</span> <span class=\"title class_\">Employee</span>(<span class=\"number\">1007</span>, <span class=\"string\">&quot;任正非&quot;</span>, <span class=\"number\">26</span>, <span class=\"number\">4333.32</span>));</span><br><span class=\"line\">      list.add(<span class=\"keyword\">new</span> <span class=\"title class_\">Employee</span>(<span class=\"number\">1008</span>, <span class=\"string\">&quot;扎克伯格&quot;</span>, <span class=\"number\">35</span>, <span class=\"number\">2500.32</span>));</span><br><span class=\"line\">      </span><br><span class=\"line\">      <span class=\"keyword\">return</span> list;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>下面来通过实际例子讲解方法引用：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 方法引用的使用</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * 1.使用情境：当要传递给Lambda体的操作，已经有实现的方法了，可以使用方法引用！</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * 2.方法引用，本质上就是Lambda表达式，而Lambda表达式作为函数式接口的实例。所以</span></span><br><span class=\"line\"><span class=\"comment\"> *   方法引用，也是函数式接口的实例。</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * 3. 使用格式：  类(或对象) :: 方法名</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * 4. 具体分为如下的三种情况：</span></span><br><span class=\"line\"><span class=\"comment\"> *    情况1     对象 :: 非静态方法</span></span><br><span class=\"line\"><span class=\"comment\"> *    情况2     类 :: 静态方法</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> *    情况3     类 :: 非静态方法</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * 5. 方法引用使用的要求：</span></span><br><span class=\"line\"><span class=\"comment\"> * \t接口中的抽象方法的形参列表和返回值类型</span></span><br><span class=\"line\"><span class=\"comment\"> * \t与</span></span><br><span class=\"line\"><span class=\"comment\"> * \t方法引用的方法的形参列表和返回值类型相同！（针对于情况1和情况2）</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">MethodRefTest</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 情况一：对象 :: 实例方法</span></span><br><span class=\"line\">\t<span class=\"comment\">//Consumer中的void accept(T t)</span></span><br><span class=\"line\">\t<span class=\"comment\">//PrintStream中的void println(T t)</span></span><br><span class=\"line\">\t<span class=\"meta\">@Test</span></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test1</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t\tConsumer&lt;String&gt; con1 = str -&gt; System.out.println(str);</span><br><span class=\"line\">\t\tcon1.accept(<span class=\"string\">&quot;北京&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;*******************&quot;</span>);</span><br><span class=\"line\">\t\t<span class=\"type\">PrintStream</span> <span class=\"variable\">ps</span> <span class=\"operator\">=</span> System.out;</span><br><span class=\"line\">\t\tConsumer&lt;String&gt; con2 = ps::println;</span><br><span class=\"line\">\t\tcon2.accept(<span class=\"string\">&quot;beijing&quot;</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">//Supplier中的T get()</span></span><br><span class=\"line\">\t<span class=\"comment\">//Employee中的String getName()</span></span><br><span class=\"line\">\t<span class=\"meta\">@Test</span></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test2</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"type\">Employee</span> <span class=\"variable\">emp</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Employee</span>(<span class=\"number\">1001</span>,<span class=\"string\">&quot;Tom&quot;</span>,<span class=\"number\">23</span>,<span class=\"number\">5600</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tSupplier&lt;String&gt; sup1 = () -&gt; emp.getName();</span><br><span class=\"line\">\t\tSystem.out.println(sup1.get());</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;*******************&quot;</span>);</span><br><span class=\"line\">\t\tSupplier&lt;String&gt; sup2 = emp::getName;</span><br><span class=\"line\">\t\tSystem.out.println(sup2.get());</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 情况二：类 :: 静态方法</span></span><br><span class=\"line\">\t<span class=\"comment\">//Comparator中的int compare(T t1,T t2)</span></span><br><span class=\"line\">\t<span class=\"comment\">//Integer中的int compare(T t1,T t2)</span></span><br><span class=\"line\">\t<span class=\"meta\">@Test</span></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test3</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t\tComparator&lt;Integer&gt; com1 = (t1,t2) -&gt; Integer.compare(t1,t2);</span><br><span class=\"line\">\t\tSystem.out.println(com1.compare(<span class=\"number\">12</span>,<span class=\"number\">21</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;*******************&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tComparator&lt;Integer&gt; com2 = Integer::compare;</span><br><span class=\"line\">\t\tSystem.out.println(com2.compare(<span class=\"number\">12</span>,<span class=\"number\">3</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">//Function中的R apply(T t)</span></span><br><span class=\"line\">\t<span class=\"comment\">//Math中的Long round(Double d)</span></span><br><span class=\"line\">\t<span class=\"meta\">@Test</span></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test4</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t\tFunction&lt;Double,Long&gt; func = <span class=\"keyword\">new</span> <span class=\"title class_\">Function</span>&lt;Double, Long&gt;() &#123;</span><br><span class=\"line\">\t\t\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">public</span> Long <span class=\"title function_\">apply</span><span class=\"params\">(Double d)</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> Math.round(d);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;*******************&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tFunction&lt;Double,Long&gt; func1 = d -&gt; Math.round(d);</span><br><span class=\"line\">\t\tSystem.out.println(func1.apply(<span class=\"number\">12.3</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;*******************&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tFunction&lt;Double,Long&gt; func2 = Math::round;</span><br><span class=\"line\">\t\tSystem.out.println(func2.apply(<span class=\"number\">12.6</span>));</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 情况三：类 :: 实例方法  (有难度)</span></span><br><span class=\"line\">\t<span class=\"comment\">// Comparator中的int comapre(T t1,T t2)  第一个参数T t1,也可以变成方法的调用者</span></span><br><span class=\"line\">\t<span class=\"comment\">// String中的int t1.compareTo(t2)        看上面说的，t1变成了调用者等价于第一个参数T t1</span></span><br><span class=\"line\">\t<span class=\"meta\">@Test</span></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test5</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t\tComparator&lt;String&gt; com1 = (s1,s2) -&gt; s1.compareTo(s2);</span><br><span class=\"line\">\t\tSystem.out.println(com1.compare(<span class=\"string\">&quot;abc&quot;</span>,<span class=\"string\">&quot;abd&quot;</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;*******************&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tComparator&lt;String&gt; com2 = String :: compareTo;</span><br><span class=\"line\">\t\tSystem.out.println(com2.compare(<span class=\"string\">&quot;abd&quot;</span>,<span class=\"string\">&quot;abm&quot;</span>));</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//BiPredicate中的boolean test(T t1, T t2);</span></span><br><span class=\"line\">\t<span class=\"comment\">//String中的boolean t1.equals(t2)</span></span><br><span class=\"line\">\t<span class=\"meta\">@Test</span></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test6</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t\tBiPredicate&lt;String,String&gt; pre1 = (s1,s2) -&gt; s1.equals(s2);</span><br><span class=\"line\">\t\tSystem.out.println(pre1.test(<span class=\"string\">&quot;abc&quot;</span>,<span class=\"string\">&quot;abc&quot;</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;*******************&quot;</span>);</span><br><span class=\"line\">\t\tBiPredicate&lt;String,String&gt; pre2 = String :: equals;</span><br><span class=\"line\">\t\tSystem.out.println(pre2.test(<span class=\"string\">&quot;abc&quot;</span>,<span class=\"string\">&quot;abd&quot;</span>));</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">// Function中的R apply(T t)</span></span><br><span class=\"line\">\t<span class=\"comment\">// Employee中的String getName();   第一个参数T t相当于方法调用者emp，返回值R和String对应</span></span><br><span class=\"line\">\t<span class=\"meta\">@Test</span></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test7</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"type\">Employee</span> <span class=\"variable\">employee</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Employee</span>(<span class=\"number\">1001</span>, <span class=\"string\">&quot;Jerry&quot;</span>, <span class=\"number\">23</span>, <span class=\"number\">6000</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">\t\tFunction&lt;Employee,String&gt; func1 = e -&gt; e.getName();</span><br><span class=\"line\">\t\tSystem.out.println(func1.apply(employee));</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;*******************&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">\t\tFunction&lt;Employee,String&gt; func2 = Employee::getName;</span><br><span class=\"line\">\t\tSystem.out.println(func2.apply(employee));</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h1 id=\"构造器引用\"><a href=\"#构造器引用\" class=\"headerlink\" title=\"构造器引用\"></a>构造器引用</h1><p>格式：ClassName :: new</p>\n<p>与函数式接口相结合，自动与函数式接口中方法兼容。可以把构造器引用赋值给定义的方法，要求构造器参数列表要与接口中抽象方法的参数列表一致！且方法的返回值即为构造器对应类的对象。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.junit.Test;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Arrays;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.function.BiFunction;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.function.Function;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.function.Supplier;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 一、构造器引用</span></span><br><span class=\"line\"><span class=\"comment\"> *      和方法引用类似，函数式接口的抽象方法的形参列表和构造器的形参列表一致。</span></span><br><span class=\"line\"><span class=\"comment\"> *      抽象方法的返回值类型即为构造器所属的类的类型</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * 二、数组引用</span></span><br><span class=\"line\"><span class=\"comment\"> *     大家可以把数组看做是一个特殊的类，则写法与构造器引用一致。</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ConstructorRefTest</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 构造器引用</span></span><br><span class=\"line\"><span class=\"comment\">     * Supplier中的T get()</span></span><br><span class=\"line\"><span class=\"comment\">     * Employee的空参构造器：Employee()</span></span><br><span class=\"line\"><span class=\"comment\">     * 1、和方法引用一样的理解方法，你的get()方法没有参数，我的Employee()也没有参数。</span></span><br><span class=\"line\"><span class=\"comment\">     * 2、你的get()方法有返回值T，我的Employee()方法返回值也是一个对象</span></span><br><span class=\"line\"><span class=\"comment\">     * 3、所以刚好可以用  </span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test1</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        Supplier&lt;Employee&gt; sup = <span class=\"keyword\">new</span> <span class=\"title class_\">Supplier</span>&lt;Employee&gt;() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"keyword\">public</span> Employee <span class=\"title function_\">get</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Employee</span>();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;*******************&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        Supplier&lt;Employee&gt;  sup1 = () -&gt; <span class=\"keyword\">new</span> <span class=\"title class_\">Employee</span>();</span><br><span class=\"line\">        System.out.println(sup1.get());</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;*******************&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        Supplier&lt;Employee&gt;  sup2 = Employee :: <span class=\"keyword\">new</span>;</span><br><span class=\"line\">        System.out.println(sup2.get());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//Function中的R apply(T t)</span></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test2</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        Function&lt;Integer,Employee&gt; func1 = id -&gt; <span class=\"keyword\">new</span> <span class=\"title class_\">Employee</span>(id);</span><br><span class=\"line\">        <span class=\"type\">Employee</span> <span class=\"variable\">employee</span> <span class=\"operator\">=</span> func1.apply(<span class=\"number\">1001</span>);</span><br><span class=\"line\">        System.out.println(employee);</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;*******************&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        Function&lt;Integer,Employee&gt; func2 = Employee :: <span class=\"keyword\">new</span>;</span><br><span class=\"line\">        <span class=\"type\">Employee</span> <span class=\"variable\">employee1</span> <span class=\"operator\">=</span> func2.apply(<span class=\"number\">1002</span>);</span><br><span class=\"line\">        System.out.println(employee1);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//BiFunction中的R apply(T t,U u)</span></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test3</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        BiFunction&lt;Integer,String,Employee&gt; func1 = (id,name) -&gt; <span class=\"keyword\">new</span> <span class=\"title class_\">Employee</span>(id,name);</span><br><span class=\"line\">        System.out.println(func1.apply(<span class=\"number\">1001</span>,<span class=\"string\">&quot;Tom&quot;</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;*******************&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        BiFunction&lt;Integer,String,Employee&gt; func2 = Employee :: <span class=\"keyword\">new</span>;</span><br><span class=\"line\">        System.out.println(func2.apply(<span class=\"number\">1002</span>,<span class=\"string\">&quot;Tom&quot;</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//数组引用</span></span><br><span class=\"line\">    <span class=\"comment\">//Function中的R apply(T t)</span></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test4</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        Function&lt;Integer,String[]&gt; func1 = length -&gt; <span class=\"keyword\">new</span> <span class=\"title class_\">String</span>[length];</span><br><span class=\"line\">        String[] arr1 = func1.apply(<span class=\"number\">5</span>);</span><br><span class=\"line\">        System.out.println(Arrays.toString(arr1));</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;*******************&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        Function&lt;Integer,String[]&gt; func2 = String[] :: <span class=\"keyword\">new</span>;</span><br><span class=\"line\">        String[] arr2 = func2.apply(<span class=\"number\">10</span>);</span><br><span class=\"line\">        System.out.println(Arrays.toString(arr2));</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"强大的Stream-API\"><a href=\"#强大的Stream-API\" class=\"headerlink\" title=\"强大的Stream API\"></a>强大的Stream API</h1><h2 id=\"Stream-API说明\"><a href=\"#Stream-API说明\" class=\"headerlink\" title=\"Stream API说明\"></a>Stream API说明</h2><ul>\n<li><p>Java8中有两大最为重要的改变。第一个是 <strong>Lambda</strong> <strong>表达式</strong>；另外一个则是 <strong>Stream API</strong>。 </p>\n</li>\n<li><p>Stream API ( java.util.stream) 把真正的函数式编程风格引入到Java中。这是目前为止对Java类库最好的补充，因为Stream API可以极大提供Java程序员的生产力，让程序员写出高效率、干净、简洁的代码。</p>\n</li>\n<li><p>Stream 是 Java8 中处理集合的关键抽象概念，它可以指定你希望对集合进行的操作，可以执行非常复杂的查找、过滤和映射数据等操作。 <strong>使用Stream API 对集合数据进行操作，就类似于使用 SQL 执行的数据库查询。</strong>也可以使用 Stream API 来并行执行操作。简言之，Stream API 提供了一种高效且易于使用的处理数据的方式</p>\n</li>\n</ul>\n<h2 id=\"为什么要使用Stream-API\"><a href=\"#为什么要使用Stream-API\" class=\"headerlink\" title=\"为什么要使用Stream API\"></a>为什么要使用Stream API</h2><ul>\n<li><p>实际开发中，项目中多数数据源都来自于Mysql，Oracle等，很多一些复杂的数据获取可以直接在sql层面去解决。但现在数据源可以更多了，有MongDB，Radis等，而这些NoSQL的数据本身不支持一些复杂的数据计算，这个时候就需要Java层面去处理。 </p>\n</li>\n<li><p>Stream 和 Collection 集合的区别：Collection 是一种静态的内存数据结构，而 Stream 是有关计算的。前者是主要面向内存，存储在内存中，后者主要是面向 CPU，通过 CPU 实现计算。</p>\n</li>\n</ul>\n<h2 id=\"什么是Stream\"><a href=\"#什么是Stream\" class=\"headerlink\" title=\"什么是Stream\"></a>什么是Stream</h2><p>Stream到底是什么呢？</p>\n<p>是数据渠道，用于操作数据源（集合、数组等）所生成的元素序列。</p>\n<p><strong>“集合讲的是数据，Stream讲的是计算！”</strong></p>\n<p><strong>注意：</strong></p>\n<p>①Stream 自己不会存储元素。</p>\n<p>②Stream 不会改变源对象。相反，他们会返回一个持有结果的新Stream。 </p>\n<p>③Stream 操作是延迟执行的。这意味着他们会等到需要结果的时候才执行</p>\n<p><strong>Stream</strong> <strong>的操作三个步骤</strong></p>\n<p>1、创建Stream</p>\n<p>一个数据源（如：集合、数组），获取一个流</p>\n<p>2、中间操作</p>\n<p>一个中间操作链，对数据源的数据进行处理</p>\n<p>3、终止操作(终端操作) </p>\n<p>一旦执行终止操作，就执行中间操作链，才产生结果【也就是所谓的延迟执行】。之后，不会再被使用</p>\n<img src=\"https://npm.elemecdn.com/youthlql@1.0.8/Java_Basis/Java8_New_Features/0004.png\">\n\n\n\n\n\n<h2 id=\"创建Stream\"><a href=\"#创建Stream\" class=\"headerlink\" title=\"创建Stream\"></a>创建Stream</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">StreamAPITest</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//创建 Stream方式一：通过集合</span></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test1</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        List&lt;Employee&gt; employees = EmployeeData.getEmployees();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//        default Stream&lt;E&gt; stream() : 返回一个顺序流，顺序流等会中间操作拿数据的时候按顺序拿</span></span><br><span class=\"line\">        Stream&lt;Employee&gt; stream = employees.stream();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//        default Stream&lt;E&gt; parallelStream() : 返回一个并行流</span></span><br><span class=\"line\">        Stream&lt;Employee&gt; parallelStream = employees.parallelStream();</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//创建 Stream方式二：通过数组</span></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test2</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span>[] arr = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[]&#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>&#125;;</span><br><span class=\"line\">        <span class=\"comment\">//调用Arrays类的static &lt;T&gt; Stream&lt;T&gt; stream(T[] array): 返回一个流</span></span><br><span class=\"line\">        <span class=\"type\">IntStream</span> <span class=\"variable\">stream</span> <span class=\"operator\">=</span> Arrays.stream(arr);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">Employee</span> <span class=\"variable\">e1</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Employee</span>(<span class=\"number\">1001</span>,<span class=\"string\">&quot;Tom&quot;</span>);</span><br><span class=\"line\">        <span class=\"type\">Employee</span> <span class=\"variable\">e2</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Employee</span>(<span class=\"number\">1002</span>,<span class=\"string\">&quot;Jerry&quot;</span>);</span><br><span class=\"line\">        Employee[] arr1 = <span class=\"keyword\">new</span> <span class=\"title class_\">Employee</span>[]&#123;e1,e2&#125;;</span><br><span class=\"line\">        Stream&lt;Employee&gt; stream1 = Arrays.stream(arr1);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//创建 Stream方式三：通过Stream的of()，通过显示值创建一个流。它可以接收任意数量的参数</span></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test3</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        Stream&lt;Integer&gt; stream = Stream.of(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//创建 Stream方式四：创建无限流【用的少，了解下就行】</span></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test4</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//      迭代</span></span><br><span class=\"line\"><span class=\"comment\">//      public static&lt;T&gt; Stream&lt;T&gt; iterate(final T seed, final UnaryOperator&lt;T&gt; f)</span></span><br><span class=\"line\">        <span class=\"comment\">//遍历前10个偶数</span></span><br><span class=\"line\">        Stream.iterate(<span class=\"number\">0</span>, t -&gt; t + <span class=\"number\">2</span>).limit(<span class=\"number\">10</span>).forEach(System.out::println);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//      生成</span></span><br><span class=\"line\"><span class=\"comment\">//      public static&lt;T&gt; Stream&lt;T&gt; generate(Supplier&lt;T&gt; s)</span></span><br><span class=\"line\">        Stream.generate(Math::random).limit(<span class=\"number\">10</span>).forEach(System.out::println);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h2 id=\"中间操作\"><a href=\"#中间操作\" class=\"headerlink\" title=\"中间操作\"></a>中间操作</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 测试Stream的中间操作</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">StreamAPITest1</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//1-筛选与切片</span></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test1</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        List&lt;Employee&gt; list = EmployeeData.getEmployees();</span><br><span class=\"line\"><span class=\"comment\">//        filter(Predicate p)——过滤   接收 Lambda ， 从流中排除某些元素。</span></span><br><span class=\"line\">        Stream&lt;Employee&gt; stream = list.stream();</span><br><span class=\"line\">        <span class=\"comment\">//练习：查询员工表中薪资大于7000的员工信息</span></span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">         * List&lt;String&gt; filterStrs1 = filterString(list,s -&gt; s.contains(&quot;京&quot;));</span></span><br><span class=\"line\"><span class=\"comment\">         * 跟之前的这个lambda表达式代码是一个意思</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        stream.filter(e -&gt; e.getSalary() &gt; <span class=\"number\">7000</span>).forEach(System.out::println);</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println();</span><br><span class=\"line\"><span class=\"comment\">//        limit(n)——截断流，使其元素不超过给定数量。</span></span><br><span class=\"line\">        list.stream().limit(<span class=\"number\">3</span>).forEach(System.out::println);</span><br><span class=\"line\">        System.out.println();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">        skip(n) —— 跳过元素，返回一个扔掉了前 n 个元素的流。若流中元素不足 n 个，</span></span><br><span class=\"line\"><span class=\"comment\">        则返回一个空流。与 limit(n) 互补</span></span><br><span class=\"line\"><span class=\"comment\">        */</span></span><br><span class=\"line\">        list.stream().skip(<span class=\"number\">3</span>).forEach(System.out::println);</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println();</span><br><span class=\"line\"><span class=\"comment\">//        distinct()——筛选，通过流所生成元素的 hashCode() 和 equals() 去除重复元素</span></span><br><span class=\"line\"></span><br><span class=\"line\">        list.add(<span class=\"keyword\">new</span> <span class=\"title class_\">Employee</span>(<span class=\"number\">1010</span>,<span class=\"string\">&quot;刘强东&quot;</span>,<span class=\"number\">40</span>,<span class=\"number\">8000</span>));</span><br><span class=\"line\">        list.add(<span class=\"keyword\">new</span> <span class=\"title class_\">Employee</span>(<span class=\"number\">1010</span>,<span class=\"string\">&quot;刘强东&quot;</span>,<span class=\"number\">41</span>,<span class=\"number\">8000</span>));</span><br><span class=\"line\">        list.add(<span class=\"keyword\">new</span> <span class=\"title class_\">Employee</span>(<span class=\"number\">1010</span>,<span class=\"string\">&quot;刘强东&quot;</span>,<span class=\"number\">40</span>,<span class=\"number\">8000</span>));</span><br><span class=\"line\">        list.add(<span class=\"keyword\">new</span> <span class=\"title class_\">Employee</span>(<span class=\"number\">1010</span>,<span class=\"string\">&quot;刘强东&quot;</span>,<span class=\"number\">40</span>,<span class=\"number\">8000</span>));</span><br><span class=\"line\">        list.add(<span class=\"keyword\">new</span> <span class=\"title class_\">Employee</span>(<span class=\"number\">1010</span>,<span class=\"string\">&quot;刘强东&quot;</span>,<span class=\"number\">40</span>,<span class=\"number\">8000</span>));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//        System.out.println(list);</span></span><br><span class=\"line\"></span><br><span class=\"line\">        list.stream().distinct().forEach(System.out::println);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//映射</span></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test2</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">        map(Function f)——接收一个函数作为参数，将元素转换成其他形式或提取信息，该函数会被应</span></span><br><span class=\"line\"><span class=\"comment\">        用到每个元素上，并将其映射成一个新的元素。</span></span><br><span class=\"line\"><span class=\"comment\">        */</span></span><br><span class=\"line\">        List&lt;String&gt; list = Arrays.asList(<span class=\"string\">&quot;aa&quot;</span>, <span class=\"string\">&quot;bb&quot;</span>, <span class=\"string\">&quot;cc&quot;</span>, <span class=\"string\">&quot;dd&quot;</span>);</span><br><span class=\"line\">        list.stream().map(str -&gt; str.toUpperCase()).forEach(System.out::println);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//        练习1：获取员工姓名长度大于3的员工的姓名。</span></span><br><span class=\"line\">        List&lt;Employee&gt; employees = EmployeeData.getEmployees();</span><br><span class=\"line\">        Stream&lt;String&gt; namesStream = employees.stream().map(Employee::getName);</span><br><span class=\"line\">        namesStream.filter(name -&gt; name.length() &gt; <span class=\"number\">3</span>).forEach(System.out::println);</span><br><span class=\"line\">        System.out.println();</span><br><span class=\"line\">        <span class=\"comment\">//练习2：</span></span><br><span class=\"line\">        Stream&lt;Stream&lt;Character&gt;&gt; streamStream = list.stream().map(StreamAPITest1::fromStringToStream);</span><br><span class=\"line\">        <span class=\"comment\">//这个还需要两层遍历</span></span><br><span class=\"line\">        streamStream.forEach(s -&gt;&#123;</span><br><span class=\"line\">            s.forEach(System.out::println);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        System.out.println();</span><br><span class=\"line\">        <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">        flatMap(Function f)——接收一个函数作为参数，将流中的每个值都换成另一个流，然后把所有流连</span></span><br><span class=\"line\"><span class=\"comment\">        接成一个流。flatMap一层遍历即可拿到想要的结果</span></span><br><span class=\"line\"><span class=\"comment\">        */</span></span><br><span class=\"line\">        Stream&lt;Character&gt; characterStream = list.stream().flatMap(StreamAPITest1::fromStringToStream);</span><br><span class=\"line\">        characterStream.forEach(System.out::println);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//将字符串中的多个字符构成的集合转换为对应的Stream的实例</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Stream&lt;Character&gt; <span class=\"title function_\">fromStringToStream</span><span class=\"params\">(String str)</span>&#123;<span class=\"comment\">//aa</span></span><br><span class=\"line\">        ArrayList&lt;Character&gt; list = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(Character c : str.toCharArray())&#123;</span><br><span class=\"line\">            list.add(c);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> list.stream();</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//3-排序</span></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test4</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\"><span class=\"comment\">//        sorted()——自然排序</span></span><br><span class=\"line\">        List&lt;Integer&gt; list = Arrays.asList(<span class=\"number\">12</span>, <span class=\"number\">43</span>, <span class=\"number\">65</span>, <span class=\"number\">34</span>, <span class=\"number\">87</span>, <span class=\"number\">0</span>, -<span class=\"number\">98</span>, <span class=\"number\">7</span>);</span><br><span class=\"line\">        list.stream().sorted().forEach(System.out::println);</span><br><span class=\"line\">        <span class=\"comment\">//抛异常，原因:Employee没有实现Comparable接口</span></span><br><span class=\"line\"><span class=\"comment\">//        List&lt;Employee&gt; employees = EmployeeData.getEmployees();</span></span><br><span class=\"line\"><span class=\"comment\">//        employees.stream().sorted().forEach(System.out::println);</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//        sorted(Comparator com)——定制排序</span></span><br><span class=\"line\"></span><br><span class=\"line\">        List&lt;Employee&gt; employees = EmployeeData.getEmployees();</span><br><span class=\"line\">        employees.stream().sorted( (e1,e2) -&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">           <span class=\"type\">int</span> <span class=\"variable\">ageValue</span> <span class=\"operator\">=</span> Integer.compare(e1.getAge(),e2.getAge());</span><br><span class=\"line\">           <span class=\"keyword\">if</span>(ageValue != <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">               <span class=\"keyword\">return</span> ageValue;</span><br><span class=\"line\">           &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">               <span class=\"keyword\">return</span> -Double.compare(e1.getSalary(),e2.getSalary());</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;).forEach(System.out::println);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"终止操作\"><a href=\"#终止操作\" class=\"headerlink\" title=\"终止操作\"></a>终止操作</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 测试Stream的终止操作</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">StreamAPITest2</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//1-匹配与查找</span></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test1</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        List&lt;Employee&gt; employees = EmployeeData.getEmployees();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//        allMatch(Predicate p)——检查是否匹配所有元素。</span></span><br><span class=\"line\"><span class=\"comment\">//          练习：是否所有的员工的年龄都大于18</span></span><br><span class=\"line\">        <span class=\"type\">boolean</span> <span class=\"variable\">allMatch</span> <span class=\"operator\">=</span> employees.stream().allMatch(e -&gt; e.getAge() &gt; <span class=\"number\">18</span>);</span><br><span class=\"line\">        System.out.println(allMatch);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//        anyMatch(Predicate p)——检查是否至少匹配一个元素。</span></span><br><span class=\"line\"><span class=\"comment\">//         练习：是否存在员工的工资大于 10000</span></span><br><span class=\"line\">        <span class=\"type\">boolean</span> <span class=\"variable\">anyMatch</span> <span class=\"operator\">=</span> employees.stream().anyMatch(e -&gt; e.getSalary() &gt; <span class=\"number\">10000</span>);</span><br><span class=\"line\">        System.out.println(anyMatch);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//        noneMatch(Predicate p)——检查是否没有匹配的元素。</span></span><br><span class=\"line\"><span class=\"comment\">//          练习：是否存在员工姓“雷”</span></span><br><span class=\"line\">        <span class=\"type\">boolean</span> <span class=\"variable\">noneMatch</span> <span class=\"operator\">=</span> employees.stream().noneMatch(e -&gt; e.getName().startsWith(<span class=\"string\">&quot;雷&quot;</span>));</span><br><span class=\"line\">        System.out.println(noneMatch);</span><br><span class=\"line\"><span class=\"comment\">//        findFirst——返回第一个元素</span></span><br><span class=\"line\">        Optional&lt;Employee&gt; employee = employees.stream().findFirst();</span><br><span class=\"line\">        System.out.println(employee);</span><br><span class=\"line\"><span class=\"comment\">//        findAny——返回当前流中的任意元素</span></span><br><span class=\"line\">        Optional&lt;Employee&gt; employee1 = employees.parallelStream().findAny();</span><br><span class=\"line\">        System.out.println(employee1);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test2</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        List&lt;Employee&gt; employees = EmployeeData.getEmployees();</span><br><span class=\"line\">        <span class=\"comment\">// count——返回流中元素的总个数</span></span><br><span class=\"line\">        <span class=\"type\">long</span> <span class=\"variable\">count</span> <span class=\"operator\">=</span> employees.stream().filter(e -&gt; e.getSalary() &gt; <span class=\"number\">5000</span>).count();</span><br><span class=\"line\">        System.out.println(count);</span><br><span class=\"line\"><span class=\"comment\">//        max(Comparator c)——返回流中最大值</span></span><br><span class=\"line\"><span class=\"comment\">//        练习：返回最高的工资：</span></span><br><span class=\"line\">        Stream&lt;Double&gt; salaryStream = employees.stream().map(e -&gt; e.getSalary());</span><br><span class=\"line\">        Optional&lt;Double&gt; maxSalary = salaryStream.max(Double::compare);</span><br><span class=\"line\">        System.out.println(maxSalary);</span><br><span class=\"line\"><span class=\"comment\">//        min(Comparator c)——返回流中最小值</span></span><br><span class=\"line\"><span class=\"comment\">//        练习：返回最低工资的员工</span></span><br><span class=\"line\">        Optional&lt;Employee&gt; employee = employees.stream().min((e1, e2) -&gt; Double.compare(e1.getSalary(), e2.getSalary()));</span><br><span class=\"line\">        System.out.println(employee);</span><br><span class=\"line\">        System.out.println();</span><br><span class=\"line\"><span class=\"comment\">//        forEach(Consumer c)——内部迭代</span></span><br><span class=\"line\">        employees.stream().forEach(System.out::println);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//使用集合的遍历操作</span></span><br><span class=\"line\">        employees.forEach(System.out::println);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//2-归约</span></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test3</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\"><span class=\"comment\">//        reduce(T identity, BinaryOperator)——可以将流中元素反复结合起来，得到一个值。返回 T</span></span><br><span class=\"line\"><span class=\"comment\">//        练习1：计算1-10的自然数的和</span></span><br><span class=\"line\">        List&lt;Integer&gt; list = Arrays.asList(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">7</span>,<span class=\"number\">8</span>,<span class=\"number\">9</span>,<span class=\"number\">10</span>);</span><br><span class=\"line\">        <span class=\"type\">Integer</span> <span class=\"variable\">sum</span> <span class=\"operator\">=</span> list.stream().reduce(<span class=\"number\">0</span>, Integer::sum);</span><br><span class=\"line\">        System.out.println(sum);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//        reduce(BinaryOperator) ——可以将流中元素反复结合起来，得到一个值。返回 Optional&lt;T&gt;</span></span><br><span class=\"line\"><span class=\"comment\">//        练习2：计算公司所有员工工资的总和</span></span><br><span class=\"line\">        List&lt;Employee&gt; employees = EmployeeData.getEmployees();</span><br><span class=\"line\">        Stream&lt;Double&gt; salaryStream = employees.stream().map(Employee::getSalary);</span><br><span class=\"line\"><span class=\"comment\">//        Optional&lt;Double&gt; sumMoney = salaryStream.reduce(Double::sum);</span></span><br><span class=\"line\">        Optional&lt;Double&gt; sumMoney = salaryStream.reduce((d1,d2) -&gt; d1 + d2);</span><br><span class=\"line\">        System.out.println(sumMoney.get());</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//3-收集</span></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test4</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\"><span class=\"comment\">// collect(Collector c)——将流转换为其他形式。接收一个 Collector接口的实现，用于给Stream中元素做汇总的方法</span></span><br><span class=\"line\"><span class=\"comment\">//        练习1：查找工资大于6000的员工，结果返回为一个List或Set</span></span><br><span class=\"line\"></span><br><span class=\"line\">        List&lt;Employee&gt; employees = EmployeeData.getEmployees();</span><br><span class=\"line\">        List&lt;Employee&gt; employeeList = employees.stream().filter(e -&gt; e.getSalary() &gt; <span class=\"number\">6000</span>).collect(Collectors.toList());</span><br><span class=\"line\"></span><br><span class=\"line\">        employeeList.forEach(System.out::println);</span><br><span class=\"line\">        System.out.println();</span><br><span class=\"line\">        Set&lt;Employee&gt; employeeSet = employees.stream().filter(e -&gt; e.getSalary() &gt; <span class=\"number\">6000</span>).collect(Collectors.toSet());</span><br><span class=\"line\"></span><br><span class=\"line\">        employeeSet.forEach(System.out::println);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"Optional类\"><a href=\"#Optional类\" class=\"headerlink\" title=\"Optional类\"></a>Optional类</h1><h2 id=\"什么是Optional？\"><a href=\"#什么是Optional？\" class=\"headerlink\" title=\"什么是Optional？\"></a>什么是Optional？</h2><ul>\n<li><p>到目前为止，臭名昭著的空指针异常是导致Java应用程序失败的最常见原因。以前，为了解决空指针异常，Google公司著名的Guava项目引入了Optional类，Guava通过使用检查空值的方式来防止代码污染，它鼓励程序员写更干净的代码。受到Google Guava的启发，Optional类已经成为Java 8类库的一部分。</p>\n</li>\n<li><p>Optional<T> 类(java.util.Optional) 是一个容器类，它可以保存类型T的值，代表这个值存在。或者仅仅保存null，表示这个值不存在。原来用 null 表示一个值不存在，现在 Optional 可以更好的表达这个概念。并且可以避免空指针异常。 </p>\n</li>\n<li><p>Optional类的Javadoc描述如下：这是一个可以为null的容器对象。如果值存在则isPresent()方法会返回true，调用get()方法会返回该对象。</p>\n</li>\n</ul>\n<h2 id=\"常用API\"><a href=\"#常用API\" class=\"headerlink\" title=\"常用API\"></a>常用API</h2><img src=\"https://npm.elemecdn.com/youthlql@1.0.8/Java_Basis/Java8_New_Features/0005.png\">\n\n\n\n\n\n<h2 id=\"举例\"><a href=\"#举例\" class=\"headerlink\" title=\"举例\"></a>举例</h2><p>首先准备两个类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Boy</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Girl girl;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">toString</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;Boy&#123;&quot;</span> +</span><br><span class=\"line\">                <span class=\"string\">&quot;girl=&quot;</span> + girl +</span><br><span class=\"line\">                <span class=\"string\">&#x27;&#125;&#x27;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Girl <span class=\"title function_\">getGirl</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> girl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setGirl</span><span class=\"params\">(Girl girl)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.girl = girl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">Boy</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">Boy</span><span class=\"params\">(Girl girl)</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">this</span>.girl = girl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Girl</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">toString</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;Girl&#123;&quot;</span> +</span><br><span class=\"line\">                <span class=\"string\">&quot;name=&#x27;&quot;</span> + name + <span class=\"string\">&#x27;\\&#x27;&#x27;</span> +</span><br><span class=\"line\">                <span class=\"string\">&#x27;&#125;&#x27;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">getName</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setName</span><span class=\"params\">(String name)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.name = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">Girl</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">Girl</span><span class=\"params\">(String name)</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">this</span>.name = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>这里只是简单的测试两个API</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Optional类：为了在程序中避免出现空指针异常而创建的。</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * 常用的方法：ofNullable(T t)</span></span><br><span class=\"line\"><span class=\"comment\"> *            orElse(T t)</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">OptionalTest</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">Optional.of(T t) : 创建一个 Optional 实例，t必须非空；</span></span><br><span class=\"line\"><span class=\"comment\">Optional.empty() : 创建一个空的 Optional 实例</span></span><br><span class=\"line\"><span class=\"comment\">Optional.ofNullable(T t)：t可以为null</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test1</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        <span class=\"type\">Girl</span> <span class=\"variable\">girl</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Girl</span>();</span><br><span class=\"line\"><span class=\"comment\">//        girl = null;</span></span><br><span class=\"line\">        <span class=\"comment\">//of(T t):保证t是非空的</span></span><br><span class=\"line\">        Optional&lt;Girl&gt; optionalGirl = Optional.of(girl);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test2</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        <span class=\"type\">Girl</span> <span class=\"variable\">girl</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Girl</span>();</span><br><span class=\"line\"><span class=\"comment\">//        girl = null;</span></span><br><span class=\"line\">        <span class=\"comment\">//ofNullable(T t)：t可以为null</span></span><br><span class=\"line\">        Optional&lt;Girl&gt; optionalGirl = Optional.ofNullable(girl);</span><br><span class=\"line\">        System.out.println(optionalGirl);</span><br><span class=\"line\">        <span class=\"comment\">//orElse(T t1):如果单前的Optional内部封装的t是非空的，则返回内部的t.</span></span><br><span class=\"line\">        <span class=\"comment\">//如果内部的t是空的，则返回orElse()方法中的参数t1.</span></span><br><span class=\"line\">        <span class=\"type\">Girl</span> <span class=\"variable\">girl1</span> <span class=\"operator\">=</span> optionalGirl.orElse(<span class=\"keyword\">new</span> <span class=\"title class_\">Girl</span>(<span class=\"string\">&quot;赵丽颖&quot;</span>));</span><br><span class=\"line\">        System.out.println(girl1);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>实际场景使用</strong></p>\n<p>可能出现空指针的例子：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> String <span class=\"title function_\">getGirlName</span><span class=\"params\">(Boy boy)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> boy.getGirl().getName();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test3</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        <span class=\"type\">Boy</span> <span class=\"variable\">boy</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Boy</span>();</span><br><span class=\"line\">        boy = <span class=\"literal\">null</span>;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">girlName</span> <span class=\"operator\">=</span> getGirlName(boy);</span><br><span class=\"line\">        System.out.println(girlName);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>结果：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">java.lang.NullPointerException</span><br><span class=\"line\">\tat com.atguigu.java4.OptionalTest.getGirlName(OptionalTest.java:47)</span><br><span class=\"line\">\tat com.atguigu.java4.OptionalTest.test3(OptionalTest.java:54)</span><br><span class=\"line\">...</span><br><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\">Process finished with exit code -1</span><br></pre></td></tr></table></figure>\n\n\n\n<p>没有Optional的解决办法，但是如果调用层数过多，就得一层一层判断是否为null，写起来很麻烦。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//优化以后的getGirlName():</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">getGirlName1</span><span class=\"params\">(Boy boy)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(boy != <span class=\"literal\">null</span>)&#123;</span><br><span class=\"line\">            <span class=\"type\">Girl</span> <span class=\"variable\">girl</span> <span class=\"operator\">=</span> boy.getGirl();</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(girl != <span class=\"literal\">null</span>)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> girl.getName();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test4</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        <span class=\"type\">Boy</span> <span class=\"variable\">boy</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Boy</span>();</span><br><span class=\"line\">        boy = <span class=\"literal\">null</span>;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">girlName</span> <span class=\"operator\">=</span> getGirlName1(boy);</span><br><span class=\"line\">        System.out.println(girlName);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>使用Optional解决问题：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//使用Optional类的getGirlName():</span></span><br><span class=\"line\">   <span class=\"keyword\">public</span> String <span class=\"title function_\">getGirlName2</span><span class=\"params\">(Boy boy)</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">       Optional&lt;Boy&gt; boyOptional = Optional.ofNullable(boy);</span><br><span class=\"line\">       <span class=\"comment\">//此时的boy1一定非空</span></span><br><span class=\"line\">       <span class=\"type\">Boy</span> <span class=\"variable\">boy1</span> <span class=\"operator\">=</span> boyOptional.orElse(<span class=\"keyword\">new</span> <span class=\"title class_\">Boy</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">Girl</span>(<span class=\"string\">&quot;迪丽热巴&quot;</span>)));</span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"type\">Girl</span> <span class=\"variable\">girl</span> <span class=\"operator\">=</span> boy1.getGirl();</span><br><span class=\"line\"></span><br><span class=\"line\">       Optional&lt;Girl&gt; girlOptional = Optional.ofNullable(girl);</span><br><span class=\"line\">       <span class=\"comment\">//girl1一定非空</span></span><br><span class=\"line\">       <span class=\"type\">Girl</span> <span class=\"variable\">girl1</span> <span class=\"operator\">=</span> girlOptional.orElse(<span class=\"keyword\">new</span> <span class=\"title class_\">Girl</span>(<span class=\"string\">&quot;古力娜扎&quot;</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"keyword\">return</span> girl1.getName();</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"meta\">@Test</span></span><br><span class=\"line\">   <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test5</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">       <span class=\"type\">Boy</span> <span class=\"variable\">boy</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">       boy = <span class=\"keyword\">new</span> <span class=\"title class_\">Boy</span>();</span><br><span class=\"line\">       boy = <span class=\"keyword\">new</span> <span class=\"title class_\">Boy</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">Girl</span>(<span class=\"string\">&quot;苍老师&quot;</span>));</span><br><span class=\"line\">       <span class=\"type\">String</span> <span class=\"variable\">girlName</span> <span class=\"operator\">=</span> getGirlName2(boy);</span><br><span class=\"line\">       System.out.println(girlName);</span><br><span class=\"line\"></span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n\n<p>这种是绝对不会出现空指针的。</p>\n<h1 id=\"接口的增强\"><a href=\"#接口的增强\" class=\"headerlink\" title=\"接口的增强\"></a>接口的增强</h1><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JDK7及以前：只能定义全局常量和抽象方法</span><br><span class=\"line\">  &gt;全局常量：public static final的.但是书写时，可以省略不写</span><br><span class=\"line\">  &gt;抽象方法：public abstract的</span><br><span class=\"line\">  \t\t\t</span><br><span class=\"line\">JDK8：除了定义全局常量和抽象方法之外，还可以定义静态方法、默认方法</span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * JDK8：除了定义全局常量和抽象方法之外，还可以定义静态方法、默认方法</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">CompareA</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//静态方法</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">method1</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;CompareA:北京&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//默认方法</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">default</span> <span class=\"keyword\">void</span> <span class=\"title function_\">method2</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;CompareA：上海&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//接口中的public 可以省略，自动就是public</span></span><br><span class=\"line\">    <span class=\"keyword\">default</span> <span class=\"keyword\">void</span> <span class=\"title function_\">method3</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;CompareA：上海&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">SuperClass</span> &#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">method3</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;SuperClass:北京&quot;</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">CompareB</span> &#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">default</span> <span class=\"keyword\">void</span> <span class=\"title function_\">method3</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;CompareB：上海&quot;</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">SubClassTest</span> &#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"type\">SubClass</span> <span class=\"variable\">s</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">SubClass</span>();</span><br><span class=\"line\">\t\t</span><br><span class=\"line\"><span class=\"comment\">//\t\ts.method1();</span></span><br><span class=\"line\"><span class=\"comment\">//\t\tSubClass.method1();</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//知识点1：接口中定义的静态方法，只能通过接口来调用。实现类用不了</span></span><br><span class=\"line\">\t\tCompareA.method1();</span><br><span class=\"line\">\t\t<span class=\"comment\">//知识点2：通过实现类的对象，可以调用接口中的默认方法。</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//如果实现类重写了接口中的默认方法，调用时，仍然调用的是重写以后的方法</span></span><br><span class=\"line\">\t\ts.method2();</span><br><span class=\"line\">\t\t<span class=\"comment\">//知识点3：如果子类(或实现类)继承的父类和实现的接口中声明了同名同参数的默认方法，</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//那么子类在没有重写此方法的情况下，默认调用的是父类中的同名同参数的方法。--&gt;类优先原则</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//知识点4：如果实现类实现了多个接口，而这多个接口中定义了同名同参数的默认方法，</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//那么在实现类没有重写此方法的情况下，报错。--&gt;接口冲突。</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//这就需要我们必须在实现类中重写此方法</span></span><br><span class=\"line\">\t\ts.method3();</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">SubClass</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">SuperClass</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">CompareA</span>,CompareB&#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">method2</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;SubClass：上海&quot;</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">method3</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;SubClass：深圳&quot;</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">//知识点5：如何在子类(或实现类)的方法中调用父类、接口中被重写的方法</span></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">myMethod</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">\t\tmethod3();<span class=\"comment\">//调用自己定义的重写的方法</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">super</span>.method3();<span class=\"comment\">//调用的是父类中声明的</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//调用接口中的默认方法</span></span><br><span class=\"line\">\t\tCompareA.<span class=\"built_in\">super</span>.method3();</span><br><span class=\"line\">\t\tCompareB.<span class=\"built_in\">super</span>.method3();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"单节点单硬盘部署MinIO","date":"2024-04-13T13:56:39.000Z","cover":"../img/minio/minio.svg","_content":"# 一、新建目录\n``` Shell\ncd /use/local\nmkdir minio\n```\n# 二、新建日志文件\n``` Shell\ncd ./minio\ntouch minio.log\n```\n# 三、下载minio文件\n``` Java\nwget https://dl.minio.io/server/minio/release/linux-amd64/minio\n```\n# 四、给minio文件赋予777权限，可写可读都执行\n``` Shell\nchmod 777 minio\n```\n# 五、设置环境变量\n``` Shell\nvim /etc/profile\n\n# 在文件末尾添加一下内容\n# minio环境变量\nexport MINIO_ROOT_USER=myminioadmin\nexport MINIO_ROOT_PASSWORD=minio-secret-key-change-me\n```\n# 六、生效环境变量\n``` Shell\nsource /etc/profile\n```\n# 七、编写minio启动Shell脚本\n``` Shell\nvim startup.sh\n\n# 添加一下内容\nnohup /usr/local/minio/minio server  /usr/local/minio/data --console-address \":35555\" > /usr/local/minio/minio.log 2>&1 &\n```\n# 八、编写minio停止sh脚本\n``` Shell\nvim stop.sh\n\n# 添加以下内容\n#!/bin/bash\n\n# 查找 MinIO 进程的 PID\nminio_pid=$(ps aux | grep '/usr/local/minio/minio server' | grep -v 'grep' | awk '{print $2}')\n\n# 如果找到了 MinIO 进程的 PID，则终止该进程\nif [ -n \"$minio_pid\" ]; then\n    echo \"Stopping MinIO server...\"\n    kill $minio_pid\nelse\n    echo \"MinIO server is not running.\"\nfi\n```\n# 九、开发端口\n``` Shell\nfirewall-cmd --zone=public --add-port=9000/tcp --permanent\nfirewall-cmd --zone=public --add-port=35555/tcp --permanent\nfirewall-cmd –reload\n```\n# 十、启动或者停止脚本\n``` Shell\n# 启动脚本\nsh startup.sh\n\n# 停止脚本\nsh stop.sh\n\n``` \n# 十一、访问minio console\n``` java\n控制台：http://ip:35555\nAPI：http://ip:9000\n```\n# 十二、注意事项\n无法访问可查看minio.log文件或者重启服务器\n``` Shell\nshutdown -r now\n```","source":"_posts/2024-04-13-单节点单硬盘部署MinIO.md","raw":"---\ntitle: 单节点单硬盘部署MinIO\ndate: 2024-04-13 21:56:39\ncover: ../img/minio/minio.svg\ntags: [ Java,对象储存,Minio ]\ncategories:\n  - Minio\n---\n# 一、新建目录\n``` Shell\ncd /use/local\nmkdir minio\n```\n# 二、新建日志文件\n``` Shell\ncd ./minio\ntouch minio.log\n```\n# 三、下载minio文件\n``` Java\nwget https://dl.minio.io/server/minio/release/linux-amd64/minio\n```\n# 四、给minio文件赋予777权限，可写可读都执行\n``` Shell\nchmod 777 minio\n```\n# 五、设置环境变量\n``` Shell\nvim /etc/profile\n\n# 在文件末尾添加一下内容\n# minio环境变量\nexport MINIO_ROOT_USER=myminioadmin\nexport MINIO_ROOT_PASSWORD=minio-secret-key-change-me\n```\n# 六、生效环境变量\n``` Shell\nsource /etc/profile\n```\n# 七、编写minio启动Shell脚本\n``` Shell\nvim startup.sh\n\n# 添加一下内容\nnohup /usr/local/minio/minio server  /usr/local/minio/data --console-address \":35555\" > /usr/local/minio/minio.log 2>&1 &\n```\n# 八、编写minio停止sh脚本\n``` Shell\nvim stop.sh\n\n# 添加以下内容\n#!/bin/bash\n\n# 查找 MinIO 进程的 PID\nminio_pid=$(ps aux | grep '/usr/local/minio/minio server' | grep -v 'grep' | awk '{print $2}')\n\n# 如果找到了 MinIO 进程的 PID，则终止该进程\nif [ -n \"$minio_pid\" ]; then\n    echo \"Stopping MinIO server...\"\n    kill $minio_pid\nelse\n    echo \"MinIO server is not running.\"\nfi\n```\n# 九、开发端口\n``` Shell\nfirewall-cmd --zone=public --add-port=9000/tcp --permanent\nfirewall-cmd --zone=public --add-port=35555/tcp --permanent\nfirewall-cmd –reload\n```\n# 十、启动或者停止脚本\n``` Shell\n# 启动脚本\nsh startup.sh\n\n# 停止脚本\nsh stop.sh\n\n``` \n# 十一、访问minio console\n``` java\n控制台：http://ip:35555\nAPI：http://ip:9000\n```\n# 十二、注意事项\n无法访问可查看minio.log文件或者重启服务器\n``` Shell\nshutdown -r now\n```","slug":"2024-04-13-单节点单硬盘部署MinIO","published":1,"updated":"2024-04-13T14:27:28.772Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clxjyo3c9000kisvddw186wnh","content":"<h1 id=\"一、新建目录\"><a href=\"#一、新建目录\" class=\"headerlink\" title=\"一、新建目录\"></a>一、新建目录</h1><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd /use/local</span><br><span class=\"line\">mkdir minio</span><br></pre></td></tr></table></figure>\n<h1 id=\"二、新建日志文件\"><a href=\"#二、新建日志文件\" class=\"headerlink\" title=\"二、新建日志文件\"></a>二、新建日志文件</h1><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd ./minio</span><br><span class=\"line\">touch minio.log</span><br></pre></td></tr></table></figure>\n<h1 id=\"三、下载minio文件\"><a href=\"#三、下载minio文件\" class=\"headerlink\" title=\"三、下载minio文件\"></a>三、下载minio文件</h1><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget https:<span class=\"comment\">//dl.minio.io/server/minio/release/linux-amd64/minio</span></span><br></pre></td></tr></table></figure>\n<h1 id=\"四、给minio文件赋予777权限，可写可读都执行\"><a href=\"#四、给minio文件赋予777权限，可写可读都执行\" class=\"headerlink\" title=\"四、给minio文件赋予777权限，可写可读都执行\"></a>四、给minio文件赋予777权限，可写可读都执行</h1><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">chmod 777 minio</span><br></pre></td></tr></table></figure>\n<h1 id=\"五、设置环境变量\"><a href=\"#五、设置环境变量\" class=\"headerlink\" title=\"五、设置环境变量\"></a>五、设置环境变量</h1><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vim /etc/profile</span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">在文件末尾添加一下内容</span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">minio环境变量</span></span><br><span class=\"line\">export MINIO_ROOT_USER=myminioadmin</span><br><span class=\"line\">export MINIO_ROOT_PASSWORD=minio-secret-key-change-me</span><br></pre></td></tr></table></figure>\n<h1 id=\"六、生效环境变量\"><a href=\"#六、生效环境变量\" class=\"headerlink\" title=\"六、生效环境变量\"></a>六、生效环境变量</h1><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">source /etc/profile</span><br></pre></td></tr></table></figure>\n<h1 id=\"七、编写minio启动Shell脚本\"><a href=\"#七、编写minio启动Shell脚本\" class=\"headerlink\" title=\"七、编写minio启动Shell脚本\"></a>七、编写minio启动Shell脚本</h1><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vim startup.sh</span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">添加一下内容</span></span><br><span class=\"line\">nohup /usr/local/minio/minio server  /usr/local/minio/data --console-address &quot;:35555&quot; &gt; /usr/local/minio/minio.log 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure>\n<h1 id=\"八、编写minio停止sh脚本\"><a href=\"#八、编写minio停止sh脚本\" class=\"headerlink\" title=\"八、编写minio停止sh脚本\"></a>八、编写minio停止sh脚本</h1><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vim stop.sh</span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">添加以下内容</span></span><br><span class=\"line\"><span class=\"meta prompt_\">#</span><span class=\"language-bash\">!/bin/bash</span></span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">查找 MinIO 进程的 PID</span></span><br><span class=\"line\">minio_pid=$(ps aux | grep &#x27;/usr/local/minio/minio server&#x27; | grep -v &#x27;grep&#x27; | awk &#x27;&#123;print $2&#125;&#x27;)</span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">如果找到了 MinIO 进程的 PID，则终止该进程</span></span><br><span class=\"line\">if [ -n &quot;$minio_pid&quot; ]; then</span><br><span class=\"line\">    echo &quot;Stopping MinIO server...&quot;</span><br><span class=\"line\">    kill $minio_pid</span><br><span class=\"line\">else</span><br><span class=\"line\">    echo &quot;MinIO server is not running.&quot;</span><br><span class=\"line\">fi</span><br></pre></td></tr></table></figure>\n<h1 id=\"九、开发端口\"><a href=\"#九、开发端口\" class=\"headerlink\" title=\"九、开发端口\"></a>九、开发端口</h1><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">firewall-cmd --zone=public --add-port=9000/tcp --permanent</span><br><span class=\"line\">firewall-cmd --zone=public --add-port=35555/tcp --permanent</span><br><span class=\"line\">firewall-cmd –reload</span><br></pre></td></tr></table></figure>\n<h1 id=\"十、启动或者停止脚本\"><a href=\"#十、启动或者停止脚本\" class=\"headerlink\" title=\"十、启动或者停止脚本\"></a>十、启动或者停止脚本</h1><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">启动脚本</span></span><br><span class=\"line\">sh startup.sh</span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">停止脚本</span></span><br><span class=\"line\">sh stop.sh</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h1 id=\"十一、访问minio-console\"><a href=\"#十一、访问minio-console\" class=\"headerlink\" title=\"十一、访问minio console\"></a>十一、访问minio console</h1><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">控制台：http:<span class=\"comment\">//ip:35555</span></span><br><span class=\"line\">API：http:<span class=\"comment\">//ip:9000</span></span><br></pre></td></tr></table></figure>\n<h1 id=\"十二、注意事项\"><a href=\"#十二、注意事项\" class=\"headerlink\" title=\"十二、注意事项\"></a>十二、注意事项</h1><p>无法访问可查看minio.log文件或者重启服务器</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">shutdown -r now</span><br></pre></td></tr></table></figure>","site":{"data":{}},"cover_type":"img","excerpt":"","more":"<h1 id=\"一、新建目录\"><a href=\"#一、新建目录\" class=\"headerlink\" title=\"一、新建目录\"></a>一、新建目录</h1><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd /use/local</span><br><span class=\"line\">mkdir minio</span><br></pre></td></tr></table></figure>\n<h1 id=\"二、新建日志文件\"><a href=\"#二、新建日志文件\" class=\"headerlink\" title=\"二、新建日志文件\"></a>二、新建日志文件</h1><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd ./minio</span><br><span class=\"line\">touch minio.log</span><br></pre></td></tr></table></figure>\n<h1 id=\"三、下载minio文件\"><a href=\"#三、下载minio文件\" class=\"headerlink\" title=\"三、下载minio文件\"></a>三、下载minio文件</h1><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget https:<span class=\"comment\">//dl.minio.io/server/minio/release/linux-amd64/minio</span></span><br></pre></td></tr></table></figure>\n<h1 id=\"四、给minio文件赋予777权限，可写可读都执行\"><a href=\"#四、给minio文件赋予777权限，可写可读都执行\" class=\"headerlink\" title=\"四、给minio文件赋予777权限，可写可读都执行\"></a>四、给minio文件赋予777权限，可写可读都执行</h1><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">chmod 777 minio</span><br></pre></td></tr></table></figure>\n<h1 id=\"五、设置环境变量\"><a href=\"#五、设置环境变量\" class=\"headerlink\" title=\"五、设置环境变量\"></a>五、设置环境变量</h1><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vim /etc/profile</span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">在文件末尾添加一下内容</span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">minio环境变量</span></span><br><span class=\"line\">export MINIO_ROOT_USER=myminioadmin</span><br><span class=\"line\">export MINIO_ROOT_PASSWORD=minio-secret-key-change-me</span><br></pre></td></tr></table></figure>\n<h1 id=\"六、生效环境变量\"><a href=\"#六、生效环境变量\" class=\"headerlink\" title=\"六、生效环境变量\"></a>六、生效环境变量</h1><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">source /etc/profile</span><br></pre></td></tr></table></figure>\n<h1 id=\"七、编写minio启动Shell脚本\"><a href=\"#七、编写minio启动Shell脚本\" class=\"headerlink\" title=\"七、编写minio启动Shell脚本\"></a>七、编写minio启动Shell脚本</h1><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vim startup.sh</span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">添加一下内容</span></span><br><span class=\"line\">nohup /usr/local/minio/minio server  /usr/local/minio/data --console-address &quot;:35555&quot; &gt; /usr/local/minio/minio.log 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure>\n<h1 id=\"八、编写minio停止sh脚本\"><a href=\"#八、编写minio停止sh脚本\" class=\"headerlink\" title=\"八、编写minio停止sh脚本\"></a>八、编写minio停止sh脚本</h1><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vim stop.sh</span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">添加以下内容</span></span><br><span class=\"line\"><span class=\"meta prompt_\">#</span><span class=\"language-bash\">!/bin/bash</span></span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">查找 MinIO 进程的 PID</span></span><br><span class=\"line\">minio_pid=$(ps aux | grep &#x27;/usr/local/minio/minio server&#x27; | grep -v &#x27;grep&#x27; | awk &#x27;&#123;print $2&#125;&#x27;)</span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">如果找到了 MinIO 进程的 PID，则终止该进程</span></span><br><span class=\"line\">if [ -n &quot;$minio_pid&quot; ]; then</span><br><span class=\"line\">    echo &quot;Stopping MinIO server...&quot;</span><br><span class=\"line\">    kill $minio_pid</span><br><span class=\"line\">else</span><br><span class=\"line\">    echo &quot;MinIO server is not running.&quot;</span><br><span class=\"line\">fi</span><br></pre></td></tr></table></figure>\n<h1 id=\"九、开发端口\"><a href=\"#九、开发端口\" class=\"headerlink\" title=\"九、开发端口\"></a>九、开发端口</h1><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">firewall-cmd --zone=public --add-port=9000/tcp --permanent</span><br><span class=\"line\">firewall-cmd --zone=public --add-port=35555/tcp --permanent</span><br><span class=\"line\">firewall-cmd –reload</span><br></pre></td></tr></table></figure>\n<h1 id=\"十、启动或者停止脚本\"><a href=\"#十、启动或者停止脚本\" class=\"headerlink\" title=\"十、启动或者停止脚本\"></a>十、启动或者停止脚本</h1><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">启动脚本</span></span><br><span class=\"line\">sh startup.sh</span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">停止脚本</span></span><br><span class=\"line\">sh stop.sh</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h1 id=\"十一、访问minio-console\"><a href=\"#十一、访问minio-console\" class=\"headerlink\" title=\"十一、访问minio console\"></a>十一、访问minio console</h1><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">控制台：http:<span class=\"comment\">//ip:35555</span></span><br><span class=\"line\">API：http:<span class=\"comment\">//ip:9000</span></span><br></pre></td></tr></table></figure>\n<h1 id=\"十二、注意事项\"><a href=\"#十二、注意事项\" class=\"headerlink\" title=\"十二、注意事项\"></a>十二、注意事项</h1><p>无法访问可查看minio.log文件或者重启服务器</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">shutdown -r now</span><br></pre></td></tr></table></figure>"},{"title":"设计模式-01.设计思想","keywords":"设计模式，设计思想","description":"设计模式第一部分-常用设计思想。","cover":"https://npm.elemecdn.com/lql_static@latest/logo/design_patterns.jpg","abbrlink":"c3dcce5d","date":"2024-04-21T15:22:58.000Z","_content":"\n# 声明\n\n> 1. 此系列文章非本人原创，是学习笔记。\n> 2. 设计模式系列以后会持续更新，包括已经发布的设计模式文章，因为后续还要再多看一下书，教程和开源项目等，继续润色文章。\n\n下面讲一些常见的设计思想\n\n## 基于接口而非实现编程\n\n这个原则非常重要，是一种非常有效的提高代码质量的手段，在平时的开发中特别经常被用到。\n\n### 如何解读原则中的“接口”二字？\n\n1. “基于接口而非实现编程”这条原则的英文描述是：“Program to an interface, not an implementation”。我们理解这条原则的时候，千万不要一开始就与具体的编程语言挂钩，局限在编程语言的“接口”语法中（比如 Java 中的 interface 接口语法）。这条原则最早出现于 1994 年 GoF 的《设计模式》这本书，它先于很多编程语言而诞生（比如 Java 语言），是一条比较抽象、泛化的设计思想。\n2. 实际上，理解这条原则的关键，就是理解其中的“接口”两个字。还记得我们上一节课讲的“接口”的定义吗？从本质上来看，“接口”就是一组“协议”或者“约定”，是功能提供者提供给使用者的一个“功能列表”。“接口”在不同的应用场景下会有不同的解读，比如服务端与客户端之间的“接口”，类库提供的“接口”，甚至是一组通信的协议都可以叫作“接口”。刚刚对“接口”的理解，都比较偏上层、偏抽象，与实际的写代码离得有点远。如果落实到具体的编码，“基于接口而非实现编程”这条原则中的“接口”，可以理解为编程语言中的接口或者抽象类。\n3. 前面我们提到，这条原则能非常有效地提高代码质量，之所以这么说，那是因为，应用这条原则，可以将接口和实现相分离，封装不稳定的实现，暴露稳定的接口。上游系统面向接口而非实现编程，不依赖不稳定的实现细节，这样当实现发生变化的时候，上游系统的代码基本上不需要做改动，以此来降低耦合性，提高扩展性。\n4. 实际上，“基于接口而非实现编程”这条原则的另一个表述方式，是“基于抽象而非实现编程”。后者的表述方式其实更能体现这条原则的设计初衷。在软件开发中，最大的挑战之一就是需求的不断变化，这也是考验代码设计好坏的一个标准。**越抽象、越顶层、越脱离具体某一实现的设计，越能提高代码的灵活性，越能应对未来的需求变化。好的代码设计，不仅能应对当下的需求，而且在将来需求发生变化的时候，仍然能够在不破坏原有代码设计的情况下灵活应对**。而抽象就是提高代码扩展性、灵活性、可维护性最有效的手段之一。\n\n\n\n### 如何将这条原则应用到实战中？\n\n假设我们的系统中有很多涉及图片处理和存储的业务逻辑。图片经过处理之后被上传到阿里云上。为了代码复用，我们封装了图片存储相关的代码逻辑，提供了一个统一的 AliyunImageStore 类，供整个系统来使用。具体的代码实现如下所示：\n\n```java\npublic class AliyunImageStore {\n  //...省略属性、构造函数等...\n  \n  public void createBucketIfNotExisting(String bucketName) {\n    // ...创建bucket代码逻辑...\n    // ...失败会抛出异常..\n  }\n  \n  public String generateAccessToken() {\n    // ...根据accesskey/secrectkey等生成access token\n  }\n  \n  public String uploadToAliyun(Image image, String bucketName, String accessToken) {\n    //...上传图片到阿里云...\n    //...返回图片存储在阿里云上的地址(url）...\n  }\n  \n  public Image downloadFromAliyun(String url, String accessToken) {\n    //...从阿里云下载图片...\n  }\n}\n\n// AliyunImageStore类的使用举例\npublic class ImageProcessingJob {\n  private static final String BUCKET_NAME = \"ai_images_bucket\";\n  //...省略其他无关代码...\n  \n  public void process() {\n    Image image = ...; //处理图片，并封装为Image对象\n    AliyunImageStore imageStore = new AliyunImageStore(/*省略参数*/);\n    imageStore.createBucketIfNotExisting(BUCKET_NAME);\n    String accessToken = imageStore.generateAccessToken();\n    imagestore.uploadToAliyun(image, BUCKET_NAME, accessToken);\n  }\n  \n}\n```\n\n\n\n1. 整个上传流程包含三个步骤：创建 bucket（你可以简单理解为存储目录）、生成 access token 访问凭证、携带 access token 上传图片到指定的 bucket 中。代码实现非常简单，类中的几个方法定义得都很干净，用起来也很清晰，乍看起来没有太大问题，完全能满足我们将图片存储在阿里云的业务需求。\n2. 不过，软件开发中唯一不变的就是变化。过了一段时间后，我们自建了私有云，不再将图片存储到阿里云了，而是将图片存储到自建私有云上。为了满足这样一个需求的变化，我们该如何修改代码呢？\n3. 我们需要重新设计实现一个存储图片到私有云的 PrivateImageStore 类，并用它替换掉项目中所有的 AliyunImageStore 类对象。这样的修改听起来并不复杂，只是简单替换而已，对整个代码的改动并不大。不过，我们经常说，“细节是魔鬼”。这句话在软件开发中特别适用。实际上，刚刚的设计实现方式，就隐藏了很多容易出问题的“魔鬼细节”，我们一块来看看都有哪些。\n4. 新的 PrivateImageStore 类需要设计实现哪些方法，才能在尽量最小化代码修改的情况下，替换掉 AliyunImageStore 类呢？这就要求我们必须将 AliyunImageStore 类中所定义的所有 public 方法，在 PrivateImageStore 类中都逐一定义并重新实现一遍。而这样做就会存在一些问题，我总结了下面两点。\n   - 首先，AliyunImageStore 类中有些函数命名暴露了实现细节，比如，uploadToAliyun() 和 downloadFromAliyun()。如果开发这个功能的同事没有接口意识、抽象思维，那这种暴露实现细节的命名方式就不足为奇了，毕竟最初我们只考虑将图片存储在阿里云上。而我们把这种包含“aliyun”字眼的方法，照抄到 PrivateImageStore 类中，显然是不合适的。如果我们在新类中重新命名 uploadToAliyun()、downloadFromAliyun() 这些方法，那就意味着，我们要修改项目中所有使用到这两个方法的代码，代码修改量可能就会很大。\n   - 其次，将图片存储到阿里云的流程，跟存储到私有云的流程，可能并不是完全一致的。比如，阿里云的图片上传和下载的过程中，需要生产 access token，而私有云不需要 access token。一方面，AliyunImageStore 中定义的 generateAccessToken() 方法不能照抄到 PrivateImageStore 中；另一方面，我们在使用 AliyunImageStore 上传、下载图片的时候，代码中用到了 generateAccessToken() 方法，如果要改为私有云的上传下载流程，这些代码都需要做调整。\n5. 那这两个问题该如何解决呢？解决这个问题的根本方法就是，在编写代码的时候，要遵从“基于接口而非实现编程”的原则，具体来讲，我们需要做到下面这 3 点。\n   1. 函数的命名不能暴露任何实现细节。比如，前面提到的 uploadToAliyun() 就不符合要求，应该改为去掉 aliyun 这样的字眼，改为更加抽象的命名方式，比如：upload()。\n   2. 封装具体的实现细节。比如，跟阿里云相关的特殊上传（或下载）流程不应该暴露给调用者。我们对上传（或下载）流程进行封装，对外提供一个包裹所有上传（或下载）细节的方法，给调用者使用。\n   3. 为实现类定义抽象的接口。具体的实现类都依赖统一的接口定义，遵从一致的上传功能协议。使用者依赖接口，而不是具体的实现类来编程。\n6. 我们按照这个思路，把代码重构一下。重构后的代码如下所示：\n\n```java\npublic interface ImageStore {\n  String upload(Image image, String bucketName);\n  Image download(String url);\n}\n\npublic class AliyunImageStore implements ImageStore {\n  //...省略属性、构造函数等...\n\n  public String upload(Image image, String bucketName) {\n    createBucketIfNotExisting(bucketName);\n    String accessToken = generateAccessToken();\n    //...上传图片到阿里云...\n    //...返回图片在阿里云上的地址(url)...\n  }\n\n  public Image download(String url) {\n    String accessToken = generateAccessToken();\n    //...从阿里云下载图片...\n  }\n\n  private void createBucketIfNotExisting(String bucketName) {\n    // ...创建bucket...\n    // ...失败会抛出异常..\n  }\n\n  private String generateAccessToken() {\n    // ...根据accesskey/secrectkey等生成access token\n  }\n}\n\n// 上传下载流程改变：私有云不需要支持access token\npublic class PrivateImageStore implements ImageStore  {\n  public String upload(Image image, String bucketName) {\n    createBucketIfNotExisting(bucketName);\n    //...上传图片到私有云...\n    //...返回图片的url...\n  }\n\n  public Image download(String url) {\n    //...从私有云下载图片...\n  }\n\n  private void createBucketIfNotExisting(String bucketName) {\n    // ...创建bucket...\n    // ...失败会抛出异常..\n  }\n}\n\n// ImageStore的使用举例\npublic class ImageProcessingJob {\n  private static final String BUCKET_NAME = \"ai_images_bucket\";\n  //...省略其他无关代码...\n  \n  public void process() {\n    Image image = ...;//处理图片，并封装为Image对象\n    ImageStore imageStore = new PrivateImageStore(...);\n    imagestore.upload(image, BUCKET_NAME);\n  }\n}\n```\n\n1. 除此之外，很多人在定义接口的时候，希望通过实现类来反推接口的定义。先把实现类写好，然后看实现类中有哪些方法，照抄到接口定义中。如果按照这种思考方式，就有可能导致接口定义不够抽象，依赖具体的实现。这样的接口设计就没有意义了。不过，如果你觉得这种思考方式更加顺畅，那也没问题，只是将实现类的方法搬移到接口定义中的时候，要有选择性的搬移，不要将跟具体实现相关的方法搬移到接口中，比如 AliyunImageStore 中的 generateAccessToken() 方法。\n2. 总结一下，我们在做软件开发的时候，一定要有抽象意识、封装意识、接口意识。在定义接口的时候，不要暴露任何实现细节。接口的定义只表明做什么，而不是怎么做。而且，在设计接口的时候，我们要多思考一下，这样的接口设计是否足够通用，是否能够做到在替换具体的接口实现的时候，不需要任何接口定义的改动。\n\n\n\n### 是否需要为每个类定义接口？\n\n1. 看了刚刚的讲解，你可能会有这样的疑问：为了满足这条原则，我是不是需要给每个实现类都定义对应的接口呢？在开发的时候，是不是任何代码都要只依赖接口，完全不依赖实现编程呢？\n2. 做任何事情都要讲求一个“度”，过度使用这条原则，非得给每个类都定义接口，接口满天飞，也会导致不必要的开发负担。至于什么时候，该为某个类定义接口，实现基于接口的编程，什么时候不需要定义接口，直接使用实现类编程，我们做权衡的根本依据，还是要回归到设计原则诞生的初衷上来。只要搞清楚了这条原则是为了解决什么样的问题而产生的，你就会发现，很多之前模棱两可的问题，都会变得豁然开朗。\n3. 前面我们也提到，这条原则的设计初衷是，将接口和实现相分离，封装不稳定的实现，暴露稳定的接口。上游系统面向接口而非实现编程，不依赖不稳定的实现细节，这样当实现发生变化的时候，上游系统的代码基本上不需要做改动，以此来降低代码间的耦合性，提高代码的扩展性。\n4. 从这个设计初衷上来看，如果在我们的业务场景中，某个功能只有一种实现方式，未来也不可能被其他实现方式替换，那我们就没有必要为其设计接口，也没有必要基于接口编程，直接使用实现类就可以了。\n5. 除此之外，越是不稳定的系统，我们越是要在代码的扩展性、维护性上下功夫。相反，如果某个系统特别稳定，在开发完之后，基本上不需要做维护，那我们就没有必要为其扩展性，投入不必要的开发时间。\n\n\n\n## 多用组合少用继承\n\n在面向对象编程中，有一条非常经典的设计原则，那就是：组合优于继承，多用组合少用继承。为什么不推荐使用继承？组合相比继承有哪些优势？如何判断该用组合还是继承？今天，我们就围绕着这三个问题，来详细讲解一下这条设计原则。\n\n\n\n\n\n### 为什么不推荐使用继承？\n\n1. 继承是面向对象的四大特性之一，用来表示类之间的 is-a 关系，可以解决代码复用的问题。虽然继承有诸多作用，但继承层次过深、过复杂，也会影响到代码的可维护性。所以，对于是否应该在项目中使用继承，网上有很多争议。很多人觉得继承是一种反模式，应该尽量少用，甚至不用。为什么会有这样的争议？我们通过一个例子来解释一下。\n2. 假设我们要设计一个关于鸟的类。我们将“鸟类”这样一个抽象的事物概念，定义为一个抽象类 AbstractBird。所有更细分的鸟，比如麻雀、鸽子、乌鸦等，都继承这个抽象类。\n3. 我们知道，大部分鸟都会飞，那我们可不可以在 AbstractBird 抽象类中，定义一个 fly() 方法呢？答案是否定的。尽管大部分鸟都会飞，但也有特例，比如鸵鸟就不会飞。鸵鸟继承具有 fly() 方法的父类，那鸵鸟就具有“飞”这样的行为，这显然不符合我们对现实世界中事物的认识。当然，你可能会说，我在鸵鸟这个子类中重写（override）fly() 方法，让它抛出 UnSupportedMethodException 异常不就可以了吗？具体的代码实现如下所示：\n\n```java\npublic class AbstractBird {\n  //...省略其他属性和方法...\n  public void fly() { //... }\n}\n\npublic class Ostrich extends AbstractBird { //鸵鸟\n  //...省略其他属性和方法...\n  public void fly() {\n    throw new UnSupportedMethodException(\"I can't fly.'\");\n  }\n}\n```\n\n1. 这种设计思路虽然可以解决问题，但不够优美。因为除了鸵鸟之外，不会飞的鸟还有很多，比如企鹅。对于这些不会飞的鸟来说，我们都需要重写 fly() 方法，抛出异常。这样的设计，一方面，徒增了编码的工作量；另一方面，也违背了我们之后要讲的最小知识原则（Least Knowledge Principle，也叫最少知识原则或者迪米特法则），暴露不该暴露的接口给外部，增加了类使用过程中被误用的概率。\n2. 你可能又会说，那我们再通过 AbstractBird 类派生出两个更加细分的抽象类：会飞的鸟类 AbstractFlyableBird 和不会飞的鸟类 AbstractUnFlyableBird，让麻雀、乌鸦这些会飞的鸟都继承 AbstractFlyableBird，让鸵鸟、企鹅这些不会飞的鸟，都继承 AbstractUnFlyableBird 类，不就可以了吗？具体的继承关系如下图所示：\n\n<img src=\"https://npm.elemecdn.com/youthlql@1.0.0/design_patterns/design_ideas/0001.png\"/>\n\n\n\n1. 从图中我们可以看出，继承关系变成了三层。不过，整体上来讲，目前的继承关系还比较简单，层次比较浅，也算是一种可以接受的设计思路。我们再继续加点难度。在刚刚这个场景中，我们只关注“鸟会不会飞”，但如果我们还关注“鸟会不会叫”，那这个时候，我们又该如何设计类之间的继承关系呢？\n\n2. 是否会飞？是否会叫？两个行为搭配起来会产生四种情况：会飞会叫、不会飞会叫、会飞不会叫、不会飞不会叫。如果我们继续沿用刚才的设计思路，那就需要再定义四个抽象类（AbstractFlyableTweetableBird、AbstractFlyableUnTweetableBird、AbstractUnFlyableTweetableBird、AbstractUnFlyableUnTweetableBird）。\n\n<img src=\"https://npm.elemecdn.com/youthlql@1.0.0/design_patterns/design_ideas/0002.png\"/>\n\n\n\n1. 如果我们还需要考虑“是否会下蛋”这样一个行为，那估计就要组合爆炸了。类的继承层次会越来越深、继承关系会越来越复杂。而这种层次很深、很复杂的继承关系，一方面，会导致代码的可读性变差。因为我们要搞清楚某个类具有哪些方法、属性，必须阅读父类的代码、父类的父类的代码……一直追溯到最顶层父类的代码。另一方面，这也破坏了类的封装特性，将父类的实现细节暴露给了子类。子类的实现依赖父类的实现，两者高度耦合，一旦父类代码修改，就会影响所有子类的逻辑。\n2. 总之，继承最大的问题就在于：继承层次过深、继承关系过于复杂会影响到代码的可读性和可维护性。这也是为什么我们不推荐使用继承。那刚刚例子中继承存在的问题，我们又该如何来解决呢？你可以先自己思考一下，再听我下面的讲解。\n\n\n\n### 组合相比继承有哪些优势？\n\n1. 实际上，我们可以利用组合（composition）、接口、委托（delegation）三个技术手段，一块儿来解决刚刚继承存在的问题。\n2. 接口表示具有某种行为特性。针对“会飞”这样一个行为特性，我们可以定义一个 Flyable 接口，只让会飞的鸟去实现这个接口。对于会叫、会下蛋这些行为特性，我们可以类似地定义 Tweetable 接口、EggLayable 接口。我们将这个设计思路翻译成 Java 代码的话，就是下面这个样子：\n\n```java\npublic interface Flyable {\n  void fly();\n}\npublic interface Tweetable {\n  void tweet();\n}\npublic interface EggLayable {\n  void layEgg();\n}\npublic class Ostrich implements Tweetable, EggLayable {//鸵鸟\n  //... 省略其他属性和方法...\n  @Override\n  public void tweet() { //... }\n  @Override\n  public void layEgg() { //... }\n}\npublic class Sparrow impelents Flyable, Tweetable, EggLayable {//麻雀\n  //... 省略其他属性和方法...\n  @Override\n  public void fly() { //... }\n  @Override\n  public void tweet() { //... }\n  @Override\n  public void layEgg() { //... }\n}\n```\n\n1. 不过，我们知道，接口只声明方法，不定义实现。也就是说，每个会下蛋的鸟都要实现一遍 layEgg() 方法，并且实现逻辑是一样的，这就会导致代码重复的问题。那这个问题又该如何解决呢？\n2. 我们可以针对三个接口再定义三个实现类，它们分别是：实现了 fly() 方法的 FlyAbility 类、实现了 tweet() 方法的 TweetAbility 类、实现了 layEgg() 方法的 EggLayAbility 类。然后，通过组合和委托技术来消除代码重复。具体的代码实现如下所示：\n\n```java\npublic interface Flyable {\n  void fly()；\n}\npublic class FlyAbility implements Flyable {\n  @Override\n  public void fly() { //... }\n}\n//省略Tweetable/TweetAbility/EggLayable/EggLayAbility\n\npublic class Ostrich implements Tweetable, EggLayable {//鸵鸟\n  private TweetAbility tweetAbility = new TweetAbility(); //组合\n  private EggLayAbility eggLayAbility = new EggLayAbility(); //组合\n  //... 省略其他属性和方法...\n  @Override\n  public void tweet() {\n    tweetAbility.tweet(); // 委托\n  }\n  @Override\n  public void layEgg() {\n    eggLayAbility.layEgg(); // 委托\n  }\n}\n```\n\n\n\n我们知道继承主要有三个作用：表示 is-a 关系，支持多态特性，代码复用。而这三个作用都可以通过其他技术手段来达成。比如 is-a 关系，我们可以通过组合和接口的 has-a 关系来替代；多态特性我们可以利用接口来实现；代码复用我们可以通过组合和委托来实现。所以，从理论上讲，通过组合、接口、委托三个技术手段，我们完全可以替换掉继承，在项目中不用或者少用继承关系，特别是一些复杂的继承关系。\n\n\n\n### 如何判断该用组合还是继承？\n\n1. 尽管我们鼓励多用组合少用继承，但组合也并不是完美的，继承也并非一无是处。从上面的例子来看，继承改写成组合意味着要做更细粒度的类的拆分。这也就意味着，我们要定义更多的类和接口。类和接口的增多也就或多或少地增加代码的复杂程度和维护成本。所以，在实际的项目开发中，我们还是要根据具体的情况，来具体选择该用继承还是组合。\n2. 如果类之间的继承结构稳定（不会轻易改变），继承层次比较浅（比如，最多有两层继承关系），继承关系不复杂，我们就可以大胆地使用继承。反之，系统越不稳定，继承层次很深，继承关系复杂，我们就尽量使用组合来替代继承。\n3. 除此之外，还有一些设计模式会固定使用继承或者组合。比如，装饰者模式（decorator pattern）、策略模式（strategy pattern）、组合模式（composite pattern）等都使用了组合关系，而模板模式（template pattern）使用了继承关系。\n4. 前面我们讲到继承可以实现代码复用。利用继承特性，我们把相同的属性和方法，抽取出来，定义到父类中。子类复用父类中的属性和方法，达到代码复用的目的。但是，有的时候，从业务含义上，A 类和 B 类并不一定具有继承关系。比如，Crawler 类和 PageAnalyzer 类，它们都用到了 URL 拼接和分割的功能，但并不具有继承关系（既不是父子关系，也不是兄弟关系）。仅仅为了代码复用，生硬地抽象出一个父类出来，会影响到代码的可读性。如果不熟悉背后设计思路的同事，发现 Crawler 类和 PageAnalyzer 类继承同一个父类，而父类中定义的却只是 URL 相关的操作，会觉得这个代码写得莫名其妙，理解不了。这个时候，使用组合就更加合理、更加灵活。具体的代码实现如下所示：\n\n```java\npublic class Url {\n  //...省略属性和方法\n}\n\npublic class Crawler {\n  private Url url; // 组合\n  public Crawler() {\n    this.url = new Url();\n  }\n  //...\n}\n\npublic class PageAnalyzer {\n  private Url url; // 组合\n  public PageAnalyzer() {\n    this.url = new Url();\n  }\n  //..\n}\n```\n\n\n\n还有一些特殊的场景要求我们必须使用继承。如果你不能改变一个函数的入参类型，而入参又非接口，为了支持多态，只能采用继承来实现。比如下面这样一段代码，其中 FeignClient 是一个外部类，我们没有权限去修改这部分代码，但是我们希望能重写这个类在运行时执行的 encode() 函数。这个时候，我们只能采用继承来实现了。\n\n\n\n```java\npublic class FeignClient { // Feign Client框架代码\n  //...省略其他代码...\n  public void encode(String url) { //... }\n}\n\npublic void demofunction(FeignClient feignClient) {\n  //...\n  feignClient.encode(url);\n  //...\n}\n\npublic class CustomizedFeignClient extends FeignClient {\n  @Override\n  public void encode(String url) { //...重写encode的实现...}\n}\n\n// 调用\nFeignClient client = new CustomizedFeignClient();\ndemofunction(client);\n```\n\n尽管有些人说，要杜绝继承，100% 用组合代替继承，但是我的观点没那么极端！之所以“多用组合少用继承”这个口号喊得这么响，只是因为，长期以来，我们过度使用继承。还是那句话，组合并不完美，继承也不是一无是处。只要我们控制好它们的副作用、发挥它们各自的优势，在不同的场合下，恰当地选择使用继承还是组合，这才是我们所追求的境界。\n\n\n\n\n\n## 如何通过封装、抽象、模块化、中间层等解耦代码？\n\n### “解耦”为何如此重要？\n\n1. 软件设计与开发最重要的工作之一就是应对复杂性。人处理复杂性的能力是有限的。过于复杂的代码往往在可读性、可维护性上都不友好。那如何来控制代码的复杂性呢？手段有很多，我个人认为，最关键的就是解耦，保证代码松耦合、高内聚。如果说重构是保证代码质量不至于腐化到无可救药地步的有效手段，那么利用解耦的方法对代码重构，就是保证代码不至于复杂到无法控制的有效手段。\n2. 后文迪米特法则有介绍，什么是“高内聚、松耦合”。。实际上，“高内聚、松耦合”是一个比较通用的设计思想，不仅可以指导细粒度的类和类之间关系的设计，还能指导粗粒度的系统、架构、模块的设计。相对于编码规范，它能够在更高层次上提高代码的可读性和可维护性。\n3. 不管是阅读代码还是修改代码，“高内聚、松耦合”的特性可以让我们聚焦在某一模块或类中，不需要了解太多其他模块或类的代码，让我们的焦点不至于过于发散，降低了阅读和修改代码的难度。而且，因为依赖关系简单，耦合小，修改代码不至于牵一发而动全身，代码改动比较集中，引入 bug 的风险也就减少了很多。同时，“高内聚、松耦合”的代码可测试性也更加好，容易 mock 或者很少需要 mock 外部依赖的模块或者类。\n4. 除此之外，代码“高内聚、松耦合”，也就意味着，代码结构清晰、分层和模块化合理、依赖关系简单、模块或类之间的耦合小，那代码整体的质量就不会差。即便某个具体的类或者模块设计得不怎么合理，代码质量不怎么高，影响的范围是非常有限的。我们可以聚焦于这个模块或者类，做相应的小型重构。而相对于代码结构的调整，这种改动范围比较集中的小型重构的难度就容易多了。\n\n\n\n### 代码是否需要“解耦”？\n\n1. 那现在问题来了，我们该怎么判断代码的耦合程度呢？或者说，怎么判断代码是否符合“高内聚、松耦合”呢？再或者说，如何判断系统是否需要解耦重构呢？\n2. 间接的衡量标准有很多，前面我们讲到了一些，比如，看修改代码会不会牵一发而动全身。除此之外，还有一个直接的衡量标准，也是我在阅读源码的时候经常会用到的，那就是把模块与模块之间、类与类之间的依赖关系画出来，根据依赖关系图的复杂性来判断是否需要解耦重构。\n3. 如果依赖关系复杂、混乱，那从代码结构上来讲，可读性和可维护性肯定不是太好，那我们就需要考虑是否可以通过解耦的方法，让依赖关系变得清晰、简单。当然，这种判断还是有比较强的主观色彩，但是可以作为一种参考和梳理依赖的手段，配合间接的衡量标准一块来使用。\n\n### 如何给代码“解耦”？\n\n>  封装与抽象\n\n封装和抽象作为两个非常通用的设计思想，可以应用在很多设计场景中，比如系统、模块、lib、组件、接口、类等等的设计。封装和抽象可以有效地隐藏实现的复杂性，隔离实现的易变性，给依赖的模块提供稳定且易用的抽象接口\n\n\n\n> 中间层\n\n引入中间层能简化模块或类之间的依赖关系。下面这张图是引入中间层前后的依赖关系对比图。在引入数据存储中间层之前，A、B、C 三个模块都要依赖内存一级缓存、Redis 二级缓存、DB 持久化存储三个模块。在引入中间层之后，三个模块只需要依赖数据存储一个模块即可。从图上可以看出，中间层的引入明显地简化了依赖关系，让代码结构更加清晰\n\n\n\n<img src=\"https://npm.elemecdn.com/youthlql@1.0.0/design_patterns/design_ideas/0003.png\"/>\n\n\n\n除此之外，我们在进行重构的时候，引入中间层可以起到过渡的作用，能够让开发和重构同步进行，不互相干扰。比如，某个接口设计得有问题，我们需要修改它的定义，同时，所有调用这个接口的代码都要做相应的改动。如果新开发的代码也用到这个接口，那开发就跟重构冲突了。为了让重构能小步快跑，我们可以分下面四个阶段来完成接口的修改。\n\n\n\n- 第一阶段：引入一个中间层，包裹老的接口，提供新的接口定义。\n- 第二阶段：新开发的代码依赖中间层提供的新接口。\n- 第三阶段：将依赖老接口的代码改为调用新接口。\n- 第四阶段：确保所有的代码都调用新接口之后，删除掉老的接口。\n\n这样，每个阶段的开发工作量都不会很大，都可以在很短的时间内完成。重构跟开发冲突的概率也变小了。\n\n\n\n\n\n> 模块化\n\n模块化是构建复杂系统常用的手段。不仅在软件行业，在建筑、机械制造等行业，这个手段也非常有用。对于一个大型复杂系统来说，没有人能掌控所有的细节。之所以我们能搭建出如此复杂的系统，并且能维护得了，最主要的原因就是将系统划分成各个独立的模块，让不同的人负责不同的模块，这样即便在不了解全部细节的情况下，管理者也能协调各个模块，让整个系统有效运转。\n\n\n\n\n\n>  其他设计思想和原则\n\n“高内聚、松耦合”是一个非常重要的设计思想，能够有效提高代码的可读性和可维护性，缩小功能改动导致的代码改动范围。实际上，在前面的章节中，我们已经多次提到过这个设计思想。很多设计原则都以实现代码的“高内聚、松耦合”为目的。我们来一块总结回顾一下都有哪些原则。\n\n(这里没有讲的，在后面文章里)\n\n- 单一职责原则\n\n我们前面提到，内聚性和耦合性并非独立的。高内聚会让代码更加松耦合，而实现高内聚的重要指导原则就是单一职责原则。模块或者类的职责设计得单一，而不是大而全，那依赖它的类和它依赖的类就会比较少，代码耦合也就相应的降低了。\n\n\n\n- 基于接口而非实现编程\n\n基于接口而非实现编程能通过接口这样一个中间层，隔离变化和具体的实现。这样做的好处是，在有依赖关系的两个模块或类之间，一个模块或者类的改动，不会影响到另一个模块或类。实际上，这就相当于将一种强依赖关系（强耦合）解耦为了弱依赖关系（弱耦合）。依赖注入\n\n\n\n- 依赖注入\n\n跟基于接口而非实现编程思想类似，依赖注入也是将代码之间的强耦合变为弱耦合。尽管依赖注入无法将本应该有依赖关系的两个类，解耦为没有依赖关系，但可以让耦合关系没那么紧密，容易做到插拔替换\n\n\n\n- 多用组合少用继承\n\n我们知道，继承是一种强依赖关系，父类与子类高度耦合，且这种耦合关系非常脆弱，牵一发而动全身，父类的每一次改动都会影响所有的子类。相反，组合关系是一种弱依赖关系，这种关系更加灵活，所以，对于继承结构比较复杂的代码，利用组合来替换继承，也是一种解耦的有效手段。\n\n\n\n- 迪米特法则\n\n迪米特法则讲的是，不该有直接依赖关系的类之间，不要有依赖；有依赖关系的类之间，尽量只依赖必要的接口。从定义上，我们明显可以看出，这条原则的目的就是为了实现代码的松耦合。至于如何应用这条原则来解耦代码，你可以回过头去阅读一下第 22 讲，这里我就不赘述了。除了上面讲到的这些设计思想和原则之外，还有一些设计模式也是为了解耦依赖，比如观察者模式，有关这一部分的内容，我们留在设计模式模块中慢慢讲解。\n\n\n\n","source":"_posts/2024-04-21-设计模式-01.设计思想.md","raw":"---\ntitle: 设计模式-01.设计思想\ntags:\n  - 设计模式\n  - 设计思想\ncategories:\n  - 设计模式\n  - 01.设计思想\nkeywords: 设计模式，设计思想\ndescription: 设计模式第一部分-常用设计思想。\ncover: 'https://npm.elemecdn.com/lql_static@latest/logo/design_patterns.jpg'\nabbrlink: c3dcce5d\ndate: 2024-04-21 23:22:58\n---\n\n# 声明\n\n> 1. 此系列文章非本人原创，是学习笔记。\n> 2. 设计模式系列以后会持续更新，包括已经发布的设计模式文章，因为后续还要再多看一下书，教程和开源项目等，继续润色文章。\n\n下面讲一些常见的设计思想\n\n## 基于接口而非实现编程\n\n这个原则非常重要，是一种非常有效的提高代码质量的手段，在平时的开发中特别经常被用到。\n\n### 如何解读原则中的“接口”二字？\n\n1. “基于接口而非实现编程”这条原则的英文描述是：“Program to an interface, not an implementation”。我们理解这条原则的时候，千万不要一开始就与具体的编程语言挂钩，局限在编程语言的“接口”语法中（比如 Java 中的 interface 接口语法）。这条原则最早出现于 1994 年 GoF 的《设计模式》这本书，它先于很多编程语言而诞生（比如 Java 语言），是一条比较抽象、泛化的设计思想。\n2. 实际上，理解这条原则的关键，就是理解其中的“接口”两个字。还记得我们上一节课讲的“接口”的定义吗？从本质上来看，“接口”就是一组“协议”或者“约定”，是功能提供者提供给使用者的一个“功能列表”。“接口”在不同的应用场景下会有不同的解读，比如服务端与客户端之间的“接口”，类库提供的“接口”，甚至是一组通信的协议都可以叫作“接口”。刚刚对“接口”的理解，都比较偏上层、偏抽象，与实际的写代码离得有点远。如果落实到具体的编码，“基于接口而非实现编程”这条原则中的“接口”，可以理解为编程语言中的接口或者抽象类。\n3. 前面我们提到，这条原则能非常有效地提高代码质量，之所以这么说，那是因为，应用这条原则，可以将接口和实现相分离，封装不稳定的实现，暴露稳定的接口。上游系统面向接口而非实现编程，不依赖不稳定的实现细节，这样当实现发生变化的时候，上游系统的代码基本上不需要做改动，以此来降低耦合性，提高扩展性。\n4. 实际上，“基于接口而非实现编程”这条原则的另一个表述方式，是“基于抽象而非实现编程”。后者的表述方式其实更能体现这条原则的设计初衷。在软件开发中，最大的挑战之一就是需求的不断变化，这也是考验代码设计好坏的一个标准。**越抽象、越顶层、越脱离具体某一实现的设计，越能提高代码的灵活性，越能应对未来的需求变化。好的代码设计，不仅能应对当下的需求，而且在将来需求发生变化的时候，仍然能够在不破坏原有代码设计的情况下灵活应对**。而抽象就是提高代码扩展性、灵活性、可维护性最有效的手段之一。\n\n\n\n### 如何将这条原则应用到实战中？\n\n假设我们的系统中有很多涉及图片处理和存储的业务逻辑。图片经过处理之后被上传到阿里云上。为了代码复用，我们封装了图片存储相关的代码逻辑，提供了一个统一的 AliyunImageStore 类，供整个系统来使用。具体的代码实现如下所示：\n\n```java\npublic class AliyunImageStore {\n  //...省略属性、构造函数等...\n  \n  public void createBucketIfNotExisting(String bucketName) {\n    // ...创建bucket代码逻辑...\n    // ...失败会抛出异常..\n  }\n  \n  public String generateAccessToken() {\n    // ...根据accesskey/secrectkey等生成access token\n  }\n  \n  public String uploadToAliyun(Image image, String bucketName, String accessToken) {\n    //...上传图片到阿里云...\n    //...返回图片存储在阿里云上的地址(url）...\n  }\n  \n  public Image downloadFromAliyun(String url, String accessToken) {\n    //...从阿里云下载图片...\n  }\n}\n\n// AliyunImageStore类的使用举例\npublic class ImageProcessingJob {\n  private static final String BUCKET_NAME = \"ai_images_bucket\";\n  //...省略其他无关代码...\n  \n  public void process() {\n    Image image = ...; //处理图片，并封装为Image对象\n    AliyunImageStore imageStore = new AliyunImageStore(/*省略参数*/);\n    imageStore.createBucketIfNotExisting(BUCKET_NAME);\n    String accessToken = imageStore.generateAccessToken();\n    imagestore.uploadToAliyun(image, BUCKET_NAME, accessToken);\n  }\n  \n}\n```\n\n\n\n1. 整个上传流程包含三个步骤：创建 bucket（你可以简单理解为存储目录）、生成 access token 访问凭证、携带 access token 上传图片到指定的 bucket 中。代码实现非常简单，类中的几个方法定义得都很干净，用起来也很清晰，乍看起来没有太大问题，完全能满足我们将图片存储在阿里云的业务需求。\n2. 不过，软件开发中唯一不变的就是变化。过了一段时间后，我们自建了私有云，不再将图片存储到阿里云了，而是将图片存储到自建私有云上。为了满足这样一个需求的变化，我们该如何修改代码呢？\n3. 我们需要重新设计实现一个存储图片到私有云的 PrivateImageStore 类，并用它替换掉项目中所有的 AliyunImageStore 类对象。这样的修改听起来并不复杂，只是简单替换而已，对整个代码的改动并不大。不过，我们经常说，“细节是魔鬼”。这句话在软件开发中特别适用。实际上，刚刚的设计实现方式，就隐藏了很多容易出问题的“魔鬼细节”，我们一块来看看都有哪些。\n4. 新的 PrivateImageStore 类需要设计实现哪些方法，才能在尽量最小化代码修改的情况下，替换掉 AliyunImageStore 类呢？这就要求我们必须将 AliyunImageStore 类中所定义的所有 public 方法，在 PrivateImageStore 类中都逐一定义并重新实现一遍。而这样做就会存在一些问题，我总结了下面两点。\n   - 首先，AliyunImageStore 类中有些函数命名暴露了实现细节，比如，uploadToAliyun() 和 downloadFromAliyun()。如果开发这个功能的同事没有接口意识、抽象思维，那这种暴露实现细节的命名方式就不足为奇了，毕竟最初我们只考虑将图片存储在阿里云上。而我们把这种包含“aliyun”字眼的方法，照抄到 PrivateImageStore 类中，显然是不合适的。如果我们在新类中重新命名 uploadToAliyun()、downloadFromAliyun() 这些方法，那就意味着，我们要修改项目中所有使用到这两个方法的代码，代码修改量可能就会很大。\n   - 其次，将图片存储到阿里云的流程，跟存储到私有云的流程，可能并不是完全一致的。比如，阿里云的图片上传和下载的过程中，需要生产 access token，而私有云不需要 access token。一方面，AliyunImageStore 中定义的 generateAccessToken() 方法不能照抄到 PrivateImageStore 中；另一方面，我们在使用 AliyunImageStore 上传、下载图片的时候，代码中用到了 generateAccessToken() 方法，如果要改为私有云的上传下载流程，这些代码都需要做调整。\n5. 那这两个问题该如何解决呢？解决这个问题的根本方法就是，在编写代码的时候，要遵从“基于接口而非实现编程”的原则，具体来讲，我们需要做到下面这 3 点。\n   1. 函数的命名不能暴露任何实现细节。比如，前面提到的 uploadToAliyun() 就不符合要求，应该改为去掉 aliyun 这样的字眼，改为更加抽象的命名方式，比如：upload()。\n   2. 封装具体的实现细节。比如，跟阿里云相关的特殊上传（或下载）流程不应该暴露给调用者。我们对上传（或下载）流程进行封装，对外提供一个包裹所有上传（或下载）细节的方法，给调用者使用。\n   3. 为实现类定义抽象的接口。具体的实现类都依赖统一的接口定义，遵从一致的上传功能协议。使用者依赖接口，而不是具体的实现类来编程。\n6. 我们按照这个思路，把代码重构一下。重构后的代码如下所示：\n\n```java\npublic interface ImageStore {\n  String upload(Image image, String bucketName);\n  Image download(String url);\n}\n\npublic class AliyunImageStore implements ImageStore {\n  //...省略属性、构造函数等...\n\n  public String upload(Image image, String bucketName) {\n    createBucketIfNotExisting(bucketName);\n    String accessToken = generateAccessToken();\n    //...上传图片到阿里云...\n    //...返回图片在阿里云上的地址(url)...\n  }\n\n  public Image download(String url) {\n    String accessToken = generateAccessToken();\n    //...从阿里云下载图片...\n  }\n\n  private void createBucketIfNotExisting(String bucketName) {\n    // ...创建bucket...\n    // ...失败会抛出异常..\n  }\n\n  private String generateAccessToken() {\n    // ...根据accesskey/secrectkey等生成access token\n  }\n}\n\n// 上传下载流程改变：私有云不需要支持access token\npublic class PrivateImageStore implements ImageStore  {\n  public String upload(Image image, String bucketName) {\n    createBucketIfNotExisting(bucketName);\n    //...上传图片到私有云...\n    //...返回图片的url...\n  }\n\n  public Image download(String url) {\n    //...从私有云下载图片...\n  }\n\n  private void createBucketIfNotExisting(String bucketName) {\n    // ...创建bucket...\n    // ...失败会抛出异常..\n  }\n}\n\n// ImageStore的使用举例\npublic class ImageProcessingJob {\n  private static final String BUCKET_NAME = \"ai_images_bucket\";\n  //...省略其他无关代码...\n  \n  public void process() {\n    Image image = ...;//处理图片，并封装为Image对象\n    ImageStore imageStore = new PrivateImageStore(...);\n    imagestore.upload(image, BUCKET_NAME);\n  }\n}\n```\n\n1. 除此之外，很多人在定义接口的时候，希望通过实现类来反推接口的定义。先把实现类写好，然后看实现类中有哪些方法，照抄到接口定义中。如果按照这种思考方式，就有可能导致接口定义不够抽象，依赖具体的实现。这样的接口设计就没有意义了。不过，如果你觉得这种思考方式更加顺畅，那也没问题，只是将实现类的方法搬移到接口定义中的时候，要有选择性的搬移，不要将跟具体实现相关的方法搬移到接口中，比如 AliyunImageStore 中的 generateAccessToken() 方法。\n2. 总结一下，我们在做软件开发的时候，一定要有抽象意识、封装意识、接口意识。在定义接口的时候，不要暴露任何实现细节。接口的定义只表明做什么，而不是怎么做。而且，在设计接口的时候，我们要多思考一下，这样的接口设计是否足够通用，是否能够做到在替换具体的接口实现的时候，不需要任何接口定义的改动。\n\n\n\n### 是否需要为每个类定义接口？\n\n1. 看了刚刚的讲解，你可能会有这样的疑问：为了满足这条原则，我是不是需要给每个实现类都定义对应的接口呢？在开发的时候，是不是任何代码都要只依赖接口，完全不依赖实现编程呢？\n2. 做任何事情都要讲求一个“度”，过度使用这条原则，非得给每个类都定义接口，接口满天飞，也会导致不必要的开发负担。至于什么时候，该为某个类定义接口，实现基于接口的编程，什么时候不需要定义接口，直接使用实现类编程，我们做权衡的根本依据，还是要回归到设计原则诞生的初衷上来。只要搞清楚了这条原则是为了解决什么样的问题而产生的，你就会发现，很多之前模棱两可的问题，都会变得豁然开朗。\n3. 前面我们也提到，这条原则的设计初衷是，将接口和实现相分离，封装不稳定的实现，暴露稳定的接口。上游系统面向接口而非实现编程，不依赖不稳定的实现细节，这样当实现发生变化的时候，上游系统的代码基本上不需要做改动，以此来降低代码间的耦合性，提高代码的扩展性。\n4. 从这个设计初衷上来看，如果在我们的业务场景中，某个功能只有一种实现方式，未来也不可能被其他实现方式替换，那我们就没有必要为其设计接口，也没有必要基于接口编程，直接使用实现类就可以了。\n5. 除此之外，越是不稳定的系统，我们越是要在代码的扩展性、维护性上下功夫。相反，如果某个系统特别稳定，在开发完之后，基本上不需要做维护，那我们就没有必要为其扩展性，投入不必要的开发时间。\n\n\n\n## 多用组合少用继承\n\n在面向对象编程中，有一条非常经典的设计原则，那就是：组合优于继承，多用组合少用继承。为什么不推荐使用继承？组合相比继承有哪些优势？如何判断该用组合还是继承？今天，我们就围绕着这三个问题，来详细讲解一下这条设计原则。\n\n\n\n\n\n### 为什么不推荐使用继承？\n\n1. 继承是面向对象的四大特性之一，用来表示类之间的 is-a 关系，可以解决代码复用的问题。虽然继承有诸多作用，但继承层次过深、过复杂，也会影响到代码的可维护性。所以，对于是否应该在项目中使用继承，网上有很多争议。很多人觉得继承是一种反模式，应该尽量少用，甚至不用。为什么会有这样的争议？我们通过一个例子来解释一下。\n2. 假设我们要设计一个关于鸟的类。我们将“鸟类”这样一个抽象的事物概念，定义为一个抽象类 AbstractBird。所有更细分的鸟，比如麻雀、鸽子、乌鸦等，都继承这个抽象类。\n3. 我们知道，大部分鸟都会飞，那我们可不可以在 AbstractBird 抽象类中，定义一个 fly() 方法呢？答案是否定的。尽管大部分鸟都会飞，但也有特例，比如鸵鸟就不会飞。鸵鸟继承具有 fly() 方法的父类，那鸵鸟就具有“飞”这样的行为，这显然不符合我们对现实世界中事物的认识。当然，你可能会说，我在鸵鸟这个子类中重写（override）fly() 方法，让它抛出 UnSupportedMethodException 异常不就可以了吗？具体的代码实现如下所示：\n\n```java\npublic class AbstractBird {\n  //...省略其他属性和方法...\n  public void fly() { //... }\n}\n\npublic class Ostrich extends AbstractBird { //鸵鸟\n  //...省略其他属性和方法...\n  public void fly() {\n    throw new UnSupportedMethodException(\"I can't fly.'\");\n  }\n}\n```\n\n1. 这种设计思路虽然可以解决问题，但不够优美。因为除了鸵鸟之外，不会飞的鸟还有很多，比如企鹅。对于这些不会飞的鸟来说，我们都需要重写 fly() 方法，抛出异常。这样的设计，一方面，徒增了编码的工作量；另一方面，也违背了我们之后要讲的最小知识原则（Least Knowledge Principle，也叫最少知识原则或者迪米特法则），暴露不该暴露的接口给外部，增加了类使用过程中被误用的概率。\n2. 你可能又会说，那我们再通过 AbstractBird 类派生出两个更加细分的抽象类：会飞的鸟类 AbstractFlyableBird 和不会飞的鸟类 AbstractUnFlyableBird，让麻雀、乌鸦这些会飞的鸟都继承 AbstractFlyableBird，让鸵鸟、企鹅这些不会飞的鸟，都继承 AbstractUnFlyableBird 类，不就可以了吗？具体的继承关系如下图所示：\n\n<img src=\"https://npm.elemecdn.com/youthlql@1.0.0/design_patterns/design_ideas/0001.png\"/>\n\n\n\n1. 从图中我们可以看出，继承关系变成了三层。不过，整体上来讲，目前的继承关系还比较简单，层次比较浅，也算是一种可以接受的设计思路。我们再继续加点难度。在刚刚这个场景中，我们只关注“鸟会不会飞”，但如果我们还关注“鸟会不会叫”，那这个时候，我们又该如何设计类之间的继承关系呢？\n\n2. 是否会飞？是否会叫？两个行为搭配起来会产生四种情况：会飞会叫、不会飞会叫、会飞不会叫、不会飞不会叫。如果我们继续沿用刚才的设计思路，那就需要再定义四个抽象类（AbstractFlyableTweetableBird、AbstractFlyableUnTweetableBird、AbstractUnFlyableTweetableBird、AbstractUnFlyableUnTweetableBird）。\n\n<img src=\"https://npm.elemecdn.com/youthlql@1.0.0/design_patterns/design_ideas/0002.png\"/>\n\n\n\n1. 如果我们还需要考虑“是否会下蛋”这样一个行为，那估计就要组合爆炸了。类的继承层次会越来越深、继承关系会越来越复杂。而这种层次很深、很复杂的继承关系，一方面，会导致代码的可读性变差。因为我们要搞清楚某个类具有哪些方法、属性，必须阅读父类的代码、父类的父类的代码……一直追溯到最顶层父类的代码。另一方面，这也破坏了类的封装特性，将父类的实现细节暴露给了子类。子类的实现依赖父类的实现，两者高度耦合，一旦父类代码修改，就会影响所有子类的逻辑。\n2. 总之，继承最大的问题就在于：继承层次过深、继承关系过于复杂会影响到代码的可读性和可维护性。这也是为什么我们不推荐使用继承。那刚刚例子中继承存在的问题，我们又该如何来解决呢？你可以先自己思考一下，再听我下面的讲解。\n\n\n\n### 组合相比继承有哪些优势？\n\n1. 实际上，我们可以利用组合（composition）、接口、委托（delegation）三个技术手段，一块儿来解决刚刚继承存在的问题。\n2. 接口表示具有某种行为特性。针对“会飞”这样一个行为特性，我们可以定义一个 Flyable 接口，只让会飞的鸟去实现这个接口。对于会叫、会下蛋这些行为特性，我们可以类似地定义 Tweetable 接口、EggLayable 接口。我们将这个设计思路翻译成 Java 代码的话，就是下面这个样子：\n\n```java\npublic interface Flyable {\n  void fly();\n}\npublic interface Tweetable {\n  void tweet();\n}\npublic interface EggLayable {\n  void layEgg();\n}\npublic class Ostrich implements Tweetable, EggLayable {//鸵鸟\n  //... 省略其他属性和方法...\n  @Override\n  public void tweet() { //... }\n  @Override\n  public void layEgg() { //... }\n}\npublic class Sparrow impelents Flyable, Tweetable, EggLayable {//麻雀\n  //... 省略其他属性和方法...\n  @Override\n  public void fly() { //... }\n  @Override\n  public void tweet() { //... }\n  @Override\n  public void layEgg() { //... }\n}\n```\n\n1. 不过，我们知道，接口只声明方法，不定义实现。也就是说，每个会下蛋的鸟都要实现一遍 layEgg() 方法，并且实现逻辑是一样的，这就会导致代码重复的问题。那这个问题又该如何解决呢？\n2. 我们可以针对三个接口再定义三个实现类，它们分别是：实现了 fly() 方法的 FlyAbility 类、实现了 tweet() 方法的 TweetAbility 类、实现了 layEgg() 方法的 EggLayAbility 类。然后，通过组合和委托技术来消除代码重复。具体的代码实现如下所示：\n\n```java\npublic interface Flyable {\n  void fly()；\n}\npublic class FlyAbility implements Flyable {\n  @Override\n  public void fly() { //... }\n}\n//省略Tweetable/TweetAbility/EggLayable/EggLayAbility\n\npublic class Ostrich implements Tweetable, EggLayable {//鸵鸟\n  private TweetAbility tweetAbility = new TweetAbility(); //组合\n  private EggLayAbility eggLayAbility = new EggLayAbility(); //组合\n  //... 省略其他属性和方法...\n  @Override\n  public void tweet() {\n    tweetAbility.tweet(); // 委托\n  }\n  @Override\n  public void layEgg() {\n    eggLayAbility.layEgg(); // 委托\n  }\n}\n```\n\n\n\n我们知道继承主要有三个作用：表示 is-a 关系，支持多态特性，代码复用。而这三个作用都可以通过其他技术手段来达成。比如 is-a 关系，我们可以通过组合和接口的 has-a 关系来替代；多态特性我们可以利用接口来实现；代码复用我们可以通过组合和委托来实现。所以，从理论上讲，通过组合、接口、委托三个技术手段，我们完全可以替换掉继承，在项目中不用或者少用继承关系，特别是一些复杂的继承关系。\n\n\n\n### 如何判断该用组合还是继承？\n\n1. 尽管我们鼓励多用组合少用继承，但组合也并不是完美的，继承也并非一无是处。从上面的例子来看，继承改写成组合意味着要做更细粒度的类的拆分。这也就意味着，我们要定义更多的类和接口。类和接口的增多也就或多或少地增加代码的复杂程度和维护成本。所以，在实际的项目开发中，我们还是要根据具体的情况，来具体选择该用继承还是组合。\n2. 如果类之间的继承结构稳定（不会轻易改变），继承层次比较浅（比如，最多有两层继承关系），继承关系不复杂，我们就可以大胆地使用继承。反之，系统越不稳定，继承层次很深，继承关系复杂，我们就尽量使用组合来替代继承。\n3. 除此之外，还有一些设计模式会固定使用继承或者组合。比如，装饰者模式（decorator pattern）、策略模式（strategy pattern）、组合模式（composite pattern）等都使用了组合关系，而模板模式（template pattern）使用了继承关系。\n4. 前面我们讲到继承可以实现代码复用。利用继承特性，我们把相同的属性和方法，抽取出来，定义到父类中。子类复用父类中的属性和方法，达到代码复用的目的。但是，有的时候，从业务含义上，A 类和 B 类并不一定具有继承关系。比如，Crawler 类和 PageAnalyzer 类，它们都用到了 URL 拼接和分割的功能，但并不具有继承关系（既不是父子关系，也不是兄弟关系）。仅仅为了代码复用，生硬地抽象出一个父类出来，会影响到代码的可读性。如果不熟悉背后设计思路的同事，发现 Crawler 类和 PageAnalyzer 类继承同一个父类，而父类中定义的却只是 URL 相关的操作，会觉得这个代码写得莫名其妙，理解不了。这个时候，使用组合就更加合理、更加灵活。具体的代码实现如下所示：\n\n```java\npublic class Url {\n  //...省略属性和方法\n}\n\npublic class Crawler {\n  private Url url; // 组合\n  public Crawler() {\n    this.url = new Url();\n  }\n  //...\n}\n\npublic class PageAnalyzer {\n  private Url url; // 组合\n  public PageAnalyzer() {\n    this.url = new Url();\n  }\n  //..\n}\n```\n\n\n\n还有一些特殊的场景要求我们必须使用继承。如果你不能改变一个函数的入参类型，而入参又非接口，为了支持多态，只能采用继承来实现。比如下面这样一段代码，其中 FeignClient 是一个外部类，我们没有权限去修改这部分代码，但是我们希望能重写这个类在运行时执行的 encode() 函数。这个时候，我们只能采用继承来实现了。\n\n\n\n```java\npublic class FeignClient { // Feign Client框架代码\n  //...省略其他代码...\n  public void encode(String url) { //... }\n}\n\npublic void demofunction(FeignClient feignClient) {\n  //...\n  feignClient.encode(url);\n  //...\n}\n\npublic class CustomizedFeignClient extends FeignClient {\n  @Override\n  public void encode(String url) { //...重写encode的实现...}\n}\n\n// 调用\nFeignClient client = new CustomizedFeignClient();\ndemofunction(client);\n```\n\n尽管有些人说，要杜绝继承，100% 用组合代替继承，但是我的观点没那么极端！之所以“多用组合少用继承”这个口号喊得这么响，只是因为，长期以来，我们过度使用继承。还是那句话，组合并不完美，继承也不是一无是处。只要我们控制好它们的副作用、发挥它们各自的优势，在不同的场合下，恰当地选择使用继承还是组合，这才是我们所追求的境界。\n\n\n\n\n\n## 如何通过封装、抽象、模块化、中间层等解耦代码？\n\n### “解耦”为何如此重要？\n\n1. 软件设计与开发最重要的工作之一就是应对复杂性。人处理复杂性的能力是有限的。过于复杂的代码往往在可读性、可维护性上都不友好。那如何来控制代码的复杂性呢？手段有很多，我个人认为，最关键的就是解耦，保证代码松耦合、高内聚。如果说重构是保证代码质量不至于腐化到无可救药地步的有效手段，那么利用解耦的方法对代码重构，就是保证代码不至于复杂到无法控制的有效手段。\n2. 后文迪米特法则有介绍，什么是“高内聚、松耦合”。。实际上，“高内聚、松耦合”是一个比较通用的设计思想，不仅可以指导细粒度的类和类之间关系的设计，还能指导粗粒度的系统、架构、模块的设计。相对于编码规范，它能够在更高层次上提高代码的可读性和可维护性。\n3. 不管是阅读代码还是修改代码，“高内聚、松耦合”的特性可以让我们聚焦在某一模块或类中，不需要了解太多其他模块或类的代码，让我们的焦点不至于过于发散，降低了阅读和修改代码的难度。而且，因为依赖关系简单，耦合小，修改代码不至于牵一发而动全身，代码改动比较集中，引入 bug 的风险也就减少了很多。同时，“高内聚、松耦合”的代码可测试性也更加好，容易 mock 或者很少需要 mock 外部依赖的模块或者类。\n4. 除此之外，代码“高内聚、松耦合”，也就意味着，代码结构清晰、分层和模块化合理、依赖关系简单、模块或类之间的耦合小，那代码整体的质量就不会差。即便某个具体的类或者模块设计得不怎么合理，代码质量不怎么高，影响的范围是非常有限的。我们可以聚焦于这个模块或者类，做相应的小型重构。而相对于代码结构的调整，这种改动范围比较集中的小型重构的难度就容易多了。\n\n\n\n### 代码是否需要“解耦”？\n\n1. 那现在问题来了，我们该怎么判断代码的耦合程度呢？或者说，怎么判断代码是否符合“高内聚、松耦合”呢？再或者说，如何判断系统是否需要解耦重构呢？\n2. 间接的衡量标准有很多，前面我们讲到了一些，比如，看修改代码会不会牵一发而动全身。除此之外，还有一个直接的衡量标准，也是我在阅读源码的时候经常会用到的，那就是把模块与模块之间、类与类之间的依赖关系画出来，根据依赖关系图的复杂性来判断是否需要解耦重构。\n3. 如果依赖关系复杂、混乱，那从代码结构上来讲，可读性和可维护性肯定不是太好，那我们就需要考虑是否可以通过解耦的方法，让依赖关系变得清晰、简单。当然，这种判断还是有比较强的主观色彩，但是可以作为一种参考和梳理依赖的手段，配合间接的衡量标准一块来使用。\n\n### 如何给代码“解耦”？\n\n>  封装与抽象\n\n封装和抽象作为两个非常通用的设计思想，可以应用在很多设计场景中，比如系统、模块、lib、组件、接口、类等等的设计。封装和抽象可以有效地隐藏实现的复杂性，隔离实现的易变性，给依赖的模块提供稳定且易用的抽象接口\n\n\n\n> 中间层\n\n引入中间层能简化模块或类之间的依赖关系。下面这张图是引入中间层前后的依赖关系对比图。在引入数据存储中间层之前，A、B、C 三个模块都要依赖内存一级缓存、Redis 二级缓存、DB 持久化存储三个模块。在引入中间层之后，三个模块只需要依赖数据存储一个模块即可。从图上可以看出，中间层的引入明显地简化了依赖关系，让代码结构更加清晰\n\n\n\n<img src=\"https://npm.elemecdn.com/youthlql@1.0.0/design_patterns/design_ideas/0003.png\"/>\n\n\n\n除此之外，我们在进行重构的时候，引入中间层可以起到过渡的作用，能够让开发和重构同步进行，不互相干扰。比如，某个接口设计得有问题，我们需要修改它的定义，同时，所有调用这个接口的代码都要做相应的改动。如果新开发的代码也用到这个接口，那开发就跟重构冲突了。为了让重构能小步快跑，我们可以分下面四个阶段来完成接口的修改。\n\n\n\n- 第一阶段：引入一个中间层，包裹老的接口，提供新的接口定义。\n- 第二阶段：新开发的代码依赖中间层提供的新接口。\n- 第三阶段：将依赖老接口的代码改为调用新接口。\n- 第四阶段：确保所有的代码都调用新接口之后，删除掉老的接口。\n\n这样，每个阶段的开发工作量都不会很大，都可以在很短的时间内完成。重构跟开发冲突的概率也变小了。\n\n\n\n\n\n> 模块化\n\n模块化是构建复杂系统常用的手段。不仅在软件行业，在建筑、机械制造等行业，这个手段也非常有用。对于一个大型复杂系统来说，没有人能掌控所有的细节。之所以我们能搭建出如此复杂的系统，并且能维护得了，最主要的原因就是将系统划分成各个独立的模块，让不同的人负责不同的模块，这样即便在不了解全部细节的情况下，管理者也能协调各个模块，让整个系统有效运转。\n\n\n\n\n\n>  其他设计思想和原则\n\n“高内聚、松耦合”是一个非常重要的设计思想，能够有效提高代码的可读性和可维护性，缩小功能改动导致的代码改动范围。实际上，在前面的章节中，我们已经多次提到过这个设计思想。很多设计原则都以实现代码的“高内聚、松耦合”为目的。我们来一块总结回顾一下都有哪些原则。\n\n(这里没有讲的，在后面文章里)\n\n- 单一职责原则\n\n我们前面提到，内聚性和耦合性并非独立的。高内聚会让代码更加松耦合，而实现高内聚的重要指导原则就是单一职责原则。模块或者类的职责设计得单一，而不是大而全，那依赖它的类和它依赖的类就会比较少，代码耦合也就相应的降低了。\n\n\n\n- 基于接口而非实现编程\n\n基于接口而非实现编程能通过接口这样一个中间层，隔离变化和具体的实现。这样做的好处是，在有依赖关系的两个模块或类之间，一个模块或者类的改动，不会影响到另一个模块或类。实际上，这就相当于将一种强依赖关系（强耦合）解耦为了弱依赖关系（弱耦合）。依赖注入\n\n\n\n- 依赖注入\n\n跟基于接口而非实现编程思想类似，依赖注入也是将代码之间的强耦合变为弱耦合。尽管依赖注入无法将本应该有依赖关系的两个类，解耦为没有依赖关系，但可以让耦合关系没那么紧密，容易做到插拔替换\n\n\n\n- 多用组合少用继承\n\n我们知道，继承是一种强依赖关系，父类与子类高度耦合，且这种耦合关系非常脆弱，牵一发而动全身，父类的每一次改动都会影响所有的子类。相反，组合关系是一种弱依赖关系，这种关系更加灵活，所以，对于继承结构比较复杂的代码，利用组合来替换继承，也是一种解耦的有效手段。\n\n\n\n- 迪米特法则\n\n迪米特法则讲的是，不该有直接依赖关系的类之间，不要有依赖；有依赖关系的类之间，尽量只依赖必要的接口。从定义上，我们明显可以看出，这条原则的目的就是为了实现代码的松耦合。至于如何应用这条原则来解耦代码，你可以回过头去阅读一下第 22 讲，这里我就不赘述了。除了上面讲到的这些设计思想和原则之外，还有一些设计模式也是为了解耦依赖，比如观察者模式，有关这一部分的内容，我们留在设计模式模块中慢慢讲解。\n\n\n\n","slug":"2024-04-21-设计模式-01.设计思想","published":1,"updated":"2024-05-01T05:29:39.556Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clxjyo3cb000lisvddzkx05s0","content":"<h1 id=\"声明\"><a href=\"#声明\" class=\"headerlink\" title=\"声明\"></a>声明</h1><blockquote>\n<ol>\n<li>此系列文章非本人原创，是学习笔记。</li>\n<li>设计模式系列以后会持续更新，包括已经发布的设计模式文章，因为后续还要再多看一下书，教程和开源项目等，继续润色文章。</li>\n</ol>\n</blockquote>\n<p>下面讲一些常见的设计思想</p>\n<h2 id=\"基于接口而非实现编程\"><a href=\"#基于接口而非实现编程\" class=\"headerlink\" title=\"基于接口而非实现编程\"></a>基于接口而非实现编程</h2><p>这个原则非常重要，是一种非常有效的提高代码质量的手段，在平时的开发中特别经常被用到。</p>\n<h3 id=\"如何解读原则中的“接口”二字？\"><a href=\"#如何解读原则中的“接口”二字？\" class=\"headerlink\" title=\"如何解读原则中的“接口”二字？\"></a>如何解读原则中的“接口”二字？</h3><ol>\n<li>“基于接口而非实现编程”这条原则的英文描述是：“Program to an interface, not an implementation”。我们理解这条原则的时候，千万不要一开始就与具体的编程语言挂钩，局限在编程语言的“接口”语法中（比如 Java 中的 interface 接口语法）。这条原则最早出现于 1994 年 GoF 的《设计模式》这本书，它先于很多编程语言而诞生（比如 Java 语言），是一条比较抽象、泛化的设计思想。</li>\n<li>实际上，理解这条原则的关键，就是理解其中的“接口”两个字。还记得我们上一节课讲的“接口”的定义吗？从本质上来看，“接口”就是一组“协议”或者“约定”，是功能提供者提供给使用者的一个“功能列表”。“接口”在不同的应用场景下会有不同的解读，比如服务端与客户端之间的“接口”，类库提供的“接口”，甚至是一组通信的协议都可以叫作“接口”。刚刚对“接口”的理解，都比较偏上层、偏抽象，与实际的写代码离得有点远。如果落实到具体的编码，“基于接口而非实现编程”这条原则中的“接口”，可以理解为编程语言中的接口或者抽象类。</li>\n<li>前面我们提到，这条原则能非常有效地提高代码质量，之所以这么说，那是因为，应用这条原则，可以将接口和实现相分离，封装不稳定的实现，暴露稳定的接口。上游系统面向接口而非实现编程，不依赖不稳定的实现细节，这样当实现发生变化的时候，上游系统的代码基本上不需要做改动，以此来降低耦合性，提高扩展性。</li>\n<li>实际上，“基于接口而非实现编程”这条原则的另一个表述方式，是“基于抽象而非实现编程”。后者的表述方式其实更能体现这条原则的设计初衷。在软件开发中，最大的挑战之一就是需求的不断变化，这也是考验代码设计好坏的一个标准。<strong>越抽象、越顶层、越脱离具体某一实现的设计，越能提高代码的灵活性，越能应对未来的需求变化。好的代码设计，不仅能应对当下的需求，而且在将来需求发生变化的时候，仍然能够在不破坏原有代码设计的情况下灵活应对</strong>。而抽象就是提高代码扩展性、灵活性、可维护性最有效的手段之一。</li>\n</ol>\n<h3 id=\"如何将这条原则应用到实战中？\"><a href=\"#如何将这条原则应用到实战中？\" class=\"headerlink\" title=\"如何将这条原则应用到实战中？\"></a>如何将这条原则应用到实战中？</h3><p>假设我们的系统中有很多涉及图片处理和存储的业务逻辑。图片经过处理之后被上传到阿里云上。为了代码复用，我们封装了图片存储相关的代码逻辑，提供了一个统一的 AliyunImageStore 类，供整个系统来使用。具体的代码实现如下所示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AliyunImageStore</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">//...省略属性、构造函数等...</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">createBucketIfNotExisting</span><span class=\"params\">(String bucketName)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...创建bucket代码逻辑...</span></span><br><span class=\"line\">    <span class=\"comment\">// ...失败会抛出异常..</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">public</span> String <span class=\"title function_\">generateAccessToken</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...根据accesskey/secrectkey等生成access token</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">public</span> String <span class=\"title function_\">uploadToAliyun</span><span class=\"params\">(Image image, String bucketName, String accessToken)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//...上传图片到阿里云...</span></span><br><span class=\"line\">    <span class=\"comment\">//...返回图片存储在阿里云上的地址(url）...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">public</span> Image <span class=\"title function_\">downloadFromAliyun</span><span class=\"params\">(String url, String accessToken)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//...从阿里云下载图片...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// AliyunImageStore类的使用举例</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ImageProcessingJob</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">String</span> <span class=\"variable\">BUCKET_NAME</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;ai_images_bucket&quot;</span>;</span><br><span class=\"line\">  <span class=\"comment\">//...省略其他无关代码...</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">process</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">Image</span> <span class=\"variable\">image</span> <span class=\"operator\">=</span> ...; <span class=\"comment\">//处理图片，并封装为Image对象</span></span><br><span class=\"line\">    <span class=\"type\">AliyunImageStore</span> <span class=\"variable\">imageStore</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">AliyunImageStore</span>(<span class=\"comment\">/*省略参数*/</span>);</span><br><span class=\"line\">    imageStore.createBucketIfNotExisting(BUCKET_NAME);</span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">accessToken</span> <span class=\"operator\">=</span> imageStore.generateAccessToken();</span><br><span class=\"line\">    imagestore.uploadToAliyun(image, BUCKET_NAME, accessToken);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<ol>\n<li>整个上传流程包含三个步骤：创建 bucket（你可以简单理解为存储目录）、生成 access token 访问凭证、携带 access token 上传图片到指定的 bucket 中。代码实现非常简单，类中的几个方法定义得都很干净，用起来也很清晰，乍看起来没有太大问题，完全能满足我们将图片存储在阿里云的业务需求。</li>\n<li>不过，软件开发中唯一不变的就是变化。过了一段时间后，我们自建了私有云，不再将图片存储到阿里云了，而是将图片存储到自建私有云上。为了满足这样一个需求的变化，我们该如何修改代码呢？</li>\n<li>我们需要重新设计实现一个存储图片到私有云的 PrivateImageStore 类，并用它替换掉项目中所有的 AliyunImageStore 类对象。这样的修改听起来并不复杂，只是简单替换而已，对整个代码的改动并不大。不过，我们经常说，“细节是魔鬼”。这句话在软件开发中特别适用。实际上，刚刚的设计实现方式，就隐藏了很多容易出问题的“魔鬼细节”，我们一块来看看都有哪些。</li>\n<li>新的 PrivateImageStore 类需要设计实现哪些方法，才能在尽量最小化代码修改的情况下，替换掉 AliyunImageStore 类呢？这就要求我们必须将 AliyunImageStore 类中所定义的所有 public 方法，在 PrivateImageStore 类中都逐一定义并重新实现一遍。而这样做就会存在一些问题，我总结了下面两点。<ul>\n<li>首先，AliyunImageStore 类中有些函数命名暴露了实现细节，比如，uploadToAliyun() 和 downloadFromAliyun()。如果开发这个功能的同事没有接口意识、抽象思维，那这种暴露实现细节的命名方式就不足为奇了，毕竟最初我们只考虑将图片存储在阿里云上。而我们把这种包含“aliyun”字眼的方法，照抄到 PrivateImageStore 类中，显然是不合适的。如果我们在新类中重新命名 uploadToAliyun()、downloadFromAliyun() 这些方法，那就意味着，我们要修改项目中所有使用到这两个方法的代码，代码修改量可能就会很大。</li>\n<li>其次，将图片存储到阿里云的流程，跟存储到私有云的流程，可能并不是完全一致的。比如，阿里云的图片上传和下载的过程中，需要生产 access token，而私有云不需要 access token。一方面，AliyunImageStore 中定义的 generateAccessToken() 方法不能照抄到 PrivateImageStore 中；另一方面，我们在使用 AliyunImageStore 上传、下载图片的时候，代码中用到了 generateAccessToken() 方法，如果要改为私有云的上传下载流程，这些代码都需要做调整。</li>\n</ul>\n</li>\n<li>那这两个问题该如何解决呢？解决这个问题的根本方法就是，在编写代码的时候，要遵从“基于接口而非实现编程”的原则，具体来讲，我们需要做到下面这 3 点。<ol>\n<li>函数的命名不能暴露任何实现细节。比如，前面提到的 uploadToAliyun() 就不符合要求，应该改为去掉 aliyun 这样的字眼，改为更加抽象的命名方式，比如：upload()。</li>\n<li>封装具体的实现细节。比如，跟阿里云相关的特殊上传（或下载）流程不应该暴露给调用者。我们对上传（或下载）流程进行封装，对外提供一个包裹所有上传（或下载）细节的方法，给调用者使用。</li>\n<li>为实现类定义抽象的接口。具体的实现类都依赖统一的接口定义，遵从一致的上传功能协议。使用者依赖接口，而不是具体的实现类来编程。</li>\n</ol>\n</li>\n<li>我们按照这个思路，把代码重构一下。重构后的代码如下所示：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">ImageStore</span> &#123;</span><br><span class=\"line\">  String <span class=\"title function_\">upload</span><span class=\"params\">(Image image, String bucketName)</span>;</span><br><span class=\"line\">  Image <span class=\"title function_\">download</span><span class=\"params\">(String url)</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AliyunImageStore</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">ImageStore</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">//...省略属性、构造函数等...</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> String <span class=\"title function_\">upload</span><span class=\"params\">(Image image, String bucketName)</span> &#123;</span><br><span class=\"line\">    createBucketIfNotExisting(bucketName);</span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">accessToken</span> <span class=\"operator\">=</span> generateAccessToken();</span><br><span class=\"line\">    <span class=\"comment\">//...上传图片到阿里云...</span></span><br><span class=\"line\">    <span class=\"comment\">//...返回图片在阿里云上的地址(url)...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> Image <span class=\"title function_\">download</span><span class=\"params\">(String url)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">accessToken</span> <span class=\"operator\">=</span> generateAccessToken();</span><br><span class=\"line\">    <span class=\"comment\">//...从阿里云下载图片...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">createBucketIfNotExisting</span><span class=\"params\">(String bucketName)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...创建bucket...</span></span><br><span class=\"line\">    <span class=\"comment\">// ...失败会抛出异常..</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> String <span class=\"title function_\">generateAccessToken</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...根据accesskey/secrectkey等生成access token</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 上传下载流程改变：私有云不需要支持access token</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">PrivateImageStore</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">ImageStore</span>  &#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> String <span class=\"title function_\">upload</span><span class=\"params\">(Image image, String bucketName)</span> &#123;</span><br><span class=\"line\">    createBucketIfNotExisting(bucketName);</span><br><span class=\"line\">    <span class=\"comment\">//...上传图片到私有云...</span></span><br><span class=\"line\">    <span class=\"comment\">//...返回图片的url...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> Image <span class=\"title function_\">download</span><span class=\"params\">(String url)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//...从私有云下载图片...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">createBucketIfNotExisting</span><span class=\"params\">(String bucketName)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...创建bucket...</span></span><br><span class=\"line\">    <span class=\"comment\">// ...失败会抛出异常..</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ImageStore的使用举例</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ImageProcessingJob</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">String</span> <span class=\"variable\">BUCKET_NAME</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;ai_images_bucket&quot;</span>;</span><br><span class=\"line\">  <span class=\"comment\">//...省略其他无关代码...</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">process</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">Image</span> <span class=\"variable\">image</span> <span class=\"operator\">=</span> ...;<span class=\"comment\">//处理图片，并封装为Image对象</span></span><br><span class=\"line\">    <span class=\"type\">ImageStore</span> <span class=\"variable\">imageStore</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">PrivateImageStore</span>(...);</span><br><span class=\"line\">    imagestore.upload(image, BUCKET_NAME);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>除此之外，很多人在定义接口的时候，希望通过实现类来反推接口的定义。先把实现类写好，然后看实现类中有哪些方法，照抄到接口定义中。如果按照这种思考方式，就有可能导致接口定义不够抽象，依赖具体的实现。这样的接口设计就没有意义了。不过，如果你觉得这种思考方式更加顺畅，那也没问题，只是将实现类的方法搬移到接口定义中的时候，要有选择性的搬移，不要将跟具体实现相关的方法搬移到接口中，比如 AliyunImageStore 中的 generateAccessToken() 方法。</li>\n<li>总结一下，我们在做软件开发的时候，一定要有抽象意识、封装意识、接口意识。在定义接口的时候，不要暴露任何实现细节。接口的定义只表明做什么，而不是怎么做。而且，在设计接口的时候，我们要多思考一下，这样的接口设计是否足够通用，是否能够做到在替换具体的接口实现的时候，不需要任何接口定义的改动。</li>\n</ol>\n<h3 id=\"是否需要为每个类定义接口？\"><a href=\"#是否需要为每个类定义接口？\" class=\"headerlink\" title=\"是否需要为每个类定义接口？\"></a>是否需要为每个类定义接口？</h3><ol>\n<li>看了刚刚的讲解，你可能会有这样的疑问：为了满足这条原则，我是不是需要给每个实现类都定义对应的接口呢？在开发的时候，是不是任何代码都要只依赖接口，完全不依赖实现编程呢？</li>\n<li>做任何事情都要讲求一个“度”，过度使用这条原则，非得给每个类都定义接口，接口满天飞，也会导致不必要的开发负担。至于什么时候，该为某个类定义接口，实现基于接口的编程，什么时候不需要定义接口，直接使用实现类编程，我们做权衡的根本依据，还是要回归到设计原则诞生的初衷上来。只要搞清楚了这条原则是为了解决什么样的问题而产生的，你就会发现，很多之前模棱两可的问题，都会变得豁然开朗。</li>\n<li>前面我们也提到，这条原则的设计初衷是，将接口和实现相分离，封装不稳定的实现，暴露稳定的接口。上游系统面向接口而非实现编程，不依赖不稳定的实现细节，这样当实现发生变化的时候，上游系统的代码基本上不需要做改动，以此来降低代码间的耦合性，提高代码的扩展性。</li>\n<li>从这个设计初衷上来看，如果在我们的业务场景中，某个功能只有一种实现方式，未来也不可能被其他实现方式替换，那我们就没有必要为其设计接口，也没有必要基于接口编程，直接使用实现类就可以了。</li>\n<li>除此之外，越是不稳定的系统，我们越是要在代码的扩展性、维护性上下功夫。相反，如果某个系统特别稳定，在开发完之后，基本上不需要做维护，那我们就没有必要为其扩展性，投入不必要的开发时间。</li>\n</ol>\n<h2 id=\"多用组合少用继承\"><a href=\"#多用组合少用继承\" class=\"headerlink\" title=\"多用组合少用继承\"></a>多用组合少用继承</h2><p>在面向对象编程中，有一条非常经典的设计原则，那就是：组合优于继承，多用组合少用继承。为什么不推荐使用继承？组合相比继承有哪些优势？如何判断该用组合还是继承？今天，我们就围绕着这三个问题，来详细讲解一下这条设计原则。</p>\n<h3 id=\"为什么不推荐使用继承？\"><a href=\"#为什么不推荐使用继承？\" class=\"headerlink\" title=\"为什么不推荐使用继承？\"></a>为什么不推荐使用继承？</h3><ol>\n<li>继承是面向对象的四大特性之一，用来表示类之间的 is-a 关系，可以解决代码复用的问题。虽然继承有诸多作用，但继承层次过深、过复杂，也会影响到代码的可维护性。所以，对于是否应该在项目中使用继承，网上有很多争议。很多人觉得继承是一种反模式，应该尽量少用，甚至不用。为什么会有这样的争议？我们通过一个例子来解释一下。</li>\n<li>假设我们要设计一个关于鸟的类。我们将“鸟类”这样一个抽象的事物概念，定义为一个抽象类 AbstractBird。所有更细分的鸟，比如麻雀、鸽子、乌鸦等，都继承这个抽象类。</li>\n<li>我们知道，大部分鸟都会飞，那我们可不可以在 AbstractBird 抽象类中，定义一个 fly() 方法呢？答案是否定的。尽管大部分鸟都会飞，但也有特例，比如鸵鸟就不会飞。鸵鸟继承具有 fly() 方法的父类，那鸵鸟就具有“飞”这样的行为，这显然不符合我们对现实世界中事物的认识。当然，你可能会说，我在鸵鸟这个子类中重写（override）fly() 方法，让它抛出 UnSupportedMethodException 异常不就可以了吗？具体的代码实现如下所示：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AbstractBird</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">//...省略其他属性和方法...</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">fly</span><span class=\"params\">()</span> &#123; <span class=\"comment\">//... &#125;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Ostrich</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">AbstractBird</span> &#123; <span class=\"comment\">//鸵鸟</span></span><br><span class=\"line\">  <span class=\"comment\">//...省略其他属性和方法...</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">fly</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">UnSupportedMethodException</span>(<span class=\"string\">&quot;I can&#x27;t fly.&#x27;&quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>这种设计思路虽然可以解决问题，但不够优美。因为除了鸵鸟之外，不会飞的鸟还有很多，比如企鹅。对于这些不会飞的鸟来说，我们都需要重写 fly() 方法，抛出异常。这样的设计，一方面，徒增了编码的工作量；另一方面，也违背了我们之后要讲的最小知识原则（Least Knowledge Principle，也叫最少知识原则或者迪米特法则），暴露不该暴露的接口给外部，增加了类使用过程中被误用的概率。</li>\n<li>你可能又会说，那我们再通过 AbstractBird 类派生出两个更加细分的抽象类：会飞的鸟类 AbstractFlyableBird 和不会飞的鸟类 AbstractUnFlyableBird，让麻雀、乌鸦这些会飞的鸟都继承 AbstractFlyableBird，让鸵鸟、企鹅这些不会飞的鸟，都继承 AbstractUnFlyableBird 类，不就可以了吗？具体的继承关系如下图所示：</li>\n</ol>\n<img src=\"https://npm.elemecdn.com/youthlql@1.0.0/design_patterns/design_ideas/0001.png\"/>\n\n\n\n<ol>\n<li><p>从图中我们可以看出，继承关系变成了三层。不过，整体上来讲，目前的继承关系还比较简单，层次比较浅，也算是一种可以接受的设计思路。我们再继续加点难度。在刚刚这个场景中，我们只关注“鸟会不会飞”，但如果我们还关注“鸟会不会叫”，那这个时候，我们又该如何设计类之间的继承关系呢？</p>\n</li>\n<li><p>是否会飞？是否会叫？两个行为搭配起来会产生四种情况：会飞会叫、不会飞会叫、会飞不会叫、不会飞不会叫。如果我们继续沿用刚才的设计思路，那就需要再定义四个抽象类（AbstractFlyableTweetableBird、AbstractFlyableUnTweetableBird、AbstractUnFlyableTweetableBird、AbstractUnFlyableUnTweetableBird）。</p>\n</li>\n</ol>\n<img src=\"https://npm.elemecdn.com/youthlql@1.0.0/design_patterns/design_ideas/0002.png\"/>\n\n\n\n<ol>\n<li>如果我们还需要考虑“是否会下蛋”这样一个行为，那估计就要组合爆炸了。类的继承层次会越来越深、继承关系会越来越复杂。而这种层次很深、很复杂的继承关系，一方面，会导致代码的可读性变差。因为我们要搞清楚某个类具有哪些方法、属性，必须阅读父类的代码、父类的父类的代码……一直追溯到最顶层父类的代码。另一方面，这也破坏了类的封装特性，将父类的实现细节暴露给了子类。子类的实现依赖父类的实现，两者高度耦合，一旦父类代码修改，就会影响所有子类的逻辑。</li>\n<li>总之，继承最大的问题就在于：继承层次过深、继承关系过于复杂会影响到代码的可读性和可维护性。这也是为什么我们不推荐使用继承。那刚刚例子中继承存在的问题，我们又该如何来解决呢？你可以先自己思考一下，再听我下面的讲解。</li>\n</ol>\n<h3 id=\"组合相比继承有哪些优势？\"><a href=\"#组合相比继承有哪些优势？\" class=\"headerlink\" title=\"组合相比继承有哪些优势？\"></a>组合相比继承有哪些优势？</h3><ol>\n<li>实际上，我们可以利用组合（composition）、接口、委托（delegation）三个技术手段，一块儿来解决刚刚继承存在的问题。</li>\n<li>接口表示具有某种行为特性。针对“会飞”这样一个行为特性，我们可以定义一个 Flyable 接口，只让会飞的鸟去实现这个接口。对于会叫、会下蛋这些行为特性，我们可以类似地定义 Tweetable 接口、EggLayable 接口。我们将这个设计思路翻译成 Java 代码的话，就是下面这个样子：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">Flyable</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">void</span> <span class=\"title function_\">fly</span><span class=\"params\">()</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">Tweetable</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">void</span> <span class=\"title function_\">tweet</span><span class=\"params\">()</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">EggLayable</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">void</span> <span class=\"title function_\">layEgg</span><span class=\"params\">()</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Ostrich</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Tweetable</span>, EggLayable &#123;<span class=\"comment\">//鸵鸟</span></span><br><span class=\"line\">  <span class=\"comment\">//... 省略其他属性和方法...</span></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">tweet</span><span class=\"params\">()</span> &#123; <span class=\"comment\">//... &#125;</span></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">layEgg</span><span class=\"params\">()</span> &#123; <span class=\"comment\">//... &#125;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Sparrow</span> impelents Flyable, Tweetable, EggLayable &#123;<span class=\"comment\">//麻雀</span></span><br><span class=\"line\">  <span class=\"comment\">//... 省略其他属性和方法...</span></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">fly</span><span class=\"params\">()</span> &#123; <span class=\"comment\">//... &#125;</span></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">tweet</span><span class=\"params\">()</span> &#123; <span class=\"comment\">//... &#125;</span></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">layEgg</span><span class=\"params\">()</span> &#123; <span class=\"comment\">//... &#125;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>不过，我们知道，接口只声明方法，不定义实现。也就是说，每个会下蛋的鸟都要实现一遍 layEgg() 方法，并且实现逻辑是一样的，这就会导致代码重复的问题。那这个问题又该如何解决呢？</li>\n<li>我们可以针对三个接口再定义三个实现类，它们分别是：实现了 fly() 方法的 FlyAbility 类、实现了 tweet() 方法的 TweetAbility 类、实现了 layEgg() 方法的 EggLayAbility 类。然后，通过组合和委托技术来消除代码重复。具体的代码实现如下所示：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">Flyable</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">void</span> <span class=\"title function_\">fly</span><span class=\"params\">()</span>；</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">FlyAbility</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Flyable</span> &#123;</span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">fly</span><span class=\"params\">()</span> &#123; <span class=\"comment\">//... &#125;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//省略Tweetable/TweetAbility/EggLayable/EggLayAbility</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Ostrich</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Tweetable</span>, EggLayable &#123;<span class=\"comment\">//鸵鸟</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"type\">TweetAbility</span> <span class=\"variable\">tweetAbility</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">TweetAbility</span>(); <span class=\"comment\">//组合</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"type\">EggLayAbility</span> <span class=\"variable\">eggLayAbility</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">EggLayAbility</span>(); <span class=\"comment\">//组合</span></span><br><span class=\"line\">  <span class=\"comment\">//... 省略其他属性和方法...</span></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">tweet</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    tweetAbility.tweet(); <span class=\"comment\">// 委托</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">layEgg</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    eggLayAbility.layEgg(); <span class=\"comment\">// 委托</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>我们知道继承主要有三个作用：表示 is-a 关系，支持多态特性，代码复用。而这三个作用都可以通过其他技术手段来达成。比如 is-a 关系，我们可以通过组合和接口的 has-a 关系来替代；多态特性我们可以利用接口来实现；代码复用我们可以通过组合和委托来实现。所以，从理论上讲，通过组合、接口、委托三个技术手段，我们完全可以替换掉继承，在项目中不用或者少用继承关系，特别是一些复杂的继承关系。</p>\n<h3 id=\"如何判断该用组合还是继承？\"><a href=\"#如何判断该用组合还是继承？\" class=\"headerlink\" title=\"如何判断该用组合还是继承？\"></a>如何判断该用组合还是继承？</h3><ol>\n<li>尽管我们鼓励多用组合少用继承，但组合也并不是完美的，继承也并非一无是处。从上面的例子来看，继承改写成组合意味着要做更细粒度的类的拆分。这也就意味着，我们要定义更多的类和接口。类和接口的增多也就或多或少地增加代码的复杂程度和维护成本。所以，在实际的项目开发中，我们还是要根据具体的情况，来具体选择该用继承还是组合。</li>\n<li>如果类之间的继承结构稳定（不会轻易改变），继承层次比较浅（比如，最多有两层继承关系），继承关系不复杂，我们就可以大胆地使用继承。反之，系统越不稳定，继承层次很深，继承关系复杂，我们就尽量使用组合来替代继承。</li>\n<li>除此之外，还有一些设计模式会固定使用继承或者组合。比如，装饰者模式（decorator pattern）、策略模式（strategy pattern）、组合模式（composite pattern）等都使用了组合关系，而模板模式（template pattern）使用了继承关系。</li>\n<li>前面我们讲到继承可以实现代码复用。利用继承特性，我们把相同的属性和方法，抽取出来，定义到父类中。子类复用父类中的属性和方法，达到代码复用的目的。但是，有的时候，从业务含义上，A 类和 B 类并不一定具有继承关系。比如，Crawler 类和 PageAnalyzer 类，它们都用到了 URL 拼接和分割的功能，但并不具有继承关系（既不是父子关系，也不是兄弟关系）。仅仅为了代码复用，生硬地抽象出一个父类出来，会影响到代码的可读性。如果不熟悉背后设计思路的同事，发现 Crawler 类和 PageAnalyzer 类继承同一个父类，而父类中定义的却只是 URL 相关的操作，会觉得这个代码写得莫名其妙，理解不了。这个时候，使用组合就更加合理、更加灵活。具体的代码实现如下所示：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Url</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">//...省略属性和方法</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Crawler</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> Url url; <span class=\"comment\">// 组合</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"title function_\">Crawler</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.url = <span class=\"keyword\">new</span> <span class=\"title class_\">Url</span>();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">PageAnalyzer</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> Url url; <span class=\"comment\">// 组合</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"title function_\">PageAnalyzer</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.url = <span class=\"keyword\">new</span> <span class=\"title class_\">Url</span>();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//..</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>还有一些特殊的场景要求我们必须使用继承。如果你不能改变一个函数的入参类型，而入参又非接口，为了支持多态，只能采用继承来实现。比如下面这样一段代码，其中 FeignClient 是一个外部类，我们没有权限去修改这部分代码，但是我们希望能重写这个类在运行时执行的 encode() 函数。这个时候，我们只能采用继承来实现了。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">FeignClient</span> &#123; <span class=\"comment\">// Feign Client框架代码</span></span><br><span class=\"line\">  <span class=\"comment\">//...省略其他代码...</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">encode</span><span class=\"params\">(String url)</span> &#123; <span class=\"comment\">//... &#125;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">demofunction</span><span class=\"params\">(FeignClient feignClient)</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">//...</span></span><br><span class=\"line\">  feignClient.encode(url);</span><br><span class=\"line\">  <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">CustomizedFeignClient</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">FeignClient</span> &#123;</span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">encode</span><span class=\"params\">(String url)</span> &#123; <span class=\"comment\">//...重写encode的实现...&#125;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 调用</span></span><br><span class=\"line\"><span class=\"type\">FeignClient</span> <span class=\"variable\">client</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">CustomizedFeignClient</span>();</span><br><span class=\"line\">demofunction(client);</span><br></pre></td></tr></table></figure>\n\n<p>尽管有些人说，要杜绝继承，100% 用组合代替继承，但是我的观点没那么极端！之所以“多用组合少用继承”这个口号喊得这么响，只是因为，长期以来，我们过度使用继承。还是那句话，组合并不完美，继承也不是一无是处。只要我们控制好它们的副作用、发挥它们各自的优势，在不同的场合下，恰当地选择使用继承还是组合，这才是我们所追求的境界。</p>\n<h2 id=\"如何通过封装、抽象、模块化、中间层等解耦代码？\"><a href=\"#如何通过封装、抽象、模块化、中间层等解耦代码？\" class=\"headerlink\" title=\"如何通过封装、抽象、模块化、中间层等解耦代码？\"></a>如何通过封装、抽象、模块化、中间层等解耦代码？</h2><h3 id=\"“解耦”为何如此重要？\"><a href=\"#“解耦”为何如此重要？\" class=\"headerlink\" title=\"“解耦”为何如此重要？\"></a>“解耦”为何如此重要？</h3><ol>\n<li>软件设计与开发最重要的工作之一就是应对复杂性。人处理复杂性的能力是有限的。过于复杂的代码往往在可读性、可维护性上都不友好。那如何来控制代码的复杂性呢？手段有很多，我个人认为，最关键的就是解耦，保证代码松耦合、高内聚。如果说重构是保证代码质量不至于腐化到无可救药地步的有效手段，那么利用解耦的方法对代码重构，就是保证代码不至于复杂到无法控制的有效手段。</li>\n<li>后文迪米特法则有介绍，什么是“高内聚、松耦合”。。实际上，“高内聚、松耦合”是一个比较通用的设计思想，不仅可以指导细粒度的类和类之间关系的设计，还能指导粗粒度的系统、架构、模块的设计。相对于编码规范，它能够在更高层次上提高代码的可读性和可维护性。</li>\n<li>不管是阅读代码还是修改代码，“高内聚、松耦合”的特性可以让我们聚焦在某一模块或类中，不需要了解太多其他模块或类的代码，让我们的焦点不至于过于发散，降低了阅读和修改代码的难度。而且，因为依赖关系简单，耦合小，修改代码不至于牵一发而动全身，代码改动比较集中，引入 bug 的风险也就减少了很多。同时，“高内聚、松耦合”的代码可测试性也更加好，容易 mock 或者很少需要 mock 外部依赖的模块或者类。</li>\n<li>除此之外，代码“高内聚、松耦合”，也就意味着，代码结构清晰、分层和模块化合理、依赖关系简单、模块或类之间的耦合小，那代码整体的质量就不会差。即便某个具体的类或者模块设计得不怎么合理，代码质量不怎么高，影响的范围是非常有限的。我们可以聚焦于这个模块或者类，做相应的小型重构。而相对于代码结构的调整，这种改动范围比较集中的小型重构的难度就容易多了。</li>\n</ol>\n<h3 id=\"代码是否需要“解耦”？\"><a href=\"#代码是否需要“解耦”？\" class=\"headerlink\" title=\"代码是否需要“解耦”？\"></a>代码是否需要“解耦”？</h3><ol>\n<li>那现在问题来了，我们该怎么判断代码的耦合程度呢？或者说，怎么判断代码是否符合“高内聚、松耦合”呢？再或者说，如何判断系统是否需要解耦重构呢？</li>\n<li>间接的衡量标准有很多，前面我们讲到了一些，比如，看修改代码会不会牵一发而动全身。除此之外，还有一个直接的衡量标准，也是我在阅读源码的时候经常会用到的，那就是把模块与模块之间、类与类之间的依赖关系画出来，根据依赖关系图的复杂性来判断是否需要解耦重构。</li>\n<li>如果依赖关系复杂、混乱，那从代码结构上来讲，可读性和可维护性肯定不是太好，那我们就需要考虑是否可以通过解耦的方法，让依赖关系变得清晰、简单。当然，这种判断还是有比较强的主观色彩，但是可以作为一种参考和梳理依赖的手段，配合间接的衡量标准一块来使用。</li>\n</ol>\n<h3 id=\"如何给代码“解耦”？\"><a href=\"#如何给代码“解耦”？\" class=\"headerlink\" title=\"如何给代码“解耦”？\"></a>如何给代码“解耦”？</h3><blockquote>\n<p> 封装与抽象</p>\n</blockquote>\n<p>封装和抽象作为两个非常通用的设计思想，可以应用在很多设计场景中，比如系统、模块、lib、组件、接口、类等等的设计。封装和抽象可以有效地隐藏实现的复杂性，隔离实现的易变性，给依赖的模块提供稳定且易用的抽象接口</p>\n<blockquote>\n<p>中间层</p>\n</blockquote>\n<p>引入中间层能简化模块或类之间的依赖关系。下面这张图是引入中间层前后的依赖关系对比图。在引入数据存储中间层之前，A、B、C 三个模块都要依赖内存一级缓存、Redis 二级缓存、DB 持久化存储三个模块。在引入中间层之后，三个模块只需要依赖数据存储一个模块即可。从图上可以看出，中间层的引入明显地简化了依赖关系，让代码结构更加清晰</p>\n<img src=\"https://npm.elemecdn.com/youthlql@1.0.0/design_patterns/design_ideas/0003.png\"/>\n\n\n\n<p>除此之外，我们在进行重构的时候，引入中间层可以起到过渡的作用，能够让开发和重构同步进行，不互相干扰。比如，某个接口设计得有问题，我们需要修改它的定义，同时，所有调用这个接口的代码都要做相应的改动。如果新开发的代码也用到这个接口，那开发就跟重构冲突了。为了让重构能小步快跑，我们可以分下面四个阶段来完成接口的修改。</p>\n<ul>\n<li>第一阶段：引入一个中间层，包裹老的接口，提供新的接口定义。</li>\n<li>第二阶段：新开发的代码依赖中间层提供的新接口。</li>\n<li>第三阶段：将依赖老接口的代码改为调用新接口。</li>\n<li>第四阶段：确保所有的代码都调用新接口之后，删除掉老的接口。</li>\n</ul>\n<p>这样，每个阶段的开发工作量都不会很大，都可以在很短的时间内完成。重构跟开发冲突的概率也变小了。</p>\n<blockquote>\n<p>模块化</p>\n</blockquote>\n<p>模块化是构建复杂系统常用的手段。不仅在软件行业，在建筑、机械制造等行业，这个手段也非常有用。对于一个大型复杂系统来说，没有人能掌控所有的细节。之所以我们能搭建出如此复杂的系统，并且能维护得了，最主要的原因就是将系统划分成各个独立的模块，让不同的人负责不同的模块，这样即便在不了解全部细节的情况下，管理者也能协调各个模块，让整个系统有效运转。</p>\n<blockquote>\n<p> 其他设计思想和原则</p>\n</blockquote>\n<p>“高内聚、松耦合”是一个非常重要的设计思想，能够有效提高代码的可读性和可维护性，缩小功能改动导致的代码改动范围。实际上，在前面的章节中，我们已经多次提到过这个设计思想。很多设计原则都以实现代码的“高内聚、松耦合”为目的。我们来一块总结回顾一下都有哪些原则。</p>\n<p>(这里没有讲的，在后面文章里)</p>\n<ul>\n<li>单一职责原则</li>\n</ul>\n<p>我们前面提到，内聚性和耦合性并非独立的。高内聚会让代码更加松耦合，而实现高内聚的重要指导原则就是单一职责原则。模块或者类的职责设计得单一，而不是大而全，那依赖它的类和它依赖的类就会比较少，代码耦合也就相应的降低了。</p>\n<ul>\n<li>基于接口而非实现编程</li>\n</ul>\n<p>基于接口而非实现编程能通过接口这样一个中间层，隔离变化和具体的实现。这样做的好处是，在有依赖关系的两个模块或类之间，一个模块或者类的改动，不会影响到另一个模块或类。实际上，这就相当于将一种强依赖关系（强耦合）解耦为了弱依赖关系（弱耦合）。依赖注入</p>\n<ul>\n<li>依赖注入</li>\n</ul>\n<p>跟基于接口而非实现编程思想类似，依赖注入也是将代码之间的强耦合变为弱耦合。尽管依赖注入无法将本应该有依赖关系的两个类，解耦为没有依赖关系，但可以让耦合关系没那么紧密，容易做到插拔替换</p>\n<ul>\n<li>多用组合少用继承</li>\n</ul>\n<p>我们知道，继承是一种强依赖关系，父类与子类高度耦合，且这种耦合关系非常脆弱，牵一发而动全身，父类的每一次改动都会影响所有的子类。相反，组合关系是一种弱依赖关系，这种关系更加灵活，所以，对于继承结构比较复杂的代码，利用组合来替换继承，也是一种解耦的有效手段。</p>\n<ul>\n<li>迪米特法则</li>\n</ul>\n<p>迪米特法则讲的是，不该有直接依赖关系的类之间，不要有依赖；有依赖关系的类之间，尽量只依赖必要的接口。从定义上，我们明显可以看出，这条原则的目的就是为了实现代码的松耦合。至于如何应用这条原则来解耦代码，你可以回过头去阅读一下第 22 讲，这里我就不赘述了。除了上面讲到的这些设计思想和原则之外，还有一些设计模式也是为了解耦依赖，比如观察者模式，有关这一部分的内容，我们留在设计模式模块中慢慢讲解。</p>\n","site":{"data":{}},"cover_type":"img","excerpt":"","more":"<h1 id=\"声明\"><a href=\"#声明\" class=\"headerlink\" title=\"声明\"></a>声明</h1><blockquote>\n<ol>\n<li>此系列文章非本人原创，是学习笔记。</li>\n<li>设计模式系列以后会持续更新，包括已经发布的设计模式文章，因为后续还要再多看一下书，教程和开源项目等，继续润色文章。</li>\n</ol>\n</blockquote>\n<p>下面讲一些常见的设计思想</p>\n<h2 id=\"基于接口而非实现编程\"><a href=\"#基于接口而非实现编程\" class=\"headerlink\" title=\"基于接口而非实现编程\"></a>基于接口而非实现编程</h2><p>这个原则非常重要，是一种非常有效的提高代码质量的手段，在平时的开发中特别经常被用到。</p>\n<h3 id=\"如何解读原则中的“接口”二字？\"><a href=\"#如何解读原则中的“接口”二字？\" class=\"headerlink\" title=\"如何解读原则中的“接口”二字？\"></a>如何解读原则中的“接口”二字？</h3><ol>\n<li>“基于接口而非实现编程”这条原则的英文描述是：“Program to an interface, not an implementation”。我们理解这条原则的时候，千万不要一开始就与具体的编程语言挂钩，局限在编程语言的“接口”语法中（比如 Java 中的 interface 接口语法）。这条原则最早出现于 1994 年 GoF 的《设计模式》这本书，它先于很多编程语言而诞生（比如 Java 语言），是一条比较抽象、泛化的设计思想。</li>\n<li>实际上，理解这条原则的关键，就是理解其中的“接口”两个字。还记得我们上一节课讲的“接口”的定义吗？从本质上来看，“接口”就是一组“协议”或者“约定”，是功能提供者提供给使用者的一个“功能列表”。“接口”在不同的应用场景下会有不同的解读，比如服务端与客户端之间的“接口”，类库提供的“接口”，甚至是一组通信的协议都可以叫作“接口”。刚刚对“接口”的理解，都比较偏上层、偏抽象，与实际的写代码离得有点远。如果落实到具体的编码，“基于接口而非实现编程”这条原则中的“接口”，可以理解为编程语言中的接口或者抽象类。</li>\n<li>前面我们提到，这条原则能非常有效地提高代码质量，之所以这么说，那是因为，应用这条原则，可以将接口和实现相分离，封装不稳定的实现，暴露稳定的接口。上游系统面向接口而非实现编程，不依赖不稳定的实现细节，这样当实现发生变化的时候，上游系统的代码基本上不需要做改动，以此来降低耦合性，提高扩展性。</li>\n<li>实际上，“基于接口而非实现编程”这条原则的另一个表述方式，是“基于抽象而非实现编程”。后者的表述方式其实更能体现这条原则的设计初衷。在软件开发中，最大的挑战之一就是需求的不断变化，这也是考验代码设计好坏的一个标准。<strong>越抽象、越顶层、越脱离具体某一实现的设计，越能提高代码的灵活性，越能应对未来的需求变化。好的代码设计，不仅能应对当下的需求，而且在将来需求发生变化的时候，仍然能够在不破坏原有代码设计的情况下灵活应对</strong>。而抽象就是提高代码扩展性、灵活性、可维护性最有效的手段之一。</li>\n</ol>\n<h3 id=\"如何将这条原则应用到实战中？\"><a href=\"#如何将这条原则应用到实战中？\" class=\"headerlink\" title=\"如何将这条原则应用到实战中？\"></a>如何将这条原则应用到实战中？</h3><p>假设我们的系统中有很多涉及图片处理和存储的业务逻辑。图片经过处理之后被上传到阿里云上。为了代码复用，我们封装了图片存储相关的代码逻辑，提供了一个统一的 AliyunImageStore 类，供整个系统来使用。具体的代码实现如下所示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AliyunImageStore</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">//...省略属性、构造函数等...</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">createBucketIfNotExisting</span><span class=\"params\">(String bucketName)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...创建bucket代码逻辑...</span></span><br><span class=\"line\">    <span class=\"comment\">// ...失败会抛出异常..</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">public</span> String <span class=\"title function_\">generateAccessToken</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...根据accesskey/secrectkey等生成access token</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">public</span> String <span class=\"title function_\">uploadToAliyun</span><span class=\"params\">(Image image, String bucketName, String accessToken)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//...上传图片到阿里云...</span></span><br><span class=\"line\">    <span class=\"comment\">//...返回图片存储在阿里云上的地址(url）...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">public</span> Image <span class=\"title function_\">downloadFromAliyun</span><span class=\"params\">(String url, String accessToken)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//...从阿里云下载图片...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// AliyunImageStore类的使用举例</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ImageProcessingJob</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">String</span> <span class=\"variable\">BUCKET_NAME</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;ai_images_bucket&quot;</span>;</span><br><span class=\"line\">  <span class=\"comment\">//...省略其他无关代码...</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">process</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">Image</span> <span class=\"variable\">image</span> <span class=\"operator\">=</span> ...; <span class=\"comment\">//处理图片，并封装为Image对象</span></span><br><span class=\"line\">    <span class=\"type\">AliyunImageStore</span> <span class=\"variable\">imageStore</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">AliyunImageStore</span>(<span class=\"comment\">/*省略参数*/</span>);</span><br><span class=\"line\">    imageStore.createBucketIfNotExisting(BUCKET_NAME);</span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">accessToken</span> <span class=\"operator\">=</span> imageStore.generateAccessToken();</span><br><span class=\"line\">    imagestore.uploadToAliyun(image, BUCKET_NAME, accessToken);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<ol>\n<li>整个上传流程包含三个步骤：创建 bucket（你可以简单理解为存储目录）、生成 access token 访问凭证、携带 access token 上传图片到指定的 bucket 中。代码实现非常简单，类中的几个方法定义得都很干净，用起来也很清晰，乍看起来没有太大问题，完全能满足我们将图片存储在阿里云的业务需求。</li>\n<li>不过，软件开发中唯一不变的就是变化。过了一段时间后，我们自建了私有云，不再将图片存储到阿里云了，而是将图片存储到自建私有云上。为了满足这样一个需求的变化，我们该如何修改代码呢？</li>\n<li>我们需要重新设计实现一个存储图片到私有云的 PrivateImageStore 类，并用它替换掉项目中所有的 AliyunImageStore 类对象。这样的修改听起来并不复杂，只是简单替换而已，对整个代码的改动并不大。不过，我们经常说，“细节是魔鬼”。这句话在软件开发中特别适用。实际上，刚刚的设计实现方式，就隐藏了很多容易出问题的“魔鬼细节”，我们一块来看看都有哪些。</li>\n<li>新的 PrivateImageStore 类需要设计实现哪些方法，才能在尽量最小化代码修改的情况下，替换掉 AliyunImageStore 类呢？这就要求我们必须将 AliyunImageStore 类中所定义的所有 public 方法，在 PrivateImageStore 类中都逐一定义并重新实现一遍。而这样做就会存在一些问题，我总结了下面两点。<ul>\n<li>首先，AliyunImageStore 类中有些函数命名暴露了实现细节，比如，uploadToAliyun() 和 downloadFromAliyun()。如果开发这个功能的同事没有接口意识、抽象思维，那这种暴露实现细节的命名方式就不足为奇了，毕竟最初我们只考虑将图片存储在阿里云上。而我们把这种包含“aliyun”字眼的方法，照抄到 PrivateImageStore 类中，显然是不合适的。如果我们在新类中重新命名 uploadToAliyun()、downloadFromAliyun() 这些方法，那就意味着，我们要修改项目中所有使用到这两个方法的代码，代码修改量可能就会很大。</li>\n<li>其次，将图片存储到阿里云的流程，跟存储到私有云的流程，可能并不是完全一致的。比如，阿里云的图片上传和下载的过程中，需要生产 access token，而私有云不需要 access token。一方面，AliyunImageStore 中定义的 generateAccessToken() 方法不能照抄到 PrivateImageStore 中；另一方面，我们在使用 AliyunImageStore 上传、下载图片的时候，代码中用到了 generateAccessToken() 方法，如果要改为私有云的上传下载流程，这些代码都需要做调整。</li>\n</ul>\n</li>\n<li>那这两个问题该如何解决呢？解决这个问题的根本方法就是，在编写代码的时候，要遵从“基于接口而非实现编程”的原则，具体来讲，我们需要做到下面这 3 点。<ol>\n<li>函数的命名不能暴露任何实现细节。比如，前面提到的 uploadToAliyun() 就不符合要求，应该改为去掉 aliyun 这样的字眼，改为更加抽象的命名方式，比如：upload()。</li>\n<li>封装具体的实现细节。比如，跟阿里云相关的特殊上传（或下载）流程不应该暴露给调用者。我们对上传（或下载）流程进行封装，对外提供一个包裹所有上传（或下载）细节的方法，给调用者使用。</li>\n<li>为实现类定义抽象的接口。具体的实现类都依赖统一的接口定义，遵从一致的上传功能协议。使用者依赖接口，而不是具体的实现类来编程。</li>\n</ol>\n</li>\n<li>我们按照这个思路，把代码重构一下。重构后的代码如下所示：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">ImageStore</span> &#123;</span><br><span class=\"line\">  String <span class=\"title function_\">upload</span><span class=\"params\">(Image image, String bucketName)</span>;</span><br><span class=\"line\">  Image <span class=\"title function_\">download</span><span class=\"params\">(String url)</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AliyunImageStore</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">ImageStore</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">//...省略属性、构造函数等...</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> String <span class=\"title function_\">upload</span><span class=\"params\">(Image image, String bucketName)</span> &#123;</span><br><span class=\"line\">    createBucketIfNotExisting(bucketName);</span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">accessToken</span> <span class=\"operator\">=</span> generateAccessToken();</span><br><span class=\"line\">    <span class=\"comment\">//...上传图片到阿里云...</span></span><br><span class=\"line\">    <span class=\"comment\">//...返回图片在阿里云上的地址(url)...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> Image <span class=\"title function_\">download</span><span class=\"params\">(String url)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">accessToken</span> <span class=\"operator\">=</span> generateAccessToken();</span><br><span class=\"line\">    <span class=\"comment\">//...从阿里云下载图片...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">createBucketIfNotExisting</span><span class=\"params\">(String bucketName)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...创建bucket...</span></span><br><span class=\"line\">    <span class=\"comment\">// ...失败会抛出异常..</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> String <span class=\"title function_\">generateAccessToken</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...根据accesskey/secrectkey等生成access token</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 上传下载流程改变：私有云不需要支持access token</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">PrivateImageStore</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">ImageStore</span>  &#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> String <span class=\"title function_\">upload</span><span class=\"params\">(Image image, String bucketName)</span> &#123;</span><br><span class=\"line\">    createBucketIfNotExisting(bucketName);</span><br><span class=\"line\">    <span class=\"comment\">//...上传图片到私有云...</span></span><br><span class=\"line\">    <span class=\"comment\">//...返回图片的url...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> Image <span class=\"title function_\">download</span><span class=\"params\">(String url)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//...从私有云下载图片...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">createBucketIfNotExisting</span><span class=\"params\">(String bucketName)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...创建bucket...</span></span><br><span class=\"line\">    <span class=\"comment\">// ...失败会抛出异常..</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ImageStore的使用举例</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ImageProcessingJob</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">String</span> <span class=\"variable\">BUCKET_NAME</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;ai_images_bucket&quot;</span>;</span><br><span class=\"line\">  <span class=\"comment\">//...省略其他无关代码...</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">process</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">Image</span> <span class=\"variable\">image</span> <span class=\"operator\">=</span> ...;<span class=\"comment\">//处理图片，并封装为Image对象</span></span><br><span class=\"line\">    <span class=\"type\">ImageStore</span> <span class=\"variable\">imageStore</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">PrivateImageStore</span>(...);</span><br><span class=\"line\">    imagestore.upload(image, BUCKET_NAME);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>除此之外，很多人在定义接口的时候，希望通过实现类来反推接口的定义。先把实现类写好，然后看实现类中有哪些方法，照抄到接口定义中。如果按照这种思考方式，就有可能导致接口定义不够抽象，依赖具体的实现。这样的接口设计就没有意义了。不过，如果你觉得这种思考方式更加顺畅，那也没问题，只是将实现类的方法搬移到接口定义中的时候，要有选择性的搬移，不要将跟具体实现相关的方法搬移到接口中，比如 AliyunImageStore 中的 generateAccessToken() 方法。</li>\n<li>总结一下，我们在做软件开发的时候，一定要有抽象意识、封装意识、接口意识。在定义接口的时候，不要暴露任何实现细节。接口的定义只表明做什么，而不是怎么做。而且，在设计接口的时候，我们要多思考一下，这样的接口设计是否足够通用，是否能够做到在替换具体的接口实现的时候，不需要任何接口定义的改动。</li>\n</ol>\n<h3 id=\"是否需要为每个类定义接口？\"><a href=\"#是否需要为每个类定义接口？\" class=\"headerlink\" title=\"是否需要为每个类定义接口？\"></a>是否需要为每个类定义接口？</h3><ol>\n<li>看了刚刚的讲解，你可能会有这样的疑问：为了满足这条原则，我是不是需要给每个实现类都定义对应的接口呢？在开发的时候，是不是任何代码都要只依赖接口，完全不依赖实现编程呢？</li>\n<li>做任何事情都要讲求一个“度”，过度使用这条原则，非得给每个类都定义接口，接口满天飞，也会导致不必要的开发负担。至于什么时候，该为某个类定义接口，实现基于接口的编程，什么时候不需要定义接口，直接使用实现类编程，我们做权衡的根本依据，还是要回归到设计原则诞生的初衷上来。只要搞清楚了这条原则是为了解决什么样的问题而产生的，你就会发现，很多之前模棱两可的问题，都会变得豁然开朗。</li>\n<li>前面我们也提到，这条原则的设计初衷是，将接口和实现相分离，封装不稳定的实现，暴露稳定的接口。上游系统面向接口而非实现编程，不依赖不稳定的实现细节，这样当实现发生变化的时候，上游系统的代码基本上不需要做改动，以此来降低代码间的耦合性，提高代码的扩展性。</li>\n<li>从这个设计初衷上来看，如果在我们的业务场景中，某个功能只有一种实现方式，未来也不可能被其他实现方式替换，那我们就没有必要为其设计接口，也没有必要基于接口编程，直接使用实现类就可以了。</li>\n<li>除此之外，越是不稳定的系统，我们越是要在代码的扩展性、维护性上下功夫。相反，如果某个系统特别稳定，在开发完之后，基本上不需要做维护，那我们就没有必要为其扩展性，投入不必要的开发时间。</li>\n</ol>\n<h2 id=\"多用组合少用继承\"><a href=\"#多用组合少用继承\" class=\"headerlink\" title=\"多用组合少用继承\"></a>多用组合少用继承</h2><p>在面向对象编程中，有一条非常经典的设计原则，那就是：组合优于继承，多用组合少用继承。为什么不推荐使用继承？组合相比继承有哪些优势？如何判断该用组合还是继承？今天，我们就围绕着这三个问题，来详细讲解一下这条设计原则。</p>\n<h3 id=\"为什么不推荐使用继承？\"><a href=\"#为什么不推荐使用继承？\" class=\"headerlink\" title=\"为什么不推荐使用继承？\"></a>为什么不推荐使用继承？</h3><ol>\n<li>继承是面向对象的四大特性之一，用来表示类之间的 is-a 关系，可以解决代码复用的问题。虽然继承有诸多作用，但继承层次过深、过复杂，也会影响到代码的可维护性。所以，对于是否应该在项目中使用继承，网上有很多争议。很多人觉得继承是一种反模式，应该尽量少用，甚至不用。为什么会有这样的争议？我们通过一个例子来解释一下。</li>\n<li>假设我们要设计一个关于鸟的类。我们将“鸟类”这样一个抽象的事物概念，定义为一个抽象类 AbstractBird。所有更细分的鸟，比如麻雀、鸽子、乌鸦等，都继承这个抽象类。</li>\n<li>我们知道，大部分鸟都会飞，那我们可不可以在 AbstractBird 抽象类中，定义一个 fly() 方法呢？答案是否定的。尽管大部分鸟都会飞，但也有特例，比如鸵鸟就不会飞。鸵鸟继承具有 fly() 方法的父类，那鸵鸟就具有“飞”这样的行为，这显然不符合我们对现实世界中事物的认识。当然，你可能会说，我在鸵鸟这个子类中重写（override）fly() 方法，让它抛出 UnSupportedMethodException 异常不就可以了吗？具体的代码实现如下所示：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AbstractBird</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">//...省略其他属性和方法...</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">fly</span><span class=\"params\">()</span> &#123; <span class=\"comment\">//... &#125;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Ostrich</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">AbstractBird</span> &#123; <span class=\"comment\">//鸵鸟</span></span><br><span class=\"line\">  <span class=\"comment\">//...省略其他属性和方法...</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">fly</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">UnSupportedMethodException</span>(<span class=\"string\">&quot;I can&#x27;t fly.&#x27;&quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>这种设计思路虽然可以解决问题，但不够优美。因为除了鸵鸟之外，不会飞的鸟还有很多，比如企鹅。对于这些不会飞的鸟来说，我们都需要重写 fly() 方法，抛出异常。这样的设计，一方面，徒增了编码的工作量；另一方面，也违背了我们之后要讲的最小知识原则（Least Knowledge Principle，也叫最少知识原则或者迪米特法则），暴露不该暴露的接口给外部，增加了类使用过程中被误用的概率。</li>\n<li>你可能又会说，那我们再通过 AbstractBird 类派生出两个更加细分的抽象类：会飞的鸟类 AbstractFlyableBird 和不会飞的鸟类 AbstractUnFlyableBird，让麻雀、乌鸦这些会飞的鸟都继承 AbstractFlyableBird，让鸵鸟、企鹅这些不会飞的鸟，都继承 AbstractUnFlyableBird 类，不就可以了吗？具体的继承关系如下图所示：</li>\n</ol>\n<img src=\"https://npm.elemecdn.com/youthlql@1.0.0/design_patterns/design_ideas/0001.png\"/>\n\n\n\n<ol>\n<li><p>从图中我们可以看出，继承关系变成了三层。不过，整体上来讲，目前的继承关系还比较简单，层次比较浅，也算是一种可以接受的设计思路。我们再继续加点难度。在刚刚这个场景中，我们只关注“鸟会不会飞”，但如果我们还关注“鸟会不会叫”，那这个时候，我们又该如何设计类之间的继承关系呢？</p>\n</li>\n<li><p>是否会飞？是否会叫？两个行为搭配起来会产生四种情况：会飞会叫、不会飞会叫、会飞不会叫、不会飞不会叫。如果我们继续沿用刚才的设计思路，那就需要再定义四个抽象类（AbstractFlyableTweetableBird、AbstractFlyableUnTweetableBird、AbstractUnFlyableTweetableBird、AbstractUnFlyableUnTweetableBird）。</p>\n</li>\n</ol>\n<img src=\"https://npm.elemecdn.com/youthlql@1.0.0/design_patterns/design_ideas/0002.png\"/>\n\n\n\n<ol>\n<li>如果我们还需要考虑“是否会下蛋”这样一个行为，那估计就要组合爆炸了。类的继承层次会越来越深、继承关系会越来越复杂。而这种层次很深、很复杂的继承关系，一方面，会导致代码的可读性变差。因为我们要搞清楚某个类具有哪些方法、属性，必须阅读父类的代码、父类的父类的代码……一直追溯到最顶层父类的代码。另一方面，这也破坏了类的封装特性，将父类的实现细节暴露给了子类。子类的实现依赖父类的实现，两者高度耦合，一旦父类代码修改，就会影响所有子类的逻辑。</li>\n<li>总之，继承最大的问题就在于：继承层次过深、继承关系过于复杂会影响到代码的可读性和可维护性。这也是为什么我们不推荐使用继承。那刚刚例子中继承存在的问题，我们又该如何来解决呢？你可以先自己思考一下，再听我下面的讲解。</li>\n</ol>\n<h3 id=\"组合相比继承有哪些优势？\"><a href=\"#组合相比继承有哪些优势？\" class=\"headerlink\" title=\"组合相比继承有哪些优势？\"></a>组合相比继承有哪些优势？</h3><ol>\n<li>实际上，我们可以利用组合（composition）、接口、委托（delegation）三个技术手段，一块儿来解决刚刚继承存在的问题。</li>\n<li>接口表示具有某种行为特性。针对“会飞”这样一个行为特性，我们可以定义一个 Flyable 接口，只让会飞的鸟去实现这个接口。对于会叫、会下蛋这些行为特性，我们可以类似地定义 Tweetable 接口、EggLayable 接口。我们将这个设计思路翻译成 Java 代码的话，就是下面这个样子：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">Flyable</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">void</span> <span class=\"title function_\">fly</span><span class=\"params\">()</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">Tweetable</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">void</span> <span class=\"title function_\">tweet</span><span class=\"params\">()</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">EggLayable</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">void</span> <span class=\"title function_\">layEgg</span><span class=\"params\">()</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Ostrich</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Tweetable</span>, EggLayable &#123;<span class=\"comment\">//鸵鸟</span></span><br><span class=\"line\">  <span class=\"comment\">//... 省略其他属性和方法...</span></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">tweet</span><span class=\"params\">()</span> &#123; <span class=\"comment\">//... &#125;</span></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">layEgg</span><span class=\"params\">()</span> &#123; <span class=\"comment\">//... &#125;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Sparrow</span> impelents Flyable, Tweetable, EggLayable &#123;<span class=\"comment\">//麻雀</span></span><br><span class=\"line\">  <span class=\"comment\">//... 省略其他属性和方法...</span></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">fly</span><span class=\"params\">()</span> &#123; <span class=\"comment\">//... &#125;</span></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">tweet</span><span class=\"params\">()</span> &#123; <span class=\"comment\">//... &#125;</span></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">layEgg</span><span class=\"params\">()</span> &#123; <span class=\"comment\">//... &#125;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>不过，我们知道，接口只声明方法，不定义实现。也就是说，每个会下蛋的鸟都要实现一遍 layEgg() 方法，并且实现逻辑是一样的，这就会导致代码重复的问题。那这个问题又该如何解决呢？</li>\n<li>我们可以针对三个接口再定义三个实现类，它们分别是：实现了 fly() 方法的 FlyAbility 类、实现了 tweet() 方法的 TweetAbility 类、实现了 layEgg() 方法的 EggLayAbility 类。然后，通过组合和委托技术来消除代码重复。具体的代码实现如下所示：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">Flyable</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">void</span> <span class=\"title function_\">fly</span><span class=\"params\">()</span>；</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">FlyAbility</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Flyable</span> &#123;</span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">fly</span><span class=\"params\">()</span> &#123; <span class=\"comment\">//... &#125;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//省略Tweetable/TweetAbility/EggLayable/EggLayAbility</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Ostrich</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Tweetable</span>, EggLayable &#123;<span class=\"comment\">//鸵鸟</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"type\">TweetAbility</span> <span class=\"variable\">tweetAbility</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">TweetAbility</span>(); <span class=\"comment\">//组合</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"type\">EggLayAbility</span> <span class=\"variable\">eggLayAbility</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">EggLayAbility</span>(); <span class=\"comment\">//组合</span></span><br><span class=\"line\">  <span class=\"comment\">//... 省略其他属性和方法...</span></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">tweet</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    tweetAbility.tweet(); <span class=\"comment\">// 委托</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">layEgg</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    eggLayAbility.layEgg(); <span class=\"comment\">// 委托</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>我们知道继承主要有三个作用：表示 is-a 关系，支持多态特性，代码复用。而这三个作用都可以通过其他技术手段来达成。比如 is-a 关系，我们可以通过组合和接口的 has-a 关系来替代；多态特性我们可以利用接口来实现；代码复用我们可以通过组合和委托来实现。所以，从理论上讲，通过组合、接口、委托三个技术手段，我们完全可以替换掉继承，在项目中不用或者少用继承关系，特别是一些复杂的继承关系。</p>\n<h3 id=\"如何判断该用组合还是继承？\"><a href=\"#如何判断该用组合还是继承？\" class=\"headerlink\" title=\"如何判断该用组合还是继承？\"></a>如何判断该用组合还是继承？</h3><ol>\n<li>尽管我们鼓励多用组合少用继承，但组合也并不是完美的，继承也并非一无是处。从上面的例子来看，继承改写成组合意味着要做更细粒度的类的拆分。这也就意味着，我们要定义更多的类和接口。类和接口的增多也就或多或少地增加代码的复杂程度和维护成本。所以，在实际的项目开发中，我们还是要根据具体的情况，来具体选择该用继承还是组合。</li>\n<li>如果类之间的继承结构稳定（不会轻易改变），继承层次比较浅（比如，最多有两层继承关系），继承关系不复杂，我们就可以大胆地使用继承。反之，系统越不稳定，继承层次很深，继承关系复杂，我们就尽量使用组合来替代继承。</li>\n<li>除此之外，还有一些设计模式会固定使用继承或者组合。比如，装饰者模式（decorator pattern）、策略模式（strategy pattern）、组合模式（composite pattern）等都使用了组合关系，而模板模式（template pattern）使用了继承关系。</li>\n<li>前面我们讲到继承可以实现代码复用。利用继承特性，我们把相同的属性和方法，抽取出来，定义到父类中。子类复用父类中的属性和方法，达到代码复用的目的。但是，有的时候，从业务含义上，A 类和 B 类并不一定具有继承关系。比如，Crawler 类和 PageAnalyzer 类，它们都用到了 URL 拼接和分割的功能，但并不具有继承关系（既不是父子关系，也不是兄弟关系）。仅仅为了代码复用，生硬地抽象出一个父类出来，会影响到代码的可读性。如果不熟悉背后设计思路的同事，发现 Crawler 类和 PageAnalyzer 类继承同一个父类，而父类中定义的却只是 URL 相关的操作，会觉得这个代码写得莫名其妙，理解不了。这个时候，使用组合就更加合理、更加灵活。具体的代码实现如下所示：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Url</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">//...省略属性和方法</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Crawler</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> Url url; <span class=\"comment\">// 组合</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"title function_\">Crawler</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.url = <span class=\"keyword\">new</span> <span class=\"title class_\">Url</span>();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">PageAnalyzer</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> Url url; <span class=\"comment\">// 组合</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"title function_\">PageAnalyzer</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.url = <span class=\"keyword\">new</span> <span class=\"title class_\">Url</span>();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//..</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>还有一些特殊的场景要求我们必须使用继承。如果你不能改变一个函数的入参类型，而入参又非接口，为了支持多态，只能采用继承来实现。比如下面这样一段代码，其中 FeignClient 是一个外部类，我们没有权限去修改这部分代码，但是我们希望能重写这个类在运行时执行的 encode() 函数。这个时候，我们只能采用继承来实现了。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">FeignClient</span> &#123; <span class=\"comment\">// Feign Client框架代码</span></span><br><span class=\"line\">  <span class=\"comment\">//...省略其他代码...</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">encode</span><span class=\"params\">(String url)</span> &#123; <span class=\"comment\">//... &#125;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">demofunction</span><span class=\"params\">(FeignClient feignClient)</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">//...</span></span><br><span class=\"line\">  feignClient.encode(url);</span><br><span class=\"line\">  <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">CustomizedFeignClient</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">FeignClient</span> &#123;</span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">encode</span><span class=\"params\">(String url)</span> &#123; <span class=\"comment\">//...重写encode的实现...&#125;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 调用</span></span><br><span class=\"line\"><span class=\"type\">FeignClient</span> <span class=\"variable\">client</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">CustomizedFeignClient</span>();</span><br><span class=\"line\">demofunction(client);</span><br></pre></td></tr></table></figure>\n\n<p>尽管有些人说，要杜绝继承，100% 用组合代替继承，但是我的观点没那么极端！之所以“多用组合少用继承”这个口号喊得这么响，只是因为，长期以来，我们过度使用继承。还是那句话，组合并不完美，继承也不是一无是处。只要我们控制好它们的副作用、发挥它们各自的优势，在不同的场合下，恰当地选择使用继承还是组合，这才是我们所追求的境界。</p>\n<h2 id=\"如何通过封装、抽象、模块化、中间层等解耦代码？\"><a href=\"#如何通过封装、抽象、模块化、中间层等解耦代码？\" class=\"headerlink\" title=\"如何通过封装、抽象、模块化、中间层等解耦代码？\"></a>如何通过封装、抽象、模块化、中间层等解耦代码？</h2><h3 id=\"“解耦”为何如此重要？\"><a href=\"#“解耦”为何如此重要？\" class=\"headerlink\" title=\"“解耦”为何如此重要？\"></a>“解耦”为何如此重要？</h3><ol>\n<li>软件设计与开发最重要的工作之一就是应对复杂性。人处理复杂性的能力是有限的。过于复杂的代码往往在可读性、可维护性上都不友好。那如何来控制代码的复杂性呢？手段有很多，我个人认为，最关键的就是解耦，保证代码松耦合、高内聚。如果说重构是保证代码质量不至于腐化到无可救药地步的有效手段，那么利用解耦的方法对代码重构，就是保证代码不至于复杂到无法控制的有效手段。</li>\n<li>后文迪米特法则有介绍，什么是“高内聚、松耦合”。。实际上，“高内聚、松耦合”是一个比较通用的设计思想，不仅可以指导细粒度的类和类之间关系的设计，还能指导粗粒度的系统、架构、模块的设计。相对于编码规范，它能够在更高层次上提高代码的可读性和可维护性。</li>\n<li>不管是阅读代码还是修改代码，“高内聚、松耦合”的特性可以让我们聚焦在某一模块或类中，不需要了解太多其他模块或类的代码，让我们的焦点不至于过于发散，降低了阅读和修改代码的难度。而且，因为依赖关系简单，耦合小，修改代码不至于牵一发而动全身，代码改动比较集中，引入 bug 的风险也就减少了很多。同时，“高内聚、松耦合”的代码可测试性也更加好，容易 mock 或者很少需要 mock 外部依赖的模块或者类。</li>\n<li>除此之外，代码“高内聚、松耦合”，也就意味着，代码结构清晰、分层和模块化合理、依赖关系简单、模块或类之间的耦合小，那代码整体的质量就不会差。即便某个具体的类或者模块设计得不怎么合理，代码质量不怎么高，影响的范围是非常有限的。我们可以聚焦于这个模块或者类，做相应的小型重构。而相对于代码结构的调整，这种改动范围比较集中的小型重构的难度就容易多了。</li>\n</ol>\n<h3 id=\"代码是否需要“解耦”？\"><a href=\"#代码是否需要“解耦”？\" class=\"headerlink\" title=\"代码是否需要“解耦”？\"></a>代码是否需要“解耦”？</h3><ol>\n<li>那现在问题来了，我们该怎么判断代码的耦合程度呢？或者说，怎么判断代码是否符合“高内聚、松耦合”呢？再或者说，如何判断系统是否需要解耦重构呢？</li>\n<li>间接的衡量标准有很多，前面我们讲到了一些，比如，看修改代码会不会牵一发而动全身。除此之外，还有一个直接的衡量标准，也是我在阅读源码的时候经常会用到的，那就是把模块与模块之间、类与类之间的依赖关系画出来，根据依赖关系图的复杂性来判断是否需要解耦重构。</li>\n<li>如果依赖关系复杂、混乱，那从代码结构上来讲，可读性和可维护性肯定不是太好，那我们就需要考虑是否可以通过解耦的方法，让依赖关系变得清晰、简单。当然，这种判断还是有比较强的主观色彩，但是可以作为一种参考和梳理依赖的手段，配合间接的衡量标准一块来使用。</li>\n</ol>\n<h3 id=\"如何给代码“解耦”？\"><a href=\"#如何给代码“解耦”？\" class=\"headerlink\" title=\"如何给代码“解耦”？\"></a>如何给代码“解耦”？</h3><blockquote>\n<p> 封装与抽象</p>\n</blockquote>\n<p>封装和抽象作为两个非常通用的设计思想，可以应用在很多设计场景中，比如系统、模块、lib、组件、接口、类等等的设计。封装和抽象可以有效地隐藏实现的复杂性，隔离实现的易变性，给依赖的模块提供稳定且易用的抽象接口</p>\n<blockquote>\n<p>中间层</p>\n</blockquote>\n<p>引入中间层能简化模块或类之间的依赖关系。下面这张图是引入中间层前后的依赖关系对比图。在引入数据存储中间层之前，A、B、C 三个模块都要依赖内存一级缓存、Redis 二级缓存、DB 持久化存储三个模块。在引入中间层之后，三个模块只需要依赖数据存储一个模块即可。从图上可以看出，中间层的引入明显地简化了依赖关系，让代码结构更加清晰</p>\n<img src=\"https://npm.elemecdn.com/youthlql@1.0.0/design_patterns/design_ideas/0003.png\"/>\n\n\n\n<p>除此之外，我们在进行重构的时候，引入中间层可以起到过渡的作用，能够让开发和重构同步进行，不互相干扰。比如，某个接口设计得有问题，我们需要修改它的定义，同时，所有调用这个接口的代码都要做相应的改动。如果新开发的代码也用到这个接口，那开发就跟重构冲突了。为了让重构能小步快跑，我们可以分下面四个阶段来完成接口的修改。</p>\n<ul>\n<li>第一阶段：引入一个中间层，包裹老的接口，提供新的接口定义。</li>\n<li>第二阶段：新开发的代码依赖中间层提供的新接口。</li>\n<li>第三阶段：将依赖老接口的代码改为调用新接口。</li>\n<li>第四阶段：确保所有的代码都调用新接口之后，删除掉老的接口。</li>\n</ul>\n<p>这样，每个阶段的开发工作量都不会很大，都可以在很短的时间内完成。重构跟开发冲突的概率也变小了。</p>\n<blockquote>\n<p>模块化</p>\n</blockquote>\n<p>模块化是构建复杂系统常用的手段。不仅在软件行业，在建筑、机械制造等行业，这个手段也非常有用。对于一个大型复杂系统来说，没有人能掌控所有的细节。之所以我们能搭建出如此复杂的系统，并且能维护得了，最主要的原因就是将系统划分成各个独立的模块，让不同的人负责不同的模块，这样即便在不了解全部细节的情况下，管理者也能协调各个模块，让整个系统有效运转。</p>\n<blockquote>\n<p> 其他设计思想和原则</p>\n</blockquote>\n<p>“高内聚、松耦合”是一个非常重要的设计思想，能够有效提高代码的可读性和可维护性，缩小功能改动导致的代码改动范围。实际上，在前面的章节中，我们已经多次提到过这个设计思想。很多设计原则都以实现代码的“高内聚、松耦合”为目的。我们来一块总结回顾一下都有哪些原则。</p>\n<p>(这里没有讲的，在后面文章里)</p>\n<ul>\n<li>单一职责原则</li>\n</ul>\n<p>我们前面提到，内聚性和耦合性并非独立的。高内聚会让代码更加松耦合，而实现高内聚的重要指导原则就是单一职责原则。模块或者类的职责设计得单一，而不是大而全，那依赖它的类和它依赖的类就会比较少，代码耦合也就相应的降低了。</p>\n<ul>\n<li>基于接口而非实现编程</li>\n</ul>\n<p>基于接口而非实现编程能通过接口这样一个中间层，隔离变化和具体的实现。这样做的好处是，在有依赖关系的两个模块或类之间，一个模块或者类的改动，不会影响到另一个模块或类。实际上，这就相当于将一种强依赖关系（强耦合）解耦为了弱依赖关系（弱耦合）。依赖注入</p>\n<ul>\n<li>依赖注入</li>\n</ul>\n<p>跟基于接口而非实现编程思想类似，依赖注入也是将代码之间的强耦合变为弱耦合。尽管依赖注入无法将本应该有依赖关系的两个类，解耦为没有依赖关系，但可以让耦合关系没那么紧密，容易做到插拔替换</p>\n<ul>\n<li>多用组合少用继承</li>\n</ul>\n<p>我们知道，继承是一种强依赖关系，父类与子类高度耦合，且这种耦合关系非常脆弱，牵一发而动全身，父类的每一次改动都会影响所有的子类。相反，组合关系是一种弱依赖关系，这种关系更加灵活，所以，对于继承结构比较复杂的代码，利用组合来替换继承，也是一种解耦的有效手段。</p>\n<ul>\n<li>迪米特法则</li>\n</ul>\n<p>迪米特法则讲的是，不该有直接依赖关系的类之间，不要有依赖；有依赖关系的类之间，尽量只依赖必要的接口。从定义上，我们明显可以看出，这条原则的目的就是为了实现代码的松耦合。至于如何应用这条原则来解耦代码，你可以回过头去阅读一下第 22 讲，这里我就不赘述了。除了上面讲到的这些设计思想和原则之外，还有一些设计模式也是为了解耦依赖，比如观察者模式，有关这一部分的内容，我们留在设计模式模块中慢慢讲解。</p>\n"},{"title":"设计模式-03.02-创建型-工厂&建造者&原型","keywords":"设计模式，工厂，建造者，原型","description":"详解常用的工厂模式和建造者模式，以及不常用的原型模式","cover":"https://npm.elemecdn.com/lql_static@latest/logo/design_patterns.jpg","abbrlink":"ba432704","date":"2024-06-18T05:21:58.000Z","_content":"\n\n# 声明\n\n> 1. 此系列文章非本人原创，是学习笔记。\n> 2. 设计模式系列以后会持续更新，包括已经发布的设计模式文章，因为后续还要再多看一下书，教程和开源项目等，继续润色文章。\n\n\n\n# 工厂模式【常用】\n\n> 工厂模式很重要，后面的很多架构设计，都是工厂模式联合着其它设计模式使用。\n\n1. 一般情况下，工厂模式分为三种更加细分的类型：简单工厂、工厂方法和抽象工厂。不过，在 GoF 的《设计模式》一书中，它将简单工厂模式看作是工厂方法模式的一种特例，所以工厂模式只被分成了工厂方法和抽象工厂两类。实际上，前面一种分类方法更加常见，所以，在今天的讲解中，我们沿用第一种分类方法。\n\n2. 在这三种细分的工厂模式中，简单工厂、工厂方法原理比较简单，在实际的项目中也比较常用。而抽象工厂的原理稍微复杂点，在实际的项目中相对也不常用。所以，我们今天讲解的重点是前两种工厂模式。对于抽象工厂，稍微了解一下即可。\n\n3. 除此之外，我们讲解的重点也不是原理和实现，因为这些都很简单，重点还是带你搞清楚应用场景：什么时候该用工厂模式？相对于直接 new 来创建对象，用工厂模式来创建究竟有什么好处呢？\n\n## 简单工厂（Simple Factory）\n\n首先，我们来看，什么是简单工厂模式。我们通过一个例子来解释一下。\n\n在下面这段代码中，我们根据配置文件的后缀（json、xml、yaml、properties），选择不同的解析器（JsonRuleConfigParser、XmlRuleConfigParser……），将存储在文件中的配置解析成内存对象 RuleConfig。\n\n```java\npublic class RuleConfigSource {\n  public RuleConfig load(String ruleConfigFilePath) {\n    String ruleConfigFileExtension = getFileExtension(ruleConfigFilePath);\n    IRuleConfigParser parser = null;\n    if (\"json\".equalsIgnoreCase(ruleConfigFileExtension)) {\n      parser = new JsonRuleConfigParser();\n    } else if (\"xml\".equalsIgnoreCase(ruleConfigFileExtension)) {\n      parser = new XmlRuleConfigParser();\n    } else if (\"yaml\".equalsIgnoreCase(ruleConfigFileExtension)) {\n      parser = new YamlRuleConfigParser();\n    } else if (\"properties\".equalsIgnoreCase(ruleConfigFileExtension)) {\n      parser = new PropertiesRuleConfigParser();\n    } else {\n      throw new InvalidRuleConfigException(\n             \"Rule config file format is not supported: \" + ruleConfigFilePath);\n    }\n\n    String configText = \"\";\n    //从ruleConfigFilePath文件中读取配置文本到configText中\n    RuleConfig ruleConfig = parser.parse(configText);\n    return ruleConfig;\n  }\n\n  private String getFileExtension(String filePath) {\n    //...解析文件名获取扩展名，比如rule.json，返回json\n    return \"json\";\n  }\n}\n```\n\n为了让代码逻辑更加清晰，可读性更好，我们要善于将功能独立的代码块封装成函数。按照这个设计思路，我们可以将代码中涉及 parser 创建的部分逻辑剥离出来，抽象成 createParser() 函数。重构之后的代码如下所示：\n\n\n\n```java\n  public RuleConfig load(String ruleConfigFilePath) {\n    String ruleConfigFileExtension = getFileExtension(ruleConfigFilePath);\n    IRuleConfigParser parser = createParser(ruleConfigFileExtension);\n    if (parser == null) {\n      throw new InvalidRuleConfigException(\n              \"Rule config file format is not supported: \" + ruleConfigFilePath);\n    }\n\n    String configText = \"\";\n    //从ruleConfigFilePath文件中读取配置文本到configText中\n    RuleConfig ruleConfig = parser.parse(configText);\n    return ruleConfig;\n  }\n\n  private String getFileExtension(String filePath) {\n    //...解析文件名获取扩展名，比如rule.json，返回json\n    return \"json\";\n  }\n\n  private IRuleConfigParser createParser(String configFormat) {\n    IRuleConfigParser parser = null;\n    if (\"json\".equalsIgnoreCase(configFormat)) {\n      parser = new JsonRuleConfigParser();\n    } else if (\"xml\".equalsIgnoreCase(configFormat)) {\n      parser = new XmlRuleConfigParser();\n    } else if (\"yaml\".equalsIgnoreCase(configFormat)) {\n      parser = new YamlRuleConfigParser();\n    } else if (\"properties\".equalsIgnoreCase(configFormat)) {\n      parser = new PropertiesRuleConfigParser();\n    }\n    return parser;\n  }\n}\n```\n\n\n\n为了让类的职责更加单一(**设计模式原则中的单一职责**，)、代码更加清晰，我们还可以进一步将 createParser() 函数剥离到一个独立的类中，让这个类只负责对象的创建。而这个类就是我们现在要讲的简单工厂模式类。具体的代码如下所示：\n\n```java\npublic class RuleConfigSource {\n  public RuleConfig load(String ruleConfigFilePath) {\n    String ruleConfigFileExtension = getFileExtension(ruleConfigFilePath);\n    IRuleConfigParser parser = RuleConfigParserFactory.createParser(ruleConfigFileExtension);\n    if (parser == null) {\n      throw new InvalidRuleConfigException(\n              \"Rule config file format is not supported: \" + ruleConfigFilePath);\n    }\n\n    String configText = \"\";\n    //从ruleConfigFilePath文件中读取配置文本到configText中\n    RuleConfig ruleConfig = parser.parse(configText);\n    return ruleConfig;\n  }\n\n  private String getFileExtension(String filePath) {\n    //...解析文件名获取扩展名，比如rule.json，返回json\n    return \"json\";\n  }\n}\n\npublic class RuleConfigParserFactory {\n  public static IRuleConfigParser createParser(String configFormat) {\n    IRuleConfigParser parser = null;\n    if (\"json\".equalsIgnoreCase(configFormat)) {\n      parser = new JsonRuleConfigParser();\n    } else if (\"xml\".equalsIgnoreCase(configFormat)) {\n      parser = new XmlRuleConfigParser();\n    } else if (\"yaml\".equalsIgnoreCase(configFormat)) {\n      parser = new YamlRuleConfigParser();\n    } else if (\"properties\".equalsIgnoreCase(configFormat)) {\n      parser = new PropertiesRuleConfigParser();\n    }\n    return parser;\n  }\n}\n```\n\n\n\n1. 在上面的代码实现中，我们每次调用 RuleConfigParserFactory 的 createParser() 的时候，都要创建一个新的 parser。\n2. 实际上，如果 parser 可以复用，为了节省内存和对象创建的时间，我们可以将 parser 事先创建好缓存起来。当调用 createParser() 函数的时候，我们从缓存中取出 parser 对象直接使用。这有点类似单例模式和简单工厂模式的结合，具体的代码实现如下所示。在接下来的讲解中，我们把上一种实现方法叫作简单工厂模式的第一种实现方法，把下面这种实现方法叫作简单工厂模式的第二种实现方法。\n\n\n\n```java\npublic class RuleConfigParserFactory {\n  private static final Map<String, RuleConfigParser> cachedParsers = new HashMap<>();\n\n  static {\n    cachedParsers.put(\"json\", new JsonRuleConfigParser());\n    cachedParsers.put(\"xml\", new XmlRuleConfigParser());\n    cachedParsers.put(\"yaml\", new YamlRuleConfigParser());\n    cachedParsers.put(\"properties\", new PropertiesRuleConfigParser());\n  }\n\n  public static IRuleConfigParser createParser(String configFormat) {\n    if (configFormat == null || configFormat.isEmpty()) {\n      return null;//返回null还是IllegalArgumentException全凭你自己说了算\n    }\n    IRuleConfigParser parser = cachedParsers.get(configFormat.toLowerCase());\n    return parser;\n  }\n}\n```\n\n\n\n1. 对于上面两种简单工厂模式的实现方法，如果我们要添加新的 parser，那势必要改动到 RuleConfigParserFactory 的代码，那这是不是违反开闭原则呢？实际上，如果不是需要频繁地添加新的 parser，只是偶尔修改一下 RuleConfigParserFactory 代码，稍微不符合开闭原则，也是完全可以接受的。\n2. 除此之外，在 RuleConfigParserFactory 的第一种代码实现中，有一组 if 分支判断逻辑，是不是应该用多态或其他设计模式来替代呢？实际上，如果 if 分支并不是很多，代码中有 if 分支也是完全可以接受的。应用多态或设计模式来替代 if 分支判断逻辑，也并不是没有任何缺点的，它虽然提高了代码的扩展性，更加符合**开闭原则**，但也增加了类的个数，牺牲了代码的可读性。关于这一点，我们在后面章节中会详细讲到。\n3. 总结一下，尽管简单工厂模式的代码实现中，有多处 if 分支判断逻辑，违背开闭原则，但权衡扩展性和可读性，这样的代码实现在大多数情况下（比如，不需要频繁地添加 parser，也没有太多的 parser）是没有问题的。\n\n\n\n## 工厂方法（Factory Method）\n\n如果我们非得要将 if 分支逻辑去掉，那该怎么办呢？比较经典处理方法就是利用多态。按照多态的实现思路，对上面的代码进行重构。重构之后的代码如下所示：\n\n```java\npublic interface IRuleConfigParserFactory {\n  IRuleConfigParser createParser();\n}\n\npublic class JsonRuleConfigParserFactory implements IRuleConfigParserFactory {\n  @Override\n  public IRuleConfigParser createParser() {\n    return new JsonRuleConfigParser();\n  }\n}\n\npublic class XmlRuleConfigParserFactory implements IRuleConfigParserFactory {\n  @Override\n  public IRuleConfigParser createParser() {\n    return new XmlRuleConfigParser();\n  }\n}\n\npublic class YamlRuleConfigParserFactory implements IRuleConfigParserFactory {\n  @Override\n  public IRuleConfigParser createParser() {\n    return new YamlRuleConfigParser();\n  }\n}\n\npublic class PropertiesRuleConfigParserFactory implements IRuleConfigParserFactory {\n  @Override\n  public IRuleConfigParser createParser() {\n    return new PropertiesRuleConfigParser();\n  }\n}\n```\n\n\n\n实际上，这就是工厂方法模式的典型代码实现。这样当我们新增一种 parser 的时候，只需要新增一个实现了 IRuleConfigParserFactory 接口的 Factory 类即可。所以，工厂方法模式比起简单工厂模式更加符合开闭原则。\n\n\n\n从上面的工厂方法的实现来看，一切都很完美，但是实际上存在挺大的问题。问题存在于这些工厂类的使用上。接下来，我们看一下，如何用这些工厂类来实现 RuleConfigSource 的 load() 函数。具体的代码如下所示：\n\n\n\n```java\npublic class RuleConfigSource {\n  public RuleConfig load(String ruleConfigFilePath) {\n    String ruleConfigFileExtension = getFileExtension(ruleConfigFilePath);\n\n    IRuleConfigParserFactory parserFactory = null;\n    if (\"json\".equalsIgnoreCase(ruleConfigFileExtension)) {\n      parserFactory = new JsonRuleConfigParserFactory();\n    } else if (\"xml\".equalsIgnoreCase(ruleConfigFileExtension)) {\n      parserFactory = new XmlRuleConfigParserFactory();\n    } else if (\"yaml\".equalsIgnoreCase(ruleConfigFileExtension)) {\n      parserFactory = new YamlRuleConfigParserFactory();\n    } else if (\"properties\".equalsIgnoreCase(ruleConfigFileExtension)) {\n      parserFactory = new PropertiesRuleConfigParserFactory();\n    } else {\n      throw new InvalidRuleConfigException(\"Rule config file format is not supported: \" + ruleConfigFilePath);\n    }\n    IRuleConfigParser parser = parserFactory.createParser();\n\n    String configText = \"\";\n    //从ruleConfigFilePath文件中读取配置文本到configText中\n    RuleConfig ruleConfig = parser.parse(configText);\n    return ruleConfig;\n  }\n\n  private String getFileExtension(String filePath) {\n    //...解析文件名获取扩展名，比如rule.json，返回json\n    return \"json\";\n  }\n}\n```\n\n\n\n1. 从上面的代码实现来看，工厂类对象的创建逻辑又耦合进了 load() 函数中，跟我们最初的代码版本非常相似，引入工厂方法非但没有解决问题，反倒让设计变得更加复杂了。那怎么来解决这个问题呢？\n2. 我们可以为工厂类再创建一个简单工厂，也就是工厂的工厂，用来创建工厂类对象。这段话听起来有点绕，我把代码实现出来了，你一看就能明白了。其中，RuleConfigParserFactoryMap 类是创建工厂对象的工厂类，getParserFactory() 返回的是缓存好的单例工厂对象。\n\n```java\npublic class RuleConfigSource {\n  public RuleConfig load(String ruleConfigFilePath) {\n    String ruleConfigFileExtension = getFileExtension(ruleConfigFilePath);\n\n    IRuleConfigParserFactory parserFactory = RuleConfigParserFactoryMap.getParserFactory(ruleConfigFileExtension);\n    if (parserFactory == null) {\n      throw new InvalidRuleConfigException(\"Rule config file format is not supported: \" + ruleConfigFilePath);\n    }\n    IRuleConfigParser parser = parserFactory.createParser();\n\n    String configText = \"\";\n    //从ruleConfigFilePath文件中读取配置文本到configText中\n    RuleConfig ruleConfig = parser.parse(configText);\n    return ruleConfig;\n  }\n\n  private String getFileExtension(String filePath) {\n    //...解析文件名获取扩展名，比如rule.json，返回json\n    return \"json\";\n  }\n}\n\n//因为工厂类只包含方法，不包含成员变量，完全可以复用，\n//不需要每次都创建新的工厂类对象，所以，简单工厂模式的第二种实现思路更加合适。\npublic class RuleConfigParserFactoryMap { //工厂的工厂\n  private static final Map<String, IRuleConfigParserFactory> cachedFactories = new HashMap<>();\n\n  static {\n    cachedFactories.put(\"json\", new JsonRuleConfigParserFactory());\n    cachedFactories.put(\"xml\", new XmlRuleConfigParserFactory());\n    cachedFactories.put(\"yaml\", new YamlRuleConfigParserFactory());\n    cachedFactories.put(\"properties\", new PropertiesRuleConfigParserFactory());\n  }\n\n  public static IRuleConfigParserFactory getParserFactory(String type) {\n    if (type == null || type.isEmpty()) {\n      return null;\n    }\n    IRuleConfigParserFactory parserFactory = cachedFactories.get(type.toLowerCase());\n    return parserFactory;\n  }\n}\n```\n\n\n\n1. 当我们需要添加新的规则配置解析器的时候，我们只需要创建新的 parser 类和 parser factory 类，并且在 RuleConfigParserFactoryMap 类中，将新的 parser factory 对象添加到 cachedFactories 中即可。代码的改动非常少，基本上符合开闭原则。\n2. 实际上，对于规则配置文件解析这个应用场景来说，工厂模式需要额外创建诸多 Factory 类，也会增加代码的复杂性，而且，每个 Factory 类只是做简单的 new 操作，功能非常单薄（只有一行代码），也没必要设计成独立的类，所以，在这个应用场景下，简单工厂模式简单好用，比工厂方法模式更加合适。\n\n\n\n### 那什么时候该用工厂方法模式，而非简单工厂模式呢？\n\n1. 我们前面提到，之所以将某个代码块剥离出来，独立为函数或者类，原因是这个代码块的逻辑过于复杂，剥离之后能让代码更加清晰，更加可读、可维护。但是，如果代码块本身并不复杂，就几行代码而已，我们完全没必要将它拆分成单独的函数或者类。\n2. 基于这个设计思想，当对象的创建逻辑比较复杂，不只是简单的 new 一下就可以，而是要组合其他类对象，做各种初始化操作的时候，我们推荐使用工厂方法模式，将复杂的创建逻辑拆分到多个工厂类中，让每个工厂类都不至于过于复杂。而使用简单工厂模式，将所有的创建逻辑都放到一个工厂类中，会导致这个工厂类变得很复杂。\n3. 除此之外，在某些场景下，如果对象不可复用，那工厂类每次都要返回不同的对象。如果我们使用简单工厂模式来实现，就只能选择第一种包含 if 分支逻辑的实现方式。如果我们还想避免烦人的 if-else 分支逻辑，这个时候，我们就推荐使用工厂方法模式。\n\n\n\n## 抽象工厂（Abstract Factory）\n\n1. 讲完了简单工厂、工厂方法，我们再来看抽象工厂模式。抽象工厂模式的应用场景比较特殊，没有前两种常用，所以不是我们学习的重点，你简单了解一下就可以了。\n2. 在简单工厂和工厂方法中，类只有一种分类方式。比如，在规则配置解析那个例子中，解析器类只会根据配置文件格式（Json、Xml、Yaml……）来分类。但是，如果类有两种分类方式，比如，我们既可以按照配置文件格式来分类，也可以按照解析的对象（Rule 规则配置还是 System 系统配置）来分类，那就会对应下面这 8 个 parser 类。\n\n```java\n针对规则配置的解析器：基于接口IRuleConfigParser\nJsonRuleConfigParser\nXmlRuleConfigParser\nYamlRuleConfigParser\nPropertiesRuleConfigParser\n\n针对系统配置的解析器：基于接口ISystemConfigParser\nJsonSystemConfigParser\nXmlSystemConfigParser\nYamlSystemConfigParser\nPropertiesSystemConfigParser\n```\n\n\n\n1. 针对这种特殊的场景，如果还是继续用工厂方法来实现的话，我们要针对每个 parser 都编写一个工厂类，也就是要编写 8 个工厂类。如果我们未来还需要增加针对业务配置的解析器（比如 IBizConfigParser），那就要再对应地增加 4 个工厂类。而我们知道，过多的类也会让系统难维护。这个问题该怎么解决呢？\n2. 抽象工厂就是针对这种非常特殊的场景而诞生的。我们可以让一个工厂负责创建多个不同类型的对象（IRuleConfigParser、ISystemConfigParser 等），而不是只创建一种 parser 对象。这样就可以有效地减少工厂类的个数。具体的代码实现如下所示：\n\n```java\npublic interface IConfigParserFactory {\n  IRuleConfigParser createRuleParser();\n  ISystemConfigParser createSystemParser();\n  //此处可以扩展新的parser类型，比如IBizConfigParser\n}\n\npublic class JsonConfigParserFactory implements IConfigParserFactory {\n  @Override\n  public IRuleConfigParser createRuleParser() {\n    return new JsonRuleConfigParser();\n  }\n\n  @Override\n  public ISystemConfigParser createSystemParser() {\n    return new JsonSystemConfigParser();\n  }\n}\n\npublic class XmlConfigParserFactory implements IConfigParserFactory {\n  @Override\n  public IRuleConfigParser createRuleParser() {\n    return new XmlRuleConfigParser();\n  }\n\n  @Override\n  public ISystemConfigParser createSystemParser() {\n    return new XmlSystemConfigParser();\n  }\n}\n\n// 省略YamlConfigParserFactory和PropertiesConfigParserFactory代码\n```\n\n\n\n## 如何设计实现一个Dependency Injection框架？\n\n\n\n当创建对象是一个“大工程”的时候，我们一般会选择使用工厂模式，来封装对象复杂的创建过程，将对象的创建和使用分离，让代码更加清晰。那何为“大工程”呢？上面我们讲了两种情况，一种是创建过程涉及复杂的 if-else 分支判断，另一种是对象创建需要组装多个其他类对象或者需要复杂的初始化过程。\n\n\n\n今天，我们再来讲一个创建对象的“大工程”，依赖注入框架，或者叫依赖注入容器（Dependency Injection Container），简称 DI 容器。在今天的讲解中，我会带你一块搞清楚这样几个问题：DI 容器跟我们讲的工厂模式又有何区别和联系？DI 容器的核心功能有哪些，以及如何实现一个简单的 DI 容器？\n\n\n\n\n\n### 工厂模式和 DI 容器有何区别？\n\n1. 实际上，DI 容器底层最基本的设计思路就是基于工厂模式的。DI 容器相当于一个大的工厂类，负责在程序启动的时候，根据配置（要创建哪些类对象，每个类对象的创建需要依赖哪些其他类对象）事先创建好对象。当应用程序需要使用某个类对象的时候，直接从容器中获取即可。正是因为它持有一堆对象，所以这个框架才被称为“容器”。\n2. DI 容器相对于我们上面讲的工厂模式的例子来说，它处理的是更大的对象创建工程。上面讲的工厂模式中，一个工厂类只负责某个类对象或者某一组相关类对象（继承自同一抽象类或者接口的子类）的创建，而 DI 容器负责的是整个应用中所有类对象的创建。\n3. 除此之外，DI 容器负责的事情要比单纯的工厂模式要多。比如，它还包括配置的解析、对象生命周期的管理。接下来，我们就详细讲讲，一个简单的 DI 容器应该包含哪些核心功能。\n\n\n\n### DI 容器的核心功能有哪些？\n\n总结一下，一个简单的 DI 容器的核心功能一般有三个：配置解析、对象创建和对象生命周期管理。\n\n\n\n> 首先，我们来看配置解析。\n\n1. 在上面讲的工厂模式中，工厂类要创建哪个类对象是事先确定好的，并且是写死在工厂类代码中的。作为一个通用的框架来说，框架代码跟应用代码应该是高度解耦的，DI 容器事先并不知道应用会创建哪些对象，不可能把某个应用要创建的对象写死在框架代码中。所以，我们需要通过一种形式，让应用告知 DI 容器要创建哪些对象。这种形式就是我们要讲的配置。\n2. 我们将需要由 DI 容器来创建的类对象和创建类对象的必要信息（使用哪个构造函数以及对应的构造函数参数都是什么等等），放到配置文件中。容器读取配置文件，根据配置文件提供的信息来创建对象。\n3. 下面是一个典型的 Spring 容器的配置文件。Spring 容器读取这个配置文件，解析出要创建的两个对象：rateLimiter 和 redisCounter，并且得到两者的依赖关系：rateLimiter 依赖 redisCounter。\n\n\n\n```java\npublic class RateLimiter {\n  private RedisCounter redisCounter;\n  public RateLimiter(RedisCounter redisCounter) {\n    this.redisCounter = redisCounter;\n  }\n  public void test() {\n    System.out.println(\"Hello World!\");\n  }\n  //...\n}\n\npublic class RedisCounter {\n  private String ipAddress;\n  private int port;\n  public RedisCounter(String ipAddress, int port) {\n    this.ipAddress = ipAddress;\n    this.port = port;\n  }\n  //...\n}\n\n配置文件beans.xml：\n<beans>\n   <bean id=\"rateLimiter\" class=\"com.xzg.RateLimiter\">\n      <constructor-arg ref=\"redisCounter\"/>\n   </bean>\n \n   <bean id=\"redisCounter\" class=\"com.xzg.redisCounter\">\n     <constructor-arg type=\"String\" value=\"127.0.0.1\">\n     <constructor-arg type=\"int\" value=1234>\n   </bean>\n</beans>\n```\n\n\n\n> 其次，我们再来看对象创建。\n\n1. 在 DI 容器中，如果我们给每个类都对应创建一个工厂类，那项目中类的个数会成倍增加，这会增加代码的维护成本。要解决这个问题并不难。我们只需要将所有类对象的创建都放到一个工厂类中完成就可以了，比如 BeansFactory。\n2. 你可能会说，如果要创建的类对象非常多，BeansFactory 中的代码会不会线性膨胀（代码量跟创建对象的个数成正比）呢？实际上并不会。待会讲到 DI 容器的具体实现的时候，我们会讲“反射”这种机制，它能在程序运行的过程中，动态地加载类、创建对象，不需要事先在代码中写死要创建哪些对象。所以，不管是创建一个对象还是十个对象，BeansFactory 工厂类代码都是一样的。\n\n\n\n> 最后，我们来看对象的生命周期管理。\n\n1. 上面我们讲到，简单工厂模式有两种实现方式，一种是每次都返回新创建的对象，另一种是每次都返回同一个事先创建好的对象，也就是所谓的单例对象。在 Spring 框架中，我们可以通过配置 scope 属性，来区分这两种不同类型的对象。scope=prototype 表示返回新创建的对象，scope=singleton 表示返回单例对象。\n2. 除此之外，我们还可以配置对象是否支持懒加载。如果 lazy-init=true，对象在真正被使用到的时候（比如：BeansFactory.getBean(“userService”)）才被被创建；如果 lazy-init=false，对象在应用启动的时候就事先创建好。\n3. 不仅如此，我们还可以配置对象的 init-method 和 destroy-method 方法，比如 init-method=loadProperties()，destroy-method=updateConfigFile()。DI 容器在创建好对象之后，会主动调用 init-method 属性指定的方法来初始化对象。在对象被最终销毁之前，DI 容器会主动调用 destroy-method 属性指定的方法来做一些清理工作，比如释放数据库连接池、关闭文件。\n\n\n\n## 如何实现一个简单的 DI 容器？\n\n用 Java 语言来实现一个简单的 DI 容器，核心逻辑只需要包括这样两个部分：配置文件解析、根据配置文件通过“反射”语法来创建对象。\n\n\n\n### 最小原型设计\n\n因为我们主要是讲解设计模式，所以，在今天的讲解中，我们只实现一个 DI 容器的最小原型。像 Spring 框架这样的 DI 容器，它支持的配置格式非常灵活和复杂。为了简化代码实现，重点讲解原理，在最小原型中，我们只支持下面配置文件中涉及的配置语法。\n\n```java\n配置文件beans.xml\n<beans>\n   <bean id=\"rateLimiter\" class=\"com.xzg.RateLimiter\">\n      <constructor-arg ref=\"redisCounter\"/>\n   </bean>\n \n   <bean id=\"redisCounter\" class=\"com.xzg.redisCounter\" scope=\"singleton\" lazy-init=\"true\">\n     <constructor-arg type=\"String\" value=\"127.0.0.1\">\n     <constructor-arg type=\"int\" value=1234>\n   </bean>\n</bean\n```\n\n\n\n最小原型的使用方式跟 Spring 框架非常类似，示例代码如下所示：\n\n```java\npublic class Demo {\n  public static void main(String[] args) {\n    ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\n            \"beans.xml\");\n    RateLimiter rateLimiter = (RateLimiter) applicationContext.getBean(\"rateLimiter\");\n    rateLimiter.test();\n    //...\n  }\n}\n```\n\n\n\n### 提供执行入口\n\n面向对象设计的最后一步是：组装类并提供执行入口。在这里，执行入口就是一组暴露给外部使用的接口和类。通过刚刚的最小原型使用示例代码，我们可以看出，执行入口主要包含两部分：ApplicationContext 和 ClassPathXmlApplicationContext。其中，ApplicationContext 是接口，ClassPathXmlApplicationContext 是接口的实现类。两个类具体实现如下所示：\n\n\n\n```java\npublic interface ApplicationContext {\n  Object getBean(String beanId);\n}\n\npublic class ClassPathXmlApplicationContext implements ApplicationContext {\n  private BeansFactory beansFactory;\n  private BeanConfigParser beanConfigParser;\n\n  public ClassPathXmlApplicationContext(String configLocation) {\n    this.beansFactory = new BeansFactory();\n    this.beanConfigParser = new XmlBeanConfigParser();\n    loadBeanDefinitions(configLocation);\n  }\n\n  private void loadBeanDefinitions(String configLocation) {\n    InputStream in = null;\n    try {\n      in = this.getClass().getResourceAsStream(\"/\" + configLocation);\n      if (in == null) {\n        throw new RuntimeException(\"Can not find config file: \" + configLocation);\n      }\n      List<BeanDefinition> beanDefinitions = beanConfigParser.parse(in);\n      beansFactory.addBeanDefinitions(beanDefinitions);\n    } finally {\n      if (in != null) {\n        try {\n          in.close();\n        } catch (IOException e) {\n          // TODO: log error\n        }\n      }\n    }\n  }\n\n  @Override\n  public Object getBean(String beanId) {\n    return beansFactory.getBean(beanId);\n  }\n}\n```\n\n从上面的代码中，我们可以看出，ClassPathXmlApplicationContext 负责组装 BeansFactory 和 BeanConfigParser 两个类，串联执行流程：从 classpath 中加载 XML 格式的配置文件，通过 BeanConfigParser 解析为统一的 BeanDefinition 格式，然后，BeansFactory 根据 BeanDefinition 来创建对象。\n\n\n\n### 配置文件解析\n\n配置文件解析主要包含 BeanConfigParser 接口和 XmlBeanConfigParser 实现类，负责将配置文件解析为 BeanDefinition 结构，以便 BeansFactory 根据这个结构来创建对象。配置文件的解析比较繁琐，不涉及我们要讲的理论知识，不是我们讲解的重点，所以这里我只给出两个类的大致设计思路，并未给出具体的实现代码。如果感兴趣的话，你可以自行补充完整。具体的代码框架如下所示：\n\n```java\npublic interface BeanConfigParser {\n  List<BeanDefinition> parse(InputStream inputStream);\n  List<BeanDefinition> parse(String configContent);\n}\n\npublic class XmlBeanConfigParser implements BeanConfigParser {\n\n  @Override\n  public List<BeanDefinition> parse(InputStream inputStream) {\n    String content = null;\n    // TODO:...\n    return parse(content);\n  }\n\n  @Override\n  public List<BeanDefinition> parse(String configContent) {\n    List<BeanDefinition> beanDefinitions = new ArrayList<>();\n    // TODO:...\n    return beanDefinitions;\n  }\n\n}\n\npublic class BeanDefinition {\n  private String id;\n  private String className;\n  private List<ConstructorArg> constructorArgs = new ArrayList<>();\n  private Scope scope = Scope.SINGLETON;\n  private boolean lazyInit = false;\n  // 省略必要的getter/setter/constructors\n \n  public boolean isSingleton() {\n    return scope.equals(Scope.SINGLETON);\n  }\n\n\n  public static enum Scope {\n    SINGLETON,\n    PROTOTYPE\n  }\n  \n  public static class ConstructorArg {\n    private boolean isRef;\n    private Class type;\n    private Object arg;\n    // 省略必要的getter/setter/constructors\n  }\n}\n```\n\n\n\n### 核心工厂类设计\n\n1. 最后，我们来看，BeansFactory 是如何设计和实现的。这也是我们这个 DI 容器最核心的一个类了。它负责根据从配置文件解析得到的 BeanDefinition 来创建对象。\n2. 如果对象的 scope 属性是 singleton，那对象创建之后会缓存在 singletonObjects 这样一个 map 中，下次再请求此对象的时候，直接从 map 中取出返回，不需要重新创建。如果对象的 scope 属性是 prototype，那每次请求对象，BeansFactory 都会创建一个新的对象返回。\n3. 实际上，BeansFactory 创建对象用到的主要技术点就是 Java 中的反射语法：一种动态加载类和创建对象的机制。我们知道，JVM 在启动的时候会根据代码自动地加载类、创建对象。至于都要加载哪些类、创建哪些对象，这些都是在代码中写死的，或者说提前写好的。但是，如果某个对象的创建并不是写死在代码中，而是放到配置文件中，我们需要在程序运行期间，动态地根据配置文件来加载类、创建对象，那这部分工作就没法让 JVM 帮我们自动完成了，我们需要利用 Java 提供的反射语法自己去编写代码。\n4. 搞清楚了反射的原理，BeansFactory 的代码就不难看懂了。具体代码实现如下所示：\n\n\n\n```java\npublic class BeansFactory {\n  private ConcurrentHashMap<String, Object> singletonObjects = new ConcurrentHashMap<>();\n  private ConcurrentHashMap<String, BeanDefinition> beanDefinitions = new ConcurrentHashMap<>();\n\n  public void addBeanDefinitions(List<BeanDefinition> beanDefinitionList) {\n    for (BeanDefinition beanDefinition : beanDefinitionList) {\n      this.beanDefinitions.putIfAbsent(beanDefinition.getId(), beanDefinition);\n    }\n\n    for (BeanDefinition beanDefinition : beanDefinitionList) {\n      if (beanDefinition.isLazyInit() == false && beanDefinition.isSingleton()) {\n        createBean(beanDefinition);\n      }\n    }\n  }\n\n  public Object getBean(String beanId) {\n    BeanDefinition beanDefinition = beanDefinitions.get(beanId);\n    if (beanDefinition == null) {\n      throw new NoSuchBeanDefinitionException(\"Bean is not defined: \" + beanId);\n    }\n    return createBean(beanDefinition);\n  }\n\n  @VisibleForTesting\n  protected Object createBean(BeanDefinition beanDefinition) {\n    if (beanDefinition.isSingleton() && singletonObjects.contains(beanDefinition.getId())) {\n      return singletonObjects.get(beanDefinition.getId());\n    }\n\n    Object bean = null;\n    try {\n      Class beanClass = Class.forName(beanDefinition.getClassName());\n      List<BeanDefinition.ConstructorArg> args = beanDefinition.getConstructorArgs();\n      if (args.isEmpty()) {\n        bean = beanClass.newInstance();\n      } else {\n        Class[] argClasses = new Class[args.size()];\n        Object[] argObjects = new Object[args.size()];\n        for (int i = 0; i < args.size(); ++i) {\n          BeanDefinition.ConstructorArg arg = args.get(i);\n          if (!arg.getIsRef()) {\n            argClasses[i] = arg.getType();\n            argObjects[i] = arg.getArg();\n          } else {\n            BeanDefinition refBeanDefinition = beanDefinitions.get(arg.getArg());\n            if (refBeanDefinition == null) {\n              throw new NoSuchBeanDefinitionException(\"Bean is not defined: \" + arg.getArg());\n            }\n            argClasses[i] = Class.forName(refBeanDefinition.getClassName());\n            argObjects[i] = createBean(refBeanDefinition);\n          }\n        }\n        bean = beanClass.getConstructor(argClasses).newInstance(argObjects);\n      }\n    } catch (ClassNotFoundException | IllegalAccessException\n            | InstantiationException | NoSuchMethodException | InvocationTargetException e) {\n      throw new BeanCreationFailureException(\"\", e);\n    }\n\n    if (bean != null && beanDefinition.isSingleton()) {\n      singletonObjects.putIfAbsent(beanDefinition.getId(), bean);\n      return singletonObjects.get(beanDefinition.getId());\n    }\n    return bean;\n  }\n}\n```\n\n1. 执行入口那里调用`addBeanDefinitions`\n2. 然后`addBeanDefinitions`再调用createBean利用反射创建对象，如果对象的 scope 属性是 singleton，那对象创建之后会缓存在 singletonObjects 这样一个 map 中\n3. 最后最小原型设计那里再调用getBean从singletonObjects 获取对象。\n\n\n\n\n\n# 建造者模式【常用】\n\n> 只要是标注常用的，基本上用的都比较多，无论篇幅长短，都不要忽视。\n\n建造者模式的原理和代码实现非常简单，掌握起来并不难，难点在于应用场景。比如，你有没有考虑过这样几个问题：直接使用构造函数或者配合 set 方法就能创建对象，为什么还需要建造者模式来创建呢？建造者模式和工厂模式都可以创建对象，那它们两个的区别在哪里呢？\n\n## 为什么需要建造者模式？\n\n\n\n1. 在平时的开发中，创建一个对象最常用的方式是，使用 new 关键字调用类的构造函数来完成。我的问题是，什么情况下这种方式就不适用了，就需要采用建造者模式来创建对象呢？你可以先思考一下，下面我通过一个例子来带你看一下。\n2. 假设有这样一道设计面试题：我们需要定义一个资源池配置类 ResourcePoolConfig。这里的资源池，你可以简单理解为线程池、连接池、对象池等。在这个资源池配置类中，有以下几个成员变量，也就是可配置项。现在，请你编写代码实现这个 ResourcePoolConfig 类。\n\n<img src=\"https://npm.elemecdn.com/youthlql@1.0.0/design_patterns/creational/03.02/0001.png\" />\n\n\n\n只要你稍微有点开发经验，那实现这样一个类对你来说并不是件难事。最常见、最容易想到的实现思路如下代码所示。因为 maxTotal、maxIdle、minIdle 不是必填变量，所以在创建 ResourcePoolConfig 对象的时候，我们通过往构造函数中，给这几个参数传递 null 值，来表示使用默认值。\n\n```java\npublic class ResourcePoolConfig {\n  private static final int DEFAULT_MAX_TOTAL = 8;\n  private static final int DEFAULT_MAX_IDLE = 8;\n  private static final int DEFAULT_MIN_IDLE = 0;\n\n  private String name;\n  private int maxTotal = DEFAULT_MAX_TOTAL;\n  private int maxIdle = DEFAULT_MAX_IDLE;\n  private int minIdle = DEFAULT_MIN_IDLE;\n\n  public ResourcePoolConfig(String name, Integer maxTotal, Integer maxIdle, Integer minIdle) {\n    if (StringUtils.isBlank(name)) {\n      throw new IllegalArgumentException(\"name should not be empty.\");\n    }\n    this.name = name;\n\n    if (maxTotal != null) {\n      if (maxTotal <= 0) {\n        throw new IllegalArgumentException(\"maxTotal should be positive.\");\n      }\n      this.maxTotal = maxTotal;\n    }\n\n    if (maxIdle != null) {\n      if (maxIdle < 0) {\n        throw new IllegalArgumentException(\"maxIdle should not be negative.\");\n      }\n      this.maxIdle = maxIdle;\n    }\n\n    if (minIdle != null) {\n      if (minIdle < 0) {\n        throw new IllegalArgumentException(\"minIdle should not be negative.\");\n      }\n      this.minIdle = minIdle;\n    }\n  }\n  //...省略getter方法...\n}\n```\n\n现在，ResourcePoolConfig 只有 4 个可配置项，对应到构造函数中，也只有 4 个参数，参数的个数不多。但是，如果可配置项逐渐增多，变成了 8 个、10 个，甚至更多，那继续沿用现在的设计思路，构造函数的参数列表会变得很长，代码在可读性和易用性上都会变差。在使用构造函数的时候，我们就容易搞错各参数的顺序，传递进错误的参数值，导致非常隐蔽的 bug。\n\n```java\n// 参数太多，导致可读性差、参数可能传递错误\nResourcePoolConfig config = new ResourcePoolConfig(\"dbconnectionpool\", 16, null, 8, null, false , true, 10, 20，false， true);\n```\n\n\n\n解决这个问题的办法你应该也已经想到了，那就是用 set() 函数来给成员变量赋值，以替代冗长的构造函数。我们直接看代码，具体如下所示。其中，配置项 name 是必填的，所以我们把它放到构造函数中设置，强制创建类对象的时候就要填写。其他配置项 maxTotal、maxIdle、minIdle 都不是必填的，所以我们通过 set() 函数来设置，让使用者自主选择填写或者不填写。\n\n\n\n```java\npublic class ResourcePoolConfig {\n  private static final int DEFAULT_MAX_TOTAL = 8;\n  private static final int DEFAULT_MAX_IDLE = 8;\n  private static final int DEFAULT_MIN_IDLE = 0;\n\n  private String name;\n  private int maxTotal = DEFAULT_MAX_TOTAL;\n  private int maxIdle = DEFAULT_MAX_IDLE;\n  private int minIdle = DEFAULT_MIN_IDLE;\n  \n  public ResourcePoolConfig(String name) {\n    if (StringUtils.isBlank(name)) {\n      throw new IllegalArgumentException(\"name should not be empty.\");\n    }\n    this.name = name;\n  }\n\n  public void setMaxTotal(int maxTotal) {\n    if (maxTotal <= 0) {\n      throw new IllegalArgumentException(\"maxTotal should be positive.\");\n    }\n    this.maxTotal = maxTotal;\n  }\n\n  public void setMaxIdle(int maxIdle) {\n    if (maxIdle < 0) {\n      throw new IllegalArgumentException(\"maxIdle should not be negative.\");\n    }\n    this.maxIdle = maxIdle;\n  }\n\n  public void setMinIdle(int minIdle) {\n    if (minIdle < 0) {\n      throw new IllegalArgumentException(\"minIdle should not be negative.\");\n    }\n    this.minIdle = minIdle;\n  }\n  //...省略getter方法...\n}\n```\n\n\n\n接下来，我们来看新的 ResourcePoolConfig 类该如何使用。我写了一个示例代码，如下所示。没有了冗长的函数调用和参数列表，代码在可读性和易用性上提高了很多。\n\n```java\n// ResourcePoolConfig使用举例\nResourcePoolConfig config = new ResourcePoolConfig(\"dbconnectionpool\");\nconfig.setMaxTotal(16);\nconfig.setMaxIdle(8);\n```\n\n\n\n至此，我们仍然没有用到建造者模式，通过构造函数设置必填项，通过 set() 方法设置可选配置项，就能实现我们的设计需求。如果我们把问题的难度再加大点，比如，还需要解决下面这三个问题，那现在的设计思路就不能满足了。\n\n- 我们刚刚讲到，name 是必填的，所以，我们把它放到构造函数中，强制创建对象的时候就设置。如果必填的配置项有很多，把这些必填配置项都放到构造函数中设置，那构造函数就又会出现参数列表很长的问题。如果我们把必填项也通过 set() 方法设置，那校验这些必填项是否已经填写的逻辑就无处安放了。\n- 除此之外，假设配置项之间有一定的依赖关系，比如，如果用户设置了 maxTotal、maxIdle、minIdle 其中一个，就必须显式地设置另外两个；或者配置项之间有一定的约束条件，比如，maxIdle 和 minIdle 要小于等于 maxTotal。如果我们继续使用现在的设计思路，那这些配置项之间的依赖关系或者约束条件的校验逻辑就无处安放了。\n- 如果我们希望 ResourcePoolConfig 类对象是不可变对象，也就是说，对象在创建好之后，就不能再修改内部的属性值。要实现这个功能，我们就不能在 ResourcePoolConfig 类中暴露 set() 方法。\n\n为了解决这些问题，建造者模式就派上用场了。我们可以把校验逻辑放置到 Builder 类中，先创建建造者，并且通过 set() 方法设置建造者的变量值，然后在使用 build() 方法真正创建对象之前，做集中的校验，校验通过之后才会创建对象。除此之外，我们把 ResourcePoolConfig 的构造函数改为 private 私有权限。这样我们就只能通过建造者来创建 ResourcePoolConfig 类对象。并且，ResourcePoolConfig 没有提供任何 set() 方法，这样我们创建出来的对象就是不可变对象了。我们用建造者模式重新实现了上面的需求，具体的代码如下所示：\n\n```java\npublic class ResourcePoolConfig {\n  private String name;\n  private int maxTotal;\n  private int maxIdle;\n  private int minIdle;\n\n  private ResourcePoolConfig(Builder builder) {\n    this.name = builder.name;\n    this.maxTotal = builder.maxTotal;\n    this.maxIdle = builder.maxIdle;\n    this.minIdle = builder.minIdle;\n  }\n  //...省略getter方法...\n\n  //我们将Builder类设计成了ResourcePoolConfig的内部类。\n  //我们也可以将Builder类设计成独立的非内部类ResourcePoolConfigBuilder。\n  public static class Builder {\n    private static final int DEFAULT_MAX_TOTAL = 8;\n    private static final int DEFAULT_MAX_IDLE = 8;\n    private static final int DEFAULT_MIN_IDLE = 0;\n\n    private String name;\n    private int maxTotal = DEFAULT_MAX_TOTAL;\n    private int maxIdle = DEFAULT_MAX_IDLE;\n    private int minIdle = DEFAULT_MIN_IDLE;\n\n    public ResourcePoolConfig build() {\n      // 校验逻辑放到这里来做，包括必填项校验、依赖关系校验、约束条件校验等\n      if (StringUtils.isBlank(name)) {\n        throw new IllegalArgumentException(\"...\");\n      }\n      if (maxIdle > maxTotal) {\n        throw new IllegalArgumentException(\"...\");\n      }\n      if (minIdle > maxTotal || minIdle > maxIdle) {\n        throw new IllegalArgumentException(\"...\");\n      }\n\n      return new ResourcePoolConfig(this);\n    }\n\n    public Builder setName(String name) {\n      if (StringUtils.isBlank(name)) {\n        throw new IllegalArgumentException(\"...\");\n      }\n      this.name = name;\n      return this;\n    }\n\n    public Builder setMaxTotal(int maxTotal) {\n      if (maxTotal <= 0) {\n        throw new IllegalArgumentException(\"...\");\n      }\n      this.maxTotal = maxTotal;\n      return this;\n    }\n\n    public Builder setMaxIdle(int maxIdle) {\n      if (maxIdle < 0) {\n        throw new IllegalArgumentException(\"...\");\n      }\n      this.maxIdle = maxIdle;\n      return this;\n    }\n\n    public Builder setMinIdle(int minIdle) {\n      if (minIdle < 0) {\n        throw new IllegalArgumentException(\"...\");\n      }\n      this.minIdle = minIdle;\n      return this;\n    }\n  }\n}\n\n// 这段代码会抛出IllegalArgumentException，因为minIdle>maxIdle\nResourcePoolConfig config = new ResourcePoolConfig.Builder()\n        .setName(\"dbconnectionpool\")\n        .setMaxTotal(16)\n        .setMaxIdle(10)\n        .setMinIdle(12)\n        .build();\n```\n\n\n\n实际上，使用建造者模式创建对象，还能避免对象存在无效状态。我再举个例子解释一下。比如我们定义了一个长方形类，如果不使用建造者模式，采用先创建后 set 的方式，那就会导致在第一个 set 之后，对象处于无效状态。具体代码如下所示\n\n```java\nRectangle r = new Rectange(); // r is invalid\nr.setWidth(2); // r is invalid\nr.setHeight(3); // r is valid\n```\n\n> 这里是说，长方形必须同时具备宽、高两个属性才是一个有效的长方形。只有其中一个属性，这个长方形对象就没有意义，是无效的。\n\n1. 为了避免这种无效状态的存在，我们就需要使用构造函数一次性初始化好所有的成员变量。如果构造函数参数过多，我们就需要考虑使用建造者模式，先设置建造者的变量，然后再一次性地创建对象，让对象一直处于有效状态。(建造者主要解决参数过多、参数检验、控制对象创建后不可变的问题)\n2. 实际上，如果我们并不是很关心对象是否有短暂的无效状态，也不是太在意对象是否是可变的。比如，对象只是用来映射数据库读出来的数据，那我们直接暴露 set() 方法来设置类的成员变量值是完全没问题的。而且，使用建造者模式来构建对象，代码实际上是有点重复的，ResourcePoolConfig 类中的成员变量，要在 Builder 类中重新再定义一遍。\n\n\n\n\n\n## 与工厂模式有何区别？\n\n\n\n1. 从上面的讲解中，我们可以看出，建造者模式是让建造者类来负责对象的创建工作。上面讲到的工厂模式，是由工厂类来负责对象创建的工作。那它们之间有什么区别呢？\n2. 实际上，工厂模式是用来创建不同但是相关类型的对象（继承同一父类或者接口的一组子类），由给定的参数来决定创建哪种类型的对象。建造者模式是用来创建一种类型的复杂对象，通过设置不同的可选参数，“定制化”地创建不同的对象。\n\n\n\n网上有一个经典的例子很好地解释了两者的区别:\n\n> 顾客走进一家餐馆点餐，我们利用工厂模式，根据用户不同的选择，来制作不同的食物，比如披萨、汉堡、沙拉。对于披萨来说，用户又有各种配料可以定制，比如奶酪、西红柿、起司，我们通过建造者模式根据用户选择的不同配料来制作披萨。\n\n实际上，我们也不要太学院派，非得把工厂模式、建造者模式分得那么清楚，我们需要知道的是，每个模式为什么这么设计，能解决什么问题。只有了解了这些最本质的东西，我们才能不生搬硬套，才能灵活应用，甚至可以混用各种模式创造出新的模式，来解决特定场景的问题。\n\n\n\n\n\n\n\n# 原型模式【不常用】\n\n今天的讲解跟具体某一语言的语法机制无关，而是通过一个 clone 散列表的例子带你搞清楚：原型模式的应用场景，以及它的两种实现方式：深拷贝和浅拷贝。虽然原型模式的原理和代码实现非常简单，但今天举的例子还是稍微有点复杂的\n\n\n\n## 原型模式的原理与应用\n\n如果对象的创建成本比较大，而同一个类的不同对象之间差别不大（大部分字段都相同），在这种情况下，我们可以利用对已有对象（原型）进行复制（或者叫拷贝）的方式来创建新对象，以达到节省创建时间的目的。这种基于原型来创建对象的方式就叫作原型设计模式（Prototype Design Pattern），简称原型模式。\n\n\n\n> 那何为“对象的创建成本比较大”？\n\n1. 实际上，创建对象包含的申请内存、给成员变量赋值这一过程，本身并不会花费太多时间，或者说对于大部分业务系统来说，这点时间完全是可以忽略的。应用一个复杂的模式，只得到一点点的性能提升，这就是所谓的过度设计，得不偿失。\n2. 但是，如果对象中的数据需要经过复杂的计算才能得到（比如排序、计算哈希值），或者需要从 RPC、网络、数据库、文件系统等非常慢速的 IO 中读取，这种情况下，我们就可以利用原型模式，从其他已有对象中直接拷贝得到，而不用每次在创建新对象的时候，都重复执行这些耗时的操作。\n\n\n\n> 这么说还是比较理论，接下来，我们通过一个例子来解释一下刚刚这段话。\n\n\n\n1. 假设数据库中存储了大约 10 万条“搜索关键词”信息，每条信息包含关键词、关键词被搜索的次数、信息最近被更新的时间等。系统 A 在启动的时候会加载这份数据到内存中，用于处理某些其他的业务需求。为了方便快速地查找某个关键词对应的信息，我们给关键词建立一个散列表索引。\n2. 如果你熟悉的是 Java 语言，可以直接使用语言中提供的 HashMap 容器来实现。其中，HashMap 的 key 为搜索关键词，value 为关键词详细信息（比如搜索次数）。我们只需要将数据从数据库中读取出来，放入 HashMap 就可以了。\n3. 不过，我们还有另外一个系统 B，专门用来分析搜索日志，定期（比如间隔 10 分钟）批量地更新数据库中的数据，并且标记为新的数据版本。比如，在下面的示例图中，我们对 v2 版本的数据进行更新，得到 v3 版本的数据。这里我们假设只有更新和新添关键词，没有删除关键词的行为。\n\n<img src=\"https://npm.elemecdn.com/youthlql@1.0.0/design_patterns/creational/03.02/0002.png\"/>\n\n\n\n1. 为了保证系统 A 中数据的实时性（不一定非常实时，但数据也不能太旧），系统 A 需要定期根据数据库中的数据，更新内存中的索引和数据。\n2. 我们该如何实现这个需求呢？实际上，也不难。我们只需要在系统 A 中，记录当前数据的版本 Va 对应的更新时间 Ta，从数据库中捞出更新时间大于 Ta 的所有搜索关键词，也就是找出 Va 版本与最新版本数据的“差集”，然后针对差集中的每个关键词进行处理。如果它已经在散列表中存在了，我们就更新相应的搜索次数、更新时间等信息；如果它在散列表中不存在，我们就将它插入到散列表中。\n3. 按照这个设计思路，我给出的示例代码如下所示：\n\n```java\npublic class Demo {\n  private ConcurrentHashMap<String, SearchWord> currentKeywords = new ConcurrentHashMap<>();\n  private long lastUpdateTime = -1;\n\n  public void refresh() {\n    // 从数据库中取出更新时间>lastUpdateTime的数据，放入到currentKeywords中\n    List<SearchWord> toBeUpdatedSearchWords = getSearchWords(lastUpdateTime);\n    long maxNewUpdatedTime = lastUpdateTime;\n    for (SearchWord searchWord : toBeUpdatedSearchWords) {\n      if (searchWord.getLastUpdateTime() > maxNewUpdatedTime) {\n        maxNewUpdatedTime = searchWord.getLastUpdateTime();\n      }\n      if (currentKeywords.containsKey(searchWord.getKeyword())) {\n        currentKeywords.replace(searchWord.getKeyword(), searchWord);\n      } else {\n        currentKeywords.put(searchWord.getKeyword(), searchWord);\n      }\n    }\n\n    lastUpdateTime = maxNewUpdatedTime;\n  }\n\n  private List<SearchWord> getSearchWords(long lastUpdateTime) {\n    // TODO: 从数据库中取出更新时间>lastUpdateTime的数据\n    return null;\n  }\n}\n```\n\n\n\n不过，现在，我们有一个特殊的要求：任何时刻，系统 A 中的所有数据都必须是同一个版本的，要么都是版本 a，要么都是版本 b，不能有的是版本 a，有的是版本 b。那刚刚的更新方式就不能满足这个要求了（因为数据很多，一个一个的for循环肯定会出现不同数据版本的问题）。除此之外，我们还要求：在更新内存数据的时候，系统 A 不能处于不可用状态，也就是不能停机更新数据。\n\n\n\n1. 那我们该如何实现现在这个需求呢？\n\n2. 实际上，也不难。我们把正在使用的数据的版本定义为“服务版本”，当我们要更新内存中的数据的时候，我们并不是直接在服务版本（假设是版本 a 数据）上更新，而是重新创建另一个版本数据（假设是版本 b 数据），等新的版本数据建好之后，再一次性地将服务版本从版本 a 切换到版本 b。这样既保证了数据一直可用，又避免了中间状态的存在。\n3. 按照这个设计思路，我给出的示例代码如下所示：\n\n```java\npublic class Demo {\n  private HashMap<String, SearchWord> currentKeywords=new HashMap<>();\n\n  public void refresh() {\n    HashMap<String, SearchWord> newKeywords = new LinkedHashMap<>();\n\n    // 从数据库中取出所有的数据，放入到newKeywords中\n    List<SearchWord> toBeUpdatedSearchWords = getSearchWords();\n    for (SearchWord searchWord : toBeUpdatedSearchWords) {\n      newKeywords.put(searchWord.getKeyword(), searchWord);\n    }\n\n    currentKeywords = newKeywords;\n  }\n\n  private List<SearchWord> getSearchWords() {\n    // TODO: 从数据库中取出所有的数据\n    return null;\n  }\n}\n```\n\n\n\n1. 不过，在上面的代码实现中，newKeywords 构建的成本比较高。我们需要将这 10 万条数据从数据库中读出，然后计算哈希值，构建 newKeywords。这个过程显然是比较耗时。为了提高效率，原型模式就派上用场了。\n2. 我们拷贝 currentKeywords 数据到 newKeywords 中，然后从数据库中只捞出新增或者有更新的关键词，更新到 newKeywords 中。而相对于 10 万条数据来说，每次新增或者更新的关键词个数是比较少的，所以，这种策略大大提高了数据更新的效率。\n3. 按照这个设计思路，我给出的示例代码如下所示：\n\n```java\npublic class Demo {\n  private HashMap<String, SearchWord> currentKeywords=new HashMap<>();\n  private long lastUpdateTime = -1;\n\n  public void refresh() {\n    // 原型模式就这么简单，拷贝已有对象的数据，更新少量差值\n    HashMap<String, SearchWord> newKeywords = (HashMap<String, SearchWord>) currentKeywords.clone();\n\n    // 从数据库中取出更新时间>lastUpdateTime的数据，放入到newKeywords中\n    List<SearchWord> toBeUpdatedSearchWords = getSearchWords(lastUpdateTime);\n    long maxNewUpdatedTime = lastUpdateTime;\n    for (SearchWord searchWord : toBeUpdatedSearchWords) {\n      if (searchWord.getLastUpdateTime() > maxNewUpdatedTime) {\n        maxNewUpdatedTime = searchWord.getLastUpdateTime();\n      }\n      if (newKeywords.containsKey(searchWord.getKeyword())) {\n        SearchWord oldSearchWord = newKeywords.get(searchWord.getKeyword());\n        oldSearchWord.setCount(searchWord.getCount());\n        oldSearchWord.setLastUpdateTime(searchWord.getLastUpdateTime());\n      } else {\n        newKeywords.put(searchWord.getKeyword(), searchWord);\n      }\n    }\n\n    lastUpdateTime = maxNewUpdatedTime;\n    currentKeywords = newKeywords;\n  }\n\n  private List<SearchWord> getSearchWords(long lastUpdateTime) {\n    // TODO: 从数据库中取出更新时间>lastUpdateTime的数据\n    return null;\n  }\n}\n```\n\n1. 这里我们利用了 Java 中的 clone() 语法来复制一个对象。如果你熟悉的语言没有这个语法，那把数据从 currentKeywords 中一个个取出来，然后再重新计算哈希值，放入到 newKeywords 中也是可以接受的。毕竟，最耗时的还是从数据库中取数据的操作。相对于数据库的 IO 操作来说，内存操作和 CPU 计算的耗时都是可以忽略的。\n2. 不过，不知道你有没有发现，实际上，刚刚的代码实现是有问题的。要弄明白到底有什么问题，我们需要先了解另外两个概念：深拷贝（Deep Copy）和浅拷贝（Shallow Copy）。\n\n\n\n\n\n## 原型模式的实现方式：深拷贝和浅拷贝\n\n> 1、关于深拷贝浅拷贝，我觉得这篇文章讲的不错：https://blog.csdn.net/baiye_xing/article/details/71788741\n\n\n\n> 我自己的总结：\n>\n> **浅拷贝**：对一个对象进行拷贝时，这个对象对应的类里的成员变量。\n>\n> - 对于数据类型是基本数据类型的成员变量，浅拷贝会直接进行值拷贝，也就是将该属性值复制一份给新的对象。因为是两份不同的数据，所以对其中一个对象的该成员变量值进行修改，不会影响另一个对象拷贝得到的数据\n> - 对于数据类型是引用数据类型的成员变量(也就是子对象，或者数组啥的)，也就是只是将该成员变量的引用值（引用拷贝【并发引用传递，Java本质还是值传递】）复制一份给新的对象。因为实际上两个对象的该成员变量都指向同一个实例。在这种情况下，在一个对象中修改该成员变量会影响到另一个对象的该成员变量值。\n>\n> 1. **深拷贝**：对基本数据类型进行值传递，对引用数据类型，创建一个新的对象，并复制其内容，此为深拷贝。\n> 2. 也就是说浅拷贝对于子对象只是拷贝了引用值，并没有真正的拷贝整个对象。\n>\n> **深拷贝实现思路：**\n>\n> 1. 对于每个子对象都实现Cloneable 接口，并重写clone方法。最后在最顶层的类的重写的 clone 方法中调用所有子对象的 clone 方法即可实现深拷贝。【简单的说就是：每一层的每个子对象都进行浅拷贝=深拷贝】\n>\n> 2. 利用序列化。【先对对象进行序列化，紧接着马上反序列化出 】\n\n\n\n我们来看，在内存中，用散列表组织的搜索关键词信息是如何存储的。我画了一张示意图，大致结构如下所示。从图中我们可以发现，散列表索引中，每个结点存储的 key 是搜索关键词，value 是 SearchWord 对象的内存地址。SearchWord 对象本身存储在散列表之外的内存空间中。\n\n<img src=\"https://npm.elemecdn.com/youthlql@1.0.0/design_patterns/creational/03.02/0003.png\"  />\n\n浅拷贝和深拷贝的区别在于，浅拷贝只会复制图中的索引（散列表），不会复制数据（SearchWord 对象）本身。相反，深拷贝不仅仅会复制索引，还会复制数据本身。浅拷贝得到的对象（newKeywords）跟原始对象（currentKeywords）共享数据（SearchWord 对象），而深拷贝得到的是一份完完全全独立的对象。具体的对比如下图所示：\n\n<img src=\"https://npm.elemecdn.com/youthlql@1.0.0/design_patterns/creational/03.02/0004.png\"/>\n\n\n\n<img src=\"https://npm.elemecdn.com/youthlql@1.0.0/design_patterns/creational/03.02/0005.png\" />\n\n\n\n1. 在 Java 语言中，Object 类的 clone() 方法执行的就是我们刚刚说的浅拷贝。它只会拷贝对象中的基本数据类型的数据（比如，int、long），以及引用对象（SearchWord）的内存地址，不会递归地拷贝引用对象本身。\n2. 在上面的代码中，我们通过调用 HashMap 上的 clone() 浅拷贝方法来实现原型模式。当我们通过 newKeywords 更新 SearchWord 对象的时候（比如，更新“设计模式”这个搜索关键词的访问次数），newKeywords 和 currentKeywords 因为指向相同的一组 SearchWord 对象，就会导致 currentKeywords 中指向的 SearchWord，有的是老版本的，有的是新版本的，就没法满足我们之前的需求：currentKeywords 中的数据在任何时刻都是同一个版本的，不存在介于老版本与新版本之间的中间状态。\n\n3. 现在，我们又该如何来解决这个问题呢？\n\n4. 我们可以将浅拷贝替换为深拷贝。newKeywords 不仅仅复制 currentKeywords 的索引，还把 SearchWord 对象也复制一份出来，这样 newKeywords 和 currentKeywords 就指向不同的 SearchWord 对象，也就不存在更新 newKeywords 的数据会导致 currentKeywords 的数据也被更新的问题了。\n5. 那如何实现深拷贝呢？总结一下的话，有下面两种方法。\n\n\n\n第一种方法：递归拷贝对象、对象的引用对象以及引用对象的引用对象……直到要拷贝的对象只包含基本数据类型数据，没有引用对象为止。根据这个思路对之前的代码进行重构。重构之后的代码如下所示：\n\n```java\npublic class Demo {\n  private HashMap<String, SearchWord> currentKeywords=new HashMap<>();\n  private long lastUpdateTime = -1;\n\n  public void refresh() {\n    // Deep copy\n    HashMap<String, SearchWord> newKeywords = new HashMap<>();\n    for (HashMap.Entry<String, SearchWord> e : currentKeywords.entrySet()) {\n      SearchWord searchWord = e.getValue();\n      SearchWord newSearchWord = new SearchWord(\n              searchWord.getKeyword(), searchWord.getCount(), searchWord.getLastUpdateTime());\n      newKeywords.put(e.getKey(), newSearchWord);\n    }\n\n    // 从数据库中取出更新时间>lastUpdateTime的数据，放入到newKeywords中\n    List<SearchWord> toBeUpdatedSearchWords = getSearchWords(lastUpdateTime);\n    long maxNewUpdatedTime = lastUpdateTime;\n    for (SearchWord searchWord : toBeUpdatedSearchWords) {\n      if (searchWord.getLastUpdateTime() > maxNewUpdatedTime) {\n        maxNewUpdatedTime = searchWord.getLastUpdateTime();\n      }\n      if (newKeywords.containsKey(searchWord.getKeyword())) {\n        SearchWord oldSearchWord = newKeywords.get(searchWord.getKeyword());\n        oldSearchWord.setCount(searchWord.getCount());\n        oldSearchWord.setLastUpdateTime(searchWord.getLastUpdateTime());\n      } else {\n        newKeywords.put(searchWord.getKeyword(), searchWord);\n      }\n    }\n\n    lastUpdateTime = maxNewUpdatedTime;\n    currentKeywords = newKeywords;\n  }\n\n  private List<SearchWord> getSearchWords(long lastUpdateTime) {\n    // TODO: 从数据库中取出更新时间>lastUpdateTime的数据\n    return null;\n  }\n\n}\n```\n\n\n\n第二种方法：先将对象序列化，然后再反序列化成新的对象。具体的示例代码如下所示：\n\n```java\npublic Object deepCopy(Object object) {\n  ByteArrayOutputStream bo = new ByteArrayOutputStream();\n  ObjectOutputStream oo = new ObjectOutputStream(bo);\n  oo.writeObject(object);\n  \n  ByteArrayInputStream bi = new ByteArrayInputStream(bo.toByteArray());\n  ObjectInputStream oi = new ObjectInputStream(bi);\n  \n  return oi.readObject();\n}\n```\n\n1. 刚刚的两种实现方法，不管采用哪种，深拷贝都要比浅拷贝耗时、耗内存空间。针对我们这个应用场景，有没有更快、更省内存的实现方式呢？\n2. 我们可以先采用浅拷贝的方式创建 newKeywords。对于需要更新的 SearchWord 对象，我们再使用深度拷贝的方式创建一份新的对象，替换 newKeywords 中的老对象。毕竟需要更新的数据是很少的。这种方式即利用了浅拷贝节省时间、空间的优点，又能保证 currentKeywords 中的中数据都是老版本的数据。具体的代码实现如下所示。这也是标题中讲到的，在我们这个应用场景下，最快速 clone 散列表的方式。\n\n\n\n```java\npublic class Demo {\n  private HashMap<String, SearchWord> currentKeywords=new HashMap<>();\n  private long lastUpdateTime = -1;\n\n  public void refresh() {\n    // Shallow copy\n    HashMap<String, SearchWord> newKeywords = (HashMap<String, SearchWord>) currentKeywords.clone();\n\n    // 从数据库中取出更新时间>lastUpdateTime的数据，放入到newKeywords中\n    List<SearchWord> toBeUpdatedSearchWords = getSearchWords(lastUpdateTime);\n    long maxNewUpdatedTime = lastUpdateTime;\n    for (SearchWord searchWord : toBeUpdatedSearchWords) {\n      if (searchWord.getLastUpdateTime() > maxNewUpdatedTime) {\n        maxNewUpdatedTime = searchWord.getLastUpdateTime();\n      }\n      if (newKeywords.containsKey(searchWord.getKeyword())) {\n        newKeywords.remove(searchWord.getKeyword());\n      }\n      newKeywords.put(searchWord.getKeyword(), searchWord);\n    }\n\n    lastUpdateTime = maxNewUpdatedTime;\n    currentKeywords = newKeywords;\n  }\n\n  private List<SearchWord> getSearchWords(long lastUpdateTime) {\n    // TODO: 从数据库中取出更新时间>lastUpdateTime的数据\n    return null;\n  }\n}\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/2024-06-18-设计模式-03.02-创建型-工厂&建造者&原型.md","raw":"---\ntitle: 设计模式-03.02-创建型-工厂&建造者&原型\ntags:\n  - 设计模式\n  - 工厂\n  - 建造者\n  - 原型\ncategories:\n  - 设计模式\n  - 03.创建型\nkeywords: 设计模式，工厂，建造者，原型\ndescription: 详解常用的工厂模式和建造者模式，以及不常用的原型模式\ncover: 'https://npm.elemecdn.com/lql_static@latest/logo/design_patterns.jpg'\nabbrlink: ba432704\ndate: 2024-06-18 13:21:58\n---\n\n\n# 声明\n\n> 1. 此系列文章非本人原创，是学习笔记。\n> 2. 设计模式系列以后会持续更新，包括已经发布的设计模式文章，因为后续还要再多看一下书，教程和开源项目等，继续润色文章。\n\n\n\n# 工厂模式【常用】\n\n> 工厂模式很重要，后面的很多架构设计，都是工厂模式联合着其它设计模式使用。\n\n1. 一般情况下，工厂模式分为三种更加细分的类型：简单工厂、工厂方法和抽象工厂。不过，在 GoF 的《设计模式》一书中，它将简单工厂模式看作是工厂方法模式的一种特例，所以工厂模式只被分成了工厂方法和抽象工厂两类。实际上，前面一种分类方法更加常见，所以，在今天的讲解中，我们沿用第一种分类方法。\n\n2. 在这三种细分的工厂模式中，简单工厂、工厂方法原理比较简单，在实际的项目中也比较常用。而抽象工厂的原理稍微复杂点，在实际的项目中相对也不常用。所以，我们今天讲解的重点是前两种工厂模式。对于抽象工厂，稍微了解一下即可。\n\n3. 除此之外，我们讲解的重点也不是原理和实现，因为这些都很简单，重点还是带你搞清楚应用场景：什么时候该用工厂模式？相对于直接 new 来创建对象，用工厂模式来创建究竟有什么好处呢？\n\n## 简单工厂（Simple Factory）\n\n首先，我们来看，什么是简单工厂模式。我们通过一个例子来解释一下。\n\n在下面这段代码中，我们根据配置文件的后缀（json、xml、yaml、properties），选择不同的解析器（JsonRuleConfigParser、XmlRuleConfigParser……），将存储在文件中的配置解析成内存对象 RuleConfig。\n\n```java\npublic class RuleConfigSource {\n  public RuleConfig load(String ruleConfigFilePath) {\n    String ruleConfigFileExtension = getFileExtension(ruleConfigFilePath);\n    IRuleConfigParser parser = null;\n    if (\"json\".equalsIgnoreCase(ruleConfigFileExtension)) {\n      parser = new JsonRuleConfigParser();\n    } else if (\"xml\".equalsIgnoreCase(ruleConfigFileExtension)) {\n      parser = new XmlRuleConfigParser();\n    } else if (\"yaml\".equalsIgnoreCase(ruleConfigFileExtension)) {\n      parser = new YamlRuleConfigParser();\n    } else if (\"properties\".equalsIgnoreCase(ruleConfigFileExtension)) {\n      parser = new PropertiesRuleConfigParser();\n    } else {\n      throw new InvalidRuleConfigException(\n             \"Rule config file format is not supported: \" + ruleConfigFilePath);\n    }\n\n    String configText = \"\";\n    //从ruleConfigFilePath文件中读取配置文本到configText中\n    RuleConfig ruleConfig = parser.parse(configText);\n    return ruleConfig;\n  }\n\n  private String getFileExtension(String filePath) {\n    //...解析文件名获取扩展名，比如rule.json，返回json\n    return \"json\";\n  }\n}\n```\n\n为了让代码逻辑更加清晰，可读性更好，我们要善于将功能独立的代码块封装成函数。按照这个设计思路，我们可以将代码中涉及 parser 创建的部分逻辑剥离出来，抽象成 createParser() 函数。重构之后的代码如下所示：\n\n\n\n```java\n  public RuleConfig load(String ruleConfigFilePath) {\n    String ruleConfigFileExtension = getFileExtension(ruleConfigFilePath);\n    IRuleConfigParser parser = createParser(ruleConfigFileExtension);\n    if (parser == null) {\n      throw new InvalidRuleConfigException(\n              \"Rule config file format is not supported: \" + ruleConfigFilePath);\n    }\n\n    String configText = \"\";\n    //从ruleConfigFilePath文件中读取配置文本到configText中\n    RuleConfig ruleConfig = parser.parse(configText);\n    return ruleConfig;\n  }\n\n  private String getFileExtension(String filePath) {\n    //...解析文件名获取扩展名，比如rule.json，返回json\n    return \"json\";\n  }\n\n  private IRuleConfigParser createParser(String configFormat) {\n    IRuleConfigParser parser = null;\n    if (\"json\".equalsIgnoreCase(configFormat)) {\n      parser = new JsonRuleConfigParser();\n    } else if (\"xml\".equalsIgnoreCase(configFormat)) {\n      parser = new XmlRuleConfigParser();\n    } else if (\"yaml\".equalsIgnoreCase(configFormat)) {\n      parser = new YamlRuleConfigParser();\n    } else if (\"properties\".equalsIgnoreCase(configFormat)) {\n      parser = new PropertiesRuleConfigParser();\n    }\n    return parser;\n  }\n}\n```\n\n\n\n为了让类的职责更加单一(**设计模式原则中的单一职责**，)、代码更加清晰，我们还可以进一步将 createParser() 函数剥离到一个独立的类中，让这个类只负责对象的创建。而这个类就是我们现在要讲的简单工厂模式类。具体的代码如下所示：\n\n```java\npublic class RuleConfigSource {\n  public RuleConfig load(String ruleConfigFilePath) {\n    String ruleConfigFileExtension = getFileExtension(ruleConfigFilePath);\n    IRuleConfigParser parser = RuleConfigParserFactory.createParser(ruleConfigFileExtension);\n    if (parser == null) {\n      throw new InvalidRuleConfigException(\n              \"Rule config file format is not supported: \" + ruleConfigFilePath);\n    }\n\n    String configText = \"\";\n    //从ruleConfigFilePath文件中读取配置文本到configText中\n    RuleConfig ruleConfig = parser.parse(configText);\n    return ruleConfig;\n  }\n\n  private String getFileExtension(String filePath) {\n    //...解析文件名获取扩展名，比如rule.json，返回json\n    return \"json\";\n  }\n}\n\npublic class RuleConfigParserFactory {\n  public static IRuleConfigParser createParser(String configFormat) {\n    IRuleConfigParser parser = null;\n    if (\"json\".equalsIgnoreCase(configFormat)) {\n      parser = new JsonRuleConfigParser();\n    } else if (\"xml\".equalsIgnoreCase(configFormat)) {\n      parser = new XmlRuleConfigParser();\n    } else if (\"yaml\".equalsIgnoreCase(configFormat)) {\n      parser = new YamlRuleConfigParser();\n    } else if (\"properties\".equalsIgnoreCase(configFormat)) {\n      parser = new PropertiesRuleConfigParser();\n    }\n    return parser;\n  }\n}\n```\n\n\n\n1. 在上面的代码实现中，我们每次调用 RuleConfigParserFactory 的 createParser() 的时候，都要创建一个新的 parser。\n2. 实际上，如果 parser 可以复用，为了节省内存和对象创建的时间，我们可以将 parser 事先创建好缓存起来。当调用 createParser() 函数的时候，我们从缓存中取出 parser 对象直接使用。这有点类似单例模式和简单工厂模式的结合，具体的代码实现如下所示。在接下来的讲解中，我们把上一种实现方法叫作简单工厂模式的第一种实现方法，把下面这种实现方法叫作简单工厂模式的第二种实现方法。\n\n\n\n```java\npublic class RuleConfigParserFactory {\n  private static final Map<String, RuleConfigParser> cachedParsers = new HashMap<>();\n\n  static {\n    cachedParsers.put(\"json\", new JsonRuleConfigParser());\n    cachedParsers.put(\"xml\", new XmlRuleConfigParser());\n    cachedParsers.put(\"yaml\", new YamlRuleConfigParser());\n    cachedParsers.put(\"properties\", new PropertiesRuleConfigParser());\n  }\n\n  public static IRuleConfigParser createParser(String configFormat) {\n    if (configFormat == null || configFormat.isEmpty()) {\n      return null;//返回null还是IllegalArgumentException全凭你自己说了算\n    }\n    IRuleConfigParser parser = cachedParsers.get(configFormat.toLowerCase());\n    return parser;\n  }\n}\n```\n\n\n\n1. 对于上面两种简单工厂模式的实现方法，如果我们要添加新的 parser，那势必要改动到 RuleConfigParserFactory 的代码，那这是不是违反开闭原则呢？实际上，如果不是需要频繁地添加新的 parser，只是偶尔修改一下 RuleConfigParserFactory 代码，稍微不符合开闭原则，也是完全可以接受的。\n2. 除此之外，在 RuleConfigParserFactory 的第一种代码实现中，有一组 if 分支判断逻辑，是不是应该用多态或其他设计模式来替代呢？实际上，如果 if 分支并不是很多，代码中有 if 分支也是完全可以接受的。应用多态或设计模式来替代 if 分支判断逻辑，也并不是没有任何缺点的，它虽然提高了代码的扩展性，更加符合**开闭原则**，但也增加了类的个数，牺牲了代码的可读性。关于这一点，我们在后面章节中会详细讲到。\n3. 总结一下，尽管简单工厂模式的代码实现中，有多处 if 分支判断逻辑，违背开闭原则，但权衡扩展性和可读性，这样的代码实现在大多数情况下（比如，不需要频繁地添加 parser，也没有太多的 parser）是没有问题的。\n\n\n\n## 工厂方法（Factory Method）\n\n如果我们非得要将 if 分支逻辑去掉，那该怎么办呢？比较经典处理方法就是利用多态。按照多态的实现思路，对上面的代码进行重构。重构之后的代码如下所示：\n\n```java\npublic interface IRuleConfigParserFactory {\n  IRuleConfigParser createParser();\n}\n\npublic class JsonRuleConfigParserFactory implements IRuleConfigParserFactory {\n  @Override\n  public IRuleConfigParser createParser() {\n    return new JsonRuleConfigParser();\n  }\n}\n\npublic class XmlRuleConfigParserFactory implements IRuleConfigParserFactory {\n  @Override\n  public IRuleConfigParser createParser() {\n    return new XmlRuleConfigParser();\n  }\n}\n\npublic class YamlRuleConfigParserFactory implements IRuleConfigParserFactory {\n  @Override\n  public IRuleConfigParser createParser() {\n    return new YamlRuleConfigParser();\n  }\n}\n\npublic class PropertiesRuleConfigParserFactory implements IRuleConfigParserFactory {\n  @Override\n  public IRuleConfigParser createParser() {\n    return new PropertiesRuleConfigParser();\n  }\n}\n```\n\n\n\n实际上，这就是工厂方法模式的典型代码实现。这样当我们新增一种 parser 的时候，只需要新增一个实现了 IRuleConfigParserFactory 接口的 Factory 类即可。所以，工厂方法模式比起简单工厂模式更加符合开闭原则。\n\n\n\n从上面的工厂方法的实现来看，一切都很完美，但是实际上存在挺大的问题。问题存在于这些工厂类的使用上。接下来，我们看一下，如何用这些工厂类来实现 RuleConfigSource 的 load() 函数。具体的代码如下所示：\n\n\n\n```java\npublic class RuleConfigSource {\n  public RuleConfig load(String ruleConfigFilePath) {\n    String ruleConfigFileExtension = getFileExtension(ruleConfigFilePath);\n\n    IRuleConfigParserFactory parserFactory = null;\n    if (\"json\".equalsIgnoreCase(ruleConfigFileExtension)) {\n      parserFactory = new JsonRuleConfigParserFactory();\n    } else if (\"xml\".equalsIgnoreCase(ruleConfigFileExtension)) {\n      parserFactory = new XmlRuleConfigParserFactory();\n    } else if (\"yaml\".equalsIgnoreCase(ruleConfigFileExtension)) {\n      parserFactory = new YamlRuleConfigParserFactory();\n    } else if (\"properties\".equalsIgnoreCase(ruleConfigFileExtension)) {\n      parserFactory = new PropertiesRuleConfigParserFactory();\n    } else {\n      throw new InvalidRuleConfigException(\"Rule config file format is not supported: \" + ruleConfigFilePath);\n    }\n    IRuleConfigParser parser = parserFactory.createParser();\n\n    String configText = \"\";\n    //从ruleConfigFilePath文件中读取配置文本到configText中\n    RuleConfig ruleConfig = parser.parse(configText);\n    return ruleConfig;\n  }\n\n  private String getFileExtension(String filePath) {\n    //...解析文件名获取扩展名，比如rule.json，返回json\n    return \"json\";\n  }\n}\n```\n\n\n\n1. 从上面的代码实现来看，工厂类对象的创建逻辑又耦合进了 load() 函数中，跟我们最初的代码版本非常相似，引入工厂方法非但没有解决问题，反倒让设计变得更加复杂了。那怎么来解决这个问题呢？\n2. 我们可以为工厂类再创建一个简单工厂，也就是工厂的工厂，用来创建工厂类对象。这段话听起来有点绕，我把代码实现出来了，你一看就能明白了。其中，RuleConfigParserFactoryMap 类是创建工厂对象的工厂类，getParserFactory() 返回的是缓存好的单例工厂对象。\n\n```java\npublic class RuleConfigSource {\n  public RuleConfig load(String ruleConfigFilePath) {\n    String ruleConfigFileExtension = getFileExtension(ruleConfigFilePath);\n\n    IRuleConfigParserFactory parserFactory = RuleConfigParserFactoryMap.getParserFactory(ruleConfigFileExtension);\n    if (parserFactory == null) {\n      throw new InvalidRuleConfigException(\"Rule config file format is not supported: \" + ruleConfigFilePath);\n    }\n    IRuleConfigParser parser = parserFactory.createParser();\n\n    String configText = \"\";\n    //从ruleConfigFilePath文件中读取配置文本到configText中\n    RuleConfig ruleConfig = parser.parse(configText);\n    return ruleConfig;\n  }\n\n  private String getFileExtension(String filePath) {\n    //...解析文件名获取扩展名，比如rule.json，返回json\n    return \"json\";\n  }\n}\n\n//因为工厂类只包含方法，不包含成员变量，完全可以复用，\n//不需要每次都创建新的工厂类对象，所以，简单工厂模式的第二种实现思路更加合适。\npublic class RuleConfigParserFactoryMap { //工厂的工厂\n  private static final Map<String, IRuleConfigParserFactory> cachedFactories = new HashMap<>();\n\n  static {\n    cachedFactories.put(\"json\", new JsonRuleConfigParserFactory());\n    cachedFactories.put(\"xml\", new XmlRuleConfigParserFactory());\n    cachedFactories.put(\"yaml\", new YamlRuleConfigParserFactory());\n    cachedFactories.put(\"properties\", new PropertiesRuleConfigParserFactory());\n  }\n\n  public static IRuleConfigParserFactory getParserFactory(String type) {\n    if (type == null || type.isEmpty()) {\n      return null;\n    }\n    IRuleConfigParserFactory parserFactory = cachedFactories.get(type.toLowerCase());\n    return parserFactory;\n  }\n}\n```\n\n\n\n1. 当我们需要添加新的规则配置解析器的时候，我们只需要创建新的 parser 类和 parser factory 类，并且在 RuleConfigParserFactoryMap 类中，将新的 parser factory 对象添加到 cachedFactories 中即可。代码的改动非常少，基本上符合开闭原则。\n2. 实际上，对于规则配置文件解析这个应用场景来说，工厂模式需要额外创建诸多 Factory 类，也会增加代码的复杂性，而且，每个 Factory 类只是做简单的 new 操作，功能非常单薄（只有一行代码），也没必要设计成独立的类，所以，在这个应用场景下，简单工厂模式简单好用，比工厂方法模式更加合适。\n\n\n\n### 那什么时候该用工厂方法模式，而非简单工厂模式呢？\n\n1. 我们前面提到，之所以将某个代码块剥离出来，独立为函数或者类，原因是这个代码块的逻辑过于复杂，剥离之后能让代码更加清晰，更加可读、可维护。但是，如果代码块本身并不复杂，就几行代码而已，我们完全没必要将它拆分成单独的函数或者类。\n2. 基于这个设计思想，当对象的创建逻辑比较复杂，不只是简单的 new 一下就可以，而是要组合其他类对象，做各种初始化操作的时候，我们推荐使用工厂方法模式，将复杂的创建逻辑拆分到多个工厂类中，让每个工厂类都不至于过于复杂。而使用简单工厂模式，将所有的创建逻辑都放到一个工厂类中，会导致这个工厂类变得很复杂。\n3. 除此之外，在某些场景下，如果对象不可复用，那工厂类每次都要返回不同的对象。如果我们使用简单工厂模式来实现，就只能选择第一种包含 if 分支逻辑的实现方式。如果我们还想避免烦人的 if-else 分支逻辑，这个时候，我们就推荐使用工厂方法模式。\n\n\n\n## 抽象工厂（Abstract Factory）\n\n1. 讲完了简单工厂、工厂方法，我们再来看抽象工厂模式。抽象工厂模式的应用场景比较特殊，没有前两种常用，所以不是我们学习的重点，你简单了解一下就可以了。\n2. 在简单工厂和工厂方法中，类只有一种分类方式。比如，在规则配置解析那个例子中，解析器类只会根据配置文件格式（Json、Xml、Yaml……）来分类。但是，如果类有两种分类方式，比如，我们既可以按照配置文件格式来分类，也可以按照解析的对象（Rule 规则配置还是 System 系统配置）来分类，那就会对应下面这 8 个 parser 类。\n\n```java\n针对规则配置的解析器：基于接口IRuleConfigParser\nJsonRuleConfigParser\nXmlRuleConfigParser\nYamlRuleConfigParser\nPropertiesRuleConfigParser\n\n针对系统配置的解析器：基于接口ISystemConfigParser\nJsonSystemConfigParser\nXmlSystemConfigParser\nYamlSystemConfigParser\nPropertiesSystemConfigParser\n```\n\n\n\n1. 针对这种特殊的场景，如果还是继续用工厂方法来实现的话，我们要针对每个 parser 都编写一个工厂类，也就是要编写 8 个工厂类。如果我们未来还需要增加针对业务配置的解析器（比如 IBizConfigParser），那就要再对应地增加 4 个工厂类。而我们知道，过多的类也会让系统难维护。这个问题该怎么解决呢？\n2. 抽象工厂就是针对这种非常特殊的场景而诞生的。我们可以让一个工厂负责创建多个不同类型的对象（IRuleConfigParser、ISystemConfigParser 等），而不是只创建一种 parser 对象。这样就可以有效地减少工厂类的个数。具体的代码实现如下所示：\n\n```java\npublic interface IConfigParserFactory {\n  IRuleConfigParser createRuleParser();\n  ISystemConfigParser createSystemParser();\n  //此处可以扩展新的parser类型，比如IBizConfigParser\n}\n\npublic class JsonConfigParserFactory implements IConfigParserFactory {\n  @Override\n  public IRuleConfigParser createRuleParser() {\n    return new JsonRuleConfigParser();\n  }\n\n  @Override\n  public ISystemConfigParser createSystemParser() {\n    return new JsonSystemConfigParser();\n  }\n}\n\npublic class XmlConfigParserFactory implements IConfigParserFactory {\n  @Override\n  public IRuleConfigParser createRuleParser() {\n    return new XmlRuleConfigParser();\n  }\n\n  @Override\n  public ISystemConfigParser createSystemParser() {\n    return new XmlSystemConfigParser();\n  }\n}\n\n// 省略YamlConfigParserFactory和PropertiesConfigParserFactory代码\n```\n\n\n\n## 如何设计实现一个Dependency Injection框架？\n\n\n\n当创建对象是一个“大工程”的时候，我们一般会选择使用工厂模式，来封装对象复杂的创建过程，将对象的创建和使用分离，让代码更加清晰。那何为“大工程”呢？上面我们讲了两种情况，一种是创建过程涉及复杂的 if-else 分支判断，另一种是对象创建需要组装多个其他类对象或者需要复杂的初始化过程。\n\n\n\n今天，我们再来讲一个创建对象的“大工程”，依赖注入框架，或者叫依赖注入容器（Dependency Injection Container），简称 DI 容器。在今天的讲解中，我会带你一块搞清楚这样几个问题：DI 容器跟我们讲的工厂模式又有何区别和联系？DI 容器的核心功能有哪些，以及如何实现一个简单的 DI 容器？\n\n\n\n\n\n### 工厂模式和 DI 容器有何区别？\n\n1. 实际上，DI 容器底层最基本的设计思路就是基于工厂模式的。DI 容器相当于一个大的工厂类，负责在程序启动的时候，根据配置（要创建哪些类对象，每个类对象的创建需要依赖哪些其他类对象）事先创建好对象。当应用程序需要使用某个类对象的时候，直接从容器中获取即可。正是因为它持有一堆对象，所以这个框架才被称为“容器”。\n2. DI 容器相对于我们上面讲的工厂模式的例子来说，它处理的是更大的对象创建工程。上面讲的工厂模式中，一个工厂类只负责某个类对象或者某一组相关类对象（继承自同一抽象类或者接口的子类）的创建，而 DI 容器负责的是整个应用中所有类对象的创建。\n3. 除此之外，DI 容器负责的事情要比单纯的工厂模式要多。比如，它还包括配置的解析、对象生命周期的管理。接下来，我们就详细讲讲，一个简单的 DI 容器应该包含哪些核心功能。\n\n\n\n### DI 容器的核心功能有哪些？\n\n总结一下，一个简单的 DI 容器的核心功能一般有三个：配置解析、对象创建和对象生命周期管理。\n\n\n\n> 首先，我们来看配置解析。\n\n1. 在上面讲的工厂模式中，工厂类要创建哪个类对象是事先确定好的，并且是写死在工厂类代码中的。作为一个通用的框架来说，框架代码跟应用代码应该是高度解耦的，DI 容器事先并不知道应用会创建哪些对象，不可能把某个应用要创建的对象写死在框架代码中。所以，我们需要通过一种形式，让应用告知 DI 容器要创建哪些对象。这种形式就是我们要讲的配置。\n2. 我们将需要由 DI 容器来创建的类对象和创建类对象的必要信息（使用哪个构造函数以及对应的构造函数参数都是什么等等），放到配置文件中。容器读取配置文件，根据配置文件提供的信息来创建对象。\n3. 下面是一个典型的 Spring 容器的配置文件。Spring 容器读取这个配置文件，解析出要创建的两个对象：rateLimiter 和 redisCounter，并且得到两者的依赖关系：rateLimiter 依赖 redisCounter。\n\n\n\n```java\npublic class RateLimiter {\n  private RedisCounter redisCounter;\n  public RateLimiter(RedisCounter redisCounter) {\n    this.redisCounter = redisCounter;\n  }\n  public void test() {\n    System.out.println(\"Hello World!\");\n  }\n  //...\n}\n\npublic class RedisCounter {\n  private String ipAddress;\n  private int port;\n  public RedisCounter(String ipAddress, int port) {\n    this.ipAddress = ipAddress;\n    this.port = port;\n  }\n  //...\n}\n\n配置文件beans.xml：\n<beans>\n   <bean id=\"rateLimiter\" class=\"com.xzg.RateLimiter\">\n      <constructor-arg ref=\"redisCounter\"/>\n   </bean>\n \n   <bean id=\"redisCounter\" class=\"com.xzg.redisCounter\">\n     <constructor-arg type=\"String\" value=\"127.0.0.1\">\n     <constructor-arg type=\"int\" value=1234>\n   </bean>\n</beans>\n```\n\n\n\n> 其次，我们再来看对象创建。\n\n1. 在 DI 容器中，如果我们给每个类都对应创建一个工厂类，那项目中类的个数会成倍增加，这会增加代码的维护成本。要解决这个问题并不难。我们只需要将所有类对象的创建都放到一个工厂类中完成就可以了，比如 BeansFactory。\n2. 你可能会说，如果要创建的类对象非常多，BeansFactory 中的代码会不会线性膨胀（代码量跟创建对象的个数成正比）呢？实际上并不会。待会讲到 DI 容器的具体实现的时候，我们会讲“反射”这种机制，它能在程序运行的过程中，动态地加载类、创建对象，不需要事先在代码中写死要创建哪些对象。所以，不管是创建一个对象还是十个对象，BeansFactory 工厂类代码都是一样的。\n\n\n\n> 最后，我们来看对象的生命周期管理。\n\n1. 上面我们讲到，简单工厂模式有两种实现方式，一种是每次都返回新创建的对象，另一种是每次都返回同一个事先创建好的对象，也就是所谓的单例对象。在 Spring 框架中，我们可以通过配置 scope 属性，来区分这两种不同类型的对象。scope=prototype 表示返回新创建的对象，scope=singleton 表示返回单例对象。\n2. 除此之外，我们还可以配置对象是否支持懒加载。如果 lazy-init=true，对象在真正被使用到的时候（比如：BeansFactory.getBean(“userService”)）才被被创建；如果 lazy-init=false，对象在应用启动的时候就事先创建好。\n3. 不仅如此，我们还可以配置对象的 init-method 和 destroy-method 方法，比如 init-method=loadProperties()，destroy-method=updateConfigFile()。DI 容器在创建好对象之后，会主动调用 init-method 属性指定的方法来初始化对象。在对象被最终销毁之前，DI 容器会主动调用 destroy-method 属性指定的方法来做一些清理工作，比如释放数据库连接池、关闭文件。\n\n\n\n## 如何实现一个简单的 DI 容器？\n\n用 Java 语言来实现一个简单的 DI 容器，核心逻辑只需要包括这样两个部分：配置文件解析、根据配置文件通过“反射”语法来创建对象。\n\n\n\n### 最小原型设计\n\n因为我们主要是讲解设计模式，所以，在今天的讲解中，我们只实现一个 DI 容器的最小原型。像 Spring 框架这样的 DI 容器，它支持的配置格式非常灵活和复杂。为了简化代码实现，重点讲解原理，在最小原型中，我们只支持下面配置文件中涉及的配置语法。\n\n```java\n配置文件beans.xml\n<beans>\n   <bean id=\"rateLimiter\" class=\"com.xzg.RateLimiter\">\n      <constructor-arg ref=\"redisCounter\"/>\n   </bean>\n \n   <bean id=\"redisCounter\" class=\"com.xzg.redisCounter\" scope=\"singleton\" lazy-init=\"true\">\n     <constructor-arg type=\"String\" value=\"127.0.0.1\">\n     <constructor-arg type=\"int\" value=1234>\n   </bean>\n</bean\n```\n\n\n\n最小原型的使用方式跟 Spring 框架非常类似，示例代码如下所示：\n\n```java\npublic class Demo {\n  public static void main(String[] args) {\n    ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\n            \"beans.xml\");\n    RateLimiter rateLimiter = (RateLimiter) applicationContext.getBean(\"rateLimiter\");\n    rateLimiter.test();\n    //...\n  }\n}\n```\n\n\n\n### 提供执行入口\n\n面向对象设计的最后一步是：组装类并提供执行入口。在这里，执行入口就是一组暴露给外部使用的接口和类。通过刚刚的最小原型使用示例代码，我们可以看出，执行入口主要包含两部分：ApplicationContext 和 ClassPathXmlApplicationContext。其中，ApplicationContext 是接口，ClassPathXmlApplicationContext 是接口的实现类。两个类具体实现如下所示：\n\n\n\n```java\npublic interface ApplicationContext {\n  Object getBean(String beanId);\n}\n\npublic class ClassPathXmlApplicationContext implements ApplicationContext {\n  private BeansFactory beansFactory;\n  private BeanConfigParser beanConfigParser;\n\n  public ClassPathXmlApplicationContext(String configLocation) {\n    this.beansFactory = new BeansFactory();\n    this.beanConfigParser = new XmlBeanConfigParser();\n    loadBeanDefinitions(configLocation);\n  }\n\n  private void loadBeanDefinitions(String configLocation) {\n    InputStream in = null;\n    try {\n      in = this.getClass().getResourceAsStream(\"/\" + configLocation);\n      if (in == null) {\n        throw new RuntimeException(\"Can not find config file: \" + configLocation);\n      }\n      List<BeanDefinition> beanDefinitions = beanConfigParser.parse(in);\n      beansFactory.addBeanDefinitions(beanDefinitions);\n    } finally {\n      if (in != null) {\n        try {\n          in.close();\n        } catch (IOException e) {\n          // TODO: log error\n        }\n      }\n    }\n  }\n\n  @Override\n  public Object getBean(String beanId) {\n    return beansFactory.getBean(beanId);\n  }\n}\n```\n\n从上面的代码中，我们可以看出，ClassPathXmlApplicationContext 负责组装 BeansFactory 和 BeanConfigParser 两个类，串联执行流程：从 classpath 中加载 XML 格式的配置文件，通过 BeanConfigParser 解析为统一的 BeanDefinition 格式，然后，BeansFactory 根据 BeanDefinition 来创建对象。\n\n\n\n### 配置文件解析\n\n配置文件解析主要包含 BeanConfigParser 接口和 XmlBeanConfigParser 实现类，负责将配置文件解析为 BeanDefinition 结构，以便 BeansFactory 根据这个结构来创建对象。配置文件的解析比较繁琐，不涉及我们要讲的理论知识，不是我们讲解的重点，所以这里我只给出两个类的大致设计思路，并未给出具体的实现代码。如果感兴趣的话，你可以自行补充完整。具体的代码框架如下所示：\n\n```java\npublic interface BeanConfigParser {\n  List<BeanDefinition> parse(InputStream inputStream);\n  List<BeanDefinition> parse(String configContent);\n}\n\npublic class XmlBeanConfigParser implements BeanConfigParser {\n\n  @Override\n  public List<BeanDefinition> parse(InputStream inputStream) {\n    String content = null;\n    // TODO:...\n    return parse(content);\n  }\n\n  @Override\n  public List<BeanDefinition> parse(String configContent) {\n    List<BeanDefinition> beanDefinitions = new ArrayList<>();\n    // TODO:...\n    return beanDefinitions;\n  }\n\n}\n\npublic class BeanDefinition {\n  private String id;\n  private String className;\n  private List<ConstructorArg> constructorArgs = new ArrayList<>();\n  private Scope scope = Scope.SINGLETON;\n  private boolean lazyInit = false;\n  // 省略必要的getter/setter/constructors\n \n  public boolean isSingleton() {\n    return scope.equals(Scope.SINGLETON);\n  }\n\n\n  public static enum Scope {\n    SINGLETON,\n    PROTOTYPE\n  }\n  \n  public static class ConstructorArg {\n    private boolean isRef;\n    private Class type;\n    private Object arg;\n    // 省略必要的getter/setter/constructors\n  }\n}\n```\n\n\n\n### 核心工厂类设计\n\n1. 最后，我们来看，BeansFactory 是如何设计和实现的。这也是我们这个 DI 容器最核心的一个类了。它负责根据从配置文件解析得到的 BeanDefinition 来创建对象。\n2. 如果对象的 scope 属性是 singleton，那对象创建之后会缓存在 singletonObjects 这样一个 map 中，下次再请求此对象的时候，直接从 map 中取出返回，不需要重新创建。如果对象的 scope 属性是 prototype，那每次请求对象，BeansFactory 都会创建一个新的对象返回。\n3. 实际上，BeansFactory 创建对象用到的主要技术点就是 Java 中的反射语法：一种动态加载类和创建对象的机制。我们知道，JVM 在启动的时候会根据代码自动地加载类、创建对象。至于都要加载哪些类、创建哪些对象，这些都是在代码中写死的，或者说提前写好的。但是，如果某个对象的创建并不是写死在代码中，而是放到配置文件中，我们需要在程序运行期间，动态地根据配置文件来加载类、创建对象，那这部分工作就没法让 JVM 帮我们自动完成了，我们需要利用 Java 提供的反射语法自己去编写代码。\n4. 搞清楚了反射的原理，BeansFactory 的代码就不难看懂了。具体代码实现如下所示：\n\n\n\n```java\npublic class BeansFactory {\n  private ConcurrentHashMap<String, Object> singletonObjects = new ConcurrentHashMap<>();\n  private ConcurrentHashMap<String, BeanDefinition> beanDefinitions = new ConcurrentHashMap<>();\n\n  public void addBeanDefinitions(List<BeanDefinition> beanDefinitionList) {\n    for (BeanDefinition beanDefinition : beanDefinitionList) {\n      this.beanDefinitions.putIfAbsent(beanDefinition.getId(), beanDefinition);\n    }\n\n    for (BeanDefinition beanDefinition : beanDefinitionList) {\n      if (beanDefinition.isLazyInit() == false && beanDefinition.isSingleton()) {\n        createBean(beanDefinition);\n      }\n    }\n  }\n\n  public Object getBean(String beanId) {\n    BeanDefinition beanDefinition = beanDefinitions.get(beanId);\n    if (beanDefinition == null) {\n      throw new NoSuchBeanDefinitionException(\"Bean is not defined: \" + beanId);\n    }\n    return createBean(beanDefinition);\n  }\n\n  @VisibleForTesting\n  protected Object createBean(BeanDefinition beanDefinition) {\n    if (beanDefinition.isSingleton() && singletonObjects.contains(beanDefinition.getId())) {\n      return singletonObjects.get(beanDefinition.getId());\n    }\n\n    Object bean = null;\n    try {\n      Class beanClass = Class.forName(beanDefinition.getClassName());\n      List<BeanDefinition.ConstructorArg> args = beanDefinition.getConstructorArgs();\n      if (args.isEmpty()) {\n        bean = beanClass.newInstance();\n      } else {\n        Class[] argClasses = new Class[args.size()];\n        Object[] argObjects = new Object[args.size()];\n        for (int i = 0; i < args.size(); ++i) {\n          BeanDefinition.ConstructorArg arg = args.get(i);\n          if (!arg.getIsRef()) {\n            argClasses[i] = arg.getType();\n            argObjects[i] = arg.getArg();\n          } else {\n            BeanDefinition refBeanDefinition = beanDefinitions.get(arg.getArg());\n            if (refBeanDefinition == null) {\n              throw new NoSuchBeanDefinitionException(\"Bean is not defined: \" + arg.getArg());\n            }\n            argClasses[i] = Class.forName(refBeanDefinition.getClassName());\n            argObjects[i] = createBean(refBeanDefinition);\n          }\n        }\n        bean = beanClass.getConstructor(argClasses).newInstance(argObjects);\n      }\n    } catch (ClassNotFoundException | IllegalAccessException\n            | InstantiationException | NoSuchMethodException | InvocationTargetException e) {\n      throw new BeanCreationFailureException(\"\", e);\n    }\n\n    if (bean != null && beanDefinition.isSingleton()) {\n      singletonObjects.putIfAbsent(beanDefinition.getId(), bean);\n      return singletonObjects.get(beanDefinition.getId());\n    }\n    return bean;\n  }\n}\n```\n\n1. 执行入口那里调用`addBeanDefinitions`\n2. 然后`addBeanDefinitions`再调用createBean利用反射创建对象，如果对象的 scope 属性是 singleton，那对象创建之后会缓存在 singletonObjects 这样一个 map 中\n3. 最后最小原型设计那里再调用getBean从singletonObjects 获取对象。\n\n\n\n\n\n# 建造者模式【常用】\n\n> 只要是标注常用的，基本上用的都比较多，无论篇幅长短，都不要忽视。\n\n建造者模式的原理和代码实现非常简单，掌握起来并不难，难点在于应用场景。比如，你有没有考虑过这样几个问题：直接使用构造函数或者配合 set 方法就能创建对象，为什么还需要建造者模式来创建呢？建造者模式和工厂模式都可以创建对象，那它们两个的区别在哪里呢？\n\n## 为什么需要建造者模式？\n\n\n\n1. 在平时的开发中，创建一个对象最常用的方式是，使用 new 关键字调用类的构造函数来完成。我的问题是，什么情况下这种方式就不适用了，就需要采用建造者模式来创建对象呢？你可以先思考一下，下面我通过一个例子来带你看一下。\n2. 假设有这样一道设计面试题：我们需要定义一个资源池配置类 ResourcePoolConfig。这里的资源池，你可以简单理解为线程池、连接池、对象池等。在这个资源池配置类中，有以下几个成员变量，也就是可配置项。现在，请你编写代码实现这个 ResourcePoolConfig 类。\n\n<img src=\"https://npm.elemecdn.com/youthlql@1.0.0/design_patterns/creational/03.02/0001.png\" />\n\n\n\n只要你稍微有点开发经验，那实现这样一个类对你来说并不是件难事。最常见、最容易想到的实现思路如下代码所示。因为 maxTotal、maxIdle、minIdle 不是必填变量，所以在创建 ResourcePoolConfig 对象的时候，我们通过往构造函数中，给这几个参数传递 null 值，来表示使用默认值。\n\n```java\npublic class ResourcePoolConfig {\n  private static final int DEFAULT_MAX_TOTAL = 8;\n  private static final int DEFAULT_MAX_IDLE = 8;\n  private static final int DEFAULT_MIN_IDLE = 0;\n\n  private String name;\n  private int maxTotal = DEFAULT_MAX_TOTAL;\n  private int maxIdle = DEFAULT_MAX_IDLE;\n  private int minIdle = DEFAULT_MIN_IDLE;\n\n  public ResourcePoolConfig(String name, Integer maxTotal, Integer maxIdle, Integer minIdle) {\n    if (StringUtils.isBlank(name)) {\n      throw new IllegalArgumentException(\"name should not be empty.\");\n    }\n    this.name = name;\n\n    if (maxTotal != null) {\n      if (maxTotal <= 0) {\n        throw new IllegalArgumentException(\"maxTotal should be positive.\");\n      }\n      this.maxTotal = maxTotal;\n    }\n\n    if (maxIdle != null) {\n      if (maxIdle < 0) {\n        throw new IllegalArgumentException(\"maxIdle should not be negative.\");\n      }\n      this.maxIdle = maxIdle;\n    }\n\n    if (minIdle != null) {\n      if (minIdle < 0) {\n        throw new IllegalArgumentException(\"minIdle should not be negative.\");\n      }\n      this.minIdle = minIdle;\n    }\n  }\n  //...省略getter方法...\n}\n```\n\n现在，ResourcePoolConfig 只有 4 个可配置项，对应到构造函数中，也只有 4 个参数，参数的个数不多。但是，如果可配置项逐渐增多，变成了 8 个、10 个，甚至更多，那继续沿用现在的设计思路，构造函数的参数列表会变得很长，代码在可读性和易用性上都会变差。在使用构造函数的时候，我们就容易搞错各参数的顺序，传递进错误的参数值，导致非常隐蔽的 bug。\n\n```java\n// 参数太多，导致可读性差、参数可能传递错误\nResourcePoolConfig config = new ResourcePoolConfig(\"dbconnectionpool\", 16, null, 8, null, false , true, 10, 20，false， true);\n```\n\n\n\n解决这个问题的办法你应该也已经想到了，那就是用 set() 函数来给成员变量赋值，以替代冗长的构造函数。我们直接看代码，具体如下所示。其中，配置项 name 是必填的，所以我们把它放到构造函数中设置，强制创建类对象的时候就要填写。其他配置项 maxTotal、maxIdle、minIdle 都不是必填的，所以我们通过 set() 函数来设置，让使用者自主选择填写或者不填写。\n\n\n\n```java\npublic class ResourcePoolConfig {\n  private static final int DEFAULT_MAX_TOTAL = 8;\n  private static final int DEFAULT_MAX_IDLE = 8;\n  private static final int DEFAULT_MIN_IDLE = 0;\n\n  private String name;\n  private int maxTotal = DEFAULT_MAX_TOTAL;\n  private int maxIdle = DEFAULT_MAX_IDLE;\n  private int minIdle = DEFAULT_MIN_IDLE;\n  \n  public ResourcePoolConfig(String name) {\n    if (StringUtils.isBlank(name)) {\n      throw new IllegalArgumentException(\"name should not be empty.\");\n    }\n    this.name = name;\n  }\n\n  public void setMaxTotal(int maxTotal) {\n    if (maxTotal <= 0) {\n      throw new IllegalArgumentException(\"maxTotal should be positive.\");\n    }\n    this.maxTotal = maxTotal;\n  }\n\n  public void setMaxIdle(int maxIdle) {\n    if (maxIdle < 0) {\n      throw new IllegalArgumentException(\"maxIdle should not be negative.\");\n    }\n    this.maxIdle = maxIdle;\n  }\n\n  public void setMinIdle(int minIdle) {\n    if (minIdle < 0) {\n      throw new IllegalArgumentException(\"minIdle should not be negative.\");\n    }\n    this.minIdle = minIdle;\n  }\n  //...省略getter方法...\n}\n```\n\n\n\n接下来，我们来看新的 ResourcePoolConfig 类该如何使用。我写了一个示例代码，如下所示。没有了冗长的函数调用和参数列表，代码在可读性和易用性上提高了很多。\n\n```java\n// ResourcePoolConfig使用举例\nResourcePoolConfig config = new ResourcePoolConfig(\"dbconnectionpool\");\nconfig.setMaxTotal(16);\nconfig.setMaxIdle(8);\n```\n\n\n\n至此，我们仍然没有用到建造者模式，通过构造函数设置必填项，通过 set() 方法设置可选配置项，就能实现我们的设计需求。如果我们把问题的难度再加大点，比如，还需要解决下面这三个问题，那现在的设计思路就不能满足了。\n\n- 我们刚刚讲到，name 是必填的，所以，我们把它放到构造函数中，强制创建对象的时候就设置。如果必填的配置项有很多，把这些必填配置项都放到构造函数中设置，那构造函数就又会出现参数列表很长的问题。如果我们把必填项也通过 set() 方法设置，那校验这些必填项是否已经填写的逻辑就无处安放了。\n- 除此之外，假设配置项之间有一定的依赖关系，比如，如果用户设置了 maxTotal、maxIdle、minIdle 其中一个，就必须显式地设置另外两个；或者配置项之间有一定的约束条件，比如，maxIdle 和 minIdle 要小于等于 maxTotal。如果我们继续使用现在的设计思路，那这些配置项之间的依赖关系或者约束条件的校验逻辑就无处安放了。\n- 如果我们希望 ResourcePoolConfig 类对象是不可变对象，也就是说，对象在创建好之后，就不能再修改内部的属性值。要实现这个功能，我们就不能在 ResourcePoolConfig 类中暴露 set() 方法。\n\n为了解决这些问题，建造者模式就派上用场了。我们可以把校验逻辑放置到 Builder 类中，先创建建造者，并且通过 set() 方法设置建造者的变量值，然后在使用 build() 方法真正创建对象之前，做集中的校验，校验通过之后才会创建对象。除此之外，我们把 ResourcePoolConfig 的构造函数改为 private 私有权限。这样我们就只能通过建造者来创建 ResourcePoolConfig 类对象。并且，ResourcePoolConfig 没有提供任何 set() 方法，这样我们创建出来的对象就是不可变对象了。我们用建造者模式重新实现了上面的需求，具体的代码如下所示：\n\n```java\npublic class ResourcePoolConfig {\n  private String name;\n  private int maxTotal;\n  private int maxIdle;\n  private int minIdle;\n\n  private ResourcePoolConfig(Builder builder) {\n    this.name = builder.name;\n    this.maxTotal = builder.maxTotal;\n    this.maxIdle = builder.maxIdle;\n    this.minIdle = builder.minIdle;\n  }\n  //...省略getter方法...\n\n  //我们将Builder类设计成了ResourcePoolConfig的内部类。\n  //我们也可以将Builder类设计成独立的非内部类ResourcePoolConfigBuilder。\n  public static class Builder {\n    private static final int DEFAULT_MAX_TOTAL = 8;\n    private static final int DEFAULT_MAX_IDLE = 8;\n    private static final int DEFAULT_MIN_IDLE = 0;\n\n    private String name;\n    private int maxTotal = DEFAULT_MAX_TOTAL;\n    private int maxIdle = DEFAULT_MAX_IDLE;\n    private int minIdle = DEFAULT_MIN_IDLE;\n\n    public ResourcePoolConfig build() {\n      // 校验逻辑放到这里来做，包括必填项校验、依赖关系校验、约束条件校验等\n      if (StringUtils.isBlank(name)) {\n        throw new IllegalArgumentException(\"...\");\n      }\n      if (maxIdle > maxTotal) {\n        throw new IllegalArgumentException(\"...\");\n      }\n      if (minIdle > maxTotal || minIdle > maxIdle) {\n        throw new IllegalArgumentException(\"...\");\n      }\n\n      return new ResourcePoolConfig(this);\n    }\n\n    public Builder setName(String name) {\n      if (StringUtils.isBlank(name)) {\n        throw new IllegalArgumentException(\"...\");\n      }\n      this.name = name;\n      return this;\n    }\n\n    public Builder setMaxTotal(int maxTotal) {\n      if (maxTotal <= 0) {\n        throw new IllegalArgumentException(\"...\");\n      }\n      this.maxTotal = maxTotal;\n      return this;\n    }\n\n    public Builder setMaxIdle(int maxIdle) {\n      if (maxIdle < 0) {\n        throw new IllegalArgumentException(\"...\");\n      }\n      this.maxIdle = maxIdle;\n      return this;\n    }\n\n    public Builder setMinIdle(int minIdle) {\n      if (minIdle < 0) {\n        throw new IllegalArgumentException(\"...\");\n      }\n      this.minIdle = minIdle;\n      return this;\n    }\n  }\n}\n\n// 这段代码会抛出IllegalArgumentException，因为minIdle>maxIdle\nResourcePoolConfig config = new ResourcePoolConfig.Builder()\n        .setName(\"dbconnectionpool\")\n        .setMaxTotal(16)\n        .setMaxIdle(10)\n        .setMinIdle(12)\n        .build();\n```\n\n\n\n实际上，使用建造者模式创建对象，还能避免对象存在无效状态。我再举个例子解释一下。比如我们定义了一个长方形类，如果不使用建造者模式，采用先创建后 set 的方式，那就会导致在第一个 set 之后，对象处于无效状态。具体代码如下所示\n\n```java\nRectangle r = new Rectange(); // r is invalid\nr.setWidth(2); // r is invalid\nr.setHeight(3); // r is valid\n```\n\n> 这里是说，长方形必须同时具备宽、高两个属性才是一个有效的长方形。只有其中一个属性，这个长方形对象就没有意义，是无效的。\n\n1. 为了避免这种无效状态的存在，我们就需要使用构造函数一次性初始化好所有的成员变量。如果构造函数参数过多，我们就需要考虑使用建造者模式，先设置建造者的变量，然后再一次性地创建对象，让对象一直处于有效状态。(建造者主要解决参数过多、参数检验、控制对象创建后不可变的问题)\n2. 实际上，如果我们并不是很关心对象是否有短暂的无效状态，也不是太在意对象是否是可变的。比如，对象只是用来映射数据库读出来的数据，那我们直接暴露 set() 方法来设置类的成员变量值是完全没问题的。而且，使用建造者模式来构建对象，代码实际上是有点重复的，ResourcePoolConfig 类中的成员变量，要在 Builder 类中重新再定义一遍。\n\n\n\n\n\n## 与工厂模式有何区别？\n\n\n\n1. 从上面的讲解中，我们可以看出，建造者模式是让建造者类来负责对象的创建工作。上面讲到的工厂模式，是由工厂类来负责对象创建的工作。那它们之间有什么区别呢？\n2. 实际上，工厂模式是用来创建不同但是相关类型的对象（继承同一父类或者接口的一组子类），由给定的参数来决定创建哪种类型的对象。建造者模式是用来创建一种类型的复杂对象，通过设置不同的可选参数，“定制化”地创建不同的对象。\n\n\n\n网上有一个经典的例子很好地解释了两者的区别:\n\n> 顾客走进一家餐馆点餐，我们利用工厂模式，根据用户不同的选择，来制作不同的食物，比如披萨、汉堡、沙拉。对于披萨来说，用户又有各种配料可以定制，比如奶酪、西红柿、起司，我们通过建造者模式根据用户选择的不同配料来制作披萨。\n\n实际上，我们也不要太学院派，非得把工厂模式、建造者模式分得那么清楚，我们需要知道的是，每个模式为什么这么设计，能解决什么问题。只有了解了这些最本质的东西，我们才能不生搬硬套，才能灵活应用，甚至可以混用各种模式创造出新的模式，来解决特定场景的问题。\n\n\n\n\n\n\n\n# 原型模式【不常用】\n\n今天的讲解跟具体某一语言的语法机制无关，而是通过一个 clone 散列表的例子带你搞清楚：原型模式的应用场景，以及它的两种实现方式：深拷贝和浅拷贝。虽然原型模式的原理和代码实现非常简单，但今天举的例子还是稍微有点复杂的\n\n\n\n## 原型模式的原理与应用\n\n如果对象的创建成本比较大，而同一个类的不同对象之间差别不大（大部分字段都相同），在这种情况下，我们可以利用对已有对象（原型）进行复制（或者叫拷贝）的方式来创建新对象，以达到节省创建时间的目的。这种基于原型来创建对象的方式就叫作原型设计模式（Prototype Design Pattern），简称原型模式。\n\n\n\n> 那何为“对象的创建成本比较大”？\n\n1. 实际上，创建对象包含的申请内存、给成员变量赋值这一过程，本身并不会花费太多时间，或者说对于大部分业务系统来说，这点时间完全是可以忽略的。应用一个复杂的模式，只得到一点点的性能提升，这就是所谓的过度设计，得不偿失。\n2. 但是，如果对象中的数据需要经过复杂的计算才能得到（比如排序、计算哈希值），或者需要从 RPC、网络、数据库、文件系统等非常慢速的 IO 中读取，这种情况下，我们就可以利用原型模式，从其他已有对象中直接拷贝得到，而不用每次在创建新对象的时候，都重复执行这些耗时的操作。\n\n\n\n> 这么说还是比较理论，接下来，我们通过一个例子来解释一下刚刚这段话。\n\n\n\n1. 假设数据库中存储了大约 10 万条“搜索关键词”信息，每条信息包含关键词、关键词被搜索的次数、信息最近被更新的时间等。系统 A 在启动的时候会加载这份数据到内存中，用于处理某些其他的业务需求。为了方便快速地查找某个关键词对应的信息，我们给关键词建立一个散列表索引。\n2. 如果你熟悉的是 Java 语言，可以直接使用语言中提供的 HashMap 容器来实现。其中，HashMap 的 key 为搜索关键词，value 为关键词详细信息（比如搜索次数）。我们只需要将数据从数据库中读取出来，放入 HashMap 就可以了。\n3. 不过，我们还有另外一个系统 B，专门用来分析搜索日志，定期（比如间隔 10 分钟）批量地更新数据库中的数据，并且标记为新的数据版本。比如，在下面的示例图中，我们对 v2 版本的数据进行更新，得到 v3 版本的数据。这里我们假设只有更新和新添关键词，没有删除关键词的行为。\n\n<img src=\"https://npm.elemecdn.com/youthlql@1.0.0/design_patterns/creational/03.02/0002.png\"/>\n\n\n\n1. 为了保证系统 A 中数据的实时性（不一定非常实时，但数据也不能太旧），系统 A 需要定期根据数据库中的数据，更新内存中的索引和数据。\n2. 我们该如何实现这个需求呢？实际上，也不难。我们只需要在系统 A 中，记录当前数据的版本 Va 对应的更新时间 Ta，从数据库中捞出更新时间大于 Ta 的所有搜索关键词，也就是找出 Va 版本与最新版本数据的“差集”，然后针对差集中的每个关键词进行处理。如果它已经在散列表中存在了，我们就更新相应的搜索次数、更新时间等信息；如果它在散列表中不存在，我们就将它插入到散列表中。\n3. 按照这个设计思路，我给出的示例代码如下所示：\n\n```java\npublic class Demo {\n  private ConcurrentHashMap<String, SearchWord> currentKeywords = new ConcurrentHashMap<>();\n  private long lastUpdateTime = -1;\n\n  public void refresh() {\n    // 从数据库中取出更新时间>lastUpdateTime的数据，放入到currentKeywords中\n    List<SearchWord> toBeUpdatedSearchWords = getSearchWords(lastUpdateTime);\n    long maxNewUpdatedTime = lastUpdateTime;\n    for (SearchWord searchWord : toBeUpdatedSearchWords) {\n      if (searchWord.getLastUpdateTime() > maxNewUpdatedTime) {\n        maxNewUpdatedTime = searchWord.getLastUpdateTime();\n      }\n      if (currentKeywords.containsKey(searchWord.getKeyword())) {\n        currentKeywords.replace(searchWord.getKeyword(), searchWord);\n      } else {\n        currentKeywords.put(searchWord.getKeyword(), searchWord);\n      }\n    }\n\n    lastUpdateTime = maxNewUpdatedTime;\n  }\n\n  private List<SearchWord> getSearchWords(long lastUpdateTime) {\n    // TODO: 从数据库中取出更新时间>lastUpdateTime的数据\n    return null;\n  }\n}\n```\n\n\n\n不过，现在，我们有一个特殊的要求：任何时刻，系统 A 中的所有数据都必须是同一个版本的，要么都是版本 a，要么都是版本 b，不能有的是版本 a，有的是版本 b。那刚刚的更新方式就不能满足这个要求了（因为数据很多，一个一个的for循环肯定会出现不同数据版本的问题）。除此之外，我们还要求：在更新内存数据的时候，系统 A 不能处于不可用状态，也就是不能停机更新数据。\n\n\n\n1. 那我们该如何实现现在这个需求呢？\n\n2. 实际上，也不难。我们把正在使用的数据的版本定义为“服务版本”，当我们要更新内存中的数据的时候，我们并不是直接在服务版本（假设是版本 a 数据）上更新，而是重新创建另一个版本数据（假设是版本 b 数据），等新的版本数据建好之后，再一次性地将服务版本从版本 a 切换到版本 b。这样既保证了数据一直可用，又避免了中间状态的存在。\n3. 按照这个设计思路，我给出的示例代码如下所示：\n\n```java\npublic class Demo {\n  private HashMap<String, SearchWord> currentKeywords=new HashMap<>();\n\n  public void refresh() {\n    HashMap<String, SearchWord> newKeywords = new LinkedHashMap<>();\n\n    // 从数据库中取出所有的数据，放入到newKeywords中\n    List<SearchWord> toBeUpdatedSearchWords = getSearchWords();\n    for (SearchWord searchWord : toBeUpdatedSearchWords) {\n      newKeywords.put(searchWord.getKeyword(), searchWord);\n    }\n\n    currentKeywords = newKeywords;\n  }\n\n  private List<SearchWord> getSearchWords() {\n    // TODO: 从数据库中取出所有的数据\n    return null;\n  }\n}\n```\n\n\n\n1. 不过，在上面的代码实现中，newKeywords 构建的成本比较高。我们需要将这 10 万条数据从数据库中读出，然后计算哈希值，构建 newKeywords。这个过程显然是比较耗时。为了提高效率，原型模式就派上用场了。\n2. 我们拷贝 currentKeywords 数据到 newKeywords 中，然后从数据库中只捞出新增或者有更新的关键词，更新到 newKeywords 中。而相对于 10 万条数据来说，每次新增或者更新的关键词个数是比较少的，所以，这种策略大大提高了数据更新的效率。\n3. 按照这个设计思路，我给出的示例代码如下所示：\n\n```java\npublic class Demo {\n  private HashMap<String, SearchWord> currentKeywords=new HashMap<>();\n  private long lastUpdateTime = -1;\n\n  public void refresh() {\n    // 原型模式就这么简单，拷贝已有对象的数据，更新少量差值\n    HashMap<String, SearchWord> newKeywords = (HashMap<String, SearchWord>) currentKeywords.clone();\n\n    // 从数据库中取出更新时间>lastUpdateTime的数据，放入到newKeywords中\n    List<SearchWord> toBeUpdatedSearchWords = getSearchWords(lastUpdateTime);\n    long maxNewUpdatedTime = lastUpdateTime;\n    for (SearchWord searchWord : toBeUpdatedSearchWords) {\n      if (searchWord.getLastUpdateTime() > maxNewUpdatedTime) {\n        maxNewUpdatedTime = searchWord.getLastUpdateTime();\n      }\n      if (newKeywords.containsKey(searchWord.getKeyword())) {\n        SearchWord oldSearchWord = newKeywords.get(searchWord.getKeyword());\n        oldSearchWord.setCount(searchWord.getCount());\n        oldSearchWord.setLastUpdateTime(searchWord.getLastUpdateTime());\n      } else {\n        newKeywords.put(searchWord.getKeyword(), searchWord);\n      }\n    }\n\n    lastUpdateTime = maxNewUpdatedTime;\n    currentKeywords = newKeywords;\n  }\n\n  private List<SearchWord> getSearchWords(long lastUpdateTime) {\n    // TODO: 从数据库中取出更新时间>lastUpdateTime的数据\n    return null;\n  }\n}\n```\n\n1. 这里我们利用了 Java 中的 clone() 语法来复制一个对象。如果你熟悉的语言没有这个语法，那把数据从 currentKeywords 中一个个取出来，然后再重新计算哈希值，放入到 newKeywords 中也是可以接受的。毕竟，最耗时的还是从数据库中取数据的操作。相对于数据库的 IO 操作来说，内存操作和 CPU 计算的耗时都是可以忽略的。\n2. 不过，不知道你有没有发现，实际上，刚刚的代码实现是有问题的。要弄明白到底有什么问题，我们需要先了解另外两个概念：深拷贝（Deep Copy）和浅拷贝（Shallow Copy）。\n\n\n\n\n\n## 原型模式的实现方式：深拷贝和浅拷贝\n\n> 1、关于深拷贝浅拷贝，我觉得这篇文章讲的不错：https://blog.csdn.net/baiye_xing/article/details/71788741\n\n\n\n> 我自己的总结：\n>\n> **浅拷贝**：对一个对象进行拷贝时，这个对象对应的类里的成员变量。\n>\n> - 对于数据类型是基本数据类型的成员变量，浅拷贝会直接进行值拷贝，也就是将该属性值复制一份给新的对象。因为是两份不同的数据，所以对其中一个对象的该成员变量值进行修改，不会影响另一个对象拷贝得到的数据\n> - 对于数据类型是引用数据类型的成员变量(也就是子对象，或者数组啥的)，也就是只是将该成员变量的引用值（引用拷贝【并发引用传递，Java本质还是值传递】）复制一份给新的对象。因为实际上两个对象的该成员变量都指向同一个实例。在这种情况下，在一个对象中修改该成员变量会影响到另一个对象的该成员变量值。\n>\n> 1. **深拷贝**：对基本数据类型进行值传递，对引用数据类型，创建一个新的对象，并复制其内容，此为深拷贝。\n> 2. 也就是说浅拷贝对于子对象只是拷贝了引用值，并没有真正的拷贝整个对象。\n>\n> **深拷贝实现思路：**\n>\n> 1. 对于每个子对象都实现Cloneable 接口，并重写clone方法。最后在最顶层的类的重写的 clone 方法中调用所有子对象的 clone 方法即可实现深拷贝。【简单的说就是：每一层的每个子对象都进行浅拷贝=深拷贝】\n>\n> 2. 利用序列化。【先对对象进行序列化，紧接着马上反序列化出 】\n\n\n\n我们来看，在内存中，用散列表组织的搜索关键词信息是如何存储的。我画了一张示意图，大致结构如下所示。从图中我们可以发现，散列表索引中，每个结点存储的 key 是搜索关键词，value 是 SearchWord 对象的内存地址。SearchWord 对象本身存储在散列表之外的内存空间中。\n\n<img src=\"https://npm.elemecdn.com/youthlql@1.0.0/design_patterns/creational/03.02/0003.png\"  />\n\n浅拷贝和深拷贝的区别在于，浅拷贝只会复制图中的索引（散列表），不会复制数据（SearchWord 对象）本身。相反，深拷贝不仅仅会复制索引，还会复制数据本身。浅拷贝得到的对象（newKeywords）跟原始对象（currentKeywords）共享数据（SearchWord 对象），而深拷贝得到的是一份完完全全独立的对象。具体的对比如下图所示：\n\n<img src=\"https://npm.elemecdn.com/youthlql@1.0.0/design_patterns/creational/03.02/0004.png\"/>\n\n\n\n<img src=\"https://npm.elemecdn.com/youthlql@1.0.0/design_patterns/creational/03.02/0005.png\" />\n\n\n\n1. 在 Java 语言中，Object 类的 clone() 方法执行的就是我们刚刚说的浅拷贝。它只会拷贝对象中的基本数据类型的数据（比如，int、long），以及引用对象（SearchWord）的内存地址，不会递归地拷贝引用对象本身。\n2. 在上面的代码中，我们通过调用 HashMap 上的 clone() 浅拷贝方法来实现原型模式。当我们通过 newKeywords 更新 SearchWord 对象的时候（比如，更新“设计模式”这个搜索关键词的访问次数），newKeywords 和 currentKeywords 因为指向相同的一组 SearchWord 对象，就会导致 currentKeywords 中指向的 SearchWord，有的是老版本的，有的是新版本的，就没法满足我们之前的需求：currentKeywords 中的数据在任何时刻都是同一个版本的，不存在介于老版本与新版本之间的中间状态。\n\n3. 现在，我们又该如何来解决这个问题呢？\n\n4. 我们可以将浅拷贝替换为深拷贝。newKeywords 不仅仅复制 currentKeywords 的索引，还把 SearchWord 对象也复制一份出来，这样 newKeywords 和 currentKeywords 就指向不同的 SearchWord 对象，也就不存在更新 newKeywords 的数据会导致 currentKeywords 的数据也被更新的问题了。\n5. 那如何实现深拷贝呢？总结一下的话，有下面两种方法。\n\n\n\n第一种方法：递归拷贝对象、对象的引用对象以及引用对象的引用对象……直到要拷贝的对象只包含基本数据类型数据，没有引用对象为止。根据这个思路对之前的代码进行重构。重构之后的代码如下所示：\n\n```java\npublic class Demo {\n  private HashMap<String, SearchWord> currentKeywords=new HashMap<>();\n  private long lastUpdateTime = -1;\n\n  public void refresh() {\n    // Deep copy\n    HashMap<String, SearchWord> newKeywords = new HashMap<>();\n    for (HashMap.Entry<String, SearchWord> e : currentKeywords.entrySet()) {\n      SearchWord searchWord = e.getValue();\n      SearchWord newSearchWord = new SearchWord(\n              searchWord.getKeyword(), searchWord.getCount(), searchWord.getLastUpdateTime());\n      newKeywords.put(e.getKey(), newSearchWord);\n    }\n\n    // 从数据库中取出更新时间>lastUpdateTime的数据，放入到newKeywords中\n    List<SearchWord> toBeUpdatedSearchWords = getSearchWords(lastUpdateTime);\n    long maxNewUpdatedTime = lastUpdateTime;\n    for (SearchWord searchWord : toBeUpdatedSearchWords) {\n      if (searchWord.getLastUpdateTime() > maxNewUpdatedTime) {\n        maxNewUpdatedTime = searchWord.getLastUpdateTime();\n      }\n      if (newKeywords.containsKey(searchWord.getKeyword())) {\n        SearchWord oldSearchWord = newKeywords.get(searchWord.getKeyword());\n        oldSearchWord.setCount(searchWord.getCount());\n        oldSearchWord.setLastUpdateTime(searchWord.getLastUpdateTime());\n      } else {\n        newKeywords.put(searchWord.getKeyword(), searchWord);\n      }\n    }\n\n    lastUpdateTime = maxNewUpdatedTime;\n    currentKeywords = newKeywords;\n  }\n\n  private List<SearchWord> getSearchWords(long lastUpdateTime) {\n    // TODO: 从数据库中取出更新时间>lastUpdateTime的数据\n    return null;\n  }\n\n}\n```\n\n\n\n第二种方法：先将对象序列化，然后再反序列化成新的对象。具体的示例代码如下所示：\n\n```java\npublic Object deepCopy(Object object) {\n  ByteArrayOutputStream bo = new ByteArrayOutputStream();\n  ObjectOutputStream oo = new ObjectOutputStream(bo);\n  oo.writeObject(object);\n  \n  ByteArrayInputStream bi = new ByteArrayInputStream(bo.toByteArray());\n  ObjectInputStream oi = new ObjectInputStream(bi);\n  \n  return oi.readObject();\n}\n```\n\n1. 刚刚的两种实现方法，不管采用哪种，深拷贝都要比浅拷贝耗时、耗内存空间。针对我们这个应用场景，有没有更快、更省内存的实现方式呢？\n2. 我们可以先采用浅拷贝的方式创建 newKeywords。对于需要更新的 SearchWord 对象，我们再使用深度拷贝的方式创建一份新的对象，替换 newKeywords 中的老对象。毕竟需要更新的数据是很少的。这种方式即利用了浅拷贝节省时间、空间的优点，又能保证 currentKeywords 中的中数据都是老版本的数据。具体的代码实现如下所示。这也是标题中讲到的，在我们这个应用场景下，最快速 clone 散列表的方式。\n\n\n\n```java\npublic class Demo {\n  private HashMap<String, SearchWord> currentKeywords=new HashMap<>();\n  private long lastUpdateTime = -1;\n\n  public void refresh() {\n    // Shallow copy\n    HashMap<String, SearchWord> newKeywords = (HashMap<String, SearchWord>) currentKeywords.clone();\n\n    // 从数据库中取出更新时间>lastUpdateTime的数据，放入到newKeywords中\n    List<SearchWord> toBeUpdatedSearchWords = getSearchWords(lastUpdateTime);\n    long maxNewUpdatedTime = lastUpdateTime;\n    for (SearchWord searchWord : toBeUpdatedSearchWords) {\n      if (searchWord.getLastUpdateTime() > maxNewUpdatedTime) {\n        maxNewUpdatedTime = searchWord.getLastUpdateTime();\n      }\n      if (newKeywords.containsKey(searchWord.getKeyword())) {\n        newKeywords.remove(searchWord.getKeyword());\n      }\n      newKeywords.put(searchWord.getKeyword(), searchWord);\n    }\n\n    lastUpdateTime = maxNewUpdatedTime;\n    currentKeywords = newKeywords;\n  }\n\n  private List<SearchWord> getSearchWords(long lastUpdateTime) {\n    // TODO: 从数据库中取出更新时间>lastUpdateTime的数据\n    return null;\n  }\n}\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"2024-06-18-设计模式-03.02-创建型-工厂&建造者&原型","published":1,"updated":"2024-06-18T05:25:21.165Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clxjyo3cd000oisvd7aqahe1m","content":"<h1 id=\"声明\"><a href=\"#声明\" class=\"headerlink\" title=\"声明\"></a>声明</h1><blockquote>\n<ol>\n<li>此系列文章非本人原创，是学习笔记。</li>\n<li>设计模式系列以后会持续更新，包括已经发布的设计模式文章，因为后续还要再多看一下书，教程和开源项目等，继续润色文章。</li>\n</ol>\n</blockquote>\n<h1 id=\"工厂模式【常用】\"><a href=\"#工厂模式【常用】\" class=\"headerlink\" title=\"工厂模式【常用】\"></a>工厂模式【常用】</h1><blockquote>\n<p>工厂模式很重要，后面的很多架构设计，都是工厂模式联合着其它设计模式使用。</p>\n</blockquote>\n<ol>\n<li><p>一般情况下，工厂模式分为三种更加细分的类型：简单工厂、工厂方法和抽象工厂。不过，在 GoF 的《设计模式》一书中，它将简单工厂模式看作是工厂方法模式的一种特例，所以工厂模式只被分成了工厂方法和抽象工厂两类。实际上，前面一种分类方法更加常见，所以，在今天的讲解中，我们沿用第一种分类方法。</p>\n</li>\n<li><p>在这三种细分的工厂模式中，简单工厂、工厂方法原理比较简单，在实际的项目中也比较常用。而抽象工厂的原理稍微复杂点，在实际的项目中相对也不常用。所以，我们今天讲解的重点是前两种工厂模式。对于抽象工厂，稍微了解一下即可。</p>\n</li>\n<li><p>除此之外，我们讲解的重点也不是原理和实现，因为这些都很简单，重点还是带你搞清楚应用场景：什么时候该用工厂模式？相对于直接 new 来创建对象，用工厂模式来创建究竟有什么好处呢？</p>\n</li>\n</ol>\n<h2 id=\"简单工厂（Simple-Factory）\"><a href=\"#简单工厂（Simple-Factory）\" class=\"headerlink\" title=\"简单工厂（Simple Factory）\"></a>简单工厂（Simple Factory）</h2><p>首先，我们来看，什么是简单工厂模式。我们通过一个例子来解释一下。</p>\n<p>在下面这段代码中，我们根据配置文件的后缀（json、xml、yaml、properties），选择不同的解析器（JsonRuleConfigParser、XmlRuleConfigParser……），将存储在文件中的配置解析成内存对象 RuleConfig。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">RuleConfigSource</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> RuleConfig <span class=\"title function_\">load</span><span class=\"params\">(String ruleConfigFilePath)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">ruleConfigFileExtension</span> <span class=\"operator\">=</span> getFileExtension(ruleConfigFilePath);</span><br><span class=\"line\">    <span class=\"type\">IRuleConfigParser</span> <span class=\"variable\">parser</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"string\">&quot;json&quot;</span>.equalsIgnoreCase(ruleConfigFileExtension)) &#123;</span><br><span class=\"line\">      parser = <span class=\"keyword\">new</span> <span class=\"title class_\">JsonRuleConfigParser</span>();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"string\">&quot;xml&quot;</span>.equalsIgnoreCase(ruleConfigFileExtension)) &#123;</span><br><span class=\"line\">      parser = <span class=\"keyword\">new</span> <span class=\"title class_\">XmlRuleConfigParser</span>();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"string\">&quot;yaml&quot;</span>.equalsIgnoreCase(ruleConfigFileExtension)) &#123;</span><br><span class=\"line\">      parser = <span class=\"keyword\">new</span> <span class=\"title class_\">YamlRuleConfigParser</span>();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"string\">&quot;properties&quot;</span>.equalsIgnoreCase(ruleConfigFileExtension)) &#123;</span><br><span class=\"line\">      parser = <span class=\"keyword\">new</span> <span class=\"title class_\">PropertiesRuleConfigParser</span>();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">InvalidRuleConfigException</span>(</span><br><span class=\"line\">             <span class=\"string\">&quot;Rule config file format is not supported: &quot;</span> + ruleConfigFilePath);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">configText</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">    <span class=\"comment\">//从ruleConfigFilePath文件中读取配置文本到configText中</span></span><br><span class=\"line\">    <span class=\"type\">RuleConfig</span> <span class=\"variable\">ruleConfig</span> <span class=\"operator\">=</span> parser.parse(configText);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ruleConfig;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> String <span class=\"title function_\">getFileExtension</span><span class=\"params\">(String filePath)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//...解析文件名获取扩展名，比如rule.json，返回json</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;json&quot;</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>为了让代码逻辑更加清晰，可读性更好，我们要善于将功能独立的代码块封装成函数。按照这个设计思路，我们可以将代码中涉及 parser 创建的部分逻辑剥离出来，抽象成 createParser() 函数。重构之后的代码如下所示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  <span class=\"keyword\">public</span> RuleConfig <span class=\"title function_\">load</span><span class=\"params\">(String ruleConfigFilePath)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">ruleConfigFileExtension</span> <span class=\"operator\">=</span> getFileExtension(ruleConfigFilePath);</span><br><span class=\"line\">    <span class=\"type\">IRuleConfigParser</span> <span class=\"variable\">parser</span> <span class=\"operator\">=</span> createParser(ruleConfigFileExtension);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (parser == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">InvalidRuleConfigException</span>(</span><br><span class=\"line\">              <span class=\"string\">&quot;Rule config file format is not supported: &quot;</span> + ruleConfigFilePath);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">configText</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">    <span class=\"comment\">//从ruleConfigFilePath文件中读取配置文本到configText中</span></span><br><span class=\"line\">    <span class=\"type\">RuleConfig</span> <span class=\"variable\">ruleConfig</span> <span class=\"operator\">=</span> parser.parse(configText);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ruleConfig;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> String <span class=\"title function_\">getFileExtension</span><span class=\"params\">(String filePath)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//...解析文件名获取扩展名，比如rule.json，返回json</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;json&quot;</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> IRuleConfigParser <span class=\"title function_\">createParser</span><span class=\"params\">(String configFormat)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">IRuleConfigParser</span> <span class=\"variable\">parser</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"string\">&quot;json&quot;</span>.equalsIgnoreCase(configFormat)) &#123;</span><br><span class=\"line\">      parser = <span class=\"keyword\">new</span> <span class=\"title class_\">JsonRuleConfigParser</span>();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"string\">&quot;xml&quot;</span>.equalsIgnoreCase(configFormat)) &#123;</span><br><span class=\"line\">      parser = <span class=\"keyword\">new</span> <span class=\"title class_\">XmlRuleConfigParser</span>();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"string\">&quot;yaml&quot;</span>.equalsIgnoreCase(configFormat)) &#123;</span><br><span class=\"line\">      parser = <span class=\"keyword\">new</span> <span class=\"title class_\">YamlRuleConfigParser</span>();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"string\">&quot;properties&quot;</span>.equalsIgnoreCase(configFormat)) &#123;</span><br><span class=\"line\">      parser = <span class=\"keyword\">new</span> <span class=\"title class_\">PropertiesRuleConfigParser</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> parser;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>为了让类的职责更加单一(<strong>设计模式原则中的单一职责</strong>，)、代码更加清晰，我们还可以进一步将 createParser() 函数剥离到一个独立的类中，让这个类只负责对象的创建。而这个类就是我们现在要讲的简单工厂模式类。具体的代码如下所示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">RuleConfigSource</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> RuleConfig <span class=\"title function_\">load</span><span class=\"params\">(String ruleConfigFilePath)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">ruleConfigFileExtension</span> <span class=\"operator\">=</span> getFileExtension(ruleConfigFilePath);</span><br><span class=\"line\">    <span class=\"type\">IRuleConfigParser</span> <span class=\"variable\">parser</span> <span class=\"operator\">=</span> RuleConfigParserFactory.createParser(ruleConfigFileExtension);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (parser == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">InvalidRuleConfigException</span>(</span><br><span class=\"line\">              <span class=\"string\">&quot;Rule config file format is not supported: &quot;</span> + ruleConfigFilePath);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">configText</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">    <span class=\"comment\">//从ruleConfigFilePath文件中读取配置文本到configText中</span></span><br><span class=\"line\">    <span class=\"type\">RuleConfig</span> <span class=\"variable\">ruleConfig</span> <span class=\"operator\">=</span> parser.parse(configText);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ruleConfig;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> String <span class=\"title function_\">getFileExtension</span><span class=\"params\">(String filePath)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//...解析文件名获取扩展名，比如rule.json，返回json</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;json&quot;</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">RuleConfigParserFactory</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> IRuleConfigParser <span class=\"title function_\">createParser</span><span class=\"params\">(String configFormat)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">IRuleConfigParser</span> <span class=\"variable\">parser</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"string\">&quot;json&quot;</span>.equalsIgnoreCase(configFormat)) &#123;</span><br><span class=\"line\">      parser = <span class=\"keyword\">new</span> <span class=\"title class_\">JsonRuleConfigParser</span>();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"string\">&quot;xml&quot;</span>.equalsIgnoreCase(configFormat)) &#123;</span><br><span class=\"line\">      parser = <span class=\"keyword\">new</span> <span class=\"title class_\">XmlRuleConfigParser</span>();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"string\">&quot;yaml&quot;</span>.equalsIgnoreCase(configFormat)) &#123;</span><br><span class=\"line\">      parser = <span class=\"keyword\">new</span> <span class=\"title class_\">YamlRuleConfigParser</span>();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"string\">&quot;properties&quot;</span>.equalsIgnoreCase(configFormat)) &#123;</span><br><span class=\"line\">      parser = <span class=\"keyword\">new</span> <span class=\"title class_\">PropertiesRuleConfigParser</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> parser;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<ol>\n<li>在上面的代码实现中，我们每次调用 RuleConfigParserFactory 的 createParser() 的时候，都要创建一个新的 parser。</li>\n<li>实际上，如果 parser 可以复用，为了节省内存和对象创建的时间，我们可以将 parser 事先创建好缓存起来。当调用 createParser() 函数的时候，我们从缓存中取出 parser 对象直接使用。这有点类似单例模式和简单工厂模式的结合，具体的代码实现如下所示。在接下来的讲解中，我们把上一种实现方法叫作简单工厂模式的第一种实现方法，把下面这种实现方法叫作简单工厂模式的第二种实现方法。</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">RuleConfigParserFactory</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Map&lt;String, RuleConfigParser&gt; cachedParsers = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">    cachedParsers.put(<span class=\"string\">&quot;json&quot;</span>, <span class=\"keyword\">new</span> <span class=\"title class_\">JsonRuleConfigParser</span>());</span><br><span class=\"line\">    cachedParsers.put(<span class=\"string\">&quot;xml&quot;</span>, <span class=\"keyword\">new</span> <span class=\"title class_\">XmlRuleConfigParser</span>());</span><br><span class=\"line\">    cachedParsers.put(<span class=\"string\">&quot;yaml&quot;</span>, <span class=\"keyword\">new</span> <span class=\"title class_\">YamlRuleConfigParser</span>());</span><br><span class=\"line\">    cachedParsers.put(<span class=\"string\">&quot;properties&quot;</span>, <span class=\"keyword\">new</span> <span class=\"title class_\">PropertiesRuleConfigParser</span>());</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> IRuleConfigParser <span class=\"title function_\">createParser</span><span class=\"params\">(String configFormat)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (configFormat == <span class=\"literal\">null</span> || configFormat.isEmpty()) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;<span class=\"comment\">//返回null还是IllegalArgumentException全凭你自己说了算</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">IRuleConfigParser</span> <span class=\"variable\">parser</span> <span class=\"operator\">=</span> cachedParsers.get(configFormat.toLowerCase());</span><br><span class=\"line\">    <span class=\"keyword\">return</span> parser;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<ol>\n<li>对于上面两种简单工厂模式的实现方法，如果我们要添加新的 parser，那势必要改动到 RuleConfigParserFactory 的代码，那这是不是违反开闭原则呢？实际上，如果不是需要频繁地添加新的 parser，只是偶尔修改一下 RuleConfigParserFactory 代码，稍微不符合开闭原则，也是完全可以接受的。</li>\n<li>除此之外，在 RuleConfigParserFactory 的第一种代码实现中，有一组 if 分支判断逻辑，是不是应该用多态或其他设计模式来替代呢？实际上，如果 if 分支并不是很多，代码中有 if 分支也是完全可以接受的。应用多态或设计模式来替代 if 分支判断逻辑，也并不是没有任何缺点的，它虽然提高了代码的扩展性，更加符合<strong>开闭原则</strong>，但也增加了类的个数，牺牲了代码的可读性。关于这一点，我们在后面章节中会详细讲到。</li>\n<li>总结一下，尽管简单工厂模式的代码实现中，有多处 if 分支判断逻辑，违背开闭原则，但权衡扩展性和可读性，这样的代码实现在大多数情况下（比如，不需要频繁地添加 parser，也没有太多的 parser）是没有问题的。</li>\n</ol>\n<h2 id=\"工厂方法（Factory-Method）\"><a href=\"#工厂方法（Factory-Method）\" class=\"headerlink\" title=\"工厂方法（Factory Method）\"></a>工厂方法（Factory Method）</h2><p>如果我们非得要将 if 分支逻辑去掉，那该怎么办呢？比较经典处理方法就是利用多态。按照多态的实现思路，对上面的代码进行重构。重构之后的代码如下所示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">IRuleConfigParserFactory</span> &#123;</span><br><span class=\"line\">  IRuleConfigParser <span class=\"title function_\">createParser</span><span class=\"params\">()</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">JsonRuleConfigParserFactory</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">IRuleConfigParserFactory</span> &#123;</span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> IRuleConfigParser <span class=\"title function_\">createParser</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">JsonRuleConfigParser</span>();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">XmlRuleConfigParserFactory</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">IRuleConfigParserFactory</span> &#123;</span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> IRuleConfigParser <span class=\"title function_\">createParser</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">XmlRuleConfigParser</span>();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">YamlRuleConfigParserFactory</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">IRuleConfigParserFactory</span> &#123;</span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> IRuleConfigParser <span class=\"title function_\">createParser</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">YamlRuleConfigParser</span>();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">PropertiesRuleConfigParserFactory</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">IRuleConfigParserFactory</span> &#123;</span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> IRuleConfigParser <span class=\"title function_\">createParser</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">PropertiesRuleConfigParser</span>();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>实际上，这就是工厂方法模式的典型代码实现。这样当我们新增一种 parser 的时候，只需要新增一个实现了 IRuleConfigParserFactory 接口的 Factory 类即可。所以，工厂方法模式比起简单工厂模式更加符合开闭原则。</p>\n<p>从上面的工厂方法的实现来看，一切都很完美，但是实际上存在挺大的问题。问题存在于这些工厂类的使用上。接下来，我们看一下，如何用这些工厂类来实现 RuleConfigSource 的 load() 函数。具体的代码如下所示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">RuleConfigSource</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> RuleConfig <span class=\"title function_\">load</span><span class=\"params\">(String ruleConfigFilePath)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">ruleConfigFileExtension</span> <span class=\"operator\">=</span> getFileExtension(ruleConfigFilePath);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">IRuleConfigParserFactory</span> <span class=\"variable\">parserFactory</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"string\">&quot;json&quot;</span>.equalsIgnoreCase(ruleConfigFileExtension)) &#123;</span><br><span class=\"line\">      parserFactory = <span class=\"keyword\">new</span> <span class=\"title class_\">JsonRuleConfigParserFactory</span>();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"string\">&quot;xml&quot;</span>.equalsIgnoreCase(ruleConfigFileExtension)) &#123;</span><br><span class=\"line\">      parserFactory = <span class=\"keyword\">new</span> <span class=\"title class_\">XmlRuleConfigParserFactory</span>();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"string\">&quot;yaml&quot;</span>.equalsIgnoreCase(ruleConfigFileExtension)) &#123;</span><br><span class=\"line\">      parserFactory = <span class=\"keyword\">new</span> <span class=\"title class_\">YamlRuleConfigParserFactory</span>();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"string\">&quot;properties&quot;</span>.equalsIgnoreCase(ruleConfigFileExtension)) &#123;</span><br><span class=\"line\">      parserFactory = <span class=\"keyword\">new</span> <span class=\"title class_\">PropertiesRuleConfigParserFactory</span>();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">InvalidRuleConfigException</span>(<span class=\"string\">&quot;Rule config file format is not supported: &quot;</span> + ruleConfigFilePath);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">IRuleConfigParser</span> <span class=\"variable\">parser</span> <span class=\"operator\">=</span> parserFactory.createParser();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">configText</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">    <span class=\"comment\">//从ruleConfigFilePath文件中读取配置文本到configText中</span></span><br><span class=\"line\">    <span class=\"type\">RuleConfig</span> <span class=\"variable\">ruleConfig</span> <span class=\"operator\">=</span> parser.parse(configText);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ruleConfig;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> String <span class=\"title function_\">getFileExtension</span><span class=\"params\">(String filePath)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//...解析文件名获取扩展名，比如rule.json，返回json</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;json&quot;</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<ol>\n<li>从上面的代码实现来看，工厂类对象的创建逻辑又耦合进了 load() 函数中，跟我们最初的代码版本非常相似，引入工厂方法非但没有解决问题，反倒让设计变得更加复杂了。那怎么来解决这个问题呢？</li>\n<li>我们可以为工厂类再创建一个简单工厂，也就是工厂的工厂，用来创建工厂类对象。这段话听起来有点绕，我把代码实现出来了，你一看就能明白了。其中，RuleConfigParserFactoryMap 类是创建工厂对象的工厂类，getParserFactory() 返回的是缓存好的单例工厂对象。</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">RuleConfigSource</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> RuleConfig <span class=\"title function_\">load</span><span class=\"params\">(String ruleConfigFilePath)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">ruleConfigFileExtension</span> <span class=\"operator\">=</span> getFileExtension(ruleConfigFilePath);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">IRuleConfigParserFactory</span> <span class=\"variable\">parserFactory</span> <span class=\"operator\">=</span> RuleConfigParserFactoryMap.getParserFactory(ruleConfigFileExtension);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (parserFactory == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">InvalidRuleConfigException</span>(<span class=\"string\">&quot;Rule config file format is not supported: &quot;</span> + ruleConfigFilePath);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">IRuleConfigParser</span> <span class=\"variable\">parser</span> <span class=\"operator\">=</span> parserFactory.createParser();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">configText</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">    <span class=\"comment\">//从ruleConfigFilePath文件中读取配置文本到configText中</span></span><br><span class=\"line\">    <span class=\"type\">RuleConfig</span> <span class=\"variable\">ruleConfig</span> <span class=\"operator\">=</span> parser.parse(configText);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ruleConfig;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> String <span class=\"title function_\">getFileExtension</span><span class=\"params\">(String filePath)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//...解析文件名获取扩展名，比如rule.json，返回json</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;json&quot;</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//因为工厂类只包含方法，不包含成员变量，完全可以复用，</span></span><br><span class=\"line\"><span class=\"comment\">//不需要每次都创建新的工厂类对象，所以，简单工厂模式的第二种实现思路更加合适。</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">RuleConfigParserFactoryMap</span> &#123; <span class=\"comment\">//工厂的工厂</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Map&lt;String, IRuleConfigParserFactory&gt; cachedFactories = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">    cachedFactories.put(<span class=\"string\">&quot;json&quot;</span>, <span class=\"keyword\">new</span> <span class=\"title class_\">JsonRuleConfigParserFactory</span>());</span><br><span class=\"line\">    cachedFactories.put(<span class=\"string\">&quot;xml&quot;</span>, <span class=\"keyword\">new</span> <span class=\"title class_\">XmlRuleConfigParserFactory</span>());</span><br><span class=\"line\">    cachedFactories.put(<span class=\"string\">&quot;yaml&quot;</span>, <span class=\"keyword\">new</span> <span class=\"title class_\">YamlRuleConfigParserFactory</span>());</span><br><span class=\"line\">    cachedFactories.put(<span class=\"string\">&quot;properties&quot;</span>, <span class=\"keyword\">new</span> <span class=\"title class_\">PropertiesRuleConfigParserFactory</span>());</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> IRuleConfigParserFactory <span class=\"title function_\">getParserFactory</span><span class=\"params\">(String type)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (type == <span class=\"literal\">null</span> || type.isEmpty()) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">IRuleConfigParserFactory</span> <span class=\"variable\">parserFactory</span> <span class=\"operator\">=</span> cachedFactories.get(type.toLowerCase());</span><br><span class=\"line\">    <span class=\"keyword\">return</span> parserFactory;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<ol>\n<li>当我们需要添加新的规则配置解析器的时候，我们只需要创建新的 parser 类和 parser factory 类，并且在 RuleConfigParserFactoryMap 类中，将新的 parser factory 对象添加到 cachedFactories 中即可。代码的改动非常少，基本上符合开闭原则。</li>\n<li>实际上，对于规则配置文件解析这个应用场景来说，工厂模式需要额外创建诸多 Factory 类，也会增加代码的复杂性，而且，每个 Factory 类只是做简单的 new 操作，功能非常单薄（只有一行代码），也没必要设计成独立的类，所以，在这个应用场景下，简单工厂模式简单好用，比工厂方法模式更加合适。</li>\n</ol>\n<h3 id=\"那什么时候该用工厂方法模式，而非简单工厂模式呢？\"><a href=\"#那什么时候该用工厂方法模式，而非简单工厂模式呢？\" class=\"headerlink\" title=\"那什么时候该用工厂方法模式，而非简单工厂模式呢？\"></a>那什么时候该用工厂方法模式，而非简单工厂模式呢？</h3><ol>\n<li>我们前面提到，之所以将某个代码块剥离出来，独立为函数或者类，原因是这个代码块的逻辑过于复杂，剥离之后能让代码更加清晰，更加可读、可维护。但是，如果代码块本身并不复杂，就几行代码而已，我们完全没必要将它拆分成单独的函数或者类。</li>\n<li>基于这个设计思想，当对象的创建逻辑比较复杂，不只是简单的 new 一下就可以，而是要组合其他类对象，做各种初始化操作的时候，我们推荐使用工厂方法模式，将复杂的创建逻辑拆分到多个工厂类中，让每个工厂类都不至于过于复杂。而使用简单工厂模式，将所有的创建逻辑都放到一个工厂类中，会导致这个工厂类变得很复杂。</li>\n<li>除此之外，在某些场景下，如果对象不可复用，那工厂类每次都要返回不同的对象。如果我们使用简单工厂模式来实现，就只能选择第一种包含 if 分支逻辑的实现方式。如果我们还想避免烦人的 if-else 分支逻辑，这个时候，我们就推荐使用工厂方法模式。</li>\n</ol>\n<h2 id=\"抽象工厂（Abstract-Factory）\"><a href=\"#抽象工厂（Abstract-Factory）\" class=\"headerlink\" title=\"抽象工厂（Abstract Factory）\"></a>抽象工厂（Abstract Factory）</h2><ol>\n<li>讲完了简单工厂、工厂方法，我们再来看抽象工厂模式。抽象工厂模式的应用场景比较特殊，没有前两种常用，所以不是我们学习的重点，你简单了解一下就可以了。</li>\n<li>在简单工厂和工厂方法中，类只有一种分类方式。比如，在规则配置解析那个例子中，解析器类只会根据配置文件格式（Json、Xml、Yaml……）来分类。但是，如果类有两种分类方式，比如，我们既可以按照配置文件格式来分类，也可以按照解析的对象（Rule 规则配置还是 System 系统配置）来分类，那就会对应下面这 8 个 parser 类。</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">针对规则配置的解析器：基于接口IRuleConfigParser</span><br><span class=\"line\">JsonRuleConfigParser</span><br><span class=\"line\">XmlRuleConfigParser</span><br><span class=\"line\">YamlRuleConfigParser</span><br><span class=\"line\">PropertiesRuleConfigParser</span><br><span class=\"line\"></span><br><span class=\"line\">针对系统配置的解析器：基于接口ISystemConfigParser</span><br><span class=\"line\">JsonSystemConfigParser</span><br><span class=\"line\">XmlSystemConfigParser</span><br><span class=\"line\">YamlSystemConfigParser</span><br><span class=\"line\">PropertiesSystemConfigParser</span><br></pre></td></tr></table></figure>\n\n\n\n<ol>\n<li>针对这种特殊的场景，如果还是继续用工厂方法来实现的话，我们要针对每个 parser 都编写一个工厂类，也就是要编写 8 个工厂类。如果我们未来还需要增加针对业务配置的解析器（比如 IBizConfigParser），那就要再对应地增加 4 个工厂类。而我们知道，过多的类也会让系统难维护。这个问题该怎么解决呢？</li>\n<li>抽象工厂就是针对这种非常特殊的场景而诞生的。我们可以让一个工厂负责创建多个不同类型的对象（IRuleConfigParser、ISystemConfigParser 等），而不是只创建一种 parser 对象。这样就可以有效地减少工厂类的个数。具体的代码实现如下所示：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">IConfigParserFactory</span> &#123;</span><br><span class=\"line\">  IRuleConfigParser <span class=\"title function_\">createRuleParser</span><span class=\"params\">()</span>;</span><br><span class=\"line\">  ISystemConfigParser <span class=\"title function_\">createSystemParser</span><span class=\"params\">()</span>;</span><br><span class=\"line\">  <span class=\"comment\">//此处可以扩展新的parser类型，比如IBizConfigParser</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">JsonConfigParserFactory</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">IConfigParserFactory</span> &#123;</span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> IRuleConfigParser <span class=\"title function_\">createRuleParser</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">JsonRuleConfigParser</span>();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> ISystemConfigParser <span class=\"title function_\">createSystemParser</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">JsonSystemConfigParser</span>();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">XmlConfigParserFactory</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">IConfigParserFactory</span> &#123;</span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> IRuleConfigParser <span class=\"title function_\">createRuleParser</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">XmlRuleConfigParser</span>();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> ISystemConfigParser <span class=\"title function_\">createSystemParser</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">XmlSystemConfigParser</span>();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 省略YamlConfigParserFactory和PropertiesConfigParserFactory代码</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"如何设计实现一个Dependency-Injection框架？\"><a href=\"#如何设计实现一个Dependency-Injection框架？\" class=\"headerlink\" title=\"如何设计实现一个Dependency Injection框架？\"></a>如何设计实现一个Dependency Injection框架？</h2><p>当创建对象是一个“大工程”的时候，我们一般会选择使用工厂模式，来封装对象复杂的创建过程，将对象的创建和使用分离，让代码更加清晰。那何为“大工程”呢？上面我们讲了两种情况，一种是创建过程涉及复杂的 if-else 分支判断，另一种是对象创建需要组装多个其他类对象或者需要复杂的初始化过程。</p>\n<p>今天，我们再来讲一个创建对象的“大工程”，依赖注入框架，或者叫依赖注入容器（Dependency Injection Container），简称 DI 容器。在今天的讲解中，我会带你一块搞清楚这样几个问题：DI 容器跟我们讲的工厂模式又有何区别和联系？DI 容器的核心功能有哪些，以及如何实现一个简单的 DI 容器？</p>\n<h3 id=\"工厂模式和-DI-容器有何区别？\"><a href=\"#工厂模式和-DI-容器有何区别？\" class=\"headerlink\" title=\"工厂模式和 DI 容器有何区别？\"></a>工厂模式和 DI 容器有何区别？</h3><ol>\n<li>实际上，DI 容器底层最基本的设计思路就是基于工厂模式的。DI 容器相当于一个大的工厂类，负责在程序启动的时候，根据配置（要创建哪些类对象，每个类对象的创建需要依赖哪些其他类对象）事先创建好对象。当应用程序需要使用某个类对象的时候，直接从容器中获取即可。正是因为它持有一堆对象，所以这个框架才被称为“容器”。</li>\n<li>DI 容器相对于我们上面讲的工厂模式的例子来说，它处理的是更大的对象创建工程。上面讲的工厂模式中，一个工厂类只负责某个类对象或者某一组相关类对象（继承自同一抽象类或者接口的子类）的创建，而 DI 容器负责的是整个应用中所有类对象的创建。</li>\n<li>除此之外，DI 容器负责的事情要比单纯的工厂模式要多。比如，它还包括配置的解析、对象生命周期的管理。接下来，我们就详细讲讲，一个简单的 DI 容器应该包含哪些核心功能。</li>\n</ol>\n<h3 id=\"DI-容器的核心功能有哪些？\"><a href=\"#DI-容器的核心功能有哪些？\" class=\"headerlink\" title=\"DI 容器的核心功能有哪些？\"></a>DI 容器的核心功能有哪些？</h3><p>总结一下，一个简单的 DI 容器的核心功能一般有三个：配置解析、对象创建和对象生命周期管理。</p>\n<blockquote>\n<p>首先，我们来看配置解析。</p>\n</blockquote>\n<ol>\n<li>在上面讲的工厂模式中，工厂类要创建哪个类对象是事先确定好的，并且是写死在工厂类代码中的。作为一个通用的框架来说，框架代码跟应用代码应该是高度解耦的，DI 容器事先并不知道应用会创建哪些对象，不可能把某个应用要创建的对象写死在框架代码中。所以，我们需要通过一种形式，让应用告知 DI 容器要创建哪些对象。这种形式就是我们要讲的配置。</li>\n<li>我们将需要由 DI 容器来创建的类对象和创建类对象的必要信息（使用哪个构造函数以及对应的构造函数参数都是什么等等），放到配置文件中。容器读取配置文件，根据配置文件提供的信息来创建对象。</li>\n<li>下面是一个典型的 Spring 容器的配置文件。Spring 容器读取这个配置文件，解析出要创建的两个对象：rateLimiter 和 redisCounter，并且得到两者的依赖关系：rateLimiter 依赖 redisCounter。</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">RateLimiter</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> RedisCounter redisCounter;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"title function_\">RateLimiter</span><span class=\"params\">(RedisCounter redisCounter)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.redisCounter = redisCounter;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;Hello World!&quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">RedisCounter</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> String ipAddress;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"type\">int</span> port;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"title function_\">RedisCounter</span><span class=\"params\">(String ipAddress, <span class=\"type\">int</span> port)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.ipAddress = ipAddress;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.port = port;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">配置文件beans.xml：</span><br><span class=\"line\">&lt;beans&gt;</span><br><span class=\"line\">   &lt;bean id=<span class=\"string\">&quot;rateLimiter&quot;</span> class=<span class=\"string\">&quot;com.xzg.RateLimiter&quot;</span>&gt;</span><br><span class=\"line\">      &lt;constructor-arg ref=<span class=\"string\">&quot;redisCounter&quot;</span>/&gt;</span><br><span class=\"line\">   &lt;/bean&gt;</span><br><span class=\"line\"> </span><br><span class=\"line\">   &lt;bean id=<span class=\"string\">&quot;redisCounter&quot;</span> class=<span class=\"string\">&quot;com.xzg.redisCounter&quot;</span>&gt;</span><br><span class=\"line\">     &lt;constructor-arg type=<span class=\"string\">&quot;String&quot;</span> value=<span class=\"string\">&quot;127.0.0.1&quot;</span>&gt;</span><br><span class=\"line\">     &lt;constructor-arg type=<span class=\"string\">&quot;int&quot;</span> value=<span class=\"number\">1234</span>&gt;</span><br><span class=\"line\">   &lt;/bean&gt;</span><br><span class=\"line\">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>\n\n\n\n<blockquote>\n<p>其次，我们再来看对象创建。</p>\n</blockquote>\n<ol>\n<li>在 DI 容器中，如果我们给每个类都对应创建一个工厂类，那项目中类的个数会成倍增加，这会增加代码的维护成本。要解决这个问题并不难。我们只需要将所有类对象的创建都放到一个工厂类中完成就可以了，比如 BeansFactory。</li>\n<li>你可能会说，如果要创建的类对象非常多，BeansFactory 中的代码会不会线性膨胀（代码量跟创建对象的个数成正比）呢？实际上并不会。待会讲到 DI 容器的具体实现的时候，我们会讲“反射”这种机制，它能在程序运行的过程中，动态地加载类、创建对象，不需要事先在代码中写死要创建哪些对象。所以，不管是创建一个对象还是十个对象，BeansFactory 工厂类代码都是一样的。</li>\n</ol>\n<blockquote>\n<p>最后，我们来看对象的生命周期管理。</p>\n</blockquote>\n<ol>\n<li>上面我们讲到，简单工厂模式有两种实现方式，一种是每次都返回新创建的对象，另一种是每次都返回同一个事先创建好的对象，也就是所谓的单例对象。在 Spring 框架中，我们可以通过配置 scope 属性，来区分这两种不同类型的对象。scope&#x3D;prototype 表示返回新创建的对象，scope&#x3D;singleton 表示返回单例对象。</li>\n<li>除此之外，我们还可以配置对象是否支持懒加载。如果 lazy-init&#x3D;true，对象在真正被使用到的时候（比如：BeansFactory.getBean(“userService”)）才被被创建；如果 lazy-init&#x3D;false，对象在应用启动的时候就事先创建好。</li>\n<li>不仅如此，我们还可以配置对象的 init-method 和 destroy-method 方法，比如 init-method&#x3D;loadProperties()，destroy-method&#x3D;updateConfigFile()。DI 容器在创建好对象之后，会主动调用 init-method 属性指定的方法来初始化对象。在对象被最终销毁之前，DI 容器会主动调用 destroy-method 属性指定的方法来做一些清理工作，比如释放数据库连接池、关闭文件。</li>\n</ol>\n<h2 id=\"如何实现一个简单的-DI-容器？\"><a href=\"#如何实现一个简单的-DI-容器？\" class=\"headerlink\" title=\"如何实现一个简单的 DI 容器？\"></a>如何实现一个简单的 DI 容器？</h2><p>用 Java 语言来实现一个简单的 DI 容器，核心逻辑只需要包括这样两个部分：配置文件解析、根据配置文件通过“反射”语法来创建对象。</p>\n<h3 id=\"最小原型设计\"><a href=\"#最小原型设计\" class=\"headerlink\" title=\"最小原型设计\"></a>最小原型设计</h3><p>因为我们主要是讲解设计模式，所以，在今天的讲解中，我们只实现一个 DI 容器的最小原型。像 Spring 框架这样的 DI 容器，它支持的配置格式非常灵活和复杂。为了简化代码实现，重点讲解原理，在最小原型中，我们只支持下面配置文件中涉及的配置语法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">配置文件beans.xml</span><br><span class=\"line\">&lt;beans&gt;</span><br><span class=\"line\">   &lt;bean id=<span class=\"string\">&quot;rateLimiter&quot;</span> class=<span class=\"string\">&quot;com.xzg.RateLimiter&quot;</span>&gt;</span><br><span class=\"line\">      &lt;constructor-arg ref=<span class=\"string\">&quot;redisCounter&quot;</span>/&gt;</span><br><span class=\"line\">   &lt;/bean&gt;</span><br><span class=\"line\"> </span><br><span class=\"line\">   &lt;bean id=<span class=\"string\">&quot;redisCounter&quot;</span> class=<span class=\"string\">&quot;com.xzg.redisCounter&quot;</span> scope=<span class=\"string\">&quot;singleton&quot;</span> lazy-init=<span class=\"string\">&quot;true&quot;</span>&gt;</span><br><span class=\"line\">     &lt;constructor-arg type=<span class=\"string\">&quot;String&quot;</span> value=<span class=\"string\">&quot;127.0.0.1&quot;</span>&gt;</span><br><span class=\"line\">     &lt;constructor-arg type=<span class=\"string\">&quot;int&quot;</span> value=<span class=\"number\">1234</span>&gt;</span><br><span class=\"line\">   &lt;/bean&gt;</span><br><span class=\"line\">&lt;/bean</span><br></pre></td></tr></table></figure>\n\n\n\n<p>最小原型的使用方式跟 Spring 框架非常类似，示例代码如下所示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Demo</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">ApplicationContext</span> <span class=\"variable\">applicationContext</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ClassPathXmlApplicationContext</span>(</span><br><span class=\"line\">            <span class=\"string\">&quot;beans.xml&quot;</span>);</span><br><span class=\"line\">    <span class=\"type\">RateLimiter</span> <span class=\"variable\">rateLimiter</span> <span class=\"operator\">=</span> (RateLimiter) applicationContext.getBean(<span class=\"string\">&quot;rateLimiter&quot;</span>);</span><br><span class=\"line\">    rateLimiter.test();</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"提供执行入口\"><a href=\"#提供执行入口\" class=\"headerlink\" title=\"提供执行入口\"></a>提供执行入口</h3><p>面向对象设计的最后一步是：组装类并提供执行入口。在这里，执行入口就是一组暴露给外部使用的接口和类。通过刚刚的最小原型使用示例代码，我们可以看出，执行入口主要包含两部分：ApplicationContext 和 ClassPathXmlApplicationContext。其中，ApplicationContext 是接口，ClassPathXmlApplicationContext 是接口的实现类。两个类具体实现如下所示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">ApplicationContext</span> &#123;</span><br><span class=\"line\">  Object <span class=\"title function_\">getBean</span><span class=\"params\">(String beanId)</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ClassPathXmlApplicationContext</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">ApplicationContext</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> BeansFactory beansFactory;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> BeanConfigParser beanConfigParser;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"title function_\">ClassPathXmlApplicationContext</span><span class=\"params\">(String configLocation)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.beansFactory = <span class=\"keyword\">new</span> <span class=\"title class_\">BeansFactory</span>();</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.beanConfigParser = <span class=\"keyword\">new</span> <span class=\"title class_\">XmlBeanConfigParser</span>();</span><br><span class=\"line\">    loadBeanDefinitions(configLocation);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">loadBeanDefinitions</span><span class=\"params\">(String configLocation)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">InputStream</span> <span class=\"variable\">in</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      in = <span class=\"built_in\">this</span>.getClass().getResourceAsStream(<span class=\"string\">&quot;/&quot;</span> + configLocation);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (in == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RuntimeException</span>(<span class=\"string\">&quot;Can not find config file: &quot;</span> + configLocation);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      List&lt;BeanDefinition&gt; beanDefinitions = beanConfigParser.parse(in);</span><br><span class=\"line\">      beansFactory.addBeanDefinitions(beanDefinitions);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (in != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">          in.close();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">          <span class=\"comment\">// <span class=\"doctag\">TODO:</span> log error</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> Object <span class=\"title function_\">getBean</span><span class=\"params\">(String beanId)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> beansFactory.getBean(beanId);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>从上面的代码中，我们可以看出，ClassPathXmlApplicationContext 负责组装 BeansFactory 和 BeanConfigParser 两个类，串联执行流程：从 classpath 中加载 XML 格式的配置文件，通过 BeanConfigParser 解析为统一的 BeanDefinition 格式，然后，BeansFactory 根据 BeanDefinition 来创建对象。</p>\n<h3 id=\"配置文件解析\"><a href=\"#配置文件解析\" class=\"headerlink\" title=\"配置文件解析\"></a>配置文件解析</h3><p>配置文件解析主要包含 BeanConfigParser 接口和 XmlBeanConfigParser 实现类，负责将配置文件解析为 BeanDefinition 结构，以便 BeansFactory 根据这个结构来创建对象。配置文件的解析比较繁琐，不涉及我们要讲的理论知识，不是我们讲解的重点，所以这里我只给出两个类的大致设计思路，并未给出具体的实现代码。如果感兴趣的话，你可以自行补充完整。具体的代码框架如下所示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">BeanConfigParser</span> &#123;</span><br><span class=\"line\">  List&lt;BeanDefinition&gt; <span class=\"title function_\">parse</span><span class=\"params\">(InputStream inputStream)</span>;</span><br><span class=\"line\">  List&lt;BeanDefinition&gt; <span class=\"title function_\">parse</span><span class=\"params\">(String configContent)</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">XmlBeanConfigParser</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">BeanConfigParser</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> List&lt;BeanDefinition&gt; <span class=\"title function_\">parse</span><span class=\"params\">(InputStream inputStream)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">content</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"comment\">// <span class=\"doctag\">TODO:</span>...</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> parse(content);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> List&lt;BeanDefinition&gt; <span class=\"title function_\">parse</span><span class=\"params\">(String configContent)</span> &#123;</span><br><span class=\"line\">    List&lt;BeanDefinition&gt; beanDefinitions = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">    <span class=\"comment\">// <span class=\"doctag\">TODO:</span>...</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> beanDefinitions;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">BeanDefinition</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> String id;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> String className;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> List&lt;ConstructorArg&gt; constructorArgs = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"type\">Scope</span> <span class=\"variable\">scope</span> <span class=\"operator\">=</span> Scope.SINGLETON;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"type\">boolean</span> <span class=\"variable\">lazyInit</span> <span class=\"operator\">=</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 省略必要的getter/setter/constructors</span></span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">isSingleton</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> scope.equals(Scope.SINGLETON);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">enum</span> <span class=\"title class_\">Scope</span> &#123;</span><br><span class=\"line\">    SINGLETON,</span><br><span class=\"line\">    PROTOTYPE</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ConstructorArg</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">boolean</span> isRef;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Class type;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Object arg;</span><br><span class=\"line\">    <span class=\"comment\">// 省略必要的getter/setter/constructors</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"核心工厂类设计\"><a href=\"#核心工厂类设计\" class=\"headerlink\" title=\"核心工厂类设计\"></a>核心工厂类设计</h3><ol>\n<li>最后，我们来看，BeansFactory 是如何设计和实现的。这也是我们这个 DI 容器最核心的一个类了。它负责根据从配置文件解析得到的 BeanDefinition 来创建对象。</li>\n<li>如果对象的 scope 属性是 singleton，那对象创建之后会缓存在 singletonObjects 这样一个 map 中，下次再请求此对象的时候，直接从 map 中取出返回，不需要重新创建。如果对象的 scope 属性是 prototype，那每次请求对象，BeansFactory 都会创建一个新的对象返回。</li>\n<li>实际上，BeansFactory 创建对象用到的主要技术点就是 Java 中的反射语法：一种动态加载类和创建对象的机制。我们知道，JVM 在启动的时候会根据代码自动地加载类、创建对象。至于都要加载哪些类、创建哪些对象，这些都是在代码中写死的，或者说提前写好的。但是，如果某个对象的创建并不是写死在代码中，而是放到配置文件中，我们需要在程序运行期间，动态地根据配置文件来加载类、创建对象，那这部分工作就没法让 JVM 帮我们自动完成了，我们需要利用 Java 提供的反射语法自己去编写代码。</li>\n<li>搞清楚了反射的原理，BeansFactory 的代码就不难看懂了。具体代码实现如下所示：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">BeansFactory</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> ConcurrentHashMap&lt;String, Object&gt; singletonObjects = <span class=\"keyword\">new</span> <span class=\"title class_\">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class=\"line\">  <span class=\"keyword\">private</span> ConcurrentHashMap&lt;String, BeanDefinition&gt; beanDefinitions = <span class=\"keyword\">new</span> <span class=\"title class_\">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">addBeanDefinitions</span><span class=\"params\">(List&lt;BeanDefinition&gt; beanDefinitionList)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (BeanDefinition beanDefinition : beanDefinitionList) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.beanDefinitions.putIfAbsent(beanDefinition.getId(), beanDefinition);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (BeanDefinition beanDefinition : beanDefinitionList) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (beanDefinition.isLazyInit() == <span class=\"literal\">false</span> &amp;&amp; beanDefinition.isSingleton()) &#123;</span><br><span class=\"line\">        createBean(beanDefinition);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> Object <span class=\"title function_\">getBean</span><span class=\"params\">(String beanId)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">BeanDefinition</span> <span class=\"variable\">beanDefinition</span> <span class=\"operator\">=</span> beanDefinitions.get(beanId);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (beanDefinition == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">NoSuchBeanDefinitionException</span>(<span class=\"string\">&quot;Bean is not defined: &quot;</span> + beanId);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> createBean(beanDefinition);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@VisibleForTesting</span></span><br><span class=\"line\">  <span class=\"keyword\">protected</span> Object <span class=\"title function_\">createBean</span><span class=\"params\">(BeanDefinition beanDefinition)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (beanDefinition.isSingleton() &amp;&amp; singletonObjects.contains(beanDefinition.getId())) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> singletonObjects.get(beanDefinition.getId());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">Object</span> <span class=\"variable\">bean</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      <span class=\"type\">Class</span> <span class=\"variable\">beanClass</span> <span class=\"operator\">=</span> Class.forName(beanDefinition.getClassName());</span><br><span class=\"line\">      List&lt;BeanDefinition.ConstructorArg&gt; args = beanDefinition.getConstructorArgs();</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (args.isEmpty()) &#123;</span><br><span class=\"line\">        bean = beanClass.newInstance();</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        Class[] argClasses = <span class=\"keyword\">new</span> <span class=\"title class_\">Class</span>[args.size()];</span><br><span class=\"line\">        Object[] argObjects = <span class=\"keyword\">new</span> <span class=\"title class_\">Object</span>[args.size()];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; args.size(); ++i) &#123;</span><br><span class=\"line\">          BeanDefinition.<span class=\"type\">ConstructorArg</span> <span class=\"variable\">arg</span> <span class=\"operator\">=</span> args.get(i);</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (!arg.getIsRef()) &#123;</span><br><span class=\"line\">            argClasses[i] = arg.getType();</span><br><span class=\"line\">            argObjects[i] = arg.getArg();</span><br><span class=\"line\">          &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"type\">BeanDefinition</span> <span class=\"variable\">refBeanDefinition</span> <span class=\"operator\">=</span> beanDefinitions.get(arg.getArg());</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (refBeanDefinition == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">              <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">NoSuchBeanDefinitionException</span>(<span class=\"string\">&quot;Bean is not defined: &quot;</span> + arg.getArg());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            argClasses[i] = Class.forName(refBeanDefinition.getClassName());</span><br><span class=\"line\">            argObjects[i] = createBean(refBeanDefinition);</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        bean = beanClass.getConstructor(argClasses).newInstance(argObjects);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (ClassNotFoundException | IllegalAccessException</span><br><span class=\"line\">            | InstantiationException | NoSuchMethodException | InvocationTargetException e) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">BeanCreationFailureException</span>(<span class=\"string\">&quot;&quot;</span>, e);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (bean != <span class=\"literal\">null</span> &amp;&amp; beanDefinition.isSingleton()) &#123;</span><br><span class=\"line\">      singletonObjects.putIfAbsent(beanDefinition.getId(), bean);</span><br><span class=\"line\">      <span class=\"keyword\">return</span> singletonObjects.get(beanDefinition.getId());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> bean;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>执行入口那里调用<code>addBeanDefinitions</code></li>\n<li>然后<code>addBeanDefinitions</code>再调用createBean利用反射创建对象，如果对象的 scope 属性是 singleton，那对象创建之后会缓存在 singletonObjects 这样一个 map 中</li>\n<li>最后最小原型设计那里再调用getBean从singletonObjects 获取对象。</li>\n</ol>\n<h1 id=\"建造者模式【常用】\"><a href=\"#建造者模式【常用】\" class=\"headerlink\" title=\"建造者模式【常用】\"></a>建造者模式【常用】</h1><blockquote>\n<p>只要是标注常用的，基本上用的都比较多，无论篇幅长短，都不要忽视。</p>\n</blockquote>\n<p>建造者模式的原理和代码实现非常简单，掌握起来并不难，难点在于应用场景。比如，你有没有考虑过这样几个问题：直接使用构造函数或者配合 set 方法就能创建对象，为什么还需要建造者模式来创建呢？建造者模式和工厂模式都可以创建对象，那它们两个的区别在哪里呢？</p>\n<h2 id=\"为什么需要建造者模式？\"><a href=\"#为什么需要建造者模式？\" class=\"headerlink\" title=\"为什么需要建造者模式？\"></a>为什么需要建造者模式？</h2><ol>\n<li>在平时的开发中，创建一个对象最常用的方式是，使用 new 关键字调用类的构造函数来完成。我的问题是，什么情况下这种方式就不适用了，就需要采用建造者模式来创建对象呢？你可以先思考一下，下面我通过一个例子来带你看一下。</li>\n<li>假设有这样一道设计面试题：我们需要定义一个资源池配置类 ResourcePoolConfig。这里的资源池，你可以简单理解为线程池、连接池、对象池等。在这个资源池配置类中，有以下几个成员变量，也就是可配置项。现在，请你编写代码实现这个 ResourcePoolConfig 类。</li>\n</ol>\n<img src=\"https://npm.elemecdn.com/youthlql@1.0.0/design_patterns/creational/03.02/0001.png\" />\n\n\n\n<p>只要你稍微有点开发经验，那实现这样一个类对你来说并不是件难事。最常见、最容易想到的实现思路如下代码所示。因为 maxTotal、maxIdle、minIdle 不是必填变量，所以在创建 ResourcePoolConfig 对象的时候，我们通过往构造函数中，给这几个参数传递 null 值，来表示使用默认值。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ResourcePoolConfig</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">DEFAULT_MAX_TOTAL</span> <span class=\"operator\">=</span> <span class=\"number\">8</span>;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">DEFAULT_MAX_IDLE</span> <span class=\"operator\">=</span> <span class=\"number\">8</span>;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">DEFAULT_MIN_IDLE</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"type\">int</span> <span class=\"variable\">maxTotal</span> <span class=\"operator\">=</span> DEFAULT_MAX_TOTAL;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"type\">int</span> <span class=\"variable\">maxIdle</span> <span class=\"operator\">=</span> DEFAULT_MAX_IDLE;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"type\">int</span> <span class=\"variable\">minIdle</span> <span class=\"operator\">=</span> DEFAULT_MIN_IDLE;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"title function_\">ResourcePoolConfig</span><span class=\"params\">(String name, Integer maxTotal, Integer maxIdle, Integer minIdle)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (StringUtils.isBlank(name)) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IllegalArgumentException</span>(<span class=\"string\">&quot;name should not be empty.&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.name = name;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (maxTotal != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (maxTotal &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IllegalArgumentException</span>(<span class=\"string\">&quot;maxTotal should be positive.&quot;</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.maxTotal = maxTotal;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (maxIdle != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (maxIdle &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IllegalArgumentException</span>(<span class=\"string\">&quot;maxIdle should not be negative.&quot;</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.maxIdle = maxIdle;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (minIdle != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (minIdle &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IllegalArgumentException</span>(<span class=\"string\">&quot;minIdle should not be negative.&quot;</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.minIdle = minIdle;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//...省略getter方法...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>现在，ResourcePoolConfig 只有 4 个可配置项，对应到构造函数中，也只有 4 个参数，参数的个数不多。但是，如果可配置项逐渐增多，变成了 8 个、10 个，甚至更多，那继续沿用现在的设计思路，构造函数的参数列表会变得很长，代码在可读性和易用性上都会变差。在使用构造函数的时候，我们就容易搞错各参数的顺序，传递进错误的参数值，导致非常隐蔽的 bug。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 参数太多，导致可读性差、参数可能传递错误</span></span><br><span class=\"line\"><span class=\"type\">ResourcePoolConfig</span> <span class=\"variable\">config</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ResourcePoolConfig</span>(<span class=\"string\">&quot;dbconnectionpool&quot;</span>, <span class=\"number\">16</span>, <span class=\"literal\">null</span>, <span class=\"number\">8</span>, <span class=\"literal\">null</span>, <span class=\"literal\">false</span> , <span class=\"literal\">true</span>, <span class=\"number\">10</span>, <span class=\"number\">20</span>，<span class=\"literal\">false</span>， <span class=\"literal\">true</span>);</span><br></pre></td></tr></table></figure>\n\n\n\n<p>解决这个问题的办法你应该也已经想到了，那就是用 set() 函数来给成员变量赋值，以替代冗长的构造函数。我们直接看代码，具体如下所示。其中，配置项 name 是必填的，所以我们把它放到构造函数中设置，强制创建类对象的时候就要填写。其他配置项 maxTotal、maxIdle、minIdle 都不是必填的，所以我们通过 set() 函数来设置，让使用者自主选择填写或者不填写。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ResourcePoolConfig</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">DEFAULT_MAX_TOTAL</span> <span class=\"operator\">=</span> <span class=\"number\">8</span>;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">DEFAULT_MAX_IDLE</span> <span class=\"operator\">=</span> <span class=\"number\">8</span>;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">DEFAULT_MIN_IDLE</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"type\">int</span> <span class=\"variable\">maxTotal</span> <span class=\"operator\">=</span> DEFAULT_MAX_TOTAL;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"type\">int</span> <span class=\"variable\">maxIdle</span> <span class=\"operator\">=</span> DEFAULT_MAX_IDLE;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"type\">int</span> <span class=\"variable\">minIdle</span> <span class=\"operator\">=</span> DEFAULT_MIN_IDLE;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"title function_\">ResourcePoolConfig</span><span class=\"params\">(String name)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (StringUtils.isBlank(name)) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IllegalArgumentException</span>(<span class=\"string\">&quot;name should not be empty.&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.name = name;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setMaxTotal</span><span class=\"params\">(<span class=\"type\">int</span> maxTotal)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (maxTotal &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IllegalArgumentException</span>(<span class=\"string\">&quot;maxTotal should be positive.&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.maxTotal = maxTotal;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setMaxIdle</span><span class=\"params\">(<span class=\"type\">int</span> maxIdle)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (maxIdle &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IllegalArgumentException</span>(<span class=\"string\">&quot;maxIdle should not be negative.&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.maxIdle = maxIdle;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setMinIdle</span><span class=\"params\">(<span class=\"type\">int</span> minIdle)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (minIdle &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IllegalArgumentException</span>(<span class=\"string\">&quot;minIdle should not be negative.&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.minIdle = minIdle;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//...省略getter方法...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>接下来，我们来看新的 ResourcePoolConfig 类该如何使用。我写了一个示例代码，如下所示。没有了冗长的函数调用和参数列表，代码在可读性和易用性上提高了很多。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ResourcePoolConfig使用举例</span></span><br><span class=\"line\"><span class=\"type\">ResourcePoolConfig</span> <span class=\"variable\">config</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ResourcePoolConfig</span>(<span class=\"string\">&quot;dbconnectionpool&quot;</span>);</span><br><span class=\"line\">config.setMaxTotal(<span class=\"number\">16</span>);</span><br><span class=\"line\">config.setMaxIdle(<span class=\"number\">8</span>);</span><br></pre></td></tr></table></figure>\n\n\n\n<p>至此，我们仍然没有用到建造者模式，通过构造函数设置必填项，通过 set() 方法设置可选配置项，就能实现我们的设计需求。如果我们把问题的难度再加大点，比如，还需要解决下面这三个问题，那现在的设计思路就不能满足了。</p>\n<ul>\n<li>我们刚刚讲到，name 是必填的，所以，我们把它放到构造函数中，强制创建对象的时候就设置。如果必填的配置项有很多，把这些必填配置项都放到构造函数中设置，那构造函数就又会出现参数列表很长的问题。如果我们把必填项也通过 set() 方法设置，那校验这些必填项是否已经填写的逻辑就无处安放了。</li>\n<li>除此之外，假设配置项之间有一定的依赖关系，比如，如果用户设置了 maxTotal、maxIdle、minIdle 其中一个，就必须显式地设置另外两个；或者配置项之间有一定的约束条件，比如，maxIdle 和 minIdle 要小于等于 maxTotal。如果我们继续使用现在的设计思路，那这些配置项之间的依赖关系或者约束条件的校验逻辑就无处安放了。</li>\n<li>如果我们希望 ResourcePoolConfig 类对象是不可变对象，也就是说，对象在创建好之后，就不能再修改内部的属性值。要实现这个功能，我们就不能在 ResourcePoolConfig 类中暴露 set() 方法。</li>\n</ul>\n<p>为了解决这些问题，建造者模式就派上用场了。我们可以把校验逻辑放置到 Builder 类中，先创建建造者，并且通过 set() 方法设置建造者的变量值，然后在使用 build() 方法真正创建对象之前，做集中的校验，校验通过之后才会创建对象。除此之外，我们把 ResourcePoolConfig 的构造函数改为 private 私有权限。这样我们就只能通过建造者来创建 ResourcePoolConfig 类对象。并且，ResourcePoolConfig 没有提供任何 set() 方法，这样我们创建出来的对象就是不可变对象了。我们用建造者模式重新实现了上面的需求，具体的代码如下所示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ResourcePoolConfig</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"type\">int</span> maxTotal;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"type\">int</span> maxIdle;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"type\">int</span> minIdle;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"title function_\">ResourcePoolConfig</span><span class=\"params\">(Builder builder)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.name = builder.name;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.maxTotal = builder.maxTotal;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.maxIdle = builder.maxIdle;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.minIdle = builder.minIdle;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//...省略getter方法...</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//我们将Builder类设计成了ResourcePoolConfig的内部类。</span></span><br><span class=\"line\">  <span class=\"comment\">//我们也可以将Builder类设计成独立的非内部类ResourcePoolConfigBuilder。</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Builder</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">DEFAULT_MAX_TOTAL</span> <span class=\"operator\">=</span> <span class=\"number\">8</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">DEFAULT_MAX_IDLE</span> <span class=\"operator\">=</span> <span class=\"number\">8</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">DEFAULT_MIN_IDLE</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">int</span> <span class=\"variable\">maxTotal</span> <span class=\"operator\">=</span> DEFAULT_MAX_TOTAL;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">int</span> <span class=\"variable\">maxIdle</span> <span class=\"operator\">=</span> DEFAULT_MAX_IDLE;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">int</span> <span class=\"variable\">minIdle</span> <span class=\"operator\">=</span> DEFAULT_MIN_IDLE;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> ResourcePoolConfig <span class=\"title function_\">build</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 校验逻辑放到这里来做，包括必填项校验、依赖关系校验、约束条件校验等</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (StringUtils.isBlank(name)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IllegalArgumentException</span>(<span class=\"string\">&quot;...&quot;</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (maxIdle &gt; maxTotal) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IllegalArgumentException</span>(<span class=\"string\">&quot;...&quot;</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (minIdle &gt; maxTotal || minIdle &gt; maxIdle) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IllegalArgumentException</span>(<span class=\"string\">&quot;...&quot;</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ResourcePoolConfig</span>(<span class=\"built_in\">this</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Builder <span class=\"title function_\">setName</span><span class=\"params\">(String name)</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (StringUtils.isBlank(name)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IllegalArgumentException</span>(<span class=\"string\">&quot;...&quot;</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.name = name;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Builder <span class=\"title function_\">setMaxTotal</span><span class=\"params\">(<span class=\"type\">int</span> maxTotal)</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (maxTotal &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IllegalArgumentException</span>(<span class=\"string\">&quot;...&quot;</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.maxTotal = maxTotal;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Builder <span class=\"title function_\">setMaxIdle</span><span class=\"params\">(<span class=\"type\">int</span> maxIdle)</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (maxIdle &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IllegalArgumentException</span>(<span class=\"string\">&quot;...&quot;</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.maxIdle = maxIdle;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Builder <span class=\"title function_\">setMinIdle</span><span class=\"params\">(<span class=\"type\">int</span> minIdle)</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (minIdle &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IllegalArgumentException</span>(<span class=\"string\">&quot;...&quot;</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.minIdle = minIdle;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 这段代码会抛出IllegalArgumentException，因为minIdle&gt;maxIdle</span></span><br><span class=\"line\"><span class=\"type\">ResourcePoolConfig</span> <span class=\"variable\">config</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ResourcePoolConfig</span>.Builder()</span><br><span class=\"line\">        .setName(<span class=\"string\">&quot;dbconnectionpool&quot;</span>)</span><br><span class=\"line\">        .setMaxTotal(<span class=\"number\">16</span>)</span><br><span class=\"line\">        .setMaxIdle(<span class=\"number\">10</span>)</span><br><span class=\"line\">        .setMinIdle(<span class=\"number\">12</span>)</span><br><span class=\"line\">        .build();</span><br></pre></td></tr></table></figure>\n\n\n\n<p>实际上，使用建造者模式创建对象，还能避免对象存在无效状态。我再举个例子解释一下。比如我们定义了一个长方形类，如果不使用建造者模式，采用先创建后 set 的方式，那就会导致在第一个 set 之后，对象处于无效状态。具体代码如下所示</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Rectangle</span> <span class=\"variable\">r</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Rectange</span>(); <span class=\"comment\">// r is invalid</span></span><br><span class=\"line\">r.setWidth(<span class=\"number\">2</span>); <span class=\"comment\">// r is invalid</span></span><br><span class=\"line\">r.setHeight(<span class=\"number\">3</span>); <span class=\"comment\">// r is valid</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>这里是说，长方形必须同时具备宽、高两个属性才是一个有效的长方形。只有其中一个属性，这个长方形对象就没有意义，是无效的。</p>\n</blockquote>\n<ol>\n<li>为了避免这种无效状态的存在，我们就需要使用构造函数一次性初始化好所有的成员变量。如果构造函数参数过多，我们就需要考虑使用建造者模式，先设置建造者的变量，然后再一次性地创建对象，让对象一直处于有效状态。(建造者主要解决参数过多、参数检验、控制对象创建后不可变的问题)</li>\n<li>实际上，如果我们并不是很关心对象是否有短暂的无效状态，也不是太在意对象是否是可变的。比如，对象只是用来映射数据库读出来的数据，那我们直接暴露 set() 方法来设置类的成员变量值是完全没问题的。而且，使用建造者模式来构建对象，代码实际上是有点重复的，ResourcePoolConfig 类中的成员变量，要在 Builder 类中重新再定义一遍。</li>\n</ol>\n<h2 id=\"与工厂模式有何区别？\"><a href=\"#与工厂模式有何区别？\" class=\"headerlink\" title=\"与工厂模式有何区别？\"></a>与工厂模式有何区别？</h2><ol>\n<li>从上面的讲解中，我们可以看出，建造者模式是让建造者类来负责对象的创建工作。上面讲到的工厂模式，是由工厂类来负责对象创建的工作。那它们之间有什么区别呢？</li>\n<li>实际上，工厂模式是用来创建不同但是相关类型的对象（继承同一父类或者接口的一组子类），由给定的参数来决定创建哪种类型的对象。建造者模式是用来创建一种类型的复杂对象，通过设置不同的可选参数，“定制化”地创建不同的对象。</li>\n</ol>\n<p>网上有一个经典的例子很好地解释了两者的区别:</p>\n<blockquote>\n<p>顾客走进一家餐馆点餐，我们利用工厂模式，根据用户不同的选择，来制作不同的食物，比如披萨、汉堡、沙拉。对于披萨来说，用户又有各种配料可以定制，比如奶酪、西红柿、起司，我们通过建造者模式根据用户选择的不同配料来制作披萨。</p>\n</blockquote>\n<p>实际上，我们也不要太学院派，非得把工厂模式、建造者模式分得那么清楚，我们需要知道的是，每个模式为什么这么设计，能解决什么问题。只有了解了这些最本质的东西，我们才能不生搬硬套，才能灵活应用，甚至可以混用各种模式创造出新的模式，来解决特定场景的问题。</p>\n<h1 id=\"原型模式【不常用】\"><a href=\"#原型模式【不常用】\" class=\"headerlink\" title=\"原型模式【不常用】\"></a>原型模式【不常用】</h1><p>今天的讲解跟具体某一语言的语法机制无关，而是通过一个 clone 散列表的例子带你搞清楚：原型模式的应用场景，以及它的两种实现方式：深拷贝和浅拷贝。虽然原型模式的原理和代码实现非常简单，但今天举的例子还是稍微有点复杂的</p>\n<h2 id=\"原型模式的原理与应用\"><a href=\"#原型模式的原理与应用\" class=\"headerlink\" title=\"原型模式的原理与应用\"></a>原型模式的原理与应用</h2><p>如果对象的创建成本比较大，而同一个类的不同对象之间差别不大（大部分字段都相同），在这种情况下，我们可以利用对已有对象（原型）进行复制（或者叫拷贝）的方式来创建新对象，以达到节省创建时间的目的。这种基于原型来创建对象的方式就叫作原型设计模式（Prototype Design Pattern），简称原型模式。</p>\n<blockquote>\n<p>那何为“对象的创建成本比较大”？</p>\n</blockquote>\n<ol>\n<li>实际上，创建对象包含的申请内存、给成员变量赋值这一过程，本身并不会花费太多时间，或者说对于大部分业务系统来说，这点时间完全是可以忽略的。应用一个复杂的模式，只得到一点点的性能提升，这就是所谓的过度设计，得不偿失。</li>\n<li>但是，如果对象中的数据需要经过复杂的计算才能得到（比如排序、计算哈希值），或者需要从 RPC、网络、数据库、文件系统等非常慢速的 IO 中读取，这种情况下，我们就可以利用原型模式，从其他已有对象中直接拷贝得到，而不用每次在创建新对象的时候，都重复执行这些耗时的操作。</li>\n</ol>\n<blockquote>\n<p>这么说还是比较理论，接下来，我们通过一个例子来解释一下刚刚这段话。</p>\n</blockquote>\n<ol>\n<li>假设数据库中存储了大约 10 万条“搜索关键词”信息，每条信息包含关键词、关键词被搜索的次数、信息最近被更新的时间等。系统 A 在启动的时候会加载这份数据到内存中，用于处理某些其他的业务需求。为了方便快速地查找某个关键词对应的信息，我们给关键词建立一个散列表索引。</li>\n<li>如果你熟悉的是 Java 语言，可以直接使用语言中提供的 HashMap 容器来实现。其中，HashMap 的 key 为搜索关键词，value 为关键词详细信息（比如搜索次数）。我们只需要将数据从数据库中读取出来，放入 HashMap 就可以了。</li>\n<li>不过，我们还有另外一个系统 B，专门用来分析搜索日志，定期（比如间隔 10 分钟）批量地更新数据库中的数据，并且标记为新的数据版本。比如，在下面的示例图中，我们对 v2 版本的数据进行更新，得到 v3 版本的数据。这里我们假设只有更新和新添关键词，没有删除关键词的行为。</li>\n</ol>\n<img src=\"https://npm.elemecdn.com/youthlql@1.0.0/design_patterns/creational/03.02/0002.png\"/>\n\n\n\n<ol>\n<li>为了保证系统 A 中数据的实时性（不一定非常实时，但数据也不能太旧），系统 A 需要定期根据数据库中的数据，更新内存中的索引和数据。</li>\n<li>我们该如何实现这个需求呢？实际上，也不难。我们只需要在系统 A 中，记录当前数据的版本 Va 对应的更新时间 Ta，从数据库中捞出更新时间大于 Ta 的所有搜索关键词，也就是找出 Va 版本与最新版本数据的“差集”，然后针对差集中的每个关键词进行处理。如果它已经在散列表中存在了，我们就更新相应的搜索次数、更新时间等信息；如果它在散列表中不存在，我们就将它插入到散列表中。</li>\n<li>按照这个设计思路，我给出的示例代码如下所示：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Demo</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> ConcurrentHashMap&lt;String, SearchWord&gt; currentKeywords = <span class=\"keyword\">new</span> <span class=\"title class_\">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"type\">long</span> <span class=\"variable\">lastUpdateTime</span> <span class=\"operator\">=</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">refresh</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 从数据库中取出更新时间&gt;lastUpdateTime的数据，放入到currentKeywords中</span></span><br><span class=\"line\">    List&lt;SearchWord&gt; toBeUpdatedSearchWords = getSearchWords(lastUpdateTime);</span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"variable\">maxNewUpdatedTime</span> <span class=\"operator\">=</span> lastUpdateTime;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (SearchWord searchWord : toBeUpdatedSearchWords) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (searchWord.getLastUpdateTime() &gt; maxNewUpdatedTime) &#123;</span><br><span class=\"line\">        maxNewUpdatedTime = searchWord.getLastUpdateTime();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (currentKeywords.containsKey(searchWord.getKeyword())) &#123;</span><br><span class=\"line\">        currentKeywords.replace(searchWord.getKeyword(), searchWord);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        currentKeywords.put(searchWord.getKeyword(), searchWord);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    lastUpdateTime = maxNewUpdatedTime;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> List&lt;SearchWord&gt; <span class=\"title function_\">getSearchWords</span><span class=\"params\">(<span class=\"type\">long</span> lastUpdateTime)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// <span class=\"doctag\">TODO:</span> 从数据库中取出更新时间&gt;lastUpdateTime的数据</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>不过，现在，我们有一个特殊的要求：任何时刻，系统 A 中的所有数据都必须是同一个版本的，要么都是版本 a，要么都是版本 b，不能有的是版本 a，有的是版本 b。那刚刚的更新方式就不能满足这个要求了（因为数据很多，一个一个的for循环肯定会出现不同数据版本的问题）。除此之外，我们还要求：在更新内存数据的时候，系统 A 不能处于不可用状态，也就是不能停机更新数据。</p>\n<ol>\n<li><p>那我们该如何实现现在这个需求呢？</p>\n</li>\n<li><p>实际上，也不难。我们把正在使用的数据的版本定义为“服务版本”，当我们要更新内存中的数据的时候，我们并不是直接在服务版本（假设是版本 a 数据）上更新，而是重新创建另一个版本数据（假设是版本 b 数据），等新的版本数据建好之后，再一次性地将服务版本从版本 a 切换到版本 b。这样既保证了数据一直可用，又避免了中间状态的存在。</p>\n</li>\n<li><p>按照这个设计思路，我给出的示例代码如下所示：</p>\n</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Demo</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> HashMap&lt;String, SearchWord&gt; currentKeywords=<span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">refresh</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    HashMap&lt;String, SearchWord&gt; newKeywords = <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedHashMap</span>&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 从数据库中取出所有的数据，放入到newKeywords中</span></span><br><span class=\"line\">    List&lt;SearchWord&gt; toBeUpdatedSearchWords = getSearchWords();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (SearchWord searchWord : toBeUpdatedSearchWords) &#123;</span><br><span class=\"line\">      newKeywords.put(searchWord.getKeyword(), searchWord);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    currentKeywords = newKeywords;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> List&lt;SearchWord&gt; <span class=\"title function_\">getSearchWords</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// <span class=\"doctag\">TODO:</span> 从数据库中取出所有的数据</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<ol>\n<li>不过，在上面的代码实现中，newKeywords 构建的成本比较高。我们需要将这 10 万条数据从数据库中读出，然后计算哈希值，构建 newKeywords。这个过程显然是比较耗时。为了提高效率，原型模式就派上用场了。</li>\n<li>我们拷贝 currentKeywords 数据到 newKeywords 中，然后从数据库中只捞出新增或者有更新的关键词，更新到 newKeywords 中。而相对于 10 万条数据来说，每次新增或者更新的关键词个数是比较少的，所以，这种策略大大提高了数据更新的效率。</li>\n<li>按照这个设计思路，我给出的示例代码如下所示：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Demo</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> HashMap&lt;String, SearchWord&gt; currentKeywords=<span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;();</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"type\">long</span> <span class=\"variable\">lastUpdateTime</span> <span class=\"operator\">=</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">refresh</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 原型模式就这么简单，拷贝已有对象的数据，更新少量差值</span></span><br><span class=\"line\">    HashMap&lt;String, SearchWord&gt; newKeywords = (HashMap&lt;String, SearchWord&gt;) currentKeywords.clone();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 从数据库中取出更新时间&gt;lastUpdateTime的数据，放入到newKeywords中</span></span><br><span class=\"line\">    List&lt;SearchWord&gt; toBeUpdatedSearchWords = getSearchWords(lastUpdateTime);</span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"variable\">maxNewUpdatedTime</span> <span class=\"operator\">=</span> lastUpdateTime;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (SearchWord searchWord : toBeUpdatedSearchWords) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (searchWord.getLastUpdateTime() &gt; maxNewUpdatedTime) &#123;</span><br><span class=\"line\">        maxNewUpdatedTime = searchWord.getLastUpdateTime();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (newKeywords.containsKey(searchWord.getKeyword())) &#123;</span><br><span class=\"line\">        <span class=\"type\">SearchWord</span> <span class=\"variable\">oldSearchWord</span> <span class=\"operator\">=</span> newKeywords.get(searchWord.getKeyword());</span><br><span class=\"line\">        oldSearchWord.setCount(searchWord.getCount());</span><br><span class=\"line\">        oldSearchWord.setLastUpdateTime(searchWord.getLastUpdateTime());</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        newKeywords.put(searchWord.getKeyword(), searchWord);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    lastUpdateTime = maxNewUpdatedTime;</span><br><span class=\"line\">    currentKeywords = newKeywords;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> List&lt;SearchWord&gt; <span class=\"title function_\">getSearchWords</span><span class=\"params\">(<span class=\"type\">long</span> lastUpdateTime)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// <span class=\"doctag\">TODO:</span> 从数据库中取出更新时间&gt;lastUpdateTime的数据</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>这里我们利用了 Java 中的 clone() 语法来复制一个对象。如果你熟悉的语言没有这个语法，那把数据从 currentKeywords 中一个个取出来，然后再重新计算哈希值，放入到 newKeywords 中也是可以接受的。毕竟，最耗时的还是从数据库中取数据的操作。相对于数据库的 IO 操作来说，内存操作和 CPU 计算的耗时都是可以忽略的。</li>\n<li>不过，不知道你有没有发现，实际上，刚刚的代码实现是有问题的。要弄明白到底有什么问题，我们需要先了解另外两个概念：深拷贝（Deep Copy）和浅拷贝（Shallow Copy）。</li>\n</ol>\n<h2 id=\"原型模式的实现方式：深拷贝和浅拷贝\"><a href=\"#原型模式的实现方式：深拷贝和浅拷贝\" class=\"headerlink\" title=\"原型模式的实现方式：深拷贝和浅拷贝\"></a>原型模式的实现方式：深拷贝和浅拷贝</h2><blockquote>\n<p>1、关于深拷贝浅拷贝，我觉得这篇文章讲的不错：<a href=\"https://blog.csdn.net/baiye_xing/article/details/71788741\">https://blog.csdn.net/baiye_xing/article/details/71788741</a></p>\n</blockquote>\n<blockquote>\n<p>我自己的总结：</p>\n<p><strong>浅拷贝</strong>：对一个对象进行拷贝时，这个对象对应的类里的成员变量。</p>\n<ul>\n<li>对于数据类型是基本数据类型的成员变量，浅拷贝会直接进行值拷贝，也就是将该属性值复制一份给新的对象。因为是两份不同的数据，所以对其中一个对象的该成员变量值进行修改，不会影响另一个对象拷贝得到的数据</li>\n<li>对于数据类型是引用数据类型的成员变量(也就是子对象，或者数组啥的)，也就是只是将该成员变量的引用值（引用拷贝【并发引用传递，Java本质还是值传递】）复制一份给新的对象。因为实际上两个对象的该成员变量都指向同一个实例。在这种情况下，在一个对象中修改该成员变量会影响到另一个对象的该成员变量值。</li>\n</ul>\n<ol>\n<li><strong>深拷贝</strong>：对基本数据类型进行值传递，对引用数据类型，创建一个新的对象，并复制其内容，此为深拷贝。</li>\n<li>也就是说浅拷贝对于子对象只是拷贝了引用值，并没有真正的拷贝整个对象。</li>\n</ol>\n<p><strong>深拷贝实现思路：</strong></p>\n<ol>\n<li><p>对于每个子对象都实现Cloneable 接口，并重写clone方法。最后在最顶层的类的重写的 clone 方法中调用所有子对象的 clone 方法即可实现深拷贝。【简单的说就是：每一层的每个子对象都进行浅拷贝&#x3D;深拷贝】</p>\n</li>\n<li><p>利用序列化。【先对对象进行序列化，紧接着马上反序列化出 】</p>\n</li>\n</ol>\n</blockquote>\n<p>我们来看，在内存中，用散列表组织的搜索关键词信息是如何存储的。我画了一张示意图，大致结构如下所示。从图中我们可以发现，散列表索引中，每个结点存储的 key 是搜索关键词，value 是 SearchWord 对象的内存地址。SearchWord 对象本身存储在散列表之外的内存空间中。</p>\n<img src=\"https://npm.elemecdn.com/youthlql@1.0.0/design_patterns/creational/03.02/0003.png\"  />\n\n<p>浅拷贝和深拷贝的区别在于，浅拷贝只会复制图中的索引（散列表），不会复制数据（SearchWord 对象）本身。相反，深拷贝不仅仅会复制索引，还会复制数据本身。浅拷贝得到的对象（newKeywords）跟原始对象（currentKeywords）共享数据（SearchWord 对象），而深拷贝得到的是一份完完全全独立的对象。具体的对比如下图所示：</p>\n<img src=\"https://npm.elemecdn.com/youthlql@1.0.0/design_patterns/creational/03.02/0004.png\"/>\n\n\n\n<img src=\"https://npm.elemecdn.com/youthlql@1.0.0/design_patterns/creational/03.02/0005.png\" />\n\n\n\n<ol>\n<li><p>在 Java 语言中，Object 类的 clone() 方法执行的就是我们刚刚说的浅拷贝。它只会拷贝对象中的基本数据类型的数据（比如，int、long），以及引用对象（SearchWord）的内存地址，不会递归地拷贝引用对象本身。</p>\n</li>\n<li><p>在上面的代码中，我们通过调用 HashMap 上的 clone() 浅拷贝方法来实现原型模式。当我们通过 newKeywords 更新 SearchWord 对象的时候（比如，更新“设计模式”这个搜索关键词的访问次数），newKeywords 和 currentKeywords 因为指向相同的一组 SearchWord 对象，就会导致 currentKeywords 中指向的 SearchWord，有的是老版本的，有的是新版本的，就没法满足我们之前的需求：currentKeywords 中的数据在任何时刻都是同一个版本的，不存在介于老版本与新版本之间的中间状态。</p>\n</li>\n<li><p>现在，我们又该如何来解决这个问题呢？</p>\n</li>\n<li><p>我们可以将浅拷贝替换为深拷贝。newKeywords 不仅仅复制 currentKeywords 的索引，还把 SearchWord 对象也复制一份出来，这样 newKeywords 和 currentKeywords 就指向不同的 SearchWord 对象，也就不存在更新 newKeywords 的数据会导致 currentKeywords 的数据也被更新的问题了。</p>\n</li>\n<li><p>那如何实现深拷贝呢？总结一下的话，有下面两种方法。</p>\n</li>\n</ol>\n<p>第一种方法：递归拷贝对象、对象的引用对象以及引用对象的引用对象……直到要拷贝的对象只包含基本数据类型数据，没有引用对象为止。根据这个思路对之前的代码进行重构。重构之后的代码如下所示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Demo</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> HashMap&lt;String, SearchWord&gt; currentKeywords=<span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;();</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"type\">long</span> <span class=\"variable\">lastUpdateTime</span> <span class=\"operator\">=</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">refresh</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Deep copy</span></span><br><span class=\"line\">    HashMap&lt;String, SearchWord&gt; newKeywords = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (HashMap.Entry&lt;String, SearchWord&gt; e : currentKeywords.entrySet()) &#123;</span><br><span class=\"line\">      <span class=\"type\">SearchWord</span> <span class=\"variable\">searchWord</span> <span class=\"operator\">=</span> e.getValue();</span><br><span class=\"line\">      <span class=\"type\">SearchWord</span> <span class=\"variable\">newSearchWord</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">SearchWord</span>(</span><br><span class=\"line\">              searchWord.getKeyword(), searchWord.getCount(), searchWord.getLastUpdateTime());</span><br><span class=\"line\">      newKeywords.put(e.getKey(), newSearchWord);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 从数据库中取出更新时间&gt;lastUpdateTime的数据，放入到newKeywords中</span></span><br><span class=\"line\">    List&lt;SearchWord&gt; toBeUpdatedSearchWords = getSearchWords(lastUpdateTime);</span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"variable\">maxNewUpdatedTime</span> <span class=\"operator\">=</span> lastUpdateTime;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (SearchWord searchWord : toBeUpdatedSearchWords) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (searchWord.getLastUpdateTime() &gt; maxNewUpdatedTime) &#123;</span><br><span class=\"line\">        maxNewUpdatedTime = searchWord.getLastUpdateTime();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (newKeywords.containsKey(searchWord.getKeyword())) &#123;</span><br><span class=\"line\">        <span class=\"type\">SearchWord</span> <span class=\"variable\">oldSearchWord</span> <span class=\"operator\">=</span> newKeywords.get(searchWord.getKeyword());</span><br><span class=\"line\">        oldSearchWord.setCount(searchWord.getCount());</span><br><span class=\"line\">        oldSearchWord.setLastUpdateTime(searchWord.getLastUpdateTime());</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        newKeywords.put(searchWord.getKeyword(), searchWord);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    lastUpdateTime = maxNewUpdatedTime;</span><br><span class=\"line\">    currentKeywords = newKeywords;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> List&lt;SearchWord&gt; <span class=\"title function_\">getSearchWords</span><span class=\"params\">(<span class=\"type\">long</span> lastUpdateTime)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// <span class=\"doctag\">TODO:</span> 从数据库中取出更新时间&gt;lastUpdateTime的数据</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>第二种方法：先将对象序列化，然后再反序列化成新的对象。具体的示例代码如下所示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> Object <span class=\"title function_\">deepCopy</span><span class=\"params\">(Object object)</span> &#123;</span><br><span class=\"line\">  <span class=\"type\">ByteArrayOutputStream</span> <span class=\"variable\">bo</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ByteArrayOutputStream</span>();</span><br><span class=\"line\">  <span class=\"type\">ObjectOutputStream</span> <span class=\"variable\">oo</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ObjectOutputStream</span>(bo);</span><br><span class=\"line\">  oo.writeObject(object);</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"type\">ByteArrayInputStream</span> <span class=\"variable\">bi</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ByteArrayInputStream</span>(bo.toByteArray());</span><br><span class=\"line\">  <span class=\"type\">ObjectInputStream</span> <span class=\"variable\">oi</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ObjectInputStream</span>(bi);</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">return</span> oi.readObject();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>刚刚的两种实现方法，不管采用哪种，深拷贝都要比浅拷贝耗时、耗内存空间。针对我们这个应用场景，有没有更快、更省内存的实现方式呢？</li>\n<li>我们可以先采用浅拷贝的方式创建 newKeywords。对于需要更新的 SearchWord 对象，我们再使用深度拷贝的方式创建一份新的对象，替换 newKeywords 中的老对象。毕竟需要更新的数据是很少的。这种方式即利用了浅拷贝节省时间、空间的优点，又能保证 currentKeywords 中的中数据都是老版本的数据。具体的代码实现如下所示。这也是标题中讲到的，在我们这个应用场景下，最快速 clone 散列表的方式。</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Demo</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> HashMap&lt;String, SearchWord&gt; currentKeywords=<span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;();</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"type\">long</span> <span class=\"variable\">lastUpdateTime</span> <span class=\"operator\">=</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">refresh</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Shallow copy</span></span><br><span class=\"line\">    HashMap&lt;String, SearchWord&gt; newKeywords = (HashMap&lt;String, SearchWord&gt;) currentKeywords.clone();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 从数据库中取出更新时间&gt;lastUpdateTime的数据，放入到newKeywords中</span></span><br><span class=\"line\">    List&lt;SearchWord&gt; toBeUpdatedSearchWords = getSearchWords(lastUpdateTime);</span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"variable\">maxNewUpdatedTime</span> <span class=\"operator\">=</span> lastUpdateTime;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (SearchWord searchWord : toBeUpdatedSearchWords) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (searchWord.getLastUpdateTime() &gt; maxNewUpdatedTime) &#123;</span><br><span class=\"line\">        maxNewUpdatedTime = searchWord.getLastUpdateTime();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (newKeywords.containsKey(searchWord.getKeyword())) &#123;</span><br><span class=\"line\">        newKeywords.remove(searchWord.getKeyword());</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      newKeywords.put(searchWord.getKeyword(), searchWord);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    lastUpdateTime = maxNewUpdatedTime;</span><br><span class=\"line\">    currentKeywords = newKeywords;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> List&lt;SearchWord&gt; <span class=\"title function_\">getSearchWords</span><span class=\"params\">(<span class=\"type\">long</span> lastUpdateTime)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// <span class=\"doctag\">TODO:</span> 从数据库中取出更新时间&gt;lastUpdateTime的数据</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","site":{"data":{}},"cover_type":"img","excerpt":"","more":"<h1 id=\"声明\"><a href=\"#声明\" class=\"headerlink\" title=\"声明\"></a>声明</h1><blockquote>\n<ol>\n<li>此系列文章非本人原创，是学习笔记。</li>\n<li>设计模式系列以后会持续更新，包括已经发布的设计模式文章，因为后续还要再多看一下书，教程和开源项目等，继续润色文章。</li>\n</ol>\n</blockquote>\n<h1 id=\"工厂模式【常用】\"><a href=\"#工厂模式【常用】\" class=\"headerlink\" title=\"工厂模式【常用】\"></a>工厂模式【常用】</h1><blockquote>\n<p>工厂模式很重要，后面的很多架构设计，都是工厂模式联合着其它设计模式使用。</p>\n</blockquote>\n<ol>\n<li><p>一般情况下，工厂模式分为三种更加细分的类型：简单工厂、工厂方法和抽象工厂。不过，在 GoF 的《设计模式》一书中，它将简单工厂模式看作是工厂方法模式的一种特例，所以工厂模式只被分成了工厂方法和抽象工厂两类。实际上，前面一种分类方法更加常见，所以，在今天的讲解中，我们沿用第一种分类方法。</p>\n</li>\n<li><p>在这三种细分的工厂模式中，简单工厂、工厂方法原理比较简单，在实际的项目中也比较常用。而抽象工厂的原理稍微复杂点，在实际的项目中相对也不常用。所以，我们今天讲解的重点是前两种工厂模式。对于抽象工厂，稍微了解一下即可。</p>\n</li>\n<li><p>除此之外，我们讲解的重点也不是原理和实现，因为这些都很简单，重点还是带你搞清楚应用场景：什么时候该用工厂模式？相对于直接 new 来创建对象，用工厂模式来创建究竟有什么好处呢？</p>\n</li>\n</ol>\n<h2 id=\"简单工厂（Simple-Factory）\"><a href=\"#简单工厂（Simple-Factory）\" class=\"headerlink\" title=\"简单工厂（Simple Factory）\"></a>简单工厂（Simple Factory）</h2><p>首先，我们来看，什么是简单工厂模式。我们通过一个例子来解释一下。</p>\n<p>在下面这段代码中，我们根据配置文件的后缀（json、xml、yaml、properties），选择不同的解析器（JsonRuleConfigParser、XmlRuleConfigParser……），将存储在文件中的配置解析成内存对象 RuleConfig。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">RuleConfigSource</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> RuleConfig <span class=\"title function_\">load</span><span class=\"params\">(String ruleConfigFilePath)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">ruleConfigFileExtension</span> <span class=\"operator\">=</span> getFileExtension(ruleConfigFilePath);</span><br><span class=\"line\">    <span class=\"type\">IRuleConfigParser</span> <span class=\"variable\">parser</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"string\">&quot;json&quot;</span>.equalsIgnoreCase(ruleConfigFileExtension)) &#123;</span><br><span class=\"line\">      parser = <span class=\"keyword\">new</span> <span class=\"title class_\">JsonRuleConfigParser</span>();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"string\">&quot;xml&quot;</span>.equalsIgnoreCase(ruleConfigFileExtension)) &#123;</span><br><span class=\"line\">      parser = <span class=\"keyword\">new</span> <span class=\"title class_\">XmlRuleConfigParser</span>();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"string\">&quot;yaml&quot;</span>.equalsIgnoreCase(ruleConfigFileExtension)) &#123;</span><br><span class=\"line\">      parser = <span class=\"keyword\">new</span> <span class=\"title class_\">YamlRuleConfigParser</span>();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"string\">&quot;properties&quot;</span>.equalsIgnoreCase(ruleConfigFileExtension)) &#123;</span><br><span class=\"line\">      parser = <span class=\"keyword\">new</span> <span class=\"title class_\">PropertiesRuleConfigParser</span>();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">InvalidRuleConfigException</span>(</span><br><span class=\"line\">             <span class=\"string\">&quot;Rule config file format is not supported: &quot;</span> + ruleConfigFilePath);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">configText</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">    <span class=\"comment\">//从ruleConfigFilePath文件中读取配置文本到configText中</span></span><br><span class=\"line\">    <span class=\"type\">RuleConfig</span> <span class=\"variable\">ruleConfig</span> <span class=\"operator\">=</span> parser.parse(configText);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ruleConfig;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> String <span class=\"title function_\">getFileExtension</span><span class=\"params\">(String filePath)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//...解析文件名获取扩展名，比如rule.json，返回json</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;json&quot;</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>为了让代码逻辑更加清晰，可读性更好，我们要善于将功能独立的代码块封装成函数。按照这个设计思路，我们可以将代码中涉及 parser 创建的部分逻辑剥离出来，抽象成 createParser() 函数。重构之后的代码如下所示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  <span class=\"keyword\">public</span> RuleConfig <span class=\"title function_\">load</span><span class=\"params\">(String ruleConfigFilePath)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">ruleConfigFileExtension</span> <span class=\"operator\">=</span> getFileExtension(ruleConfigFilePath);</span><br><span class=\"line\">    <span class=\"type\">IRuleConfigParser</span> <span class=\"variable\">parser</span> <span class=\"operator\">=</span> createParser(ruleConfigFileExtension);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (parser == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">InvalidRuleConfigException</span>(</span><br><span class=\"line\">              <span class=\"string\">&quot;Rule config file format is not supported: &quot;</span> + ruleConfigFilePath);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">configText</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">    <span class=\"comment\">//从ruleConfigFilePath文件中读取配置文本到configText中</span></span><br><span class=\"line\">    <span class=\"type\">RuleConfig</span> <span class=\"variable\">ruleConfig</span> <span class=\"operator\">=</span> parser.parse(configText);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ruleConfig;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> String <span class=\"title function_\">getFileExtension</span><span class=\"params\">(String filePath)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//...解析文件名获取扩展名，比如rule.json，返回json</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;json&quot;</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> IRuleConfigParser <span class=\"title function_\">createParser</span><span class=\"params\">(String configFormat)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">IRuleConfigParser</span> <span class=\"variable\">parser</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"string\">&quot;json&quot;</span>.equalsIgnoreCase(configFormat)) &#123;</span><br><span class=\"line\">      parser = <span class=\"keyword\">new</span> <span class=\"title class_\">JsonRuleConfigParser</span>();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"string\">&quot;xml&quot;</span>.equalsIgnoreCase(configFormat)) &#123;</span><br><span class=\"line\">      parser = <span class=\"keyword\">new</span> <span class=\"title class_\">XmlRuleConfigParser</span>();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"string\">&quot;yaml&quot;</span>.equalsIgnoreCase(configFormat)) &#123;</span><br><span class=\"line\">      parser = <span class=\"keyword\">new</span> <span class=\"title class_\">YamlRuleConfigParser</span>();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"string\">&quot;properties&quot;</span>.equalsIgnoreCase(configFormat)) &#123;</span><br><span class=\"line\">      parser = <span class=\"keyword\">new</span> <span class=\"title class_\">PropertiesRuleConfigParser</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> parser;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>为了让类的职责更加单一(<strong>设计模式原则中的单一职责</strong>，)、代码更加清晰，我们还可以进一步将 createParser() 函数剥离到一个独立的类中，让这个类只负责对象的创建。而这个类就是我们现在要讲的简单工厂模式类。具体的代码如下所示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">RuleConfigSource</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> RuleConfig <span class=\"title function_\">load</span><span class=\"params\">(String ruleConfigFilePath)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">ruleConfigFileExtension</span> <span class=\"operator\">=</span> getFileExtension(ruleConfigFilePath);</span><br><span class=\"line\">    <span class=\"type\">IRuleConfigParser</span> <span class=\"variable\">parser</span> <span class=\"operator\">=</span> RuleConfigParserFactory.createParser(ruleConfigFileExtension);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (parser == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">InvalidRuleConfigException</span>(</span><br><span class=\"line\">              <span class=\"string\">&quot;Rule config file format is not supported: &quot;</span> + ruleConfigFilePath);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">configText</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">    <span class=\"comment\">//从ruleConfigFilePath文件中读取配置文本到configText中</span></span><br><span class=\"line\">    <span class=\"type\">RuleConfig</span> <span class=\"variable\">ruleConfig</span> <span class=\"operator\">=</span> parser.parse(configText);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ruleConfig;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> String <span class=\"title function_\">getFileExtension</span><span class=\"params\">(String filePath)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//...解析文件名获取扩展名，比如rule.json，返回json</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;json&quot;</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">RuleConfigParserFactory</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> IRuleConfigParser <span class=\"title function_\">createParser</span><span class=\"params\">(String configFormat)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">IRuleConfigParser</span> <span class=\"variable\">parser</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"string\">&quot;json&quot;</span>.equalsIgnoreCase(configFormat)) &#123;</span><br><span class=\"line\">      parser = <span class=\"keyword\">new</span> <span class=\"title class_\">JsonRuleConfigParser</span>();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"string\">&quot;xml&quot;</span>.equalsIgnoreCase(configFormat)) &#123;</span><br><span class=\"line\">      parser = <span class=\"keyword\">new</span> <span class=\"title class_\">XmlRuleConfigParser</span>();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"string\">&quot;yaml&quot;</span>.equalsIgnoreCase(configFormat)) &#123;</span><br><span class=\"line\">      parser = <span class=\"keyword\">new</span> <span class=\"title class_\">YamlRuleConfigParser</span>();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"string\">&quot;properties&quot;</span>.equalsIgnoreCase(configFormat)) &#123;</span><br><span class=\"line\">      parser = <span class=\"keyword\">new</span> <span class=\"title class_\">PropertiesRuleConfigParser</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> parser;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<ol>\n<li>在上面的代码实现中，我们每次调用 RuleConfigParserFactory 的 createParser() 的时候，都要创建一个新的 parser。</li>\n<li>实际上，如果 parser 可以复用，为了节省内存和对象创建的时间，我们可以将 parser 事先创建好缓存起来。当调用 createParser() 函数的时候，我们从缓存中取出 parser 对象直接使用。这有点类似单例模式和简单工厂模式的结合，具体的代码实现如下所示。在接下来的讲解中，我们把上一种实现方法叫作简单工厂模式的第一种实现方法，把下面这种实现方法叫作简单工厂模式的第二种实现方法。</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">RuleConfigParserFactory</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Map&lt;String, RuleConfigParser&gt; cachedParsers = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">    cachedParsers.put(<span class=\"string\">&quot;json&quot;</span>, <span class=\"keyword\">new</span> <span class=\"title class_\">JsonRuleConfigParser</span>());</span><br><span class=\"line\">    cachedParsers.put(<span class=\"string\">&quot;xml&quot;</span>, <span class=\"keyword\">new</span> <span class=\"title class_\">XmlRuleConfigParser</span>());</span><br><span class=\"line\">    cachedParsers.put(<span class=\"string\">&quot;yaml&quot;</span>, <span class=\"keyword\">new</span> <span class=\"title class_\">YamlRuleConfigParser</span>());</span><br><span class=\"line\">    cachedParsers.put(<span class=\"string\">&quot;properties&quot;</span>, <span class=\"keyword\">new</span> <span class=\"title class_\">PropertiesRuleConfigParser</span>());</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> IRuleConfigParser <span class=\"title function_\">createParser</span><span class=\"params\">(String configFormat)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (configFormat == <span class=\"literal\">null</span> || configFormat.isEmpty()) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;<span class=\"comment\">//返回null还是IllegalArgumentException全凭你自己说了算</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">IRuleConfigParser</span> <span class=\"variable\">parser</span> <span class=\"operator\">=</span> cachedParsers.get(configFormat.toLowerCase());</span><br><span class=\"line\">    <span class=\"keyword\">return</span> parser;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<ol>\n<li>对于上面两种简单工厂模式的实现方法，如果我们要添加新的 parser，那势必要改动到 RuleConfigParserFactory 的代码，那这是不是违反开闭原则呢？实际上，如果不是需要频繁地添加新的 parser，只是偶尔修改一下 RuleConfigParserFactory 代码，稍微不符合开闭原则，也是完全可以接受的。</li>\n<li>除此之外，在 RuleConfigParserFactory 的第一种代码实现中，有一组 if 分支判断逻辑，是不是应该用多态或其他设计模式来替代呢？实际上，如果 if 分支并不是很多，代码中有 if 分支也是完全可以接受的。应用多态或设计模式来替代 if 分支判断逻辑，也并不是没有任何缺点的，它虽然提高了代码的扩展性，更加符合<strong>开闭原则</strong>，但也增加了类的个数，牺牲了代码的可读性。关于这一点，我们在后面章节中会详细讲到。</li>\n<li>总结一下，尽管简单工厂模式的代码实现中，有多处 if 分支判断逻辑，违背开闭原则，但权衡扩展性和可读性，这样的代码实现在大多数情况下（比如，不需要频繁地添加 parser，也没有太多的 parser）是没有问题的。</li>\n</ol>\n<h2 id=\"工厂方法（Factory-Method）\"><a href=\"#工厂方法（Factory-Method）\" class=\"headerlink\" title=\"工厂方法（Factory Method）\"></a>工厂方法（Factory Method）</h2><p>如果我们非得要将 if 分支逻辑去掉，那该怎么办呢？比较经典处理方法就是利用多态。按照多态的实现思路，对上面的代码进行重构。重构之后的代码如下所示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">IRuleConfigParserFactory</span> &#123;</span><br><span class=\"line\">  IRuleConfigParser <span class=\"title function_\">createParser</span><span class=\"params\">()</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">JsonRuleConfigParserFactory</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">IRuleConfigParserFactory</span> &#123;</span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> IRuleConfigParser <span class=\"title function_\">createParser</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">JsonRuleConfigParser</span>();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">XmlRuleConfigParserFactory</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">IRuleConfigParserFactory</span> &#123;</span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> IRuleConfigParser <span class=\"title function_\">createParser</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">XmlRuleConfigParser</span>();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">YamlRuleConfigParserFactory</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">IRuleConfigParserFactory</span> &#123;</span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> IRuleConfigParser <span class=\"title function_\">createParser</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">YamlRuleConfigParser</span>();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">PropertiesRuleConfigParserFactory</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">IRuleConfigParserFactory</span> &#123;</span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> IRuleConfigParser <span class=\"title function_\">createParser</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">PropertiesRuleConfigParser</span>();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>实际上，这就是工厂方法模式的典型代码实现。这样当我们新增一种 parser 的时候，只需要新增一个实现了 IRuleConfigParserFactory 接口的 Factory 类即可。所以，工厂方法模式比起简单工厂模式更加符合开闭原则。</p>\n<p>从上面的工厂方法的实现来看，一切都很完美，但是实际上存在挺大的问题。问题存在于这些工厂类的使用上。接下来，我们看一下，如何用这些工厂类来实现 RuleConfigSource 的 load() 函数。具体的代码如下所示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">RuleConfigSource</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> RuleConfig <span class=\"title function_\">load</span><span class=\"params\">(String ruleConfigFilePath)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">ruleConfigFileExtension</span> <span class=\"operator\">=</span> getFileExtension(ruleConfigFilePath);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">IRuleConfigParserFactory</span> <span class=\"variable\">parserFactory</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"string\">&quot;json&quot;</span>.equalsIgnoreCase(ruleConfigFileExtension)) &#123;</span><br><span class=\"line\">      parserFactory = <span class=\"keyword\">new</span> <span class=\"title class_\">JsonRuleConfigParserFactory</span>();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"string\">&quot;xml&quot;</span>.equalsIgnoreCase(ruleConfigFileExtension)) &#123;</span><br><span class=\"line\">      parserFactory = <span class=\"keyword\">new</span> <span class=\"title class_\">XmlRuleConfigParserFactory</span>();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"string\">&quot;yaml&quot;</span>.equalsIgnoreCase(ruleConfigFileExtension)) &#123;</span><br><span class=\"line\">      parserFactory = <span class=\"keyword\">new</span> <span class=\"title class_\">YamlRuleConfigParserFactory</span>();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"string\">&quot;properties&quot;</span>.equalsIgnoreCase(ruleConfigFileExtension)) &#123;</span><br><span class=\"line\">      parserFactory = <span class=\"keyword\">new</span> <span class=\"title class_\">PropertiesRuleConfigParserFactory</span>();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">InvalidRuleConfigException</span>(<span class=\"string\">&quot;Rule config file format is not supported: &quot;</span> + ruleConfigFilePath);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">IRuleConfigParser</span> <span class=\"variable\">parser</span> <span class=\"operator\">=</span> parserFactory.createParser();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">configText</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">    <span class=\"comment\">//从ruleConfigFilePath文件中读取配置文本到configText中</span></span><br><span class=\"line\">    <span class=\"type\">RuleConfig</span> <span class=\"variable\">ruleConfig</span> <span class=\"operator\">=</span> parser.parse(configText);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ruleConfig;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> String <span class=\"title function_\">getFileExtension</span><span class=\"params\">(String filePath)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//...解析文件名获取扩展名，比如rule.json，返回json</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;json&quot;</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<ol>\n<li>从上面的代码实现来看，工厂类对象的创建逻辑又耦合进了 load() 函数中，跟我们最初的代码版本非常相似，引入工厂方法非但没有解决问题，反倒让设计变得更加复杂了。那怎么来解决这个问题呢？</li>\n<li>我们可以为工厂类再创建一个简单工厂，也就是工厂的工厂，用来创建工厂类对象。这段话听起来有点绕，我把代码实现出来了，你一看就能明白了。其中，RuleConfigParserFactoryMap 类是创建工厂对象的工厂类，getParserFactory() 返回的是缓存好的单例工厂对象。</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">RuleConfigSource</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> RuleConfig <span class=\"title function_\">load</span><span class=\"params\">(String ruleConfigFilePath)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">ruleConfigFileExtension</span> <span class=\"operator\">=</span> getFileExtension(ruleConfigFilePath);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">IRuleConfigParserFactory</span> <span class=\"variable\">parserFactory</span> <span class=\"operator\">=</span> RuleConfigParserFactoryMap.getParserFactory(ruleConfigFileExtension);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (parserFactory == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">InvalidRuleConfigException</span>(<span class=\"string\">&quot;Rule config file format is not supported: &quot;</span> + ruleConfigFilePath);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">IRuleConfigParser</span> <span class=\"variable\">parser</span> <span class=\"operator\">=</span> parserFactory.createParser();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">configText</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">    <span class=\"comment\">//从ruleConfigFilePath文件中读取配置文本到configText中</span></span><br><span class=\"line\">    <span class=\"type\">RuleConfig</span> <span class=\"variable\">ruleConfig</span> <span class=\"operator\">=</span> parser.parse(configText);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ruleConfig;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> String <span class=\"title function_\">getFileExtension</span><span class=\"params\">(String filePath)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//...解析文件名获取扩展名，比如rule.json，返回json</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;json&quot;</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//因为工厂类只包含方法，不包含成员变量，完全可以复用，</span></span><br><span class=\"line\"><span class=\"comment\">//不需要每次都创建新的工厂类对象，所以，简单工厂模式的第二种实现思路更加合适。</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">RuleConfigParserFactoryMap</span> &#123; <span class=\"comment\">//工厂的工厂</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Map&lt;String, IRuleConfigParserFactory&gt; cachedFactories = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">    cachedFactories.put(<span class=\"string\">&quot;json&quot;</span>, <span class=\"keyword\">new</span> <span class=\"title class_\">JsonRuleConfigParserFactory</span>());</span><br><span class=\"line\">    cachedFactories.put(<span class=\"string\">&quot;xml&quot;</span>, <span class=\"keyword\">new</span> <span class=\"title class_\">XmlRuleConfigParserFactory</span>());</span><br><span class=\"line\">    cachedFactories.put(<span class=\"string\">&quot;yaml&quot;</span>, <span class=\"keyword\">new</span> <span class=\"title class_\">YamlRuleConfigParserFactory</span>());</span><br><span class=\"line\">    cachedFactories.put(<span class=\"string\">&quot;properties&quot;</span>, <span class=\"keyword\">new</span> <span class=\"title class_\">PropertiesRuleConfigParserFactory</span>());</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> IRuleConfigParserFactory <span class=\"title function_\">getParserFactory</span><span class=\"params\">(String type)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (type == <span class=\"literal\">null</span> || type.isEmpty()) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">IRuleConfigParserFactory</span> <span class=\"variable\">parserFactory</span> <span class=\"operator\">=</span> cachedFactories.get(type.toLowerCase());</span><br><span class=\"line\">    <span class=\"keyword\">return</span> parserFactory;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<ol>\n<li>当我们需要添加新的规则配置解析器的时候，我们只需要创建新的 parser 类和 parser factory 类，并且在 RuleConfigParserFactoryMap 类中，将新的 parser factory 对象添加到 cachedFactories 中即可。代码的改动非常少，基本上符合开闭原则。</li>\n<li>实际上，对于规则配置文件解析这个应用场景来说，工厂模式需要额外创建诸多 Factory 类，也会增加代码的复杂性，而且，每个 Factory 类只是做简单的 new 操作，功能非常单薄（只有一行代码），也没必要设计成独立的类，所以，在这个应用场景下，简单工厂模式简单好用，比工厂方法模式更加合适。</li>\n</ol>\n<h3 id=\"那什么时候该用工厂方法模式，而非简单工厂模式呢？\"><a href=\"#那什么时候该用工厂方法模式，而非简单工厂模式呢？\" class=\"headerlink\" title=\"那什么时候该用工厂方法模式，而非简单工厂模式呢？\"></a>那什么时候该用工厂方法模式，而非简单工厂模式呢？</h3><ol>\n<li>我们前面提到，之所以将某个代码块剥离出来，独立为函数或者类，原因是这个代码块的逻辑过于复杂，剥离之后能让代码更加清晰，更加可读、可维护。但是，如果代码块本身并不复杂，就几行代码而已，我们完全没必要将它拆分成单独的函数或者类。</li>\n<li>基于这个设计思想，当对象的创建逻辑比较复杂，不只是简单的 new 一下就可以，而是要组合其他类对象，做各种初始化操作的时候，我们推荐使用工厂方法模式，将复杂的创建逻辑拆分到多个工厂类中，让每个工厂类都不至于过于复杂。而使用简单工厂模式，将所有的创建逻辑都放到一个工厂类中，会导致这个工厂类变得很复杂。</li>\n<li>除此之外，在某些场景下，如果对象不可复用，那工厂类每次都要返回不同的对象。如果我们使用简单工厂模式来实现，就只能选择第一种包含 if 分支逻辑的实现方式。如果我们还想避免烦人的 if-else 分支逻辑，这个时候，我们就推荐使用工厂方法模式。</li>\n</ol>\n<h2 id=\"抽象工厂（Abstract-Factory）\"><a href=\"#抽象工厂（Abstract-Factory）\" class=\"headerlink\" title=\"抽象工厂（Abstract Factory）\"></a>抽象工厂（Abstract Factory）</h2><ol>\n<li>讲完了简单工厂、工厂方法，我们再来看抽象工厂模式。抽象工厂模式的应用场景比较特殊，没有前两种常用，所以不是我们学习的重点，你简单了解一下就可以了。</li>\n<li>在简单工厂和工厂方法中，类只有一种分类方式。比如，在规则配置解析那个例子中，解析器类只会根据配置文件格式（Json、Xml、Yaml……）来分类。但是，如果类有两种分类方式，比如，我们既可以按照配置文件格式来分类，也可以按照解析的对象（Rule 规则配置还是 System 系统配置）来分类，那就会对应下面这 8 个 parser 类。</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">针对规则配置的解析器：基于接口IRuleConfigParser</span><br><span class=\"line\">JsonRuleConfigParser</span><br><span class=\"line\">XmlRuleConfigParser</span><br><span class=\"line\">YamlRuleConfigParser</span><br><span class=\"line\">PropertiesRuleConfigParser</span><br><span class=\"line\"></span><br><span class=\"line\">针对系统配置的解析器：基于接口ISystemConfigParser</span><br><span class=\"line\">JsonSystemConfigParser</span><br><span class=\"line\">XmlSystemConfigParser</span><br><span class=\"line\">YamlSystemConfigParser</span><br><span class=\"line\">PropertiesSystemConfigParser</span><br></pre></td></tr></table></figure>\n\n\n\n<ol>\n<li>针对这种特殊的场景，如果还是继续用工厂方法来实现的话，我们要针对每个 parser 都编写一个工厂类，也就是要编写 8 个工厂类。如果我们未来还需要增加针对业务配置的解析器（比如 IBizConfigParser），那就要再对应地增加 4 个工厂类。而我们知道，过多的类也会让系统难维护。这个问题该怎么解决呢？</li>\n<li>抽象工厂就是针对这种非常特殊的场景而诞生的。我们可以让一个工厂负责创建多个不同类型的对象（IRuleConfigParser、ISystemConfigParser 等），而不是只创建一种 parser 对象。这样就可以有效地减少工厂类的个数。具体的代码实现如下所示：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">IConfigParserFactory</span> &#123;</span><br><span class=\"line\">  IRuleConfigParser <span class=\"title function_\">createRuleParser</span><span class=\"params\">()</span>;</span><br><span class=\"line\">  ISystemConfigParser <span class=\"title function_\">createSystemParser</span><span class=\"params\">()</span>;</span><br><span class=\"line\">  <span class=\"comment\">//此处可以扩展新的parser类型，比如IBizConfigParser</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">JsonConfigParserFactory</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">IConfigParserFactory</span> &#123;</span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> IRuleConfigParser <span class=\"title function_\">createRuleParser</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">JsonRuleConfigParser</span>();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> ISystemConfigParser <span class=\"title function_\">createSystemParser</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">JsonSystemConfigParser</span>();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">XmlConfigParserFactory</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">IConfigParserFactory</span> &#123;</span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> IRuleConfigParser <span class=\"title function_\">createRuleParser</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">XmlRuleConfigParser</span>();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> ISystemConfigParser <span class=\"title function_\">createSystemParser</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">XmlSystemConfigParser</span>();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 省略YamlConfigParserFactory和PropertiesConfigParserFactory代码</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"如何设计实现一个Dependency-Injection框架？\"><a href=\"#如何设计实现一个Dependency-Injection框架？\" class=\"headerlink\" title=\"如何设计实现一个Dependency Injection框架？\"></a>如何设计实现一个Dependency Injection框架？</h2><p>当创建对象是一个“大工程”的时候，我们一般会选择使用工厂模式，来封装对象复杂的创建过程，将对象的创建和使用分离，让代码更加清晰。那何为“大工程”呢？上面我们讲了两种情况，一种是创建过程涉及复杂的 if-else 分支判断，另一种是对象创建需要组装多个其他类对象或者需要复杂的初始化过程。</p>\n<p>今天，我们再来讲一个创建对象的“大工程”，依赖注入框架，或者叫依赖注入容器（Dependency Injection Container），简称 DI 容器。在今天的讲解中，我会带你一块搞清楚这样几个问题：DI 容器跟我们讲的工厂模式又有何区别和联系？DI 容器的核心功能有哪些，以及如何实现一个简单的 DI 容器？</p>\n<h3 id=\"工厂模式和-DI-容器有何区别？\"><a href=\"#工厂模式和-DI-容器有何区别？\" class=\"headerlink\" title=\"工厂模式和 DI 容器有何区别？\"></a>工厂模式和 DI 容器有何区别？</h3><ol>\n<li>实际上，DI 容器底层最基本的设计思路就是基于工厂模式的。DI 容器相当于一个大的工厂类，负责在程序启动的时候，根据配置（要创建哪些类对象，每个类对象的创建需要依赖哪些其他类对象）事先创建好对象。当应用程序需要使用某个类对象的时候，直接从容器中获取即可。正是因为它持有一堆对象，所以这个框架才被称为“容器”。</li>\n<li>DI 容器相对于我们上面讲的工厂模式的例子来说，它处理的是更大的对象创建工程。上面讲的工厂模式中，一个工厂类只负责某个类对象或者某一组相关类对象（继承自同一抽象类或者接口的子类）的创建，而 DI 容器负责的是整个应用中所有类对象的创建。</li>\n<li>除此之外，DI 容器负责的事情要比单纯的工厂模式要多。比如，它还包括配置的解析、对象生命周期的管理。接下来，我们就详细讲讲，一个简单的 DI 容器应该包含哪些核心功能。</li>\n</ol>\n<h3 id=\"DI-容器的核心功能有哪些？\"><a href=\"#DI-容器的核心功能有哪些？\" class=\"headerlink\" title=\"DI 容器的核心功能有哪些？\"></a>DI 容器的核心功能有哪些？</h3><p>总结一下，一个简单的 DI 容器的核心功能一般有三个：配置解析、对象创建和对象生命周期管理。</p>\n<blockquote>\n<p>首先，我们来看配置解析。</p>\n</blockquote>\n<ol>\n<li>在上面讲的工厂模式中，工厂类要创建哪个类对象是事先确定好的，并且是写死在工厂类代码中的。作为一个通用的框架来说，框架代码跟应用代码应该是高度解耦的，DI 容器事先并不知道应用会创建哪些对象，不可能把某个应用要创建的对象写死在框架代码中。所以，我们需要通过一种形式，让应用告知 DI 容器要创建哪些对象。这种形式就是我们要讲的配置。</li>\n<li>我们将需要由 DI 容器来创建的类对象和创建类对象的必要信息（使用哪个构造函数以及对应的构造函数参数都是什么等等），放到配置文件中。容器读取配置文件，根据配置文件提供的信息来创建对象。</li>\n<li>下面是一个典型的 Spring 容器的配置文件。Spring 容器读取这个配置文件，解析出要创建的两个对象：rateLimiter 和 redisCounter，并且得到两者的依赖关系：rateLimiter 依赖 redisCounter。</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">RateLimiter</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> RedisCounter redisCounter;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"title function_\">RateLimiter</span><span class=\"params\">(RedisCounter redisCounter)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.redisCounter = redisCounter;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;Hello World!&quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">RedisCounter</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> String ipAddress;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"type\">int</span> port;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"title function_\">RedisCounter</span><span class=\"params\">(String ipAddress, <span class=\"type\">int</span> port)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.ipAddress = ipAddress;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.port = port;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">配置文件beans.xml：</span><br><span class=\"line\">&lt;beans&gt;</span><br><span class=\"line\">   &lt;bean id=<span class=\"string\">&quot;rateLimiter&quot;</span> class=<span class=\"string\">&quot;com.xzg.RateLimiter&quot;</span>&gt;</span><br><span class=\"line\">      &lt;constructor-arg ref=<span class=\"string\">&quot;redisCounter&quot;</span>/&gt;</span><br><span class=\"line\">   &lt;/bean&gt;</span><br><span class=\"line\"> </span><br><span class=\"line\">   &lt;bean id=<span class=\"string\">&quot;redisCounter&quot;</span> class=<span class=\"string\">&quot;com.xzg.redisCounter&quot;</span>&gt;</span><br><span class=\"line\">     &lt;constructor-arg type=<span class=\"string\">&quot;String&quot;</span> value=<span class=\"string\">&quot;127.0.0.1&quot;</span>&gt;</span><br><span class=\"line\">     &lt;constructor-arg type=<span class=\"string\">&quot;int&quot;</span> value=<span class=\"number\">1234</span>&gt;</span><br><span class=\"line\">   &lt;/bean&gt;</span><br><span class=\"line\">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>\n\n\n\n<blockquote>\n<p>其次，我们再来看对象创建。</p>\n</blockquote>\n<ol>\n<li>在 DI 容器中，如果我们给每个类都对应创建一个工厂类，那项目中类的个数会成倍增加，这会增加代码的维护成本。要解决这个问题并不难。我们只需要将所有类对象的创建都放到一个工厂类中完成就可以了，比如 BeansFactory。</li>\n<li>你可能会说，如果要创建的类对象非常多，BeansFactory 中的代码会不会线性膨胀（代码量跟创建对象的个数成正比）呢？实际上并不会。待会讲到 DI 容器的具体实现的时候，我们会讲“反射”这种机制，它能在程序运行的过程中，动态地加载类、创建对象，不需要事先在代码中写死要创建哪些对象。所以，不管是创建一个对象还是十个对象，BeansFactory 工厂类代码都是一样的。</li>\n</ol>\n<blockquote>\n<p>最后，我们来看对象的生命周期管理。</p>\n</blockquote>\n<ol>\n<li>上面我们讲到，简单工厂模式有两种实现方式，一种是每次都返回新创建的对象，另一种是每次都返回同一个事先创建好的对象，也就是所谓的单例对象。在 Spring 框架中，我们可以通过配置 scope 属性，来区分这两种不同类型的对象。scope&#x3D;prototype 表示返回新创建的对象，scope&#x3D;singleton 表示返回单例对象。</li>\n<li>除此之外，我们还可以配置对象是否支持懒加载。如果 lazy-init&#x3D;true，对象在真正被使用到的时候（比如：BeansFactory.getBean(“userService”)）才被被创建；如果 lazy-init&#x3D;false，对象在应用启动的时候就事先创建好。</li>\n<li>不仅如此，我们还可以配置对象的 init-method 和 destroy-method 方法，比如 init-method&#x3D;loadProperties()，destroy-method&#x3D;updateConfigFile()。DI 容器在创建好对象之后，会主动调用 init-method 属性指定的方法来初始化对象。在对象被最终销毁之前，DI 容器会主动调用 destroy-method 属性指定的方法来做一些清理工作，比如释放数据库连接池、关闭文件。</li>\n</ol>\n<h2 id=\"如何实现一个简单的-DI-容器？\"><a href=\"#如何实现一个简单的-DI-容器？\" class=\"headerlink\" title=\"如何实现一个简单的 DI 容器？\"></a>如何实现一个简单的 DI 容器？</h2><p>用 Java 语言来实现一个简单的 DI 容器，核心逻辑只需要包括这样两个部分：配置文件解析、根据配置文件通过“反射”语法来创建对象。</p>\n<h3 id=\"最小原型设计\"><a href=\"#最小原型设计\" class=\"headerlink\" title=\"最小原型设计\"></a>最小原型设计</h3><p>因为我们主要是讲解设计模式，所以，在今天的讲解中，我们只实现一个 DI 容器的最小原型。像 Spring 框架这样的 DI 容器，它支持的配置格式非常灵活和复杂。为了简化代码实现，重点讲解原理，在最小原型中，我们只支持下面配置文件中涉及的配置语法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">配置文件beans.xml</span><br><span class=\"line\">&lt;beans&gt;</span><br><span class=\"line\">   &lt;bean id=<span class=\"string\">&quot;rateLimiter&quot;</span> class=<span class=\"string\">&quot;com.xzg.RateLimiter&quot;</span>&gt;</span><br><span class=\"line\">      &lt;constructor-arg ref=<span class=\"string\">&quot;redisCounter&quot;</span>/&gt;</span><br><span class=\"line\">   &lt;/bean&gt;</span><br><span class=\"line\"> </span><br><span class=\"line\">   &lt;bean id=<span class=\"string\">&quot;redisCounter&quot;</span> class=<span class=\"string\">&quot;com.xzg.redisCounter&quot;</span> scope=<span class=\"string\">&quot;singleton&quot;</span> lazy-init=<span class=\"string\">&quot;true&quot;</span>&gt;</span><br><span class=\"line\">     &lt;constructor-arg type=<span class=\"string\">&quot;String&quot;</span> value=<span class=\"string\">&quot;127.0.0.1&quot;</span>&gt;</span><br><span class=\"line\">     &lt;constructor-arg type=<span class=\"string\">&quot;int&quot;</span> value=<span class=\"number\">1234</span>&gt;</span><br><span class=\"line\">   &lt;/bean&gt;</span><br><span class=\"line\">&lt;/bean</span><br></pre></td></tr></table></figure>\n\n\n\n<p>最小原型的使用方式跟 Spring 框架非常类似，示例代码如下所示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Demo</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">ApplicationContext</span> <span class=\"variable\">applicationContext</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ClassPathXmlApplicationContext</span>(</span><br><span class=\"line\">            <span class=\"string\">&quot;beans.xml&quot;</span>);</span><br><span class=\"line\">    <span class=\"type\">RateLimiter</span> <span class=\"variable\">rateLimiter</span> <span class=\"operator\">=</span> (RateLimiter) applicationContext.getBean(<span class=\"string\">&quot;rateLimiter&quot;</span>);</span><br><span class=\"line\">    rateLimiter.test();</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"提供执行入口\"><a href=\"#提供执行入口\" class=\"headerlink\" title=\"提供执行入口\"></a>提供执行入口</h3><p>面向对象设计的最后一步是：组装类并提供执行入口。在这里，执行入口就是一组暴露给外部使用的接口和类。通过刚刚的最小原型使用示例代码，我们可以看出，执行入口主要包含两部分：ApplicationContext 和 ClassPathXmlApplicationContext。其中，ApplicationContext 是接口，ClassPathXmlApplicationContext 是接口的实现类。两个类具体实现如下所示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">ApplicationContext</span> &#123;</span><br><span class=\"line\">  Object <span class=\"title function_\">getBean</span><span class=\"params\">(String beanId)</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ClassPathXmlApplicationContext</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">ApplicationContext</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> BeansFactory beansFactory;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> BeanConfigParser beanConfigParser;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"title function_\">ClassPathXmlApplicationContext</span><span class=\"params\">(String configLocation)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.beansFactory = <span class=\"keyword\">new</span> <span class=\"title class_\">BeansFactory</span>();</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.beanConfigParser = <span class=\"keyword\">new</span> <span class=\"title class_\">XmlBeanConfigParser</span>();</span><br><span class=\"line\">    loadBeanDefinitions(configLocation);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">loadBeanDefinitions</span><span class=\"params\">(String configLocation)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">InputStream</span> <span class=\"variable\">in</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      in = <span class=\"built_in\">this</span>.getClass().getResourceAsStream(<span class=\"string\">&quot;/&quot;</span> + configLocation);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (in == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RuntimeException</span>(<span class=\"string\">&quot;Can not find config file: &quot;</span> + configLocation);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      List&lt;BeanDefinition&gt; beanDefinitions = beanConfigParser.parse(in);</span><br><span class=\"line\">      beansFactory.addBeanDefinitions(beanDefinitions);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (in != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">          in.close();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">          <span class=\"comment\">// <span class=\"doctag\">TODO:</span> log error</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> Object <span class=\"title function_\">getBean</span><span class=\"params\">(String beanId)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> beansFactory.getBean(beanId);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>从上面的代码中，我们可以看出，ClassPathXmlApplicationContext 负责组装 BeansFactory 和 BeanConfigParser 两个类，串联执行流程：从 classpath 中加载 XML 格式的配置文件，通过 BeanConfigParser 解析为统一的 BeanDefinition 格式，然后，BeansFactory 根据 BeanDefinition 来创建对象。</p>\n<h3 id=\"配置文件解析\"><a href=\"#配置文件解析\" class=\"headerlink\" title=\"配置文件解析\"></a>配置文件解析</h3><p>配置文件解析主要包含 BeanConfigParser 接口和 XmlBeanConfigParser 实现类，负责将配置文件解析为 BeanDefinition 结构，以便 BeansFactory 根据这个结构来创建对象。配置文件的解析比较繁琐，不涉及我们要讲的理论知识，不是我们讲解的重点，所以这里我只给出两个类的大致设计思路，并未给出具体的实现代码。如果感兴趣的话，你可以自行补充完整。具体的代码框架如下所示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">BeanConfigParser</span> &#123;</span><br><span class=\"line\">  List&lt;BeanDefinition&gt; <span class=\"title function_\">parse</span><span class=\"params\">(InputStream inputStream)</span>;</span><br><span class=\"line\">  List&lt;BeanDefinition&gt; <span class=\"title function_\">parse</span><span class=\"params\">(String configContent)</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">XmlBeanConfigParser</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">BeanConfigParser</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> List&lt;BeanDefinition&gt; <span class=\"title function_\">parse</span><span class=\"params\">(InputStream inputStream)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">content</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"comment\">// <span class=\"doctag\">TODO:</span>...</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> parse(content);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> List&lt;BeanDefinition&gt; <span class=\"title function_\">parse</span><span class=\"params\">(String configContent)</span> &#123;</span><br><span class=\"line\">    List&lt;BeanDefinition&gt; beanDefinitions = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">    <span class=\"comment\">// <span class=\"doctag\">TODO:</span>...</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> beanDefinitions;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">BeanDefinition</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> String id;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> String className;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> List&lt;ConstructorArg&gt; constructorArgs = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"type\">Scope</span> <span class=\"variable\">scope</span> <span class=\"operator\">=</span> Scope.SINGLETON;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"type\">boolean</span> <span class=\"variable\">lazyInit</span> <span class=\"operator\">=</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 省略必要的getter/setter/constructors</span></span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">isSingleton</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> scope.equals(Scope.SINGLETON);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">enum</span> <span class=\"title class_\">Scope</span> &#123;</span><br><span class=\"line\">    SINGLETON,</span><br><span class=\"line\">    PROTOTYPE</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ConstructorArg</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">boolean</span> isRef;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Class type;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Object arg;</span><br><span class=\"line\">    <span class=\"comment\">// 省略必要的getter/setter/constructors</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"核心工厂类设计\"><a href=\"#核心工厂类设计\" class=\"headerlink\" title=\"核心工厂类设计\"></a>核心工厂类设计</h3><ol>\n<li>最后，我们来看，BeansFactory 是如何设计和实现的。这也是我们这个 DI 容器最核心的一个类了。它负责根据从配置文件解析得到的 BeanDefinition 来创建对象。</li>\n<li>如果对象的 scope 属性是 singleton，那对象创建之后会缓存在 singletonObjects 这样一个 map 中，下次再请求此对象的时候，直接从 map 中取出返回，不需要重新创建。如果对象的 scope 属性是 prototype，那每次请求对象，BeansFactory 都会创建一个新的对象返回。</li>\n<li>实际上，BeansFactory 创建对象用到的主要技术点就是 Java 中的反射语法：一种动态加载类和创建对象的机制。我们知道，JVM 在启动的时候会根据代码自动地加载类、创建对象。至于都要加载哪些类、创建哪些对象，这些都是在代码中写死的，或者说提前写好的。但是，如果某个对象的创建并不是写死在代码中，而是放到配置文件中，我们需要在程序运行期间，动态地根据配置文件来加载类、创建对象，那这部分工作就没法让 JVM 帮我们自动完成了，我们需要利用 Java 提供的反射语法自己去编写代码。</li>\n<li>搞清楚了反射的原理，BeansFactory 的代码就不难看懂了。具体代码实现如下所示：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">BeansFactory</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> ConcurrentHashMap&lt;String, Object&gt; singletonObjects = <span class=\"keyword\">new</span> <span class=\"title class_\">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class=\"line\">  <span class=\"keyword\">private</span> ConcurrentHashMap&lt;String, BeanDefinition&gt; beanDefinitions = <span class=\"keyword\">new</span> <span class=\"title class_\">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">addBeanDefinitions</span><span class=\"params\">(List&lt;BeanDefinition&gt; beanDefinitionList)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (BeanDefinition beanDefinition : beanDefinitionList) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.beanDefinitions.putIfAbsent(beanDefinition.getId(), beanDefinition);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (BeanDefinition beanDefinition : beanDefinitionList) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (beanDefinition.isLazyInit() == <span class=\"literal\">false</span> &amp;&amp; beanDefinition.isSingleton()) &#123;</span><br><span class=\"line\">        createBean(beanDefinition);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> Object <span class=\"title function_\">getBean</span><span class=\"params\">(String beanId)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">BeanDefinition</span> <span class=\"variable\">beanDefinition</span> <span class=\"operator\">=</span> beanDefinitions.get(beanId);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (beanDefinition == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">NoSuchBeanDefinitionException</span>(<span class=\"string\">&quot;Bean is not defined: &quot;</span> + beanId);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> createBean(beanDefinition);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@VisibleForTesting</span></span><br><span class=\"line\">  <span class=\"keyword\">protected</span> Object <span class=\"title function_\">createBean</span><span class=\"params\">(BeanDefinition beanDefinition)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (beanDefinition.isSingleton() &amp;&amp; singletonObjects.contains(beanDefinition.getId())) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> singletonObjects.get(beanDefinition.getId());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">Object</span> <span class=\"variable\">bean</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      <span class=\"type\">Class</span> <span class=\"variable\">beanClass</span> <span class=\"operator\">=</span> Class.forName(beanDefinition.getClassName());</span><br><span class=\"line\">      List&lt;BeanDefinition.ConstructorArg&gt; args = beanDefinition.getConstructorArgs();</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (args.isEmpty()) &#123;</span><br><span class=\"line\">        bean = beanClass.newInstance();</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        Class[] argClasses = <span class=\"keyword\">new</span> <span class=\"title class_\">Class</span>[args.size()];</span><br><span class=\"line\">        Object[] argObjects = <span class=\"keyword\">new</span> <span class=\"title class_\">Object</span>[args.size()];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; args.size(); ++i) &#123;</span><br><span class=\"line\">          BeanDefinition.<span class=\"type\">ConstructorArg</span> <span class=\"variable\">arg</span> <span class=\"operator\">=</span> args.get(i);</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (!arg.getIsRef()) &#123;</span><br><span class=\"line\">            argClasses[i] = arg.getType();</span><br><span class=\"line\">            argObjects[i] = arg.getArg();</span><br><span class=\"line\">          &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"type\">BeanDefinition</span> <span class=\"variable\">refBeanDefinition</span> <span class=\"operator\">=</span> beanDefinitions.get(arg.getArg());</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (refBeanDefinition == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">              <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">NoSuchBeanDefinitionException</span>(<span class=\"string\">&quot;Bean is not defined: &quot;</span> + arg.getArg());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            argClasses[i] = Class.forName(refBeanDefinition.getClassName());</span><br><span class=\"line\">            argObjects[i] = createBean(refBeanDefinition);</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        bean = beanClass.getConstructor(argClasses).newInstance(argObjects);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (ClassNotFoundException | IllegalAccessException</span><br><span class=\"line\">            | InstantiationException | NoSuchMethodException | InvocationTargetException e) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">BeanCreationFailureException</span>(<span class=\"string\">&quot;&quot;</span>, e);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (bean != <span class=\"literal\">null</span> &amp;&amp; beanDefinition.isSingleton()) &#123;</span><br><span class=\"line\">      singletonObjects.putIfAbsent(beanDefinition.getId(), bean);</span><br><span class=\"line\">      <span class=\"keyword\">return</span> singletonObjects.get(beanDefinition.getId());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> bean;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>执行入口那里调用<code>addBeanDefinitions</code></li>\n<li>然后<code>addBeanDefinitions</code>再调用createBean利用反射创建对象，如果对象的 scope 属性是 singleton，那对象创建之后会缓存在 singletonObjects 这样一个 map 中</li>\n<li>最后最小原型设计那里再调用getBean从singletonObjects 获取对象。</li>\n</ol>\n<h1 id=\"建造者模式【常用】\"><a href=\"#建造者模式【常用】\" class=\"headerlink\" title=\"建造者模式【常用】\"></a>建造者模式【常用】</h1><blockquote>\n<p>只要是标注常用的，基本上用的都比较多，无论篇幅长短，都不要忽视。</p>\n</blockquote>\n<p>建造者模式的原理和代码实现非常简单，掌握起来并不难，难点在于应用场景。比如，你有没有考虑过这样几个问题：直接使用构造函数或者配合 set 方法就能创建对象，为什么还需要建造者模式来创建呢？建造者模式和工厂模式都可以创建对象，那它们两个的区别在哪里呢？</p>\n<h2 id=\"为什么需要建造者模式？\"><a href=\"#为什么需要建造者模式？\" class=\"headerlink\" title=\"为什么需要建造者模式？\"></a>为什么需要建造者模式？</h2><ol>\n<li>在平时的开发中，创建一个对象最常用的方式是，使用 new 关键字调用类的构造函数来完成。我的问题是，什么情况下这种方式就不适用了，就需要采用建造者模式来创建对象呢？你可以先思考一下，下面我通过一个例子来带你看一下。</li>\n<li>假设有这样一道设计面试题：我们需要定义一个资源池配置类 ResourcePoolConfig。这里的资源池，你可以简单理解为线程池、连接池、对象池等。在这个资源池配置类中，有以下几个成员变量，也就是可配置项。现在，请你编写代码实现这个 ResourcePoolConfig 类。</li>\n</ol>\n<img src=\"https://npm.elemecdn.com/youthlql@1.0.0/design_patterns/creational/03.02/0001.png\" />\n\n\n\n<p>只要你稍微有点开发经验，那实现这样一个类对你来说并不是件难事。最常见、最容易想到的实现思路如下代码所示。因为 maxTotal、maxIdle、minIdle 不是必填变量，所以在创建 ResourcePoolConfig 对象的时候，我们通过往构造函数中，给这几个参数传递 null 值，来表示使用默认值。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ResourcePoolConfig</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">DEFAULT_MAX_TOTAL</span> <span class=\"operator\">=</span> <span class=\"number\">8</span>;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">DEFAULT_MAX_IDLE</span> <span class=\"operator\">=</span> <span class=\"number\">8</span>;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">DEFAULT_MIN_IDLE</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"type\">int</span> <span class=\"variable\">maxTotal</span> <span class=\"operator\">=</span> DEFAULT_MAX_TOTAL;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"type\">int</span> <span class=\"variable\">maxIdle</span> <span class=\"operator\">=</span> DEFAULT_MAX_IDLE;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"type\">int</span> <span class=\"variable\">minIdle</span> <span class=\"operator\">=</span> DEFAULT_MIN_IDLE;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"title function_\">ResourcePoolConfig</span><span class=\"params\">(String name, Integer maxTotal, Integer maxIdle, Integer minIdle)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (StringUtils.isBlank(name)) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IllegalArgumentException</span>(<span class=\"string\">&quot;name should not be empty.&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.name = name;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (maxTotal != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (maxTotal &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IllegalArgumentException</span>(<span class=\"string\">&quot;maxTotal should be positive.&quot;</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.maxTotal = maxTotal;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (maxIdle != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (maxIdle &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IllegalArgumentException</span>(<span class=\"string\">&quot;maxIdle should not be negative.&quot;</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.maxIdle = maxIdle;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (minIdle != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (minIdle &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IllegalArgumentException</span>(<span class=\"string\">&quot;minIdle should not be negative.&quot;</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.minIdle = minIdle;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//...省略getter方法...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>现在，ResourcePoolConfig 只有 4 个可配置项，对应到构造函数中，也只有 4 个参数，参数的个数不多。但是，如果可配置项逐渐增多，变成了 8 个、10 个，甚至更多，那继续沿用现在的设计思路，构造函数的参数列表会变得很长，代码在可读性和易用性上都会变差。在使用构造函数的时候，我们就容易搞错各参数的顺序，传递进错误的参数值，导致非常隐蔽的 bug。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 参数太多，导致可读性差、参数可能传递错误</span></span><br><span class=\"line\"><span class=\"type\">ResourcePoolConfig</span> <span class=\"variable\">config</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ResourcePoolConfig</span>(<span class=\"string\">&quot;dbconnectionpool&quot;</span>, <span class=\"number\">16</span>, <span class=\"literal\">null</span>, <span class=\"number\">8</span>, <span class=\"literal\">null</span>, <span class=\"literal\">false</span> , <span class=\"literal\">true</span>, <span class=\"number\">10</span>, <span class=\"number\">20</span>，<span class=\"literal\">false</span>， <span class=\"literal\">true</span>);</span><br></pre></td></tr></table></figure>\n\n\n\n<p>解决这个问题的办法你应该也已经想到了，那就是用 set() 函数来给成员变量赋值，以替代冗长的构造函数。我们直接看代码，具体如下所示。其中，配置项 name 是必填的，所以我们把它放到构造函数中设置，强制创建类对象的时候就要填写。其他配置项 maxTotal、maxIdle、minIdle 都不是必填的，所以我们通过 set() 函数来设置，让使用者自主选择填写或者不填写。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ResourcePoolConfig</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">DEFAULT_MAX_TOTAL</span> <span class=\"operator\">=</span> <span class=\"number\">8</span>;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">DEFAULT_MAX_IDLE</span> <span class=\"operator\">=</span> <span class=\"number\">8</span>;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">DEFAULT_MIN_IDLE</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"type\">int</span> <span class=\"variable\">maxTotal</span> <span class=\"operator\">=</span> DEFAULT_MAX_TOTAL;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"type\">int</span> <span class=\"variable\">maxIdle</span> <span class=\"operator\">=</span> DEFAULT_MAX_IDLE;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"type\">int</span> <span class=\"variable\">minIdle</span> <span class=\"operator\">=</span> DEFAULT_MIN_IDLE;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"title function_\">ResourcePoolConfig</span><span class=\"params\">(String name)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (StringUtils.isBlank(name)) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IllegalArgumentException</span>(<span class=\"string\">&quot;name should not be empty.&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.name = name;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setMaxTotal</span><span class=\"params\">(<span class=\"type\">int</span> maxTotal)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (maxTotal &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IllegalArgumentException</span>(<span class=\"string\">&quot;maxTotal should be positive.&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.maxTotal = maxTotal;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setMaxIdle</span><span class=\"params\">(<span class=\"type\">int</span> maxIdle)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (maxIdle &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IllegalArgumentException</span>(<span class=\"string\">&quot;maxIdle should not be negative.&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.maxIdle = maxIdle;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setMinIdle</span><span class=\"params\">(<span class=\"type\">int</span> minIdle)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (minIdle &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IllegalArgumentException</span>(<span class=\"string\">&quot;minIdle should not be negative.&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.minIdle = minIdle;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//...省略getter方法...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>接下来，我们来看新的 ResourcePoolConfig 类该如何使用。我写了一个示例代码，如下所示。没有了冗长的函数调用和参数列表，代码在可读性和易用性上提高了很多。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ResourcePoolConfig使用举例</span></span><br><span class=\"line\"><span class=\"type\">ResourcePoolConfig</span> <span class=\"variable\">config</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ResourcePoolConfig</span>(<span class=\"string\">&quot;dbconnectionpool&quot;</span>);</span><br><span class=\"line\">config.setMaxTotal(<span class=\"number\">16</span>);</span><br><span class=\"line\">config.setMaxIdle(<span class=\"number\">8</span>);</span><br></pre></td></tr></table></figure>\n\n\n\n<p>至此，我们仍然没有用到建造者模式，通过构造函数设置必填项，通过 set() 方法设置可选配置项，就能实现我们的设计需求。如果我们把问题的难度再加大点，比如，还需要解决下面这三个问题，那现在的设计思路就不能满足了。</p>\n<ul>\n<li>我们刚刚讲到，name 是必填的，所以，我们把它放到构造函数中，强制创建对象的时候就设置。如果必填的配置项有很多，把这些必填配置项都放到构造函数中设置，那构造函数就又会出现参数列表很长的问题。如果我们把必填项也通过 set() 方法设置，那校验这些必填项是否已经填写的逻辑就无处安放了。</li>\n<li>除此之外，假设配置项之间有一定的依赖关系，比如，如果用户设置了 maxTotal、maxIdle、minIdle 其中一个，就必须显式地设置另外两个；或者配置项之间有一定的约束条件，比如，maxIdle 和 minIdle 要小于等于 maxTotal。如果我们继续使用现在的设计思路，那这些配置项之间的依赖关系或者约束条件的校验逻辑就无处安放了。</li>\n<li>如果我们希望 ResourcePoolConfig 类对象是不可变对象，也就是说，对象在创建好之后，就不能再修改内部的属性值。要实现这个功能，我们就不能在 ResourcePoolConfig 类中暴露 set() 方法。</li>\n</ul>\n<p>为了解决这些问题，建造者模式就派上用场了。我们可以把校验逻辑放置到 Builder 类中，先创建建造者，并且通过 set() 方法设置建造者的变量值，然后在使用 build() 方法真正创建对象之前，做集中的校验，校验通过之后才会创建对象。除此之外，我们把 ResourcePoolConfig 的构造函数改为 private 私有权限。这样我们就只能通过建造者来创建 ResourcePoolConfig 类对象。并且，ResourcePoolConfig 没有提供任何 set() 方法，这样我们创建出来的对象就是不可变对象了。我们用建造者模式重新实现了上面的需求，具体的代码如下所示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ResourcePoolConfig</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"type\">int</span> maxTotal;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"type\">int</span> maxIdle;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"type\">int</span> minIdle;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"title function_\">ResourcePoolConfig</span><span class=\"params\">(Builder builder)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.name = builder.name;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.maxTotal = builder.maxTotal;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.maxIdle = builder.maxIdle;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.minIdle = builder.minIdle;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//...省略getter方法...</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//我们将Builder类设计成了ResourcePoolConfig的内部类。</span></span><br><span class=\"line\">  <span class=\"comment\">//我们也可以将Builder类设计成独立的非内部类ResourcePoolConfigBuilder。</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Builder</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">DEFAULT_MAX_TOTAL</span> <span class=\"operator\">=</span> <span class=\"number\">8</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">DEFAULT_MAX_IDLE</span> <span class=\"operator\">=</span> <span class=\"number\">8</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">DEFAULT_MIN_IDLE</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">int</span> <span class=\"variable\">maxTotal</span> <span class=\"operator\">=</span> DEFAULT_MAX_TOTAL;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">int</span> <span class=\"variable\">maxIdle</span> <span class=\"operator\">=</span> DEFAULT_MAX_IDLE;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">int</span> <span class=\"variable\">minIdle</span> <span class=\"operator\">=</span> DEFAULT_MIN_IDLE;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> ResourcePoolConfig <span class=\"title function_\">build</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 校验逻辑放到这里来做，包括必填项校验、依赖关系校验、约束条件校验等</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (StringUtils.isBlank(name)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IllegalArgumentException</span>(<span class=\"string\">&quot;...&quot;</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (maxIdle &gt; maxTotal) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IllegalArgumentException</span>(<span class=\"string\">&quot;...&quot;</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (minIdle &gt; maxTotal || minIdle &gt; maxIdle) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IllegalArgumentException</span>(<span class=\"string\">&quot;...&quot;</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ResourcePoolConfig</span>(<span class=\"built_in\">this</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Builder <span class=\"title function_\">setName</span><span class=\"params\">(String name)</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (StringUtils.isBlank(name)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IllegalArgumentException</span>(<span class=\"string\">&quot;...&quot;</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.name = name;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Builder <span class=\"title function_\">setMaxTotal</span><span class=\"params\">(<span class=\"type\">int</span> maxTotal)</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (maxTotal &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IllegalArgumentException</span>(<span class=\"string\">&quot;...&quot;</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.maxTotal = maxTotal;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Builder <span class=\"title function_\">setMaxIdle</span><span class=\"params\">(<span class=\"type\">int</span> maxIdle)</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (maxIdle &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IllegalArgumentException</span>(<span class=\"string\">&quot;...&quot;</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.maxIdle = maxIdle;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Builder <span class=\"title function_\">setMinIdle</span><span class=\"params\">(<span class=\"type\">int</span> minIdle)</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (minIdle &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IllegalArgumentException</span>(<span class=\"string\">&quot;...&quot;</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.minIdle = minIdle;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 这段代码会抛出IllegalArgumentException，因为minIdle&gt;maxIdle</span></span><br><span class=\"line\"><span class=\"type\">ResourcePoolConfig</span> <span class=\"variable\">config</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ResourcePoolConfig</span>.Builder()</span><br><span class=\"line\">        .setName(<span class=\"string\">&quot;dbconnectionpool&quot;</span>)</span><br><span class=\"line\">        .setMaxTotal(<span class=\"number\">16</span>)</span><br><span class=\"line\">        .setMaxIdle(<span class=\"number\">10</span>)</span><br><span class=\"line\">        .setMinIdle(<span class=\"number\">12</span>)</span><br><span class=\"line\">        .build();</span><br></pre></td></tr></table></figure>\n\n\n\n<p>实际上，使用建造者模式创建对象，还能避免对象存在无效状态。我再举个例子解释一下。比如我们定义了一个长方形类，如果不使用建造者模式，采用先创建后 set 的方式，那就会导致在第一个 set 之后，对象处于无效状态。具体代码如下所示</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Rectangle</span> <span class=\"variable\">r</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Rectange</span>(); <span class=\"comment\">// r is invalid</span></span><br><span class=\"line\">r.setWidth(<span class=\"number\">2</span>); <span class=\"comment\">// r is invalid</span></span><br><span class=\"line\">r.setHeight(<span class=\"number\">3</span>); <span class=\"comment\">// r is valid</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>这里是说，长方形必须同时具备宽、高两个属性才是一个有效的长方形。只有其中一个属性，这个长方形对象就没有意义，是无效的。</p>\n</blockquote>\n<ol>\n<li>为了避免这种无效状态的存在，我们就需要使用构造函数一次性初始化好所有的成员变量。如果构造函数参数过多，我们就需要考虑使用建造者模式，先设置建造者的变量，然后再一次性地创建对象，让对象一直处于有效状态。(建造者主要解决参数过多、参数检验、控制对象创建后不可变的问题)</li>\n<li>实际上，如果我们并不是很关心对象是否有短暂的无效状态，也不是太在意对象是否是可变的。比如，对象只是用来映射数据库读出来的数据，那我们直接暴露 set() 方法来设置类的成员变量值是完全没问题的。而且，使用建造者模式来构建对象，代码实际上是有点重复的，ResourcePoolConfig 类中的成员变量，要在 Builder 类中重新再定义一遍。</li>\n</ol>\n<h2 id=\"与工厂模式有何区别？\"><a href=\"#与工厂模式有何区别？\" class=\"headerlink\" title=\"与工厂模式有何区别？\"></a>与工厂模式有何区别？</h2><ol>\n<li>从上面的讲解中，我们可以看出，建造者模式是让建造者类来负责对象的创建工作。上面讲到的工厂模式，是由工厂类来负责对象创建的工作。那它们之间有什么区别呢？</li>\n<li>实际上，工厂模式是用来创建不同但是相关类型的对象（继承同一父类或者接口的一组子类），由给定的参数来决定创建哪种类型的对象。建造者模式是用来创建一种类型的复杂对象，通过设置不同的可选参数，“定制化”地创建不同的对象。</li>\n</ol>\n<p>网上有一个经典的例子很好地解释了两者的区别:</p>\n<blockquote>\n<p>顾客走进一家餐馆点餐，我们利用工厂模式，根据用户不同的选择，来制作不同的食物，比如披萨、汉堡、沙拉。对于披萨来说，用户又有各种配料可以定制，比如奶酪、西红柿、起司，我们通过建造者模式根据用户选择的不同配料来制作披萨。</p>\n</blockquote>\n<p>实际上，我们也不要太学院派，非得把工厂模式、建造者模式分得那么清楚，我们需要知道的是，每个模式为什么这么设计，能解决什么问题。只有了解了这些最本质的东西，我们才能不生搬硬套，才能灵活应用，甚至可以混用各种模式创造出新的模式，来解决特定场景的问题。</p>\n<h1 id=\"原型模式【不常用】\"><a href=\"#原型模式【不常用】\" class=\"headerlink\" title=\"原型模式【不常用】\"></a>原型模式【不常用】</h1><p>今天的讲解跟具体某一语言的语法机制无关，而是通过一个 clone 散列表的例子带你搞清楚：原型模式的应用场景，以及它的两种实现方式：深拷贝和浅拷贝。虽然原型模式的原理和代码实现非常简单，但今天举的例子还是稍微有点复杂的</p>\n<h2 id=\"原型模式的原理与应用\"><a href=\"#原型模式的原理与应用\" class=\"headerlink\" title=\"原型模式的原理与应用\"></a>原型模式的原理与应用</h2><p>如果对象的创建成本比较大，而同一个类的不同对象之间差别不大（大部分字段都相同），在这种情况下，我们可以利用对已有对象（原型）进行复制（或者叫拷贝）的方式来创建新对象，以达到节省创建时间的目的。这种基于原型来创建对象的方式就叫作原型设计模式（Prototype Design Pattern），简称原型模式。</p>\n<blockquote>\n<p>那何为“对象的创建成本比较大”？</p>\n</blockquote>\n<ol>\n<li>实际上，创建对象包含的申请内存、给成员变量赋值这一过程，本身并不会花费太多时间，或者说对于大部分业务系统来说，这点时间完全是可以忽略的。应用一个复杂的模式，只得到一点点的性能提升，这就是所谓的过度设计，得不偿失。</li>\n<li>但是，如果对象中的数据需要经过复杂的计算才能得到（比如排序、计算哈希值），或者需要从 RPC、网络、数据库、文件系统等非常慢速的 IO 中读取，这种情况下，我们就可以利用原型模式，从其他已有对象中直接拷贝得到，而不用每次在创建新对象的时候，都重复执行这些耗时的操作。</li>\n</ol>\n<blockquote>\n<p>这么说还是比较理论，接下来，我们通过一个例子来解释一下刚刚这段话。</p>\n</blockquote>\n<ol>\n<li>假设数据库中存储了大约 10 万条“搜索关键词”信息，每条信息包含关键词、关键词被搜索的次数、信息最近被更新的时间等。系统 A 在启动的时候会加载这份数据到内存中，用于处理某些其他的业务需求。为了方便快速地查找某个关键词对应的信息，我们给关键词建立一个散列表索引。</li>\n<li>如果你熟悉的是 Java 语言，可以直接使用语言中提供的 HashMap 容器来实现。其中，HashMap 的 key 为搜索关键词，value 为关键词详细信息（比如搜索次数）。我们只需要将数据从数据库中读取出来，放入 HashMap 就可以了。</li>\n<li>不过，我们还有另外一个系统 B，专门用来分析搜索日志，定期（比如间隔 10 分钟）批量地更新数据库中的数据，并且标记为新的数据版本。比如，在下面的示例图中，我们对 v2 版本的数据进行更新，得到 v3 版本的数据。这里我们假设只有更新和新添关键词，没有删除关键词的行为。</li>\n</ol>\n<img src=\"https://npm.elemecdn.com/youthlql@1.0.0/design_patterns/creational/03.02/0002.png\"/>\n\n\n\n<ol>\n<li>为了保证系统 A 中数据的实时性（不一定非常实时，但数据也不能太旧），系统 A 需要定期根据数据库中的数据，更新内存中的索引和数据。</li>\n<li>我们该如何实现这个需求呢？实际上，也不难。我们只需要在系统 A 中，记录当前数据的版本 Va 对应的更新时间 Ta，从数据库中捞出更新时间大于 Ta 的所有搜索关键词，也就是找出 Va 版本与最新版本数据的“差集”，然后针对差集中的每个关键词进行处理。如果它已经在散列表中存在了，我们就更新相应的搜索次数、更新时间等信息；如果它在散列表中不存在，我们就将它插入到散列表中。</li>\n<li>按照这个设计思路，我给出的示例代码如下所示：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Demo</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> ConcurrentHashMap&lt;String, SearchWord&gt; currentKeywords = <span class=\"keyword\">new</span> <span class=\"title class_\">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"type\">long</span> <span class=\"variable\">lastUpdateTime</span> <span class=\"operator\">=</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">refresh</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 从数据库中取出更新时间&gt;lastUpdateTime的数据，放入到currentKeywords中</span></span><br><span class=\"line\">    List&lt;SearchWord&gt; toBeUpdatedSearchWords = getSearchWords(lastUpdateTime);</span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"variable\">maxNewUpdatedTime</span> <span class=\"operator\">=</span> lastUpdateTime;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (SearchWord searchWord : toBeUpdatedSearchWords) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (searchWord.getLastUpdateTime() &gt; maxNewUpdatedTime) &#123;</span><br><span class=\"line\">        maxNewUpdatedTime = searchWord.getLastUpdateTime();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (currentKeywords.containsKey(searchWord.getKeyword())) &#123;</span><br><span class=\"line\">        currentKeywords.replace(searchWord.getKeyword(), searchWord);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        currentKeywords.put(searchWord.getKeyword(), searchWord);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    lastUpdateTime = maxNewUpdatedTime;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> List&lt;SearchWord&gt; <span class=\"title function_\">getSearchWords</span><span class=\"params\">(<span class=\"type\">long</span> lastUpdateTime)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// <span class=\"doctag\">TODO:</span> 从数据库中取出更新时间&gt;lastUpdateTime的数据</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>不过，现在，我们有一个特殊的要求：任何时刻，系统 A 中的所有数据都必须是同一个版本的，要么都是版本 a，要么都是版本 b，不能有的是版本 a，有的是版本 b。那刚刚的更新方式就不能满足这个要求了（因为数据很多，一个一个的for循环肯定会出现不同数据版本的问题）。除此之外，我们还要求：在更新内存数据的时候，系统 A 不能处于不可用状态，也就是不能停机更新数据。</p>\n<ol>\n<li><p>那我们该如何实现现在这个需求呢？</p>\n</li>\n<li><p>实际上，也不难。我们把正在使用的数据的版本定义为“服务版本”，当我们要更新内存中的数据的时候，我们并不是直接在服务版本（假设是版本 a 数据）上更新，而是重新创建另一个版本数据（假设是版本 b 数据），等新的版本数据建好之后，再一次性地将服务版本从版本 a 切换到版本 b。这样既保证了数据一直可用，又避免了中间状态的存在。</p>\n</li>\n<li><p>按照这个设计思路，我给出的示例代码如下所示：</p>\n</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Demo</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> HashMap&lt;String, SearchWord&gt; currentKeywords=<span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">refresh</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    HashMap&lt;String, SearchWord&gt; newKeywords = <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedHashMap</span>&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 从数据库中取出所有的数据，放入到newKeywords中</span></span><br><span class=\"line\">    List&lt;SearchWord&gt; toBeUpdatedSearchWords = getSearchWords();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (SearchWord searchWord : toBeUpdatedSearchWords) &#123;</span><br><span class=\"line\">      newKeywords.put(searchWord.getKeyword(), searchWord);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    currentKeywords = newKeywords;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> List&lt;SearchWord&gt; <span class=\"title function_\">getSearchWords</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// <span class=\"doctag\">TODO:</span> 从数据库中取出所有的数据</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<ol>\n<li>不过，在上面的代码实现中，newKeywords 构建的成本比较高。我们需要将这 10 万条数据从数据库中读出，然后计算哈希值，构建 newKeywords。这个过程显然是比较耗时。为了提高效率，原型模式就派上用场了。</li>\n<li>我们拷贝 currentKeywords 数据到 newKeywords 中，然后从数据库中只捞出新增或者有更新的关键词，更新到 newKeywords 中。而相对于 10 万条数据来说，每次新增或者更新的关键词个数是比较少的，所以，这种策略大大提高了数据更新的效率。</li>\n<li>按照这个设计思路，我给出的示例代码如下所示：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Demo</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> HashMap&lt;String, SearchWord&gt; currentKeywords=<span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;();</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"type\">long</span> <span class=\"variable\">lastUpdateTime</span> <span class=\"operator\">=</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">refresh</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 原型模式就这么简单，拷贝已有对象的数据，更新少量差值</span></span><br><span class=\"line\">    HashMap&lt;String, SearchWord&gt; newKeywords = (HashMap&lt;String, SearchWord&gt;) currentKeywords.clone();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 从数据库中取出更新时间&gt;lastUpdateTime的数据，放入到newKeywords中</span></span><br><span class=\"line\">    List&lt;SearchWord&gt; toBeUpdatedSearchWords = getSearchWords(lastUpdateTime);</span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"variable\">maxNewUpdatedTime</span> <span class=\"operator\">=</span> lastUpdateTime;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (SearchWord searchWord : toBeUpdatedSearchWords) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (searchWord.getLastUpdateTime() &gt; maxNewUpdatedTime) &#123;</span><br><span class=\"line\">        maxNewUpdatedTime = searchWord.getLastUpdateTime();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (newKeywords.containsKey(searchWord.getKeyword())) &#123;</span><br><span class=\"line\">        <span class=\"type\">SearchWord</span> <span class=\"variable\">oldSearchWord</span> <span class=\"operator\">=</span> newKeywords.get(searchWord.getKeyword());</span><br><span class=\"line\">        oldSearchWord.setCount(searchWord.getCount());</span><br><span class=\"line\">        oldSearchWord.setLastUpdateTime(searchWord.getLastUpdateTime());</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        newKeywords.put(searchWord.getKeyword(), searchWord);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    lastUpdateTime = maxNewUpdatedTime;</span><br><span class=\"line\">    currentKeywords = newKeywords;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> List&lt;SearchWord&gt; <span class=\"title function_\">getSearchWords</span><span class=\"params\">(<span class=\"type\">long</span> lastUpdateTime)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// <span class=\"doctag\">TODO:</span> 从数据库中取出更新时间&gt;lastUpdateTime的数据</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>这里我们利用了 Java 中的 clone() 语法来复制一个对象。如果你熟悉的语言没有这个语法，那把数据从 currentKeywords 中一个个取出来，然后再重新计算哈希值，放入到 newKeywords 中也是可以接受的。毕竟，最耗时的还是从数据库中取数据的操作。相对于数据库的 IO 操作来说，内存操作和 CPU 计算的耗时都是可以忽略的。</li>\n<li>不过，不知道你有没有发现，实际上，刚刚的代码实现是有问题的。要弄明白到底有什么问题，我们需要先了解另外两个概念：深拷贝（Deep Copy）和浅拷贝（Shallow Copy）。</li>\n</ol>\n<h2 id=\"原型模式的实现方式：深拷贝和浅拷贝\"><a href=\"#原型模式的实现方式：深拷贝和浅拷贝\" class=\"headerlink\" title=\"原型模式的实现方式：深拷贝和浅拷贝\"></a>原型模式的实现方式：深拷贝和浅拷贝</h2><blockquote>\n<p>1、关于深拷贝浅拷贝，我觉得这篇文章讲的不错：<a href=\"https://blog.csdn.net/baiye_xing/article/details/71788741\">https://blog.csdn.net/baiye_xing/article/details/71788741</a></p>\n</blockquote>\n<blockquote>\n<p>我自己的总结：</p>\n<p><strong>浅拷贝</strong>：对一个对象进行拷贝时，这个对象对应的类里的成员变量。</p>\n<ul>\n<li>对于数据类型是基本数据类型的成员变量，浅拷贝会直接进行值拷贝，也就是将该属性值复制一份给新的对象。因为是两份不同的数据，所以对其中一个对象的该成员变量值进行修改，不会影响另一个对象拷贝得到的数据</li>\n<li>对于数据类型是引用数据类型的成员变量(也就是子对象，或者数组啥的)，也就是只是将该成员变量的引用值（引用拷贝【并发引用传递，Java本质还是值传递】）复制一份给新的对象。因为实际上两个对象的该成员变量都指向同一个实例。在这种情况下，在一个对象中修改该成员变量会影响到另一个对象的该成员变量值。</li>\n</ul>\n<ol>\n<li><strong>深拷贝</strong>：对基本数据类型进行值传递，对引用数据类型，创建一个新的对象，并复制其内容，此为深拷贝。</li>\n<li>也就是说浅拷贝对于子对象只是拷贝了引用值，并没有真正的拷贝整个对象。</li>\n</ol>\n<p><strong>深拷贝实现思路：</strong></p>\n<ol>\n<li><p>对于每个子对象都实现Cloneable 接口，并重写clone方法。最后在最顶层的类的重写的 clone 方法中调用所有子对象的 clone 方法即可实现深拷贝。【简单的说就是：每一层的每个子对象都进行浅拷贝&#x3D;深拷贝】</p>\n</li>\n<li><p>利用序列化。【先对对象进行序列化，紧接着马上反序列化出 】</p>\n</li>\n</ol>\n</blockquote>\n<p>我们来看，在内存中，用散列表组织的搜索关键词信息是如何存储的。我画了一张示意图，大致结构如下所示。从图中我们可以发现，散列表索引中，每个结点存储的 key 是搜索关键词，value 是 SearchWord 对象的内存地址。SearchWord 对象本身存储在散列表之外的内存空间中。</p>\n<img src=\"https://npm.elemecdn.com/youthlql@1.0.0/design_patterns/creational/03.02/0003.png\"  />\n\n<p>浅拷贝和深拷贝的区别在于，浅拷贝只会复制图中的索引（散列表），不会复制数据（SearchWord 对象）本身。相反，深拷贝不仅仅会复制索引，还会复制数据本身。浅拷贝得到的对象（newKeywords）跟原始对象（currentKeywords）共享数据（SearchWord 对象），而深拷贝得到的是一份完完全全独立的对象。具体的对比如下图所示：</p>\n<img src=\"https://npm.elemecdn.com/youthlql@1.0.0/design_patterns/creational/03.02/0004.png\"/>\n\n\n\n<img src=\"https://npm.elemecdn.com/youthlql@1.0.0/design_patterns/creational/03.02/0005.png\" />\n\n\n\n<ol>\n<li><p>在 Java 语言中，Object 类的 clone() 方法执行的就是我们刚刚说的浅拷贝。它只会拷贝对象中的基本数据类型的数据（比如，int、long），以及引用对象（SearchWord）的内存地址，不会递归地拷贝引用对象本身。</p>\n</li>\n<li><p>在上面的代码中，我们通过调用 HashMap 上的 clone() 浅拷贝方法来实现原型模式。当我们通过 newKeywords 更新 SearchWord 对象的时候（比如，更新“设计模式”这个搜索关键词的访问次数），newKeywords 和 currentKeywords 因为指向相同的一组 SearchWord 对象，就会导致 currentKeywords 中指向的 SearchWord，有的是老版本的，有的是新版本的，就没法满足我们之前的需求：currentKeywords 中的数据在任何时刻都是同一个版本的，不存在介于老版本与新版本之间的中间状态。</p>\n</li>\n<li><p>现在，我们又该如何来解决这个问题呢？</p>\n</li>\n<li><p>我们可以将浅拷贝替换为深拷贝。newKeywords 不仅仅复制 currentKeywords 的索引，还把 SearchWord 对象也复制一份出来，这样 newKeywords 和 currentKeywords 就指向不同的 SearchWord 对象，也就不存在更新 newKeywords 的数据会导致 currentKeywords 的数据也被更新的问题了。</p>\n</li>\n<li><p>那如何实现深拷贝呢？总结一下的话，有下面两种方法。</p>\n</li>\n</ol>\n<p>第一种方法：递归拷贝对象、对象的引用对象以及引用对象的引用对象……直到要拷贝的对象只包含基本数据类型数据，没有引用对象为止。根据这个思路对之前的代码进行重构。重构之后的代码如下所示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Demo</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> HashMap&lt;String, SearchWord&gt; currentKeywords=<span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;();</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"type\">long</span> <span class=\"variable\">lastUpdateTime</span> <span class=\"operator\">=</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">refresh</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Deep copy</span></span><br><span class=\"line\">    HashMap&lt;String, SearchWord&gt; newKeywords = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (HashMap.Entry&lt;String, SearchWord&gt; e : currentKeywords.entrySet()) &#123;</span><br><span class=\"line\">      <span class=\"type\">SearchWord</span> <span class=\"variable\">searchWord</span> <span class=\"operator\">=</span> e.getValue();</span><br><span class=\"line\">      <span class=\"type\">SearchWord</span> <span class=\"variable\">newSearchWord</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">SearchWord</span>(</span><br><span class=\"line\">              searchWord.getKeyword(), searchWord.getCount(), searchWord.getLastUpdateTime());</span><br><span class=\"line\">      newKeywords.put(e.getKey(), newSearchWord);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 从数据库中取出更新时间&gt;lastUpdateTime的数据，放入到newKeywords中</span></span><br><span class=\"line\">    List&lt;SearchWord&gt; toBeUpdatedSearchWords = getSearchWords(lastUpdateTime);</span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"variable\">maxNewUpdatedTime</span> <span class=\"operator\">=</span> lastUpdateTime;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (SearchWord searchWord : toBeUpdatedSearchWords) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (searchWord.getLastUpdateTime() &gt; maxNewUpdatedTime) &#123;</span><br><span class=\"line\">        maxNewUpdatedTime = searchWord.getLastUpdateTime();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (newKeywords.containsKey(searchWord.getKeyword())) &#123;</span><br><span class=\"line\">        <span class=\"type\">SearchWord</span> <span class=\"variable\">oldSearchWord</span> <span class=\"operator\">=</span> newKeywords.get(searchWord.getKeyword());</span><br><span class=\"line\">        oldSearchWord.setCount(searchWord.getCount());</span><br><span class=\"line\">        oldSearchWord.setLastUpdateTime(searchWord.getLastUpdateTime());</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        newKeywords.put(searchWord.getKeyword(), searchWord);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    lastUpdateTime = maxNewUpdatedTime;</span><br><span class=\"line\">    currentKeywords = newKeywords;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> List&lt;SearchWord&gt; <span class=\"title function_\">getSearchWords</span><span class=\"params\">(<span class=\"type\">long</span> lastUpdateTime)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// <span class=\"doctag\">TODO:</span> 从数据库中取出更新时间&gt;lastUpdateTime的数据</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>第二种方法：先将对象序列化，然后再反序列化成新的对象。具体的示例代码如下所示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> Object <span class=\"title function_\">deepCopy</span><span class=\"params\">(Object object)</span> &#123;</span><br><span class=\"line\">  <span class=\"type\">ByteArrayOutputStream</span> <span class=\"variable\">bo</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ByteArrayOutputStream</span>();</span><br><span class=\"line\">  <span class=\"type\">ObjectOutputStream</span> <span class=\"variable\">oo</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ObjectOutputStream</span>(bo);</span><br><span class=\"line\">  oo.writeObject(object);</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"type\">ByteArrayInputStream</span> <span class=\"variable\">bi</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ByteArrayInputStream</span>(bo.toByteArray());</span><br><span class=\"line\">  <span class=\"type\">ObjectInputStream</span> <span class=\"variable\">oi</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ObjectInputStream</span>(bi);</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">return</span> oi.readObject();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>刚刚的两种实现方法，不管采用哪种，深拷贝都要比浅拷贝耗时、耗内存空间。针对我们这个应用场景，有没有更快、更省内存的实现方式呢？</li>\n<li>我们可以先采用浅拷贝的方式创建 newKeywords。对于需要更新的 SearchWord 对象，我们再使用深度拷贝的方式创建一份新的对象，替换 newKeywords 中的老对象。毕竟需要更新的数据是很少的。这种方式即利用了浅拷贝节省时间、空间的优点，又能保证 currentKeywords 中的中数据都是老版本的数据。具体的代码实现如下所示。这也是标题中讲到的，在我们这个应用场景下，最快速 clone 散列表的方式。</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Demo</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> HashMap&lt;String, SearchWord&gt; currentKeywords=<span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;();</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"type\">long</span> <span class=\"variable\">lastUpdateTime</span> <span class=\"operator\">=</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">refresh</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Shallow copy</span></span><br><span class=\"line\">    HashMap&lt;String, SearchWord&gt; newKeywords = (HashMap&lt;String, SearchWord&gt;) currentKeywords.clone();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 从数据库中取出更新时间&gt;lastUpdateTime的数据，放入到newKeywords中</span></span><br><span class=\"line\">    List&lt;SearchWord&gt; toBeUpdatedSearchWords = getSearchWords(lastUpdateTime);</span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"variable\">maxNewUpdatedTime</span> <span class=\"operator\">=</span> lastUpdateTime;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (SearchWord searchWord : toBeUpdatedSearchWords) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (searchWord.getLastUpdateTime() &gt; maxNewUpdatedTime) &#123;</span><br><span class=\"line\">        maxNewUpdatedTime = searchWord.getLastUpdateTime();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (newKeywords.containsKey(searchWord.getKeyword())) &#123;</span><br><span class=\"line\">        newKeywords.remove(searchWord.getKeyword());</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      newKeywords.put(searchWord.getKeyword(), searchWord);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    lastUpdateTime = maxNewUpdatedTime;</span><br><span class=\"line\">    currentKeywords = newKeywords;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> List&lt;SearchWord&gt; <span class=\"title function_\">getSearchWords</span><span class=\"params\">(<span class=\"type\">long</span> lastUpdateTime)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// <span class=\"doctag\">TODO:</span> 从数据库中取出更新时间&gt;lastUpdateTime的数据</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"},{"title":"设计模式-02.经典设计原则-第二节[必读]","keywords":"设计模式，经典设计原则","description":"设计模式-经典设计原则，例如：迪米特法则，依赖反转原则，KISS等等。","cover":"https://npm.elemecdn.com/lql_static@latest/logo/design_patterns.jpg","abbrlink":"994a8ed3","date":"2024-05-01T05:28:50.000Z","_content":"\n# 声明\n\n> 1. 此系列文章非本人原创，是学习笔记。\n> 2. 设计模式系列以后会持续更新，包括已经发布的设计模式文章，因为后续还要再多看一下书，教程和开源项目等，继续润色文章。\n\n# 设计模式经典设计原则-第二节\n\n## 依赖反转原则（DIP）\n\n关于 SOLID 原则，我们已经学过单一职责、开闭、里式替换、接口隔离这四个原则。今天，我们再来学习最后一个原则：依赖反转原则。在前面，我们讲到，单一职责原则和开闭原则的原理比较简单，但是，想要在实践中用好却比较难。而今天我们要讲到的依赖反转原则正好相反。这个原则用起来比较简单，但概念理解起来比较难。比如，下面这几个问题，你看看能否清晰地回答出来：\n\n- “依赖反转”这个概念指的是“谁跟谁”的“什么依赖”被反转了？“反转”两个字该如何理解？\n- 我们还经常听到另外两个概念：“控制反转”和“依赖注入”。这两个概念跟“依赖反转”有什么区别和联系呢？它们说的是同一个事情吗？\n- 如果你熟悉 Java 语言，那 Spring 框架中的 IOC 跟这些概念又有什么关系呢？\n\n\n\n### 控制反转（IOC）\n\n在讲“依赖反转原则”之前，我们先讲一讲“控制反转”。控制反转的英文翻译是 Inversion Of Control，缩写为 IOC。此处我要强调一下，暂时别把这个“IOC”跟 Spring 框架的 IOC 联系在一起。关于 Spring 的 IOC，我们待会儿还会讲到。我们先通过一个例子来看一下，什么是控制反转。\n\n```java\npublic class UserServiceTest {\n  public static boolean doTest() {\n    // ... \n  }\n  \n  public static void main(String[] args) {//这部分逻辑可以放到框架中\n    if (doTest()) {\n      System.out.println(\"Test succeed.\");\n    } else {\n      System.out.println(\"Test failed.\");\n    }\n  }\n}\n```\n\n在上面的代码中，所有的流程都由程序员来控制。如果我们抽象出一个下面这样一个框架，我们再来看，如何利用框架来实现同样的功能。具体的代码实现如下所示：\n\n\n\n```java\npublic abstract class TestCase {\n  public void run() {\n    if (doTest()) {\n      System.out.println(\"Test succeed.\");\n    } else {\n      System.out.println(\"Test failed.\");\n    }\n  }\n  \n  public abstract boolean doTest();\n}\n\npublic class JunitApplication {\n  private static final List<TestCase> testCases = new ArrayList<>();\n  \n  public static void register(TestCase testCase) {\n    testCases.add(testCase);\n  }\n  \n  public static final void main(String[] args) {\n    for (TestCase case: testCases) {\n      case.run();\n    }\n  }\n```\n\n把这个简化版本的测试框架引入到工程中之后，我们只需要在框架预留的扩展点，也就是 TestCase 类中的 doTest() 抽象函数中，填充具体的测试代码就可以实现之前的功能了，完全不需要写负责执行流程的 main() 函数了。 具体的代码如下所示：\n\n```java\npublic class UserServiceTest extends TestCase {\n  @Override\n  public boolean doTest() {\n    // ... \n  }\n}\n\n// 注册操作还可以通过配置的方式来实现，不需要程序员显示调用register()\nJunitApplication.register(new UserServiceTest();\n```\n\n\n\n1. 刚刚举的这个例子，就是典型的通过框架来实现“控制反转”的例子。框架提供了一个可扩展的代码骨架，用来组装对象、管理整个执行流程。程序员利用框架进行开发的时候，只需要往预留的扩展点上，添加跟自己业务相关的代码，就可以利用框架来驱动整个程序流程的执行。\n2. 这里的“控制”指的是对程序执行流程的控制，而“反转”指的是在没有使用框架之前，程序员自己控制整个程序的执行。在使用框架之后，整个程序的执行流程可以通过框架来控制。流程的控制权从程序员“反转”到了框架。\n3. 实际上，实现控制反转的方法有很多，除了刚才例子中所示的类似于模板设计模式的方法之外，还有马上要讲到的依赖注入等方法，所以，控制反转并不是一种具体的实现技巧，而是一个比较笼统的设计思想，一般用来指导框架层面的设计。\n\n\n\n### 依赖注入（DI）\n\n1. 接下来，我们再来看依赖注入。依赖注入跟控制反转恰恰相反，它是一种具体的编码技巧。那到底什么是依赖注入呢？我们用一句话来概括就是：不通过 new() 的方式在类内部创建依赖类对象，而是将依赖的类对象在外部创建好之后，通过构造函数、函数参数等方式传递（或注入）给类使用。\n2. 我们还是通过一个例子来解释一下。在这个例子中，Notification 类负责消息推送，依赖 MessageSender 类实现推送商品促销、验证码等消息给用户。我们分别用依赖注入和非依赖注入两种方式来实现一下。具体的实现代码如下所示：\n\n\n\n```java\n// 非依赖注入实现方式\npublic class Notification {\n  private MessageSender messageSender;\n  \n  public Notification() {\n    this.messageSender = new MessageSender(); //此处有点像hardcode\n  }\n  \n  public void sendMessage(String cellphone, String message) {\n    //...省略校验逻辑等...\n    this.messageSender.send(cellphone, message);\n  }\n}\n\npublic class MessageSender {\n  public void send(String cellphone, String message) {\n    //....\n  }\n}\n// 使用Notification\nNotification notification = new Notification();\n\n// 依赖注入的实现方式\npublic class Notification {\n  private MessageSender messageSender;\n  \n  // 通过构造函数将messageSender传递进来\n  public Notification(MessageSender messageSender) {\n    this.messageSender = messageSender;\n  }\n  \n  public void sendMessage(String cellphone, String message) {\n    //...省略校验逻辑等...\n    this.messageSender.send(cellphone, message);\n  }\n}\n//使用Notification\nMessageSender messageSender = new MessageSender();\nNotification notification = new Notification(messageSender);\n```\n\n通过依赖注入的方式来将依赖的类对象传递进来，这样就提高了代码的扩展性，我们可以灵活地替换依赖的类。这一点在我们之前讲“开闭原则”的时候也提到过。当然，上面代码还有继续优化的空间，我们还可以把 MessageSender 定义成接口，基于接口而非实现编程。改造后的代码如下所示：\n\n\n\n```java\npublic class Notification {\n  private MessageSender messageSender;\n  \n  public Notification(MessageSender messageSender) {\n    this.messageSender = messageSender;\n  }\n  \n  public void sendMessage(String cellphone, String message) {\n    this.messageSender.send(cellphone, message);\n  }\n}\n\npublic interface MessageSender {\n  void send(String cellphone, String message);\n}\n\n// 短信发送类\npublic class SmsSender implements MessageSender {\n  @Override\n  public void send(String cellphone, String message) {\n    //....\n  }\n}\n\n// 站内信发送类\npublic class InboxSender implements MessageSender {\n  @Override\n  public void send(String cellphone, String message) {\n    //....\n  }\n}\n\n//使用Notification\nMessageSender messageSender = new SmsSender();\nNotification notification = new Notification(messageSender);\n```\n\n\n\n实际上，你只需要掌握刚刚举的这个例子，就等于完全掌握了依赖注入。尽管依赖注入非常简单，但却非常有用，\n\n\n\n### 依赖注入框架（DI Framework）\n\n弄懂了什么是“依赖注入”，我们再来看一下，什么是“依赖注入框架”。我们还是借用刚刚的例子来解释。在采用依赖注入实现的 Notification 类中，虽然我们不需要用类似 hard code 的方式，在类内部通过 new 来创建 MessageSender 对象，但是，这个创建对象、组装（或注入）对象的工作仅仅是被移动到了更上层代码而已，还是需要我们程序员自己来实现。具体代码如下所示：\n\n\n\n```java\npublic class Demo {\n  public static final void main(String args[]) {\n    MessageSender sender = new SmsSender(); //创建对象\n    Notification notification = new Notification(sender);//依赖注入\n    notification.sendMessage(\"13918942177\", \"短信验证码：2346\");\n  }\n}\n```\n\n1. 在实际的软件开发中，一些项目可能会涉及几十、上百、甚至几百个类，类对象的创建和依赖注入会变得非常复杂。如果这部分工作都是靠程序员自己写代码来完成，容易出错且开发成本也比较高。而对象创建和依赖注入的工作，本身跟具体的业务无关，我们完全可以抽象成框架来自动完成。\n2. 你可能已经猜到，这个框架就是“依赖注入框架”。我们只需要通过依赖注入框架提供的扩展点，简单配置一下所有需要创建的类对象、类与类之间的依赖关系，就可以实现由框架来自动创建对象、管理对象的生命周期、依赖注入等原本需要程序员来做的事情。\n3. 实际上，现成的依赖注入框架有很多，比如 Google Guice、Java Spring、Pico Container、Butterfly Container 等。不过，如果你熟悉 Java Spring 框架，你可能会说，Spring 框架自己声称是控制反转容器（Inversion Of Control Container）。\n4. 实际上，这两种说法都没错。只是控制反转容器这种表述是一种非常宽泛的描述，DI 依赖注入框架的表述更具体、更有针对性。因为我们前面讲到实现控制反转的方式有很多，除了依赖注入，还有模板模式等，而 Spring 框架的控制反转主要是通过依赖注入来实现的。不过这点区分并不是很明显，也不是很重要，你稍微了解一下就可以了。\n\n\n\n### 什么是依赖反转原则？\n\n\n\n1. 前面讲了控制反转、依赖注入、依赖注入框架，现在，我们来讲一讲今天的主角：依赖反转原则。依赖反转原则的英文翻译是 Dependency Inversion Principle，缩写为 DIP。中文翻译有时候也叫依赖倒置原则。\n2. 英文描述：High-level modules shouldn’t depend on low-level modules. Both modules should depend on abstractions. In addition, abstractions shouldn’t depend on details. Details depend on abstractions.\n3. 我们将它翻译成中文，大概意思就是：高层模块（high-level modules）不要依赖低层模块（low-level）。高层模块和低层模块应该通过抽象（abstractions）来互相依赖。除此之外，抽象（abstractions）不要依赖具体实现细节（details），具体实现细节（details）依赖抽象（abstractions）。\n4. 所谓高层模块和低层模块的划分，简单来说就是，在调用链上，调用者属于高层，被调用者属于低层。在平时的业务代码开发中，高层模块依赖底层模块是没有任何问题的。实际上，这条原则主要还是用来指导框架层面的设计，跟前面讲到的控制反转类似。我们拿 Tomcat 这个 Servlet 容器作为例子来解释一下。\n5. Tomcat 是运行 Java Web 应用程序的容器。我们编写的 Web 应用程序代码只需要部署在 Tomcat 容器下，便可以被 Tomcat 容器调用执行。按照之前的划分原则，Tomcat 就是高层模块，我们编写的 Web 应用程序代码就是低层模块。Tomcat 和应用程序代码之间并没有直接的依赖关系，两者都依赖同一个“抽象”，也就是 Servlet 规范。Servlet 规范不依赖具体的 Tomcat 容器和应用程序的实现细节，而 Tomcat 容器和应用程序依赖 Servlet 规范。\n\n\n\n## KISS原则和YAGNI原则\n\n\n\n1. 我们学习了经典的 SOLID 原则。今天，我们讲两个设计原则：KISS 原则和 YAGNI 原则。其中，KISS 原则比较经典，耳熟能详，但 YAGNI 你可能没怎么听过，不过它理解起来也不难。\n2. 理解这两个原则时候，经常会有一个共同的问题，那就是，看一眼就感觉懂了，但深究的话，又有很多细节问题不是很清楚。比如，怎么理解 KISS 原则中“简单”两个字？什么样的代码才算“简单”？怎样的代码才算“复杂”？如何才能写出“简单”的代码？YAGNI 原则跟 KISS 原则说的是一回事吗？\n\n\n\nKISS 原则的英文描述有好几个版本，比如下面这几个。\n\n- Keep It Simple and Stupid.\n- Keep It Short and Simple.\n- Keep It Simple and Straightforward.\n\n1. 不过，仔细看你就会发现，它们要表达的意思其实差不多，翻译成中文就是：尽量保持简单。\n\n2. 我们知道，代码的可读性和可维护性是衡量代码质量非常重要的两个标准。而 KISS 原则就是保持代码可读和可维护的重要手段。代码足够简单，也就意味着很容易读懂，bug 比较难隐藏。即便出现 bug，修复起来也比较简单。不过，这条原则只是告诉我们，要保持代码“Simple and Stupid”，但并没有讲到，什么样的代码才是“Simple and Stupid”的，更没有给出特别明确的方法论，来指导如何开发出“Simple and Stupid”的代码。\n3. 所以，接下来，为了能让这条原则切实地落地，能够指导实际的项目开发，我就针对刚刚的这些问题来进一步讲讲我的理解。\n\n\n\n### 代码行数越少就越“简单”吗？\n\n我们先一起看一个例子。下面这三段代码可以实现同样一个功能：检查输入的字符串 ipAddress 是否是合法的 IP 地址。一个合法的 IP 地址由四个数字组成，并且通过“.”来进行分割。每组数字的取值范围是 0~255。第一组数字比较特殊，不允许为 0。对比这三段代码，你觉得哪一段代码最符合 KISS 原则呢？如果让你来实现这个功能，你会选择用哪种实现方法呢？你可以先自己思考一下，然后再看我下面的讲解。\n\n```java\n// 第一种实现方式: 使用正则表达式\npublic boolean isValidIpAddressV1(String ipAddress) {\n  if (StringUtils.isBlank(ipAddress)) return false;\n  String regex = \"^(1\\\\d{2}|2[0-4]\\\\d|25[0-5]|[1-9]\\\\d|[1-9])\\\\.\"\n          + \"(1\\\\d{2}|2[0-4]\\\\d|25[0-5]|[1-9]\\\\d|\\\\d)\\\\.\"\n          + \"(1\\\\d{2}|2[0-4]\\\\d|25[0-5]|[1-9]\\\\d|\\\\d)\\\\.\"\n          + \"(1\\\\d{2}|2[0-4]\\\\d|25[0-5]|[1-9]\\\\d|\\\\d)$\";\n  return ipAddress.matches(regex);\n}\n\n// 第二种实现方式: 使用现成的工具类\npublic boolean isValidIpAddressV2(String ipAddress) {\n  if (StringUtils.isBlank(ipAddress)) return false;\n  String[] ipUnits = StringUtils.split(ipAddress, '.');\n  if (ipUnits.length != 4) {\n    return false;\n  }\n  for (int i = 0; i < 4; ++i) {\n    int ipUnitIntValue;\n    try {\n      ipUnitIntValue = Integer.parseInt(ipUnits[i]);\n    } catch (NumberFormatException e) {\n      return false;\n    }\n    if (ipUnitIntValue < 0 || ipUnitIntValue > 255) {\n      return false;\n    }\n    if (i == 0 && ipUnitIntValue == 0) {\n      return false;\n    }\n  }\n  return true;\n}\n\n// 第三种实现方式: 不使用任何工具类\npublic boolean isValidIpAddressV3(String ipAddress) {\n  char[] ipChars = ipAddress.toCharArray();\n  int length = ipChars.length;\n  int ipUnitIntValue = -1;\n  boolean isFirstUnit = true;\n  int unitsCount = 0;\n  for (int i = 0; i < length; ++i) {\n    char c = ipChars[i];\n    if (c == '.') {\n      if (ipUnitIntValue < 0 || ipUnitIntValue > 255) return false;\n      if (isFirstUnit && ipUnitIntValue == 0) return false;\n      if (isFirstUnit) isFirstUnit = false;\n      ipUnitIntValue = -1;\n      unitsCount++;\n      continue;\n    }\n    if (c < '0' || c > '9') {\n      return false;\n    }\n    if (ipUnitIntValue == -1) ipUnitIntValue = 0;\n    ipUnitIntValue = ipUnitIntValue * 10 + (c - '0');\n  }\n  if (ipUnitIntValue < 0 || ipUnitIntValue > 255) return false;\n  if (unitsCount != 3) return false;\n  return true;\n}\n```\n\n\n\n1. 第一种实现方式利用的是正则表达式，只用三行代码就把这个问题搞定了。它的代码行数最少，那是不是就最符合 KISS 原则呢？答案是否定的。虽然代码行数最少，看似最简单，实际上却很复杂。这正是因为它使用了正则表达式。\n2. 一方面，正则表达式本身是比较复杂的，写出完全没有 bug 的正则表达本身就比较有挑战；另一方面，并不是每个程序员都精通正则表达式。对于不怎么懂正则表达式的同事来说，看懂并且维护这段正则表达式是比较困难的。这种实现方式会导致代码的可读性和可维护性变差，所以，从 KISS 原则的设计初衷上来讲，这种实现方式并不符合 KISS 原则。\n3. 讲完了第一种实现方式，我们再来看下其他两种实现方式。\n4. 第二种实现方式使用了 StringUtils 类、Integer 类提供的一些现成的工具函数，来处理 IP 地址字符串。第三种实现方式，不使用任何工具函数，而是通过逐一处理 IP 地址中的字符，来判断是否合法。从代码行数上来说，这两种方式差不多。但是，第三种要比第二种更加有难度，更容易写出 bug。从可读性上来说，第二种实现方式的代码逻辑更清晰、更好理解。所以，在这两种实现方式中，第二种实现方式更加“简单”，更加符合 KISS 原则。\n5. 不过，你可能会说，第三种实现方式虽然实现起来稍微有点复杂，但性能要比第二种实现方式高一些啊。从性能的角度来说，选择第三种实现方式是不是更好些呢？在回答这个问题之前，我先解释一下，为什么说第三种实现方式性能会更高一些。一般来说，工具类的功能都比较通用和全面，所以，在代码实现上，需要考虑和处理更多的细节，执行效率就会有所影响。而第三种实现方式，完全是自己操作底层字符，只针对 IP 地址这一种格式的数据输入来做处理，没有太多多余的函数调用和其他不必要的处理逻辑，所以，在执行效率上，这种类似定制化的处理代码方式肯定比通用的工具类要高些。\n6. 不过，尽管第三种实现方式性能更高些，但我还是更倾向于选择第二种实现方法。那是因为第三种实现方式实际上是一种过度优化。除非 isValidIpAddress() 函数是影响系统性能的瓶颈代码，否则，这样优化的投入产出比并不高，增加了代码实现的难度、牺牲了代码的可读性，性能上的提升却并不明显。\n\n\n\n### 代码逻辑复杂就违背 KISS 原则吗？\n\n刚刚我们提到，并不是代码行数越少就越“简单”，还要考虑逻辑复杂度、实现难度、代码的可读性等。那如果一段代码的逻辑复杂、实现难度大、可读性也不太好，是不是就一定违背 KISS 原则呢？在回答这个问题之前，我们先来看下面这段代码：\n\n```java\n// KMP algorithm: a, b分别是主串和模式串；n, m分别是主串和模式串的长度。\npublic static int kmp(char[] a, int n, char[] b, int m) {\n  int[] next = getNexts(b, m);\n  int j = 0;\n  for (int i = 0; i < n; ++i) {\n    while (j > 0 && a[i] != b[j]) { // 一直找到a[i]和b[j]\n      j = next[j - 1] + 1;\n    }\n    if (a[i] == b[j]) {\n      ++j;\n    }\n    if (j == m) { // 找到匹配模式串的了\n      return i - m + 1;\n    }\n  }\n  return -1;\n}\n\n// b表示模式串，m表示模式串的长度\nprivate static int[] getNexts(char[] b, int m) {\n  int[] next = new int[m];\n  next[0] = -1;\n  int k = -1;\n  for (int i = 1; i < m; ++i) {\n    while (k != -1 && b[k + 1] != b[i]) {\n      k = next[k];\n    }\n    if (b[k + 1] == b[i]) {\n      ++k;\n    }\n    next[i] = k;\n  }\n  return next;\n}\n```\n\n\n\n1. 这段代码是KMP 字符串匹配算法的代码实现。这段代码完全符合我们刚提到的逻辑复杂、实现难度大、可读性差的特点，但它并不违反 KISS 原则。为什么这么说呢？\n\n2. KMP 算法以快速高效著称。当我们需要处理长文本字符串匹配问题（几百 MB 大小文本内容的匹配），或者字符串匹配是某个产品的核心功能（比如 Vim、Word 等文本编辑器），又或者字符串匹配算法是系统性能瓶颈的时候，我们就应该选择尽可能高效的 KMP 算法。而 KMP 算法本身具有逻辑复杂、实现难度大、可读性差的特点。本身就复杂的问题，用复杂的方法解决，并不违背 KISS 原则。\n3. 不过，平时的项目开发中涉及的字符串匹配问题，大部分都是针对比较小的文本。在这种情况下，直接调用编程语言提供的现成的字符串匹配函数就足够了。如果非得用 KMP 算法、BM 算法来实现字符串匹配，那就真的违背 KISS 原则了。也就是说，同样的代码，在某个业务场景下满足 KISS 原则，换一个应用场景可能就不满足了。\n\n\n\n\n\n### 如何写出满足 KISS 原则的代码？\n\n\n\n实际上，我们前面已经讲到了一些方法。这里我稍微总结一下。\n\n- 不要使用同事可能不懂的技术来实现代码。比如前面例子中的正则表达式，还有一些编程语言中过于高级的语法等。\n- 不要重复造轮子，要善于使用已经有的工具类库。经验证明，自己去实现这些类库，出 bug 的概率会更高，维护的成本也比较高。\n- 不要过度优化。不要过度使用一些奇技淫巧（比如，位运算代替算术运算、复杂的条件语句代替 if-else、使用一些过于底层的函数等）来优化代码，牺牲代码的可读性。\n- 实际上，代码是否足够简单是一个挺主观的评判。同样的代码，有的人觉得简单，有的人觉得不够简单。而往往自己编写的代码，自己都会觉得够简单。所以，评判代码是否简单，还有一个很有效的间接方法，那就是 code review。如果在 code review 的时候，同事对你的代码有很多疑问，那就说明你的代码有可能不够“简单”，需要优化啦。\n\n\n\n\n\n### YAGNI 跟 KISS 说的是一回事吗？\n\n1. YAGNI 原则的英文全称是：You Ain’t Gonna Need It。直译就是：你不会需要它。这条原则也算是万金油了。当用在软件开发中的时候，它的意思是：不要去设计当前用不到的功能；不要去编写当前用不到的代码。实际上，这条原则的核心思想就是：不要做过度设计。\n2. 比如，我们的系统暂时只用 Redis 存储配置信息，以后可能会用到 ZooKeeper。根据 YAGNI 原则，在未用到 ZooKeeper 之前，我们没必要提前编写这部分代码。当然，这并不是说我们就不需要考虑代码的扩展性。我们还是要预留好扩展点，等到需要的时候，再去实现 ZooKeeper 存储配置信息这部分代码。\n3. 再比如，我们不要在项目中提前引入不需要依赖的开发包。对于 Java 程序员来说，我们经常使用 Maven 或者 Gradle 来管理依赖的类库（library）。我发现，有些同事为了避免开发中 library 包缺失而频繁地修改 Maven 或者 Gradle 配置文件，提前往项目里引入大量常用的 library 包。实际上，这样的做法也是违背 YAGNI 原则的。\n4. 从刚刚的分析我们可以看出，YAGNI 原则跟 KISS 原则并非一回事儿。KISS 原则讲的是“如何做”的问题（尽量保持简单），而 YAGNI 原则说的是“要不要做”的问题（当前不需要的就不要做）。\n\n\n\n## DRY 原则\n\nDon’t Repeat Yourself。中文直译为：不要重复自己。将它应用在编程中，可以理解为：不要写重复的代码。DRY 原则的定义非常简单，我就不再过度解读。今天，我们主要讲三种典型的代码重复情况，它们分别是：实现逻辑重复、功能语义重复和代码执行重复。这三种代码重复，有的看似违反 DRY，实际上并不违反；有的看似不违反，实际上却违反了。\n\n\n\n### 实现逻辑重复\n\n我们先来看下面这样一段代码是否违反了 DRY 原则。如果违反了，你觉得应该如何重构，才能让它满足 DRY 原则？如果没有违反，那又是为什么呢？\n\n```java\npublic class UserAuthenticator {\n  public void authenticate(String username, String password) {\n    if (!isValidUsername(username)) {\n      // ...throw InvalidUsernameException...\n    }\n    if (!isValidPassword(password)) {\n      // ...throw InvalidPasswordException...\n    }\n    //...省略其他代码...\n  }\n\n  private boolean isValidUsername(String username) {\n    // check not null, not empty\n    if (StringUtils.isBlank(username)) {\n      return false;\n    }\n    // check length: 4~64\n    int length = username.length();\n    if (length < 4 || length > 64) {\n      return false;\n    }\n    // contains only lowcase characters\n    if (!StringUtils.isAllLowerCase(username)) {\n      return false;\n    }\n    // contains only a~z,0~9,dot\n    for (int i = 0; i < length; ++i) {\n      char c = username.charAt(i);\n      if (!(c >= 'a' && c <= 'z') || (c >= '0' && c <= '9') || c == '.') {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  private boolean isValidPassword(String password) {\n    // check not null, not empty\n    if (StringUtils.isBlank(password)) {\n      return false;\n    }\n    // check length: 4~64\n    int length = password.length();\n    if (length < 4 || length > 64) {\n      return false;\n    }\n    // contains only lowcase characters\n    if (!StringUtils.isAllLowerCase(password)) {\n      return false;\n    }\n    // contains only a~z,0~9,dot\n    for (int i = 0; i < length; ++i) {\n      char c = password.charAt(i);\n      if (!(c >= 'a' && c <= 'z') || (c >= '0' && c <= '9') || c == '.') {\n        return false;\n      }\n    }\n    return true;\n  }\n}\n```\n\n代码很简单，我就不做过多解释了。在代码中，有两处非常明显的重复的代码片段：isValidUserName() 函数和 isValidPassword() 函数。重复的代码被敲了两遍，或者简单 copy-paste 了一下，看起来明显违反 DRY 原则。为了移除重复的代码，我们对上面的代码做下重构，将 isValidUserName() 函数和 isValidPassword() 函数，合并为一个更通用的函数 isValidUserNameOrPassword()。重构后的代码如下所示：\n\n```java\npublic class UserAuthenticatorV2 {\n\n  public void authenticate(String userName, String password) {\n    if (!isValidUsernameOrPassword(userName)) {\n      // ...throw InvalidUsernameException...\n    }\n\n    if (!isValidUsernameOrPassword(password)) {\n      // ...throw InvalidPasswordException...\n    }\n  }\n\n  private boolean isValidUsernameOrPassword(String usernameOrPassword) {\n    //省略实现逻辑\n    //跟原来的isValidUsername()或isValidPassword()的实现逻辑一样...\n    return true;\n  }\n}\n```\n\n1. 经过重构之后，代码行数减少了，也没有重复的代码了，是不是更好了呢？答案是否定的，这可能跟你预期的不一样，我来解释一下为什么。\n2. 单从名字上看，我们就能发现，合并之后的 isValidUserNameOrPassword() 函数，负责两件事情：验证用户名和验证密码，违反了“单一职责原则”和“接口隔离原则”。实际上，即便将两个函数合并成 isValidUserNameOrPassword()，代码仍然存在问题。\n3. 因为 isValidUserName() 和 isValidPassword() 两个函数，虽然从代码实现逻辑上看起来是重复的，但是从语义上并不重复。所谓“语义不重复”指的是：从功能上来看，这两个函数干的是完全不重复的两件事情，一个是校验用户名，另一个是校验密码。尽管在目前的设计中，两个校验逻辑是完全一样的，但如果按照第二种写法，将两个函数的合并，那就会存在潜在的问题。在未来的某一天，如果我们修改了密码的校验逻辑，比如，允许密码包含大写字符，允许密码的长度为 8 到 64 个字符，那这个时候，isValidUserName() 和 isValidPassword() 的实现逻辑就会不相同。我们就要把合并后的函数，重新拆成合并前的那两个函数。\n4. 尽管代码的实现逻辑是相同的，但语义不同，我们判定它并不违反 DRY 原则。对于包含重复代码的问题，我们可以通过抽象成更细粒度函数的方式来解决。比如将校验只包含 a~z、0~9、dot 的逻辑封装成 boolean onlyContains(String str, String charlist); 函数。\n\n\n\n### 功能语义重复\n\n1. 现在我们再来看另外一个例子。在同一个项目代码中有下面两个函数：isValidIp() 和 checkIfIpValid()。尽管两个函数的命名不同，实现逻辑不同，但功能是相同的，都是用来判定 IP 地址是否合法的。\n2. 之所以在同一个项目中会有两个功能相同的函数，那是因为这两个函数是由两个不同的同事开发的，其中一个同事在不知道已经有了 isValidIp() 的情况下，自己又定义并实现了同样用来校验 IP 地址是否合法的 checkIfIpValid() 函数。那在同一项目代码中，存在如下两个函数，是否违反 DRY 原则呢？\n\n```java\npublic boolean isValidIp(String ipAddress) {\n  if (StringUtils.isBlank(ipAddress)) return false;\n  String regex = \"^(1\\\\d{2}|2[0-4]\\\\d|25[0-5]|[1-9]\\\\d|[1-9])\\\\.\"\n          + \"(1\\\\d{2}|2[0-4]\\\\d|25[0-5]|[1-9]\\\\d|\\\\d)\\\\.\"\n          + \"(1\\\\d{2}|2[0-4]\\\\d|25[0-5]|[1-9]\\\\d|\\\\d)\\\\.\"\n          + \"(1\\\\d{2}|2[0-4]\\\\d|25[0-5]|[1-9]\\\\d|\\\\d)$\";\n  return ipAddress.matches(regex);\n}\n\npublic boolean checkIfIpValid(String ipAddress) {\n  if (StringUtils.isBlank(ipAddress)) return false;\n  String[] ipUnits = StringUtils.split(ipAddress, '.');\n  if (ipUnits.length != 4) {\n    return false;\n  }\n  for (int i = 0; i < 4; ++i) {\n    int ipUnitIntValue;\n    try {\n      ipUnitIntValue = Integer.parseInt(ipUnits[i]);\n    } catch (NumberFormatException e) {\n      return false;\n    }\n    if (ipUnitIntValue < 0 || ipUnitIntValue > 255) {\n      return false;\n    }\n    if (i == 0 && ipUnitIntValue == 0) {\n      return false;\n    }\n  }\n  return true;\n}\n```\n\n1. 这个例子跟上个例子正好相反。上一个例子是代码实现逻辑重复，但语义不重复，我们并不认为它违反了 DRY 原则。而在这个例子中，尽管两段代码的实现逻辑不重复，但语义重复，也就是功能重复，我们认为它违反了 DRY 原则。我们应该在项目中，统一一种实现思路，所有用到判断 IP 地址是否合法的地方，都统一调用同一个函数。\n2. 假设我们不统一实现思路，那有些地方调用了 isValidIp() 函数，有些地方又调用了 checkIfIpValid() 函数，这就会导致代码看起来很奇怪，相当于给代码“埋坑”，给不熟悉这部分代码的同事增加了阅读的难度。同事有可能研究了半天，觉得功能是一样的，但又有点疑惑，觉得是不是有更高深的考量，才定义了两个功能类似的函数，最终发现居然是代码设计的问题。\n3. 除此之外，如果哪天项目中 IP 地址是否合法的判定规则改变了，比如：255.255.255.255 不再被判定为合法的了，相应地，我们对 isValidIp() 的实现逻辑做了相应的修改，但却忘记了修改 checkIfIpValid() 函数。又或者，我们压根就不知道还存在一个功能相同的 checkIfIpValid() 函数，这样就会导致有些代码仍然使用老的 IP 地址判断逻辑，导致出现一些莫名其妙的 bug。\n\n\n\n### 代码执行重复\n\n前两个例子一个是实现逻辑重复，一个是语义重复，我们再来看第三个例子。其中，UserService 中 login() 函数用来校验用户登录是否成功。如果失败，就返回异常；如果成功，就返回用户信息。具体代码如下所示：\n\n```java\npublic class UserService {\n  private UserRepo userRepo;//通过依赖注入或者IOC框架注入\n\n  public User login(String email, String password) {\n    boolean existed = userRepo.checkIfUserExisted(email, password);\n    if (!existed) {\n      // ... throw AuthenticationFailureException...\n    }\n    User user = userRepo.getUserByEmail(email);\n    return user;\n  }\n}\n\npublic class UserRepo {\n  public boolean checkIfUserExisted(String email, String password) {\n    if (!EmailValidation.validate(email)) {\n      // ... throw InvalidEmailException...\n    }\n\n    if (!PasswordValidation.validate(password)) {\n      // ... throw InvalidPasswordException...\n    }\n\n    //...query db to check if email&password exists...\n  }\n\n  public User getUserByEmail(String email) {\n    if (!EmailValidation.validate(email)) {\n      // ... throw InvalidEmailException...\n    }\n    //...query db to get user by email...\n  }\n}\n```\n\n1. 上面这段代码，既没有逻辑重复，也没有语义重复，但仍然违反了 DRY 原则。这是因为代码中存在“执行重复”。我们一块儿来看下，到底哪些代码被重复执行了？\n2. 重复执行最明显的一个地方，就是在 login() 函数中，email 的校验逻辑被执行了两次。一次是在调用 checkIfUserExisted() 函数的时候，另一次是调用 getUserByEmail() 函数的时候。这个问题解决起来比较简单，我们只需要将校验逻辑从 UserRepo 中移除，统一放到 UserService 中就可以了。\n3. 除此之外，代码中还有一处比较隐蔽的执行重复，不知道你发现了没有？实际上，login() 函数并不需要调用 checkIfUserExisted() 函数，只需要调用一次 getUserByEmail() 函数，从数据库中获取到用户的 email、password 等信息，然后跟用户输入的 email、password 信息做对比，依次判断是否登录成功。\n4. 实际上，这样的优化是很有必要的。因为 checkIfUserExisted() 函数和 getUserByEmail() 函数都需要查询数据库，而数据库这类的 I/O 操作是比较耗时的。我们在写代码的时候，应当尽量减少这类 I/O 操作。\n5. 按照刚刚的修改思路，我们把代码重构一下，移除“重复执行”的代码，只校验一次 email 和 password，并且只查询一次数据库。重构之后的代码如下所示：\n\n```java\npublic class UserService {\n  private UserRepo userRepo;//通过依赖注入或者IOC框架注入\n\n  public User login(String email, String password) {\n    if (!EmailValidation.validate(email)) {\n      // ... throw InvalidEmailException...\n    }\n    if (!PasswordValidation.validate(password)) {\n      // ... throw InvalidPasswordException...\n    }\n    User user = userRepo.getUserByEmail(email);\n    if (user == null || !password.equals(user.getPassword()) {\n      // ... throw AuthenticationFailureException...\n    }\n    return user;\n  }\n}\n\npublic class UserRepo {\n  public boolean checkIfUserExisted(String email, String password) {\n    //...query db to check if email&password exists\n  }\n\n  public User getUserByEmail(String email) {\n    //...query db to get user by email...\n  }\n}\n```\n\n\n\n### 代码复用性（Code Reusability）\n\n1. 我们首先来区分三个概念：代码复用性（Code Reusability）、代码复用（Code Resue）和 DRY 原则。代码复用表示一种行为：我们在开发新功能的时候，尽量复用已经存在的代码。代码的可复用性表示一段代码可被复用的特性或能力：我们在编写代码的时候，让代码尽量可复用。DRY 原则是一条原则：不要写重复的代码。从定义描述上，它们好像有点类似，但深究起来，三者的区别还是蛮大的。\n\n2. 首先，“不重复”并不代表“可复用”。在一个项目代码中，可能不存在任何重复的代码，但也并不表示里面有可复用的代码，不重复和可复用完全是两个概念。所以，从这个角度来说，DRY 原则跟代码的可复用性讲的是两回事。\n3. 其次，“复用”和“可复用性”关注角度不同。代码“可复用性”是从代码开发者的角度来讲的，“复用”是从代码使用者的角度来讲的。比如，A 同事编写了一个 UrlUtils 类，代码的“可复用性”很好。B 同事在开发新功能的时候，直接“复用”A 同事编写的 UrlUtils 类。尽管复用、可复用性、DRY 原则这三者从理解上有所区别，但实际上要达到的目的都是类似的，都是为了减少代码量，提高代码的可读性、可维护性。除此之外，复用已经经过测试的老代码，bug 会比从零重新开发要少。\n4. “复用”这个概念不仅可以指导细粒度的模块、类、函数的设计开发，实际上，一些框架、类库、组件等的产生也都是为了达到复用的目的。比如，Spring 框架、Google Guava 类库、UI 组件等等。\n\n\n\n### 怎么提高代码复用性？\n\n实际上，我们前面已经讲到过很多提高代码可复用性的手段，今天算是集中总结一下，我总结了 7 条，具体如下。\n\n> 减少代码耦合\n\n对于高度耦合的代码，当我们希望复用其中的一个功能，想把这个功能的代码抽取出来成为一个独立的模块、类或者函数的时候，往往会发现牵一发而动全身。移动一点代码，就要牵连到很多其他相关的代码。所以，高度耦合的代码会影响到代码的复用性，我们要尽量减少代码耦合。\n\n> 满足单一职责原则\n\n我们前面讲过，如果职责不够单一，模块、类设计得大而全，那依赖它的代码或者它依赖的代码就会比较多，进而增加了代码的耦合。根据上一点，也就会影响到代码的复用性。相反，越细粒度的代码，代码的通用性会越好，越容易被复用。\n\n> 模块化\n\n这里的“模块”，不单单指一组类构成的模块，还可以理解为单个类、函数。我们要善于将功能独立的代码，封装成模块。独立的模块就像一块一块的积木，更加容易复用，可以直接拿来搭建更加复杂的系统。\n\n> 业务与非业务逻辑分离\n\n越是跟业务无关的代码越是容易复用，越是针对特定业务的代码越难复用。所以，为了复用跟业务无关的代码，我们将业务和非业务逻辑代码分离，抽取成一些通用的框架、类库、组件等。\n\n> 通用代码下沉\n\n从分层的角度来看，越底层的代码越通用、会被越多的模块调用，越应该设计得足够可复用。一般情况下，在代码分层之后，为了避免交叉调用导致调用关系混乱，我们只允许上层代码调用下层代码及同层代码之间的调用，杜绝下层代码调用上层代码。所以，通用的代码我们尽量下沉到更下层。\n\n> 继承、多态、抽象、封装\n\n在讲面向对象特性的时候，利用继承，可以将公共的代码抽取到父类，子类复用父类的属性和方法。利用多态，我们可以动态地替换一段代码的部分逻辑，让这段代码可复用。除此之外，抽象和封装，从更加广义的层面、而非狭义的面向对象特性的层面来理解的话，越抽象、越不依赖具体的实现，越容易复用。代码封装成模块，隐藏可变的细节、暴露不变的接口，就越容易复用。\n\n> 应用模板等设计模式\n\n一些设计模式，也能提高代码的复用性。比如，模板模式利用了多态来实现，可以灵活地替换其中的部分代码，整个流程模板代码可复用。关于应用设计模式提高代码复用性这一部分，我们留在后面慢慢来讲解。除了刚刚我们讲到的几点，还有一些跟编程语言相关的特性，也能提高代码的复用性，比如泛型编程等。实际上，除了上面讲到的这些方法之外，复用意识也非常重要。在写代码的时候，我们要多去思考一下，这\n\n\n\n\n\n\n\n\n\n## 迪米特法则\n\n\n\n我们讲最后一个设计原则：迪米特法则。尽管它不像 SOLID、KISS、DRY 原则那样，人尽皆知，但它却非常实用。利用这个原则，能够帮我们实现代码的“高内聚、松耦合”。今天，我们就围绕下面几个问题，并结合两个代码实战案例，来深入地学习这个法则。\n\n- 什么是“高内聚、松耦合”？\n- 如何利用迪米特法则来实现“高内聚、松耦合”？\n- 有哪些代码设计是明显违背迪米特法则的？对此又该如何重构？\n\n\n\n\n\n### 何为“高内聚、松耦合”？\n\n1. “高内聚、松耦合”是一个非常重要的设计思想，能够有效地提高代码的可读性和可维护性，缩小功能改动导致的代码改动范围。\n2. 实际上，在前面的章节中，我们已经多次提到过这个设计思想。很多设计原则都以实现代码的“高内聚、松耦合”为目的，比如单一职责原则、基于接口而非实现编程等。实际上，“高内聚、松耦合”是一个比较通用的设计思想，可以用来指导不同粒度代码的设计与开发，比如系统、模块、类，甚至是函数，也可以应用到不同的开发场景中，比如微服务、框架、组件、类库等。为了方便我讲解，接下来我以“类”作为这个设计思想的应用对象来展开讲解，其他应用场景你可以自行类比。\n3. 在这个设计思想中，“高内聚”用来指导类本身的设计，“松耦合”用来指导类与类之间依赖关系的设计。不过，这两者并非完全独立不相干。高内聚有助于松耦合，松耦合又需要高内聚的支持。\n\n\n\n> 那到底什么是“高内聚”呢？\n\n\n\n所谓高内聚，就是指相近的功能应该放到同一个类中，不相近的功能不要放到同一个类中。相近的功能往往会被同时修改，放到同一个类中，修改会比较集中，代码容易维护。实际上，我们前面讲过的单一职责原则是实现代码高内聚非常有效的设计原则。\n\n\n\n> 我们再来看一下，什么是“松耦合”？\n\n所谓松耦合是说，在代码中，类与类之间的依赖关系简单清晰。即使两个类有依赖关系，一个类的代码改动不会或者很少导致依赖类的代码改动。实际上，我们前面讲的依赖注入、接口隔离、基于接口而非实现编程，以及今天讲的迪米特法则，都是为了实现代码的松耦合\n\n\n\n\n\n> 最后，我们来看一下，“内聚”和“耦合”之间的关系\n\n前面也提到，“高内聚”有助于“松耦合”，同理，“低内聚”也会导致“紧耦合”。关于这一点，我画了一张对比图来解释。图中左边部分的代码结构是“高内聚、松耦合”；右边部分正好相反，是“低内聚、紧耦合”。\n\n<img src=\"https://npm.elemecdn.com/youthlql@1.0.0/design_patterns/design_principles/0001.png\" />\n\n\n\n\n\n1. 图中左边部分的代码设计中，类的粒度比较小，每个类的职责都比较单一。相近的功能都放到了一个类中，不相近的功能被分割到了多个类中。这样类更加独立，代码的内聚性更好。因为职责单一，所以每个类被依赖的类就会比较少，代码低耦合。一个类的修改，只会影响到一个依赖类的代码改动。我们只需要测试这一个依赖类是否还能正常工作就行了。\n2. 图中右边部分的代码设计中，类粒度比较大，低内聚，功能大而全，不相近的功能放到了一个类中。这就导致很多其他类都依赖这个类。当我们修改这个类的某一个功能代码的时候，会影响依赖它的多个类。我们需要测试这三个依赖类，是否还能正常工作。这也就是所谓的“牵一发而动全身”。\n3. 除此之外，从图中我们也可以看出，高内聚、低耦合的代码结构更加简单、清晰，相应地，在可维护性和可读性上确实要好很多。\n\n\n\n\n\n### “迪米特法则”理论描述\n\n1. 迪米特法则的英文翻译是：Law of Demeter，缩写是 LOD。单从这个名字上来看，我们完全猜不出这个原则讲的是什么。不过，它还有另外一个更加达意的名字，叫作最小知识原则，英文翻译为：The Least Knowledge Principle。\n\n2. 关于这个设计原则，我们先来看一下它最原汁原味的英文定义：\n\n   > Each unit should have only limited knowledge about other units: only units “closely” related to the current unit. Or: Each unit should only talk to its friends; Don’t talk to strangers.\n\n   我们把它直译成中文，就是下面这个样子：\n\n   > 每个模块（unit）只应该了解那些与它关系密切的模块（units: only units “closely” related to the current unit）的有限知识（knowledge）。或者说，每个模块只和自己的朋友“说话”（talk），不和陌生人“说话”（talk）。\n\n   我们之前讲过，大部分设计原则和思想都非常抽象，有各种各样的解读，要想灵活地应用到实际的开发中，需要有实战经验的积累。迪米特法则也不例外。所以，我结合我自己的理解和经验，对刚刚的定义重新描述一下。注意，为了统一讲解，我把定义描述中的“模块”替换成了“类”。\n\n   > 不该有直接依赖关系的类之间，不要有依赖；有依赖关系的类之间，尽量只依赖必要的接口（也就是定义中的“有限知识”）。从上面的描述中，我们可以看出，迪米特法则包含前后两部分，这两部分讲的是两件事情，我用两个实战案例分别来解读一下。\n\n\n\n\n\n### 理论解读与代码实战一\n\n1. 我们先来看这条原则中的前半部分，**“不该有直接依赖关系的类之间，不要有依赖”**。我举个例子解释一下。\n2. 这个例子实现了简化版的搜索引擎爬取网页的功能。代码中包含三个主要的类。其中，NetworkTransporter 类负责底层网络通信，根据请求获取数据；HtmlDownloader 类用来通过 URL 获取网页；Document 表示网页文档，后续的网页内容抽取、分词、索引都是以此为处理对象。具体的代码实现如下所示：\n\n```java\npublic class NetworkTransporter {\n    // 省略属性和其他方法...\n    public Byte[] send(HtmlRequest htmlRequest) {\n      //...\n    }\n}\n\npublic class HtmlDownloader {\n  private NetworkTransporter transporter;//通过构造函数或IOC注入\n  \n  public Html downloadHtml(String url) {\n    Byte[] rawHtml = transporter.send(new HtmlRequest(url));\n    return new Html(rawHtml);\n  }\n}\n\npublic class Document {\n  private Html html;\n  private String url;\n  \n  public Document(String url) {\n    this.url = url;\n    HtmlDownloader downloader = new HtmlDownloader();\n    this.html = downloader.downloadHtml(url);\n  }\n  //...\n}\n```\n\n1. 这段代码虽然“能用”，能实现我们想要的功能，但是它不够“好用”，有比较多的设计缺陷。你可以先试着思考一下，看看都有哪些缺陷，然后再来看我下面的讲解。\n2. 首先，我们来看 NetworkTransporter 类。作为一个底层网络通信类，我们希望它的功能尽可能通用，而不只是服务于下载 HTML，所以，我们不应该直接依赖太具体的发送对象 HtmlRequest。从这一点上讲，NetworkTransporter 类的设计违背迪米特法则，依赖了不该有直接依赖关系的 HtmlRequest 类。\n3. 我们应该如何进行重构，让 NetworkTransporter 类满足迪米特法则呢？我这里有个形象的比喻。假如你现在要去商店买东西，你肯定不会直接把钱包给收银员，让收银员自己从里面拿钱，而是你从钱包里把钱拿出来交给收银员。这里的 HtmlRequest 对象就相当于钱包，HtmlRequest 里的 address 和 content 对象就相当于钱。我们应该把 address 和 content 交给 NetworkTransporter，而非是直接把 HtmlRequest 交给 NetworkTransporter。根据这个思路，NetworkTransporter 重构之后的代码如下所示：\n\n```java\npublic class NetworkTransporter {\n    // 省略属性和其他方法...\n    public Byte[] send(String address, Byte[] data) {\n      //...\n    }\n}\n```\n\n\n\n我们再来看 HtmlDownloader 类。这个类的设计没有问题。不过，我们修改了 NetworkTransporter 的 send() 函数的定义，而这个类用到了 send() 函数，所以我们需要对它做相应的修改，修改后的代码如下所示\n\n\n\n```java\npublic class HtmlDownloader {\n  private NetworkTransporter transporter;//通过构造函数或IOC注入\n  \n  // HtmlDownloader这里也要有相应的修改\n  public Html downloadHtml(String url) {\n    HtmlRequest htmlRequest = new HtmlRequest(url);\n    Byte[] rawHtml = transporter.send(\n      htmlRequest.getAddress(), htmlRequest.getContent().getBytes());\n    return new Html(rawHtml);\n  }\n}\n```\n\n\n\n最后，我们来看下 Document 类。这个类的问题比较多，主要有三点。第一，构造函数中的 downloader.downloadHtml() 逻辑复杂，耗时长，不应该放到构造函数中，会影响代码的可测试性。代码的可测试性我们后面会讲到，这里你先知道有这回事就可以了。第二，HtmlDownloader 对象在构造函数中通过 new 来创建，违反了基于接口而非实现编程的设计思想，也会影响到代码的可测试性。第三，从业务含义上来讲，Document 网页文档没必要依赖 HtmlDownloader 类，违背了迪米特法则。\n\n虽然 Document 类的问题很多，但修改起来比较简单，只要一处改动就可以解决所有问题。修改之后的代码如下所示：\n\n```java\npublic class Document {\n  private Html html;\n  private String url;\n  \n  public Document(String url, Html html) {\n    this.html = html;\n    this.url = url;\n  }\n  //...\n}\n\n// 通过一个工厂方法来创建Document\npublic class DocumentFactory {\n  private HtmlDownloader downloader;\n  \n  public DocumentFactory(HtmlDownloader downloader) {\n    this.downloader = downloader;\n  }\n  \n  public Document createDocument(String url) {\n    Html html = downloader.downloadHtml(url);\n    return new Document(url, html);\n  }\n}\n```\n\n\n\n\n\n### 理论解读与代码实战二\n\n现在，我们再来看一下这条原则中的后半部分：“有依赖关系的类之间，尽量只依赖必要的接口”。我们还是结合一个例子来讲解。下面这段代码非常简单，Serialization 类负责对象的序列化和反序列化\n\n\n\n```java\npublic class Serialization {\n  public String serialize(Object object) {\n    String serializedResult = ...;\n    //...\n    return serializedResult;\n  }\n  \n  public Object deserialize(String str) {\n    Object deserializedResult = ...;\n    //...\n    return deserializedResult;\n  }\n}\n```\n\n\n\n1. 单看这个类的设计，没有一点问题。不过，如果我们把它放到一定的应用场景里，那就还有继续优化的空间。假设在我们的项目中，有些类只用到了序列化操作，而另一些类只用到反序列化操作。那基于迪米特法则后半部分“有依赖关系的类之间，尽量只依赖必要的接口”，只用到序列化操作的那部分类不应该依赖反序列化接口。同理，只用到反序列化操作的那部分类不应该依赖序列化接口。\n2. 根据这个思路，我们应该将 Serialization 类拆分为两个更小粒度的类，一个只负责序列化（Serializer 类），一个只负责反序列化（Deserializer 类）。拆分之后，使用序列化操作的类只需要依赖 Serializer 类，使用反序列化操作的类只需要依赖 Deserializer 类。拆分之后的代码如下所示：\n\n```java\npublic class Serializer {\n  public String serialize(Object object) {\n    String serializedResult = ...;\n    ...\n    return serializedResult;\n  }\n}\n\npublic class Deserializer {\n  public Object deserialize(String str) {\n    Object deserializedResult = ...;\n    ...\n    return deserializedResult;\n  }\n}\n```\n\n\n\n\n\n1. 不知道你有没有看出来，尽管拆分之后的代码更能满足迪米特法则，但却违背了高内聚的设计思想。高内聚要求相近的功能要放到同一个类中，这样可以方便功能修改的时候，修改的地方不至于过于分散。对于刚刚这个例子来说，如果我们修改了序列化的实现方式，比如从 JSON 换成了 XML，那反序列化的实现逻辑也需要一并修改。在未拆分的情况下，我们只需要修改一个类即可。在拆分之后，我们需要修改两个类。显然，这种设计思路的代码改动范围变大了。\n2. 如果我们既不想违背高内聚的设计思想，也不想违背迪米特法则，那我们该如何解决这个问题呢？实际上，通过引入两个接口就能轻松解决这个问题，具体的代码如下所示。实际上，我们在讲到“接口隔离原则”的时候，第三个例子就使用了类似的实现思路，你可以结合着一块儿来看。\n\n```java\npublic interface Serializable {\n  String serialize(Object object);\n}\n\npublic interface Deserializable {\n  Object deserialize(String text);\n}\n\npublic class Serialization implements Serializable, Deserializable {\n  @Override\n  public String serialize(Object object) {\n    String serializedResult = ...;\n    ...\n    return serializedResult;\n  }\n  \n  @Override\n  public Object deserialize(String str) {\n    Object deserializedResult = ...;\n    ...\n    return deserializedResult;\n  }\n}\n\npublic class DemoClass_1 {\n  private Serializable serializer;\n  \n  public Demo(Serializable serializer) {\n    this.serializer = serializer;\n  }\n  //...\n}\n\npublic class DemoClass_2 {\n  private Deserializable deserializer;\n  \n  public Demo(Deserializable deserializer) {\n    this.deserializer = deserializer;\n  }\n  //...\n}\n```\n\n1. 尽管我们还是要往 DemoClass_1 的构造函数中，传入包含序列化和反序列化的 Serialization 实现类，但是，我们依赖的 Serializable 接口只包含序列化操作，DemoClass_1 无法使用 Serialization 类中的反序列化接口，对反序列化操作无感知，这也就符合了迪米特法则后半部分所说的“依赖有限接口”的要求。\n2. 实际上，上面的的代码实现思路，也体现了“基于接口而非实现编程”的设计原则，结合迪米特法则，我们可以总结出一条新的设计原则，那就是“基于最小接口而非最大实现编程”。有些同学之前问，新的设计模式和设计原则是怎么创造出来的，实际上，就是在大量的实践中，针对开发痛点总结归纳出来的套路。\n\n\n\n### 辩证思考与灵活应用\n\n1. 对于实战二最终的设计思路，你有没有什么不同的观点呢？\n2. 整个类只包含序列化和反序列化两个操作，只用到序列化操作的使用者，即便能够感知到仅有的一个反序列化函数，问题也不大。那为了满足迪米特法则，我们将一个非常简单的类，拆分出两个接口，是否有点过度设计的意思呢？\n3. 设计原则本身没有对错，只有能否用对之说。不要为了应用设计原则而应用设计原则，我们在应用设计原则的时候，一定要具体问题具体分析。\n4. 对于刚刚这个 Serialization 类来说，只包含两个操作，确实没有太大必要拆分成两个接口。但是，如果我们对 Serialization 类添加更多的功能，实现更多更好用的序列化、反序列化函数，我们来重新考虑一下这个问题。修改之后的具体的代码如下\n\n```java\npublic class Serializer { // 参看JSON的接口定义\n  public String serialize(Object object) { //... }\n  public String serializeMap(Map map) { //... }\n  public String serializeList(List list) { //... }\n  \n  public Object deserialize(String objectString) { //... }\n  public Map deserializeMap(String mapString) { //... }\n  public List deserializeList(String listString) { //... }\n}\n```\n\n在这种场景下，第二种设计思路要更好些。因为基于之前的应用场景来说，大部分代码只需要用到序列化的功能。对于这部分使用者，没必要了解反序列化的“知识”，而修改之后的 Serialization 类，反序列化的“知识”，从一个函数变成了三个。一旦任一反序列化操作有代码改动，我们都需要检查、测试所有依赖 Serialization 类的代码是否还能正常工作。为了减少耦合和测试工作量，我们应该按照迪米特法则，将反序列化和序列化的功能隔离开来。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/2024-05-01-设计模式-02.经典设计原则-第二节[必读].md","raw":"---\ntitle: '设计模式-02.经典设计原则-第二节[必读]'\ntags:\n  - 设计模式\n  - 设计原则\ncategories:\n  - 设计模式\n  - 02.经典设计原则\nkeywords: 设计模式，经典设计原则\ndescription: 设计模式-经典设计原则，例如：迪米特法则，依赖反转原则，KISS等等。\ncover: 'https://npm.elemecdn.com/lql_static@latest/logo/design_patterns.jpg'\nabbrlink: 994a8ed3\ndate: 2024-05-01 13:28:50\n---\n\n# 声明\n\n> 1. 此系列文章非本人原创，是学习笔记。\n> 2. 设计模式系列以后会持续更新，包括已经发布的设计模式文章，因为后续还要再多看一下书，教程和开源项目等，继续润色文章。\n\n# 设计模式经典设计原则-第二节\n\n## 依赖反转原则（DIP）\n\n关于 SOLID 原则，我们已经学过单一职责、开闭、里式替换、接口隔离这四个原则。今天，我们再来学习最后一个原则：依赖反转原则。在前面，我们讲到，单一职责原则和开闭原则的原理比较简单，但是，想要在实践中用好却比较难。而今天我们要讲到的依赖反转原则正好相反。这个原则用起来比较简单，但概念理解起来比较难。比如，下面这几个问题，你看看能否清晰地回答出来：\n\n- “依赖反转”这个概念指的是“谁跟谁”的“什么依赖”被反转了？“反转”两个字该如何理解？\n- 我们还经常听到另外两个概念：“控制反转”和“依赖注入”。这两个概念跟“依赖反转”有什么区别和联系呢？它们说的是同一个事情吗？\n- 如果你熟悉 Java 语言，那 Spring 框架中的 IOC 跟这些概念又有什么关系呢？\n\n\n\n### 控制反转（IOC）\n\n在讲“依赖反转原则”之前，我们先讲一讲“控制反转”。控制反转的英文翻译是 Inversion Of Control，缩写为 IOC。此处我要强调一下，暂时别把这个“IOC”跟 Spring 框架的 IOC 联系在一起。关于 Spring 的 IOC，我们待会儿还会讲到。我们先通过一个例子来看一下，什么是控制反转。\n\n```java\npublic class UserServiceTest {\n  public static boolean doTest() {\n    // ... \n  }\n  \n  public static void main(String[] args) {//这部分逻辑可以放到框架中\n    if (doTest()) {\n      System.out.println(\"Test succeed.\");\n    } else {\n      System.out.println(\"Test failed.\");\n    }\n  }\n}\n```\n\n在上面的代码中，所有的流程都由程序员来控制。如果我们抽象出一个下面这样一个框架，我们再来看，如何利用框架来实现同样的功能。具体的代码实现如下所示：\n\n\n\n```java\npublic abstract class TestCase {\n  public void run() {\n    if (doTest()) {\n      System.out.println(\"Test succeed.\");\n    } else {\n      System.out.println(\"Test failed.\");\n    }\n  }\n  \n  public abstract boolean doTest();\n}\n\npublic class JunitApplication {\n  private static final List<TestCase> testCases = new ArrayList<>();\n  \n  public static void register(TestCase testCase) {\n    testCases.add(testCase);\n  }\n  \n  public static final void main(String[] args) {\n    for (TestCase case: testCases) {\n      case.run();\n    }\n  }\n```\n\n把这个简化版本的测试框架引入到工程中之后，我们只需要在框架预留的扩展点，也就是 TestCase 类中的 doTest() 抽象函数中，填充具体的测试代码就可以实现之前的功能了，完全不需要写负责执行流程的 main() 函数了。 具体的代码如下所示：\n\n```java\npublic class UserServiceTest extends TestCase {\n  @Override\n  public boolean doTest() {\n    // ... \n  }\n}\n\n// 注册操作还可以通过配置的方式来实现，不需要程序员显示调用register()\nJunitApplication.register(new UserServiceTest();\n```\n\n\n\n1. 刚刚举的这个例子，就是典型的通过框架来实现“控制反转”的例子。框架提供了一个可扩展的代码骨架，用来组装对象、管理整个执行流程。程序员利用框架进行开发的时候，只需要往预留的扩展点上，添加跟自己业务相关的代码，就可以利用框架来驱动整个程序流程的执行。\n2. 这里的“控制”指的是对程序执行流程的控制，而“反转”指的是在没有使用框架之前，程序员自己控制整个程序的执行。在使用框架之后，整个程序的执行流程可以通过框架来控制。流程的控制权从程序员“反转”到了框架。\n3. 实际上，实现控制反转的方法有很多，除了刚才例子中所示的类似于模板设计模式的方法之外，还有马上要讲到的依赖注入等方法，所以，控制反转并不是一种具体的实现技巧，而是一个比较笼统的设计思想，一般用来指导框架层面的设计。\n\n\n\n### 依赖注入（DI）\n\n1. 接下来，我们再来看依赖注入。依赖注入跟控制反转恰恰相反，它是一种具体的编码技巧。那到底什么是依赖注入呢？我们用一句话来概括就是：不通过 new() 的方式在类内部创建依赖类对象，而是将依赖的类对象在外部创建好之后，通过构造函数、函数参数等方式传递（或注入）给类使用。\n2. 我们还是通过一个例子来解释一下。在这个例子中，Notification 类负责消息推送，依赖 MessageSender 类实现推送商品促销、验证码等消息给用户。我们分别用依赖注入和非依赖注入两种方式来实现一下。具体的实现代码如下所示：\n\n\n\n```java\n// 非依赖注入实现方式\npublic class Notification {\n  private MessageSender messageSender;\n  \n  public Notification() {\n    this.messageSender = new MessageSender(); //此处有点像hardcode\n  }\n  \n  public void sendMessage(String cellphone, String message) {\n    //...省略校验逻辑等...\n    this.messageSender.send(cellphone, message);\n  }\n}\n\npublic class MessageSender {\n  public void send(String cellphone, String message) {\n    //....\n  }\n}\n// 使用Notification\nNotification notification = new Notification();\n\n// 依赖注入的实现方式\npublic class Notification {\n  private MessageSender messageSender;\n  \n  // 通过构造函数将messageSender传递进来\n  public Notification(MessageSender messageSender) {\n    this.messageSender = messageSender;\n  }\n  \n  public void sendMessage(String cellphone, String message) {\n    //...省略校验逻辑等...\n    this.messageSender.send(cellphone, message);\n  }\n}\n//使用Notification\nMessageSender messageSender = new MessageSender();\nNotification notification = new Notification(messageSender);\n```\n\n通过依赖注入的方式来将依赖的类对象传递进来，这样就提高了代码的扩展性，我们可以灵活地替换依赖的类。这一点在我们之前讲“开闭原则”的时候也提到过。当然，上面代码还有继续优化的空间，我们还可以把 MessageSender 定义成接口，基于接口而非实现编程。改造后的代码如下所示：\n\n\n\n```java\npublic class Notification {\n  private MessageSender messageSender;\n  \n  public Notification(MessageSender messageSender) {\n    this.messageSender = messageSender;\n  }\n  \n  public void sendMessage(String cellphone, String message) {\n    this.messageSender.send(cellphone, message);\n  }\n}\n\npublic interface MessageSender {\n  void send(String cellphone, String message);\n}\n\n// 短信发送类\npublic class SmsSender implements MessageSender {\n  @Override\n  public void send(String cellphone, String message) {\n    //....\n  }\n}\n\n// 站内信发送类\npublic class InboxSender implements MessageSender {\n  @Override\n  public void send(String cellphone, String message) {\n    //....\n  }\n}\n\n//使用Notification\nMessageSender messageSender = new SmsSender();\nNotification notification = new Notification(messageSender);\n```\n\n\n\n实际上，你只需要掌握刚刚举的这个例子，就等于完全掌握了依赖注入。尽管依赖注入非常简单，但却非常有用，\n\n\n\n### 依赖注入框架（DI Framework）\n\n弄懂了什么是“依赖注入”，我们再来看一下，什么是“依赖注入框架”。我们还是借用刚刚的例子来解释。在采用依赖注入实现的 Notification 类中，虽然我们不需要用类似 hard code 的方式，在类内部通过 new 来创建 MessageSender 对象，但是，这个创建对象、组装（或注入）对象的工作仅仅是被移动到了更上层代码而已，还是需要我们程序员自己来实现。具体代码如下所示：\n\n\n\n```java\npublic class Demo {\n  public static final void main(String args[]) {\n    MessageSender sender = new SmsSender(); //创建对象\n    Notification notification = new Notification(sender);//依赖注入\n    notification.sendMessage(\"13918942177\", \"短信验证码：2346\");\n  }\n}\n```\n\n1. 在实际的软件开发中，一些项目可能会涉及几十、上百、甚至几百个类，类对象的创建和依赖注入会变得非常复杂。如果这部分工作都是靠程序员自己写代码来完成，容易出错且开发成本也比较高。而对象创建和依赖注入的工作，本身跟具体的业务无关，我们完全可以抽象成框架来自动完成。\n2. 你可能已经猜到，这个框架就是“依赖注入框架”。我们只需要通过依赖注入框架提供的扩展点，简单配置一下所有需要创建的类对象、类与类之间的依赖关系，就可以实现由框架来自动创建对象、管理对象的生命周期、依赖注入等原本需要程序员来做的事情。\n3. 实际上，现成的依赖注入框架有很多，比如 Google Guice、Java Spring、Pico Container、Butterfly Container 等。不过，如果你熟悉 Java Spring 框架，你可能会说，Spring 框架自己声称是控制反转容器（Inversion Of Control Container）。\n4. 实际上，这两种说法都没错。只是控制反转容器这种表述是一种非常宽泛的描述，DI 依赖注入框架的表述更具体、更有针对性。因为我们前面讲到实现控制反转的方式有很多，除了依赖注入，还有模板模式等，而 Spring 框架的控制反转主要是通过依赖注入来实现的。不过这点区分并不是很明显，也不是很重要，你稍微了解一下就可以了。\n\n\n\n### 什么是依赖反转原则？\n\n\n\n1. 前面讲了控制反转、依赖注入、依赖注入框架，现在，我们来讲一讲今天的主角：依赖反转原则。依赖反转原则的英文翻译是 Dependency Inversion Principle，缩写为 DIP。中文翻译有时候也叫依赖倒置原则。\n2. 英文描述：High-level modules shouldn’t depend on low-level modules. Both modules should depend on abstractions. In addition, abstractions shouldn’t depend on details. Details depend on abstractions.\n3. 我们将它翻译成中文，大概意思就是：高层模块（high-level modules）不要依赖低层模块（low-level）。高层模块和低层模块应该通过抽象（abstractions）来互相依赖。除此之外，抽象（abstractions）不要依赖具体实现细节（details），具体实现细节（details）依赖抽象（abstractions）。\n4. 所谓高层模块和低层模块的划分，简单来说就是，在调用链上，调用者属于高层，被调用者属于低层。在平时的业务代码开发中，高层模块依赖底层模块是没有任何问题的。实际上，这条原则主要还是用来指导框架层面的设计，跟前面讲到的控制反转类似。我们拿 Tomcat 这个 Servlet 容器作为例子来解释一下。\n5. Tomcat 是运行 Java Web 应用程序的容器。我们编写的 Web 应用程序代码只需要部署在 Tomcat 容器下，便可以被 Tomcat 容器调用执行。按照之前的划分原则，Tomcat 就是高层模块，我们编写的 Web 应用程序代码就是低层模块。Tomcat 和应用程序代码之间并没有直接的依赖关系，两者都依赖同一个“抽象”，也就是 Servlet 规范。Servlet 规范不依赖具体的 Tomcat 容器和应用程序的实现细节，而 Tomcat 容器和应用程序依赖 Servlet 规范。\n\n\n\n## KISS原则和YAGNI原则\n\n\n\n1. 我们学习了经典的 SOLID 原则。今天，我们讲两个设计原则：KISS 原则和 YAGNI 原则。其中，KISS 原则比较经典，耳熟能详，但 YAGNI 你可能没怎么听过，不过它理解起来也不难。\n2. 理解这两个原则时候，经常会有一个共同的问题，那就是，看一眼就感觉懂了，但深究的话，又有很多细节问题不是很清楚。比如，怎么理解 KISS 原则中“简单”两个字？什么样的代码才算“简单”？怎样的代码才算“复杂”？如何才能写出“简单”的代码？YAGNI 原则跟 KISS 原则说的是一回事吗？\n\n\n\nKISS 原则的英文描述有好几个版本，比如下面这几个。\n\n- Keep It Simple and Stupid.\n- Keep It Short and Simple.\n- Keep It Simple and Straightforward.\n\n1. 不过，仔细看你就会发现，它们要表达的意思其实差不多，翻译成中文就是：尽量保持简单。\n\n2. 我们知道，代码的可读性和可维护性是衡量代码质量非常重要的两个标准。而 KISS 原则就是保持代码可读和可维护的重要手段。代码足够简单，也就意味着很容易读懂，bug 比较难隐藏。即便出现 bug，修复起来也比较简单。不过，这条原则只是告诉我们，要保持代码“Simple and Stupid”，但并没有讲到，什么样的代码才是“Simple and Stupid”的，更没有给出特别明确的方法论，来指导如何开发出“Simple and Stupid”的代码。\n3. 所以，接下来，为了能让这条原则切实地落地，能够指导实际的项目开发，我就针对刚刚的这些问题来进一步讲讲我的理解。\n\n\n\n### 代码行数越少就越“简单”吗？\n\n我们先一起看一个例子。下面这三段代码可以实现同样一个功能：检查输入的字符串 ipAddress 是否是合法的 IP 地址。一个合法的 IP 地址由四个数字组成，并且通过“.”来进行分割。每组数字的取值范围是 0~255。第一组数字比较特殊，不允许为 0。对比这三段代码，你觉得哪一段代码最符合 KISS 原则呢？如果让你来实现这个功能，你会选择用哪种实现方法呢？你可以先自己思考一下，然后再看我下面的讲解。\n\n```java\n// 第一种实现方式: 使用正则表达式\npublic boolean isValidIpAddressV1(String ipAddress) {\n  if (StringUtils.isBlank(ipAddress)) return false;\n  String regex = \"^(1\\\\d{2}|2[0-4]\\\\d|25[0-5]|[1-9]\\\\d|[1-9])\\\\.\"\n          + \"(1\\\\d{2}|2[0-4]\\\\d|25[0-5]|[1-9]\\\\d|\\\\d)\\\\.\"\n          + \"(1\\\\d{2}|2[0-4]\\\\d|25[0-5]|[1-9]\\\\d|\\\\d)\\\\.\"\n          + \"(1\\\\d{2}|2[0-4]\\\\d|25[0-5]|[1-9]\\\\d|\\\\d)$\";\n  return ipAddress.matches(regex);\n}\n\n// 第二种实现方式: 使用现成的工具类\npublic boolean isValidIpAddressV2(String ipAddress) {\n  if (StringUtils.isBlank(ipAddress)) return false;\n  String[] ipUnits = StringUtils.split(ipAddress, '.');\n  if (ipUnits.length != 4) {\n    return false;\n  }\n  for (int i = 0; i < 4; ++i) {\n    int ipUnitIntValue;\n    try {\n      ipUnitIntValue = Integer.parseInt(ipUnits[i]);\n    } catch (NumberFormatException e) {\n      return false;\n    }\n    if (ipUnitIntValue < 0 || ipUnitIntValue > 255) {\n      return false;\n    }\n    if (i == 0 && ipUnitIntValue == 0) {\n      return false;\n    }\n  }\n  return true;\n}\n\n// 第三种实现方式: 不使用任何工具类\npublic boolean isValidIpAddressV3(String ipAddress) {\n  char[] ipChars = ipAddress.toCharArray();\n  int length = ipChars.length;\n  int ipUnitIntValue = -1;\n  boolean isFirstUnit = true;\n  int unitsCount = 0;\n  for (int i = 0; i < length; ++i) {\n    char c = ipChars[i];\n    if (c == '.') {\n      if (ipUnitIntValue < 0 || ipUnitIntValue > 255) return false;\n      if (isFirstUnit && ipUnitIntValue == 0) return false;\n      if (isFirstUnit) isFirstUnit = false;\n      ipUnitIntValue = -1;\n      unitsCount++;\n      continue;\n    }\n    if (c < '0' || c > '9') {\n      return false;\n    }\n    if (ipUnitIntValue == -1) ipUnitIntValue = 0;\n    ipUnitIntValue = ipUnitIntValue * 10 + (c - '0');\n  }\n  if (ipUnitIntValue < 0 || ipUnitIntValue > 255) return false;\n  if (unitsCount != 3) return false;\n  return true;\n}\n```\n\n\n\n1. 第一种实现方式利用的是正则表达式，只用三行代码就把这个问题搞定了。它的代码行数最少，那是不是就最符合 KISS 原则呢？答案是否定的。虽然代码行数最少，看似最简单，实际上却很复杂。这正是因为它使用了正则表达式。\n2. 一方面，正则表达式本身是比较复杂的，写出完全没有 bug 的正则表达本身就比较有挑战；另一方面，并不是每个程序员都精通正则表达式。对于不怎么懂正则表达式的同事来说，看懂并且维护这段正则表达式是比较困难的。这种实现方式会导致代码的可读性和可维护性变差，所以，从 KISS 原则的设计初衷上来讲，这种实现方式并不符合 KISS 原则。\n3. 讲完了第一种实现方式，我们再来看下其他两种实现方式。\n4. 第二种实现方式使用了 StringUtils 类、Integer 类提供的一些现成的工具函数，来处理 IP 地址字符串。第三种实现方式，不使用任何工具函数，而是通过逐一处理 IP 地址中的字符，来判断是否合法。从代码行数上来说，这两种方式差不多。但是，第三种要比第二种更加有难度，更容易写出 bug。从可读性上来说，第二种实现方式的代码逻辑更清晰、更好理解。所以，在这两种实现方式中，第二种实现方式更加“简单”，更加符合 KISS 原则。\n5. 不过，你可能会说，第三种实现方式虽然实现起来稍微有点复杂，但性能要比第二种实现方式高一些啊。从性能的角度来说，选择第三种实现方式是不是更好些呢？在回答这个问题之前，我先解释一下，为什么说第三种实现方式性能会更高一些。一般来说，工具类的功能都比较通用和全面，所以，在代码实现上，需要考虑和处理更多的细节，执行效率就会有所影响。而第三种实现方式，完全是自己操作底层字符，只针对 IP 地址这一种格式的数据输入来做处理，没有太多多余的函数调用和其他不必要的处理逻辑，所以，在执行效率上，这种类似定制化的处理代码方式肯定比通用的工具类要高些。\n6. 不过，尽管第三种实现方式性能更高些，但我还是更倾向于选择第二种实现方法。那是因为第三种实现方式实际上是一种过度优化。除非 isValidIpAddress() 函数是影响系统性能的瓶颈代码，否则，这样优化的投入产出比并不高，增加了代码实现的难度、牺牲了代码的可读性，性能上的提升却并不明显。\n\n\n\n### 代码逻辑复杂就违背 KISS 原则吗？\n\n刚刚我们提到，并不是代码行数越少就越“简单”，还要考虑逻辑复杂度、实现难度、代码的可读性等。那如果一段代码的逻辑复杂、实现难度大、可读性也不太好，是不是就一定违背 KISS 原则呢？在回答这个问题之前，我们先来看下面这段代码：\n\n```java\n// KMP algorithm: a, b分别是主串和模式串；n, m分别是主串和模式串的长度。\npublic static int kmp(char[] a, int n, char[] b, int m) {\n  int[] next = getNexts(b, m);\n  int j = 0;\n  for (int i = 0; i < n; ++i) {\n    while (j > 0 && a[i] != b[j]) { // 一直找到a[i]和b[j]\n      j = next[j - 1] + 1;\n    }\n    if (a[i] == b[j]) {\n      ++j;\n    }\n    if (j == m) { // 找到匹配模式串的了\n      return i - m + 1;\n    }\n  }\n  return -1;\n}\n\n// b表示模式串，m表示模式串的长度\nprivate static int[] getNexts(char[] b, int m) {\n  int[] next = new int[m];\n  next[0] = -1;\n  int k = -1;\n  for (int i = 1; i < m; ++i) {\n    while (k != -1 && b[k + 1] != b[i]) {\n      k = next[k];\n    }\n    if (b[k + 1] == b[i]) {\n      ++k;\n    }\n    next[i] = k;\n  }\n  return next;\n}\n```\n\n\n\n1. 这段代码是KMP 字符串匹配算法的代码实现。这段代码完全符合我们刚提到的逻辑复杂、实现难度大、可读性差的特点，但它并不违反 KISS 原则。为什么这么说呢？\n\n2. KMP 算法以快速高效著称。当我们需要处理长文本字符串匹配问题（几百 MB 大小文本内容的匹配），或者字符串匹配是某个产品的核心功能（比如 Vim、Word 等文本编辑器），又或者字符串匹配算法是系统性能瓶颈的时候，我们就应该选择尽可能高效的 KMP 算法。而 KMP 算法本身具有逻辑复杂、实现难度大、可读性差的特点。本身就复杂的问题，用复杂的方法解决，并不违背 KISS 原则。\n3. 不过，平时的项目开发中涉及的字符串匹配问题，大部分都是针对比较小的文本。在这种情况下，直接调用编程语言提供的现成的字符串匹配函数就足够了。如果非得用 KMP 算法、BM 算法来实现字符串匹配，那就真的违背 KISS 原则了。也就是说，同样的代码，在某个业务场景下满足 KISS 原则，换一个应用场景可能就不满足了。\n\n\n\n\n\n### 如何写出满足 KISS 原则的代码？\n\n\n\n实际上，我们前面已经讲到了一些方法。这里我稍微总结一下。\n\n- 不要使用同事可能不懂的技术来实现代码。比如前面例子中的正则表达式，还有一些编程语言中过于高级的语法等。\n- 不要重复造轮子，要善于使用已经有的工具类库。经验证明，自己去实现这些类库，出 bug 的概率会更高，维护的成本也比较高。\n- 不要过度优化。不要过度使用一些奇技淫巧（比如，位运算代替算术运算、复杂的条件语句代替 if-else、使用一些过于底层的函数等）来优化代码，牺牲代码的可读性。\n- 实际上，代码是否足够简单是一个挺主观的评判。同样的代码，有的人觉得简单，有的人觉得不够简单。而往往自己编写的代码，自己都会觉得够简单。所以，评判代码是否简单，还有一个很有效的间接方法，那就是 code review。如果在 code review 的时候，同事对你的代码有很多疑问，那就说明你的代码有可能不够“简单”，需要优化啦。\n\n\n\n\n\n### YAGNI 跟 KISS 说的是一回事吗？\n\n1. YAGNI 原则的英文全称是：You Ain’t Gonna Need It。直译就是：你不会需要它。这条原则也算是万金油了。当用在软件开发中的时候，它的意思是：不要去设计当前用不到的功能；不要去编写当前用不到的代码。实际上，这条原则的核心思想就是：不要做过度设计。\n2. 比如，我们的系统暂时只用 Redis 存储配置信息，以后可能会用到 ZooKeeper。根据 YAGNI 原则，在未用到 ZooKeeper 之前，我们没必要提前编写这部分代码。当然，这并不是说我们就不需要考虑代码的扩展性。我们还是要预留好扩展点，等到需要的时候，再去实现 ZooKeeper 存储配置信息这部分代码。\n3. 再比如，我们不要在项目中提前引入不需要依赖的开发包。对于 Java 程序员来说，我们经常使用 Maven 或者 Gradle 来管理依赖的类库（library）。我发现，有些同事为了避免开发中 library 包缺失而频繁地修改 Maven 或者 Gradle 配置文件，提前往项目里引入大量常用的 library 包。实际上，这样的做法也是违背 YAGNI 原则的。\n4. 从刚刚的分析我们可以看出，YAGNI 原则跟 KISS 原则并非一回事儿。KISS 原则讲的是“如何做”的问题（尽量保持简单），而 YAGNI 原则说的是“要不要做”的问题（当前不需要的就不要做）。\n\n\n\n## DRY 原则\n\nDon’t Repeat Yourself。中文直译为：不要重复自己。将它应用在编程中，可以理解为：不要写重复的代码。DRY 原则的定义非常简单，我就不再过度解读。今天，我们主要讲三种典型的代码重复情况，它们分别是：实现逻辑重复、功能语义重复和代码执行重复。这三种代码重复，有的看似违反 DRY，实际上并不违反；有的看似不违反，实际上却违反了。\n\n\n\n### 实现逻辑重复\n\n我们先来看下面这样一段代码是否违反了 DRY 原则。如果违反了，你觉得应该如何重构，才能让它满足 DRY 原则？如果没有违反，那又是为什么呢？\n\n```java\npublic class UserAuthenticator {\n  public void authenticate(String username, String password) {\n    if (!isValidUsername(username)) {\n      // ...throw InvalidUsernameException...\n    }\n    if (!isValidPassword(password)) {\n      // ...throw InvalidPasswordException...\n    }\n    //...省略其他代码...\n  }\n\n  private boolean isValidUsername(String username) {\n    // check not null, not empty\n    if (StringUtils.isBlank(username)) {\n      return false;\n    }\n    // check length: 4~64\n    int length = username.length();\n    if (length < 4 || length > 64) {\n      return false;\n    }\n    // contains only lowcase characters\n    if (!StringUtils.isAllLowerCase(username)) {\n      return false;\n    }\n    // contains only a~z,0~9,dot\n    for (int i = 0; i < length; ++i) {\n      char c = username.charAt(i);\n      if (!(c >= 'a' && c <= 'z') || (c >= '0' && c <= '9') || c == '.') {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  private boolean isValidPassword(String password) {\n    // check not null, not empty\n    if (StringUtils.isBlank(password)) {\n      return false;\n    }\n    // check length: 4~64\n    int length = password.length();\n    if (length < 4 || length > 64) {\n      return false;\n    }\n    // contains only lowcase characters\n    if (!StringUtils.isAllLowerCase(password)) {\n      return false;\n    }\n    // contains only a~z,0~9,dot\n    for (int i = 0; i < length; ++i) {\n      char c = password.charAt(i);\n      if (!(c >= 'a' && c <= 'z') || (c >= '0' && c <= '9') || c == '.') {\n        return false;\n      }\n    }\n    return true;\n  }\n}\n```\n\n代码很简单，我就不做过多解释了。在代码中，有两处非常明显的重复的代码片段：isValidUserName() 函数和 isValidPassword() 函数。重复的代码被敲了两遍，或者简单 copy-paste 了一下，看起来明显违反 DRY 原则。为了移除重复的代码，我们对上面的代码做下重构，将 isValidUserName() 函数和 isValidPassword() 函数，合并为一个更通用的函数 isValidUserNameOrPassword()。重构后的代码如下所示：\n\n```java\npublic class UserAuthenticatorV2 {\n\n  public void authenticate(String userName, String password) {\n    if (!isValidUsernameOrPassword(userName)) {\n      // ...throw InvalidUsernameException...\n    }\n\n    if (!isValidUsernameOrPassword(password)) {\n      // ...throw InvalidPasswordException...\n    }\n  }\n\n  private boolean isValidUsernameOrPassword(String usernameOrPassword) {\n    //省略实现逻辑\n    //跟原来的isValidUsername()或isValidPassword()的实现逻辑一样...\n    return true;\n  }\n}\n```\n\n1. 经过重构之后，代码行数减少了，也没有重复的代码了，是不是更好了呢？答案是否定的，这可能跟你预期的不一样，我来解释一下为什么。\n2. 单从名字上看，我们就能发现，合并之后的 isValidUserNameOrPassword() 函数，负责两件事情：验证用户名和验证密码，违反了“单一职责原则”和“接口隔离原则”。实际上，即便将两个函数合并成 isValidUserNameOrPassword()，代码仍然存在问题。\n3. 因为 isValidUserName() 和 isValidPassword() 两个函数，虽然从代码实现逻辑上看起来是重复的，但是从语义上并不重复。所谓“语义不重复”指的是：从功能上来看，这两个函数干的是完全不重复的两件事情，一个是校验用户名，另一个是校验密码。尽管在目前的设计中，两个校验逻辑是完全一样的，但如果按照第二种写法，将两个函数的合并，那就会存在潜在的问题。在未来的某一天，如果我们修改了密码的校验逻辑，比如，允许密码包含大写字符，允许密码的长度为 8 到 64 个字符，那这个时候，isValidUserName() 和 isValidPassword() 的实现逻辑就会不相同。我们就要把合并后的函数，重新拆成合并前的那两个函数。\n4. 尽管代码的实现逻辑是相同的，但语义不同，我们判定它并不违反 DRY 原则。对于包含重复代码的问题，我们可以通过抽象成更细粒度函数的方式来解决。比如将校验只包含 a~z、0~9、dot 的逻辑封装成 boolean onlyContains(String str, String charlist); 函数。\n\n\n\n### 功能语义重复\n\n1. 现在我们再来看另外一个例子。在同一个项目代码中有下面两个函数：isValidIp() 和 checkIfIpValid()。尽管两个函数的命名不同，实现逻辑不同，但功能是相同的，都是用来判定 IP 地址是否合法的。\n2. 之所以在同一个项目中会有两个功能相同的函数，那是因为这两个函数是由两个不同的同事开发的，其中一个同事在不知道已经有了 isValidIp() 的情况下，自己又定义并实现了同样用来校验 IP 地址是否合法的 checkIfIpValid() 函数。那在同一项目代码中，存在如下两个函数，是否违反 DRY 原则呢？\n\n```java\npublic boolean isValidIp(String ipAddress) {\n  if (StringUtils.isBlank(ipAddress)) return false;\n  String regex = \"^(1\\\\d{2}|2[0-4]\\\\d|25[0-5]|[1-9]\\\\d|[1-9])\\\\.\"\n          + \"(1\\\\d{2}|2[0-4]\\\\d|25[0-5]|[1-9]\\\\d|\\\\d)\\\\.\"\n          + \"(1\\\\d{2}|2[0-4]\\\\d|25[0-5]|[1-9]\\\\d|\\\\d)\\\\.\"\n          + \"(1\\\\d{2}|2[0-4]\\\\d|25[0-5]|[1-9]\\\\d|\\\\d)$\";\n  return ipAddress.matches(regex);\n}\n\npublic boolean checkIfIpValid(String ipAddress) {\n  if (StringUtils.isBlank(ipAddress)) return false;\n  String[] ipUnits = StringUtils.split(ipAddress, '.');\n  if (ipUnits.length != 4) {\n    return false;\n  }\n  for (int i = 0; i < 4; ++i) {\n    int ipUnitIntValue;\n    try {\n      ipUnitIntValue = Integer.parseInt(ipUnits[i]);\n    } catch (NumberFormatException e) {\n      return false;\n    }\n    if (ipUnitIntValue < 0 || ipUnitIntValue > 255) {\n      return false;\n    }\n    if (i == 0 && ipUnitIntValue == 0) {\n      return false;\n    }\n  }\n  return true;\n}\n```\n\n1. 这个例子跟上个例子正好相反。上一个例子是代码实现逻辑重复，但语义不重复，我们并不认为它违反了 DRY 原则。而在这个例子中，尽管两段代码的实现逻辑不重复，但语义重复，也就是功能重复，我们认为它违反了 DRY 原则。我们应该在项目中，统一一种实现思路，所有用到判断 IP 地址是否合法的地方，都统一调用同一个函数。\n2. 假设我们不统一实现思路，那有些地方调用了 isValidIp() 函数，有些地方又调用了 checkIfIpValid() 函数，这就会导致代码看起来很奇怪，相当于给代码“埋坑”，给不熟悉这部分代码的同事增加了阅读的难度。同事有可能研究了半天，觉得功能是一样的，但又有点疑惑，觉得是不是有更高深的考量，才定义了两个功能类似的函数，最终发现居然是代码设计的问题。\n3. 除此之外，如果哪天项目中 IP 地址是否合法的判定规则改变了，比如：255.255.255.255 不再被判定为合法的了，相应地，我们对 isValidIp() 的实现逻辑做了相应的修改，但却忘记了修改 checkIfIpValid() 函数。又或者，我们压根就不知道还存在一个功能相同的 checkIfIpValid() 函数，这样就会导致有些代码仍然使用老的 IP 地址判断逻辑，导致出现一些莫名其妙的 bug。\n\n\n\n### 代码执行重复\n\n前两个例子一个是实现逻辑重复，一个是语义重复，我们再来看第三个例子。其中，UserService 中 login() 函数用来校验用户登录是否成功。如果失败，就返回异常；如果成功，就返回用户信息。具体代码如下所示：\n\n```java\npublic class UserService {\n  private UserRepo userRepo;//通过依赖注入或者IOC框架注入\n\n  public User login(String email, String password) {\n    boolean existed = userRepo.checkIfUserExisted(email, password);\n    if (!existed) {\n      // ... throw AuthenticationFailureException...\n    }\n    User user = userRepo.getUserByEmail(email);\n    return user;\n  }\n}\n\npublic class UserRepo {\n  public boolean checkIfUserExisted(String email, String password) {\n    if (!EmailValidation.validate(email)) {\n      // ... throw InvalidEmailException...\n    }\n\n    if (!PasswordValidation.validate(password)) {\n      // ... throw InvalidPasswordException...\n    }\n\n    //...query db to check if email&password exists...\n  }\n\n  public User getUserByEmail(String email) {\n    if (!EmailValidation.validate(email)) {\n      // ... throw InvalidEmailException...\n    }\n    //...query db to get user by email...\n  }\n}\n```\n\n1. 上面这段代码，既没有逻辑重复，也没有语义重复，但仍然违反了 DRY 原则。这是因为代码中存在“执行重复”。我们一块儿来看下，到底哪些代码被重复执行了？\n2. 重复执行最明显的一个地方，就是在 login() 函数中，email 的校验逻辑被执行了两次。一次是在调用 checkIfUserExisted() 函数的时候，另一次是调用 getUserByEmail() 函数的时候。这个问题解决起来比较简单，我们只需要将校验逻辑从 UserRepo 中移除，统一放到 UserService 中就可以了。\n3. 除此之外，代码中还有一处比较隐蔽的执行重复，不知道你发现了没有？实际上，login() 函数并不需要调用 checkIfUserExisted() 函数，只需要调用一次 getUserByEmail() 函数，从数据库中获取到用户的 email、password 等信息，然后跟用户输入的 email、password 信息做对比，依次判断是否登录成功。\n4. 实际上，这样的优化是很有必要的。因为 checkIfUserExisted() 函数和 getUserByEmail() 函数都需要查询数据库，而数据库这类的 I/O 操作是比较耗时的。我们在写代码的时候，应当尽量减少这类 I/O 操作。\n5. 按照刚刚的修改思路，我们把代码重构一下，移除“重复执行”的代码，只校验一次 email 和 password，并且只查询一次数据库。重构之后的代码如下所示：\n\n```java\npublic class UserService {\n  private UserRepo userRepo;//通过依赖注入或者IOC框架注入\n\n  public User login(String email, String password) {\n    if (!EmailValidation.validate(email)) {\n      // ... throw InvalidEmailException...\n    }\n    if (!PasswordValidation.validate(password)) {\n      // ... throw InvalidPasswordException...\n    }\n    User user = userRepo.getUserByEmail(email);\n    if (user == null || !password.equals(user.getPassword()) {\n      // ... throw AuthenticationFailureException...\n    }\n    return user;\n  }\n}\n\npublic class UserRepo {\n  public boolean checkIfUserExisted(String email, String password) {\n    //...query db to check if email&password exists\n  }\n\n  public User getUserByEmail(String email) {\n    //...query db to get user by email...\n  }\n}\n```\n\n\n\n### 代码复用性（Code Reusability）\n\n1. 我们首先来区分三个概念：代码复用性（Code Reusability）、代码复用（Code Resue）和 DRY 原则。代码复用表示一种行为：我们在开发新功能的时候，尽量复用已经存在的代码。代码的可复用性表示一段代码可被复用的特性或能力：我们在编写代码的时候，让代码尽量可复用。DRY 原则是一条原则：不要写重复的代码。从定义描述上，它们好像有点类似，但深究起来，三者的区别还是蛮大的。\n\n2. 首先，“不重复”并不代表“可复用”。在一个项目代码中，可能不存在任何重复的代码，但也并不表示里面有可复用的代码，不重复和可复用完全是两个概念。所以，从这个角度来说，DRY 原则跟代码的可复用性讲的是两回事。\n3. 其次，“复用”和“可复用性”关注角度不同。代码“可复用性”是从代码开发者的角度来讲的，“复用”是从代码使用者的角度来讲的。比如，A 同事编写了一个 UrlUtils 类，代码的“可复用性”很好。B 同事在开发新功能的时候，直接“复用”A 同事编写的 UrlUtils 类。尽管复用、可复用性、DRY 原则这三者从理解上有所区别，但实际上要达到的目的都是类似的，都是为了减少代码量，提高代码的可读性、可维护性。除此之外，复用已经经过测试的老代码，bug 会比从零重新开发要少。\n4. “复用”这个概念不仅可以指导细粒度的模块、类、函数的设计开发，实际上，一些框架、类库、组件等的产生也都是为了达到复用的目的。比如，Spring 框架、Google Guava 类库、UI 组件等等。\n\n\n\n### 怎么提高代码复用性？\n\n实际上，我们前面已经讲到过很多提高代码可复用性的手段，今天算是集中总结一下，我总结了 7 条，具体如下。\n\n> 减少代码耦合\n\n对于高度耦合的代码，当我们希望复用其中的一个功能，想把这个功能的代码抽取出来成为一个独立的模块、类或者函数的时候，往往会发现牵一发而动全身。移动一点代码，就要牵连到很多其他相关的代码。所以，高度耦合的代码会影响到代码的复用性，我们要尽量减少代码耦合。\n\n> 满足单一职责原则\n\n我们前面讲过，如果职责不够单一，模块、类设计得大而全，那依赖它的代码或者它依赖的代码就会比较多，进而增加了代码的耦合。根据上一点，也就会影响到代码的复用性。相反，越细粒度的代码，代码的通用性会越好，越容易被复用。\n\n> 模块化\n\n这里的“模块”，不单单指一组类构成的模块，还可以理解为单个类、函数。我们要善于将功能独立的代码，封装成模块。独立的模块就像一块一块的积木，更加容易复用，可以直接拿来搭建更加复杂的系统。\n\n> 业务与非业务逻辑分离\n\n越是跟业务无关的代码越是容易复用，越是针对特定业务的代码越难复用。所以，为了复用跟业务无关的代码，我们将业务和非业务逻辑代码分离，抽取成一些通用的框架、类库、组件等。\n\n> 通用代码下沉\n\n从分层的角度来看，越底层的代码越通用、会被越多的模块调用，越应该设计得足够可复用。一般情况下，在代码分层之后，为了避免交叉调用导致调用关系混乱，我们只允许上层代码调用下层代码及同层代码之间的调用，杜绝下层代码调用上层代码。所以，通用的代码我们尽量下沉到更下层。\n\n> 继承、多态、抽象、封装\n\n在讲面向对象特性的时候，利用继承，可以将公共的代码抽取到父类，子类复用父类的属性和方法。利用多态，我们可以动态地替换一段代码的部分逻辑，让这段代码可复用。除此之外，抽象和封装，从更加广义的层面、而非狭义的面向对象特性的层面来理解的话，越抽象、越不依赖具体的实现，越容易复用。代码封装成模块，隐藏可变的细节、暴露不变的接口，就越容易复用。\n\n> 应用模板等设计模式\n\n一些设计模式，也能提高代码的复用性。比如，模板模式利用了多态来实现，可以灵活地替换其中的部分代码，整个流程模板代码可复用。关于应用设计模式提高代码复用性这一部分，我们留在后面慢慢来讲解。除了刚刚我们讲到的几点，还有一些跟编程语言相关的特性，也能提高代码的复用性，比如泛型编程等。实际上，除了上面讲到的这些方法之外，复用意识也非常重要。在写代码的时候，我们要多去思考一下，这\n\n\n\n\n\n\n\n\n\n## 迪米特法则\n\n\n\n我们讲最后一个设计原则：迪米特法则。尽管它不像 SOLID、KISS、DRY 原则那样，人尽皆知，但它却非常实用。利用这个原则，能够帮我们实现代码的“高内聚、松耦合”。今天，我们就围绕下面几个问题，并结合两个代码实战案例，来深入地学习这个法则。\n\n- 什么是“高内聚、松耦合”？\n- 如何利用迪米特法则来实现“高内聚、松耦合”？\n- 有哪些代码设计是明显违背迪米特法则的？对此又该如何重构？\n\n\n\n\n\n### 何为“高内聚、松耦合”？\n\n1. “高内聚、松耦合”是一个非常重要的设计思想，能够有效地提高代码的可读性和可维护性，缩小功能改动导致的代码改动范围。\n2. 实际上，在前面的章节中，我们已经多次提到过这个设计思想。很多设计原则都以实现代码的“高内聚、松耦合”为目的，比如单一职责原则、基于接口而非实现编程等。实际上，“高内聚、松耦合”是一个比较通用的设计思想，可以用来指导不同粒度代码的设计与开发，比如系统、模块、类，甚至是函数，也可以应用到不同的开发场景中，比如微服务、框架、组件、类库等。为了方便我讲解，接下来我以“类”作为这个设计思想的应用对象来展开讲解，其他应用场景你可以自行类比。\n3. 在这个设计思想中，“高内聚”用来指导类本身的设计，“松耦合”用来指导类与类之间依赖关系的设计。不过，这两者并非完全独立不相干。高内聚有助于松耦合，松耦合又需要高内聚的支持。\n\n\n\n> 那到底什么是“高内聚”呢？\n\n\n\n所谓高内聚，就是指相近的功能应该放到同一个类中，不相近的功能不要放到同一个类中。相近的功能往往会被同时修改，放到同一个类中，修改会比较集中，代码容易维护。实际上，我们前面讲过的单一职责原则是实现代码高内聚非常有效的设计原则。\n\n\n\n> 我们再来看一下，什么是“松耦合”？\n\n所谓松耦合是说，在代码中，类与类之间的依赖关系简单清晰。即使两个类有依赖关系，一个类的代码改动不会或者很少导致依赖类的代码改动。实际上，我们前面讲的依赖注入、接口隔离、基于接口而非实现编程，以及今天讲的迪米特法则，都是为了实现代码的松耦合\n\n\n\n\n\n> 最后，我们来看一下，“内聚”和“耦合”之间的关系\n\n前面也提到，“高内聚”有助于“松耦合”，同理，“低内聚”也会导致“紧耦合”。关于这一点，我画了一张对比图来解释。图中左边部分的代码结构是“高内聚、松耦合”；右边部分正好相反，是“低内聚、紧耦合”。\n\n<img src=\"https://npm.elemecdn.com/youthlql@1.0.0/design_patterns/design_principles/0001.png\" />\n\n\n\n\n\n1. 图中左边部分的代码设计中，类的粒度比较小，每个类的职责都比较单一。相近的功能都放到了一个类中，不相近的功能被分割到了多个类中。这样类更加独立，代码的内聚性更好。因为职责单一，所以每个类被依赖的类就会比较少，代码低耦合。一个类的修改，只会影响到一个依赖类的代码改动。我们只需要测试这一个依赖类是否还能正常工作就行了。\n2. 图中右边部分的代码设计中，类粒度比较大，低内聚，功能大而全，不相近的功能放到了一个类中。这就导致很多其他类都依赖这个类。当我们修改这个类的某一个功能代码的时候，会影响依赖它的多个类。我们需要测试这三个依赖类，是否还能正常工作。这也就是所谓的“牵一发而动全身”。\n3. 除此之外，从图中我们也可以看出，高内聚、低耦合的代码结构更加简单、清晰，相应地，在可维护性和可读性上确实要好很多。\n\n\n\n\n\n### “迪米特法则”理论描述\n\n1. 迪米特法则的英文翻译是：Law of Demeter，缩写是 LOD。单从这个名字上来看，我们完全猜不出这个原则讲的是什么。不过，它还有另外一个更加达意的名字，叫作最小知识原则，英文翻译为：The Least Knowledge Principle。\n\n2. 关于这个设计原则，我们先来看一下它最原汁原味的英文定义：\n\n   > Each unit should have only limited knowledge about other units: only units “closely” related to the current unit. Or: Each unit should only talk to its friends; Don’t talk to strangers.\n\n   我们把它直译成中文，就是下面这个样子：\n\n   > 每个模块（unit）只应该了解那些与它关系密切的模块（units: only units “closely” related to the current unit）的有限知识（knowledge）。或者说，每个模块只和自己的朋友“说话”（talk），不和陌生人“说话”（talk）。\n\n   我们之前讲过，大部分设计原则和思想都非常抽象，有各种各样的解读，要想灵活地应用到实际的开发中，需要有实战经验的积累。迪米特法则也不例外。所以，我结合我自己的理解和经验，对刚刚的定义重新描述一下。注意，为了统一讲解，我把定义描述中的“模块”替换成了“类”。\n\n   > 不该有直接依赖关系的类之间，不要有依赖；有依赖关系的类之间，尽量只依赖必要的接口（也就是定义中的“有限知识”）。从上面的描述中，我们可以看出，迪米特法则包含前后两部分，这两部分讲的是两件事情，我用两个实战案例分别来解读一下。\n\n\n\n\n\n### 理论解读与代码实战一\n\n1. 我们先来看这条原则中的前半部分，**“不该有直接依赖关系的类之间，不要有依赖”**。我举个例子解释一下。\n2. 这个例子实现了简化版的搜索引擎爬取网页的功能。代码中包含三个主要的类。其中，NetworkTransporter 类负责底层网络通信，根据请求获取数据；HtmlDownloader 类用来通过 URL 获取网页；Document 表示网页文档，后续的网页内容抽取、分词、索引都是以此为处理对象。具体的代码实现如下所示：\n\n```java\npublic class NetworkTransporter {\n    // 省略属性和其他方法...\n    public Byte[] send(HtmlRequest htmlRequest) {\n      //...\n    }\n}\n\npublic class HtmlDownloader {\n  private NetworkTransporter transporter;//通过构造函数或IOC注入\n  \n  public Html downloadHtml(String url) {\n    Byte[] rawHtml = transporter.send(new HtmlRequest(url));\n    return new Html(rawHtml);\n  }\n}\n\npublic class Document {\n  private Html html;\n  private String url;\n  \n  public Document(String url) {\n    this.url = url;\n    HtmlDownloader downloader = new HtmlDownloader();\n    this.html = downloader.downloadHtml(url);\n  }\n  //...\n}\n```\n\n1. 这段代码虽然“能用”，能实现我们想要的功能，但是它不够“好用”，有比较多的设计缺陷。你可以先试着思考一下，看看都有哪些缺陷，然后再来看我下面的讲解。\n2. 首先，我们来看 NetworkTransporter 类。作为一个底层网络通信类，我们希望它的功能尽可能通用，而不只是服务于下载 HTML，所以，我们不应该直接依赖太具体的发送对象 HtmlRequest。从这一点上讲，NetworkTransporter 类的设计违背迪米特法则，依赖了不该有直接依赖关系的 HtmlRequest 类。\n3. 我们应该如何进行重构，让 NetworkTransporter 类满足迪米特法则呢？我这里有个形象的比喻。假如你现在要去商店买东西，你肯定不会直接把钱包给收银员，让收银员自己从里面拿钱，而是你从钱包里把钱拿出来交给收银员。这里的 HtmlRequest 对象就相当于钱包，HtmlRequest 里的 address 和 content 对象就相当于钱。我们应该把 address 和 content 交给 NetworkTransporter，而非是直接把 HtmlRequest 交给 NetworkTransporter。根据这个思路，NetworkTransporter 重构之后的代码如下所示：\n\n```java\npublic class NetworkTransporter {\n    // 省略属性和其他方法...\n    public Byte[] send(String address, Byte[] data) {\n      //...\n    }\n}\n```\n\n\n\n我们再来看 HtmlDownloader 类。这个类的设计没有问题。不过，我们修改了 NetworkTransporter 的 send() 函数的定义，而这个类用到了 send() 函数，所以我们需要对它做相应的修改，修改后的代码如下所示\n\n\n\n```java\npublic class HtmlDownloader {\n  private NetworkTransporter transporter;//通过构造函数或IOC注入\n  \n  // HtmlDownloader这里也要有相应的修改\n  public Html downloadHtml(String url) {\n    HtmlRequest htmlRequest = new HtmlRequest(url);\n    Byte[] rawHtml = transporter.send(\n      htmlRequest.getAddress(), htmlRequest.getContent().getBytes());\n    return new Html(rawHtml);\n  }\n}\n```\n\n\n\n最后，我们来看下 Document 类。这个类的问题比较多，主要有三点。第一，构造函数中的 downloader.downloadHtml() 逻辑复杂，耗时长，不应该放到构造函数中，会影响代码的可测试性。代码的可测试性我们后面会讲到，这里你先知道有这回事就可以了。第二，HtmlDownloader 对象在构造函数中通过 new 来创建，违反了基于接口而非实现编程的设计思想，也会影响到代码的可测试性。第三，从业务含义上来讲，Document 网页文档没必要依赖 HtmlDownloader 类，违背了迪米特法则。\n\n虽然 Document 类的问题很多，但修改起来比较简单，只要一处改动就可以解决所有问题。修改之后的代码如下所示：\n\n```java\npublic class Document {\n  private Html html;\n  private String url;\n  \n  public Document(String url, Html html) {\n    this.html = html;\n    this.url = url;\n  }\n  //...\n}\n\n// 通过一个工厂方法来创建Document\npublic class DocumentFactory {\n  private HtmlDownloader downloader;\n  \n  public DocumentFactory(HtmlDownloader downloader) {\n    this.downloader = downloader;\n  }\n  \n  public Document createDocument(String url) {\n    Html html = downloader.downloadHtml(url);\n    return new Document(url, html);\n  }\n}\n```\n\n\n\n\n\n### 理论解读与代码实战二\n\n现在，我们再来看一下这条原则中的后半部分：“有依赖关系的类之间，尽量只依赖必要的接口”。我们还是结合一个例子来讲解。下面这段代码非常简单，Serialization 类负责对象的序列化和反序列化\n\n\n\n```java\npublic class Serialization {\n  public String serialize(Object object) {\n    String serializedResult = ...;\n    //...\n    return serializedResult;\n  }\n  \n  public Object deserialize(String str) {\n    Object deserializedResult = ...;\n    //...\n    return deserializedResult;\n  }\n}\n```\n\n\n\n1. 单看这个类的设计，没有一点问题。不过，如果我们把它放到一定的应用场景里，那就还有继续优化的空间。假设在我们的项目中，有些类只用到了序列化操作，而另一些类只用到反序列化操作。那基于迪米特法则后半部分“有依赖关系的类之间，尽量只依赖必要的接口”，只用到序列化操作的那部分类不应该依赖反序列化接口。同理，只用到反序列化操作的那部分类不应该依赖序列化接口。\n2. 根据这个思路，我们应该将 Serialization 类拆分为两个更小粒度的类，一个只负责序列化（Serializer 类），一个只负责反序列化（Deserializer 类）。拆分之后，使用序列化操作的类只需要依赖 Serializer 类，使用反序列化操作的类只需要依赖 Deserializer 类。拆分之后的代码如下所示：\n\n```java\npublic class Serializer {\n  public String serialize(Object object) {\n    String serializedResult = ...;\n    ...\n    return serializedResult;\n  }\n}\n\npublic class Deserializer {\n  public Object deserialize(String str) {\n    Object deserializedResult = ...;\n    ...\n    return deserializedResult;\n  }\n}\n```\n\n\n\n\n\n1. 不知道你有没有看出来，尽管拆分之后的代码更能满足迪米特法则，但却违背了高内聚的设计思想。高内聚要求相近的功能要放到同一个类中，这样可以方便功能修改的时候，修改的地方不至于过于分散。对于刚刚这个例子来说，如果我们修改了序列化的实现方式，比如从 JSON 换成了 XML，那反序列化的实现逻辑也需要一并修改。在未拆分的情况下，我们只需要修改一个类即可。在拆分之后，我们需要修改两个类。显然，这种设计思路的代码改动范围变大了。\n2. 如果我们既不想违背高内聚的设计思想，也不想违背迪米特法则，那我们该如何解决这个问题呢？实际上，通过引入两个接口就能轻松解决这个问题，具体的代码如下所示。实际上，我们在讲到“接口隔离原则”的时候，第三个例子就使用了类似的实现思路，你可以结合着一块儿来看。\n\n```java\npublic interface Serializable {\n  String serialize(Object object);\n}\n\npublic interface Deserializable {\n  Object deserialize(String text);\n}\n\npublic class Serialization implements Serializable, Deserializable {\n  @Override\n  public String serialize(Object object) {\n    String serializedResult = ...;\n    ...\n    return serializedResult;\n  }\n  \n  @Override\n  public Object deserialize(String str) {\n    Object deserializedResult = ...;\n    ...\n    return deserializedResult;\n  }\n}\n\npublic class DemoClass_1 {\n  private Serializable serializer;\n  \n  public Demo(Serializable serializer) {\n    this.serializer = serializer;\n  }\n  //...\n}\n\npublic class DemoClass_2 {\n  private Deserializable deserializer;\n  \n  public Demo(Deserializable deserializer) {\n    this.deserializer = deserializer;\n  }\n  //...\n}\n```\n\n1. 尽管我们还是要往 DemoClass_1 的构造函数中，传入包含序列化和反序列化的 Serialization 实现类，但是，我们依赖的 Serializable 接口只包含序列化操作，DemoClass_1 无法使用 Serialization 类中的反序列化接口，对反序列化操作无感知，这也就符合了迪米特法则后半部分所说的“依赖有限接口”的要求。\n2. 实际上，上面的的代码实现思路，也体现了“基于接口而非实现编程”的设计原则，结合迪米特法则，我们可以总结出一条新的设计原则，那就是“基于最小接口而非最大实现编程”。有些同学之前问，新的设计模式和设计原则是怎么创造出来的，实际上，就是在大量的实践中，针对开发痛点总结归纳出来的套路。\n\n\n\n### 辩证思考与灵活应用\n\n1. 对于实战二最终的设计思路，你有没有什么不同的观点呢？\n2. 整个类只包含序列化和反序列化两个操作，只用到序列化操作的使用者，即便能够感知到仅有的一个反序列化函数，问题也不大。那为了满足迪米特法则，我们将一个非常简单的类，拆分出两个接口，是否有点过度设计的意思呢？\n3. 设计原则本身没有对错，只有能否用对之说。不要为了应用设计原则而应用设计原则，我们在应用设计原则的时候，一定要具体问题具体分析。\n4. 对于刚刚这个 Serialization 类来说，只包含两个操作，确实没有太大必要拆分成两个接口。但是，如果我们对 Serialization 类添加更多的功能，实现更多更好用的序列化、反序列化函数，我们来重新考虑一下这个问题。修改之后的具体的代码如下\n\n```java\npublic class Serializer { // 参看JSON的接口定义\n  public String serialize(Object object) { //... }\n  public String serializeMap(Map map) { //... }\n  public String serializeList(List list) { //... }\n  \n  public Object deserialize(String objectString) { //... }\n  public Map deserializeMap(String mapString) { //... }\n  public List deserializeList(String listString) { //... }\n}\n```\n\n在这种场景下，第二种设计思路要更好些。因为基于之前的应用场景来说，大部分代码只需要用到序列化的功能。对于这部分使用者，没必要了解反序列化的“知识”，而修改之后的 Serialization 类，反序列化的“知识”，从一个函数变成了三个。一旦任一反序列化操作有代码改动，我们都需要检查、测试所有依赖 Serialization 类的代码是否还能正常工作。为了减少耦合和测试工作量，我们应该按照迪米特法则，将反序列化和序列化的功能隔离开来。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"2024-05-01-设计模式-02.经典设计原则-第二节[必读]","published":1,"updated":"2024-05-01T05:28:39.562Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clxjyo3ce000pisvd3at1bmdq","content":"<h1 id=\"声明\"><a href=\"#声明\" class=\"headerlink\" title=\"声明\"></a>声明</h1><blockquote>\n<ol>\n<li>此系列文章非本人原创，是学习笔记。</li>\n<li>设计模式系列以后会持续更新，包括已经发布的设计模式文章，因为后续还要再多看一下书，教程和开源项目等，继续润色文章。</li>\n</ol>\n</blockquote>\n<h1 id=\"设计模式经典设计原则-第二节\"><a href=\"#设计模式经典设计原则-第二节\" class=\"headerlink\" title=\"设计模式经典设计原则-第二节\"></a>设计模式经典设计原则-第二节</h1><h2 id=\"依赖反转原则（DIP）\"><a href=\"#依赖反转原则（DIP）\" class=\"headerlink\" title=\"依赖反转原则（DIP）\"></a>依赖反转原则（DIP）</h2><p>关于 SOLID 原则，我们已经学过单一职责、开闭、里式替换、接口隔离这四个原则。今天，我们再来学习最后一个原则：依赖反转原则。在前面，我们讲到，单一职责原则和开闭原则的原理比较简单，但是，想要在实践中用好却比较难。而今天我们要讲到的依赖反转原则正好相反。这个原则用起来比较简单，但概念理解起来比较难。比如，下面这几个问题，你看看能否清晰地回答出来：</p>\n<ul>\n<li>“依赖反转”这个概念指的是“谁跟谁”的“什么依赖”被反转了？“反转”两个字该如何理解？</li>\n<li>我们还经常听到另外两个概念：“控制反转”和“依赖注入”。这两个概念跟“依赖反转”有什么区别和联系呢？它们说的是同一个事情吗？</li>\n<li>如果你熟悉 Java 语言，那 Spring 框架中的 IOC 跟这些概念又有什么关系呢？</li>\n</ul>\n<h3 id=\"控制反转（IOC）\"><a href=\"#控制反转（IOC）\" class=\"headerlink\" title=\"控制反转（IOC）\"></a>控制反转（IOC）</h3><p>在讲“依赖反转原则”之前，我们先讲一讲“控制反转”。控制反转的英文翻译是 Inversion Of Control，缩写为 IOC。此处我要强调一下，暂时别把这个“IOC”跟 Spring 框架的 IOC 联系在一起。关于 Spring 的 IOC，我们待会儿还会讲到。我们先通过一个例子来看一下，什么是控制反转。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">UserServiceTest</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"type\">boolean</span> <span class=\"title function_\">doTest</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ... </span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;<span class=\"comment\">//这部分逻辑可以放到框架中</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (doTest()) &#123;</span><br><span class=\"line\">      System.out.println(<span class=\"string\">&quot;Test succeed.&quot;</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      System.out.println(<span class=\"string\">&quot;Test failed.&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在上面的代码中，所有的流程都由程序员来控制。如果我们抽象出一个下面这样一个框架，我们再来看，如何利用框架来实现同样的功能。具体的代码实现如下所示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">class</span> <span class=\"title class_\">TestCase</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (doTest()) &#123;</span><br><span class=\"line\">      System.out.println(<span class=\"string\">&quot;Test succeed.&quot;</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      System.out.println(<span class=\"string\">&quot;Test failed.&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"type\">boolean</span> <span class=\"title function_\">doTest</span><span class=\"params\">()</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">JunitApplication</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> List&lt;TestCase&gt; testCases = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">register</span><span class=\"params\">(TestCase testCase)</span> &#123;</span><br><span class=\"line\">    testCases.add(testCase);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (TestCase <span class=\"keyword\">case</span>: testCases) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">case</span>.run();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n<p>把这个简化版本的测试框架引入到工程中之后，我们只需要在框架预留的扩展点，也就是 TestCase 类中的 doTest() 抽象函数中，填充具体的测试代码就可以实现之前的功能了，完全不需要写负责执行流程的 main() 函数了。 具体的代码如下所示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">UserServiceTest</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">TestCase</span> &#123;</span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">doTest</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ... </span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 注册操作还可以通过配置的方式来实现，不需要程序员显示调用register()</span></span><br><span class=\"line\">JunitApplication.register(<span class=\"keyword\">new</span> <span class=\"title class_\">UserServiceTest</span>();</span><br></pre></td></tr></table></figure>\n\n\n\n<ol>\n<li>刚刚举的这个例子，就是典型的通过框架来实现“控制反转”的例子。框架提供了一个可扩展的代码骨架，用来组装对象、管理整个执行流程。程序员利用框架进行开发的时候，只需要往预留的扩展点上，添加跟自己业务相关的代码，就可以利用框架来驱动整个程序流程的执行。</li>\n<li>这里的“控制”指的是对程序执行流程的控制，而“反转”指的是在没有使用框架之前，程序员自己控制整个程序的执行。在使用框架之后，整个程序的执行流程可以通过框架来控制。流程的控制权从程序员“反转”到了框架。</li>\n<li>实际上，实现控制反转的方法有很多，除了刚才例子中所示的类似于模板设计模式的方法之外，还有马上要讲到的依赖注入等方法，所以，控制反转并不是一种具体的实现技巧，而是一个比较笼统的设计思想，一般用来指导框架层面的设计。</li>\n</ol>\n<h3 id=\"依赖注入（DI）\"><a href=\"#依赖注入（DI）\" class=\"headerlink\" title=\"依赖注入（DI）\"></a>依赖注入（DI）</h3><ol>\n<li>接下来，我们再来看依赖注入。依赖注入跟控制反转恰恰相反，它是一种具体的编码技巧。那到底什么是依赖注入呢？我们用一句话来概括就是：不通过 new() 的方式在类内部创建依赖类对象，而是将依赖的类对象在外部创建好之后，通过构造函数、函数参数等方式传递（或注入）给类使用。</li>\n<li>我们还是通过一个例子来解释一下。在这个例子中，Notification 类负责消息推送，依赖 MessageSender 类实现推送商品促销、验证码等消息给用户。我们分别用依赖注入和非依赖注入两种方式来实现一下。具体的实现代码如下所示：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 非依赖注入实现方式</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Notification</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> MessageSender messageSender;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"title function_\">Notification</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.messageSender = <span class=\"keyword\">new</span> <span class=\"title class_\">MessageSender</span>(); <span class=\"comment\">//此处有点像hardcode</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">sendMessage</span><span class=\"params\">(String cellphone, String message)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//...省略校验逻辑等...</span></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.messageSender.send(cellphone, message);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">MessageSender</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">send</span><span class=\"params\">(String cellphone, String message)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//....</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 使用Notification</span></span><br><span class=\"line\"><span class=\"type\">Notification</span> <span class=\"variable\">notification</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Notification</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 依赖注入的实现方式</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Notification</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> MessageSender messageSender;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">// 通过构造函数将messageSender传递进来</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"title function_\">Notification</span><span class=\"params\">(MessageSender messageSender)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.messageSender = messageSender;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">sendMessage</span><span class=\"params\">(String cellphone, String message)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//...省略校验逻辑等...</span></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.messageSender.send(cellphone, message);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//使用Notification</span></span><br><span class=\"line\"><span class=\"type\">MessageSender</span> <span class=\"variable\">messageSender</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">MessageSender</span>();</span><br><span class=\"line\"><span class=\"type\">Notification</span> <span class=\"variable\">notification</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Notification</span>(messageSender);</span><br></pre></td></tr></table></figure>\n\n<p>通过依赖注入的方式来将依赖的类对象传递进来，这样就提高了代码的扩展性，我们可以灵活地替换依赖的类。这一点在我们之前讲“开闭原则”的时候也提到过。当然，上面代码还有继续优化的空间，我们还可以把 MessageSender 定义成接口，基于接口而非实现编程。改造后的代码如下所示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Notification</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> MessageSender messageSender;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"title function_\">Notification</span><span class=\"params\">(MessageSender messageSender)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.messageSender = messageSender;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">sendMessage</span><span class=\"params\">(String cellphone, String message)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.messageSender.send(cellphone, message);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">MessageSender</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">void</span> <span class=\"title function_\">send</span><span class=\"params\">(String cellphone, String message)</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 短信发送类</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">SmsSender</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">MessageSender</span> &#123;</span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">send</span><span class=\"params\">(String cellphone, String message)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//....</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 站内信发送类</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">InboxSender</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">MessageSender</span> &#123;</span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">send</span><span class=\"params\">(String cellphone, String message)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//....</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//使用Notification</span></span><br><span class=\"line\"><span class=\"type\">MessageSender</span> <span class=\"variable\">messageSender</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">SmsSender</span>();</span><br><span class=\"line\"><span class=\"type\">Notification</span> <span class=\"variable\">notification</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Notification</span>(messageSender);</span><br></pre></td></tr></table></figure>\n\n\n\n<p>实际上，你只需要掌握刚刚举的这个例子，就等于完全掌握了依赖注入。尽管依赖注入非常简单，但却非常有用，</p>\n<h3 id=\"依赖注入框架（DI-Framework）\"><a href=\"#依赖注入框架（DI-Framework）\" class=\"headerlink\" title=\"依赖注入框架（DI Framework）\"></a>依赖注入框架（DI Framework）</h3><p>弄懂了什么是“依赖注入”，我们再来看一下，什么是“依赖注入框架”。我们还是借用刚刚的例子来解释。在采用依赖注入实现的 Notification 类中，虽然我们不需要用类似 hard code 的方式，在类内部通过 new 来创建 MessageSender 对象，但是，这个创建对象、组装（或注入）对象的工作仅仅是被移动到了更上层代码而已，还是需要我们程序员自己来实现。具体代码如下所示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Demo</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String args[])</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">MessageSender</span> <span class=\"variable\">sender</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">SmsSender</span>(); <span class=\"comment\">//创建对象</span></span><br><span class=\"line\">    <span class=\"type\">Notification</span> <span class=\"variable\">notification</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Notification</span>(sender);<span class=\"comment\">//依赖注入</span></span><br><span class=\"line\">    notification.sendMessage(<span class=\"string\">&quot;13918942177&quot;</span>, <span class=\"string\">&quot;短信验证码：2346&quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>在实际的软件开发中，一些项目可能会涉及几十、上百、甚至几百个类，类对象的创建和依赖注入会变得非常复杂。如果这部分工作都是靠程序员自己写代码来完成，容易出错且开发成本也比较高。而对象创建和依赖注入的工作，本身跟具体的业务无关，我们完全可以抽象成框架来自动完成。</li>\n<li>你可能已经猜到，这个框架就是“依赖注入框架”。我们只需要通过依赖注入框架提供的扩展点，简单配置一下所有需要创建的类对象、类与类之间的依赖关系，就可以实现由框架来自动创建对象、管理对象的生命周期、依赖注入等原本需要程序员来做的事情。</li>\n<li>实际上，现成的依赖注入框架有很多，比如 Google Guice、Java Spring、Pico Container、Butterfly Container 等。不过，如果你熟悉 Java Spring 框架，你可能会说，Spring 框架自己声称是控制反转容器（Inversion Of Control Container）。</li>\n<li>实际上，这两种说法都没错。只是控制反转容器这种表述是一种非常宽泛的描述，DI 依赖注入框架的表述更具体、更有针对性。因为我们前面讲到实现控制反转的方式有很多，除了依赖注入，还有模板模式等，而 Spring 框架的控制反转主要是通过依赖注入来实现的。不过这点区分并不是很明显，也不是很重要，你稍微了解一下就可以了。</li>\n</ol>\n<h3 id=\"什么是依赖反转原则？\"><a href=\"#什么是依赖反转原则？\" class=\"headerlink\" title=\"什么是依赖反转原则？\"></a>什么是依赖反转原则？</h3><ol>\n<li>前面讲了控制反转、依赖注入、依赖注入框架，现在，我们来讲一讲今天的主角：依赖反转原则。依赖反转原则的英文翻译是 Dependency Inversion Principle，缩写为 DIP。中文翻译有时候也叫依赖倒置原则。</li>\n<li>英文描述：High-level modules shouldn’t depend on low-level modules. Both modules should depend on abstractions. In addition, abstractions shouldn’t depend on details. Details depend on abstractions.</li>\n<li>我们将它翻译成中文，大概意思就是：高层模块（high-level modules）不要依赖低层模块（low-level）。高层模块和低层模块应该通过抽象（abstractions）来互相依赖。除此之外，抽象（abstractions）不要依赖具体实现细节（details），具体实现细节（details）依赖抽象（abstractions）。</li>\n<li>所谓高层模块和低层模块的划分，简单来说就是，在调用链上，调用者属于高层，被调用者属于低层。在平时的业务代码开发中，高层模块依赖底层模块是没有任何问题的。实际上，这条原则主要还是用来指导框架层面的设计，跟前面讲到的控制反转类似。我们拿 Tomcat 这个 Servlet 容器作为例子来解释一下。</li>\n<li>Tomcat 是运行 Java Web 应用程序的容器。我们编写的 Web 应用程序代码只需要部署在 Tomcat 容器下，便可以被 Tomcat 容器调用执行。按照之前的划分原则，Tomcat 就是高层模块，我们编写的 Web 应用程序代码就是低层模块。Tomcat 和应用程序代码之间并没有直接的依赖关系，两者都依赖同一个“抽象”，也就是 Servlet 规范。Servlet 规范不依赖具体的 Tomcat 容器和应用程序的实现细节，而 Tomcat 容器和应用程序依赖 Servlet 规范。</li>\n</ol>\n<h2 id=\"KISS原则和YAGNI原则\"><a href=\"#KISS原则和YAGNI原则\" class=\"headerlink\" title=\"KISS原则和YAGNI原则\"></a>KISS原则和YAGNI原则</h2><ol>\n<li>我们学习了经典的 SOLID 原则。今天，我们讲两个设计原则：KISS 原则和 YAGNI 原则。其中，KISS 原则比较经典，耳熟能详，但 YAGNI 你可能没怎么听过，不过它理解起来也不难。</li>\n<li>理解这两个原则时候，经常会有一个共同的问题，那就是，看一眼就感觉懂了，但深究的话，又有很多细节问题不是很清楚。比如，怎么理解 KISS 原则中“简单”两个字？什么样的代码才算“简单”？怎样的代码才算“复杂”？如何才能写出“简单”的代码？YAGNI 原则跟 KISS 原则说的是一回事吗？</li>\n</ol>\n<p>KISS 原则的英文描述有好几个版本，比如下面这几个。</p>\n<ul>\n<li>Keep It Simple and Stupid.</li>\n<li>Keep It Short and Simple.</li>\n<li>Keep It Simple and Straightforward.</li>\n</ul>\n<ol>\n<li><p>不过，仔细看你就会发现，它们要表达的意思其实差不多，翻译成中文就是：尽量保持简单。</p>\n</li>\n<li><p>我们知道，代码的可读性和可维护性是衡量代码质量非常重要的两个标准。而 KISS 原则就是保持代码可读和可维护的重要手段。代码足够简单，也就意味着很容易读懂，bug 比较难隐藏。即便出现 bug，修复起来也比较简单。不过，这条原则只是告诉我们，要保持代码“Simple and Stupid”，但并没有讲到，什么样的代码才是“Simple and Stupid”的，更没有给出特别明确的方法论，来指导如何开发出“Simple and Stupid”的代码。</p>\n</li>\n<li><p>所以，接下来，为了能让这条原则切实地落地，能够指导实际的项目开发，我就针对刚刚的这些问题来进一步讲讲我的理解。</p>\n</li>\n</ol>\n<h3 id=\"代码行数越少就越“简单”吗？\"><a href=\"#代码行数越少就越“简单”吗？\" class=\"headerlink\" title=\"代码行数越少就越“简单”吗？\"></a>代码行数越少就越“简单”吗？</h3><p>我们先一起看一个例子。下面这三段代码可以实现同样一个功能：检查输入的字符串 ipAddress 是否是合法的 IP 地址。一个合法的 IP 地址由四个数字组成，并且通过“.”来进行分割。每组数字的取值范围是 0~255。第一组数字比较特殊，不允许为 0。对比这三段代码，你觉得哪一段代码最符合 KISS 原则呢？如果让你来实现这个功能，你会选择用哪种实现方法呢？你可以先自己思考一下，然后再看我下面的讲解。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 第一种实现方式: 使用正则表达式</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">isValidIpAddressV1</span><span class=\"params\">(String ipAddress)</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (StringUtils.isBlank(ipAddress)) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  <span class=\"type\">String</span> <span class=\"variable\">regex</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;^(1\\\\d&#123;2&#125;|2[0-4]\\\\d|25[0-5]|[1-9]\\\\d|[1-9])\\\\.&quot;</span></span><br><span class=\"line\">          + <span class=\"string\">&quot;(1\\\\d&#123;2&#125;|2[0-4]\\\\d|25[0-5]|[1-9]\\\\d|\\\\d)\\\\.&quot;</span></span><br><span class=\"line\">          + <span class=\"string\">&quot;(1\\\\d&#123;2&#125;|2[0-4]\\\\d|25[0-5]|[1-9]\\\\d|\\\\d)\\\\.&quot;</span></span><br><span class=\"line\">          + <span class=\"string\">&quot;(1\\\\d&#123;2&#125;|2[0-4]\\\\d|25[0-5]|[1-9]\\\\d|\\\\d)$&quot;</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> ipAddress.matches(regex);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 第二种实现方式: 使用现成的工具类</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">isValidIpAddressV2</span><span class=\"params\">(String ipAddress)</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (StringUtils.isBlank(ipAddress)) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  String[] ipUnits = StringUtils.split(ipAddress, <span class=\"string\">&#x27;.&#x27;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (ipUnits.length != <span class=\"number\">4</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">4</span>; ++i) &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> ipUnitIntValue;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      ipUnitIntValue = Integer.parseInt(ipUnits[i]);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (NumberFormatException e) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ipUnitIntValue &lt; <span class=\"number\">0</span> || ipUnitIntValue &gt; <span class=\"number\">255</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (i == <span class=\"number\">0</span> &amp;&amp; ipUnitIntValue == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 第三种实现方式: 不使用任何工具类</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">isValidIpAddressV3</span><span class=\"params\">(String ipAddress)</span> &#123;</span><br><span class=\"line\">  <span class=\"type\">char</span>[] ipChars = ipAddress.toCharArray();</span><br><span class=\"line\">  <span class=\"type\">int</span> <span class=\"variable\">length</span> <span class=\"operator\">=</span> ipChars.length;</span><br><span class=\"line\">  <span class=\"type\">int</span> <span class=\"variable\">ipUnitIntValue</span> <span class=\"operator\">=</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"type\">boolean</span> <span class=\"variable\">isFirstUnit</span> <span class=\"operator\">=</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">  <span class=\"type\">int</span> <span class=\"variable\">unitsCount</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; length; ++i) &#123;</span><br><span class=\"line\">    <span class=\"type\">char</span> <span class=\"variable\">c</span> <span class=\"operator\">=</span> ipChars[i];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (c == <span class=\"string\">&#x27;.&#x27;</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (ipUnitIntValue &lt; <span class=\"number\">0</span> || ipUnitIntValue &gt; <span class=\"number\">255</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (isFirstUnit &amp;&amp; ipUnitIntValue == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (isFirstUnit) isFirstUnit = <span class=\"literal\">false</span>;</span><br><span class=\"line\">      ipUnitIntValue = -<span class=\"number\">1</span>;</span><br><span class=\"line\">      unitsCount++;</span><br><span class=\"line\">      <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (c &lt; <span class=\"string\">&#x27;0&#x27;</span> || c &gt; <span class=\"string\">&#x27;9&#x27;</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ipUnitIntValue == -<span class=\"number\">1</span>) ipUnitIntValue = <span class=\"number\">0</span>;</span><br><span class=\"line\">    ipUnitIntValue = ipUnitIntValue * <span class=\"number\">10</span> + (c - <span class=\"string\">&#x27;0&#x27;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (ipUnitIntValue &lt; <span class=\"number\">0</span> || ipUnitIntValue &gt; <span class=\"number\">255</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (unitsCount != <span class=\"number\">3</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<ol>\n<li>第一种实现方式利用的是正则表达式，只用三行代码就把这个问题搞定了。它的代码行数最少，那是不是就最符合 KISS 原则呢？答案是否定的。虽然代码行数最少，看似最简单，实际上却很复杂。这正是因为它使用了正则表达式。</li>\n<li>一方面，正则表达式本身是比较复杂的，写出完全没有 bug 的正则表达本身就比较有挑战；另一方面，并不是每个程序员都精通正则表达式。对于不怎么懂正则表达式的同事来说，看懂并且维护这段正则表达式是比较困难的。这种实现方式会导致代码的可读性和可维护性变差，所以，从 KISS 原则的设计初衷上来讲，这种实现方式并不符合 KISS 原则。</li>\n<li>讲完了第一种实现方式，我们再来看下其他两种实现方式。</li>\n<li>第二种实现方式使用了 StringUtils 类、Integer 类提供的一些现成的工具函数，来处理 IP 地址字符串。第三种实现方式，不使用任何工具函数，而是通过逐一处理 IP 地址中的字符，来判断是否合法。从代码行数上来说，这两种方式差不多。但是，第三种要比第二种更加有难度，更容易写出 bug。从可读性上来说，第二种实现方式的代码逻辑更清晰、更好理解。所以，在这两种实现方式中，第二种实现方式更加“简单”，更加符合 KISS 原则。</li>\n<li>不过，你可能会说，第三种实现方式虽然实现起来稍微有点复杂，但性能要比第二种实现方式高一些啊。从性能的角度来说，选择第三种实现方式是不是更好些呢？在回答这个问题之前，我先解释一下，为什么说第三种实现方式性能会更高一些。一般来说，工具类的功能都比较通用和全面，所以，在代码实现上，需要考虑和处理更多的细节，执行效率就会有所影响。而第三种实现方式，完全是自己操作底层字符，只针对 IP 地址这一种格式的数据输入来做处理，没有太多多余的函数调用和其他不必要的处理逻辑，所以，在执行效率上，这种类似定制化的处理代码方式肯定比通用的工具类要高些。</li>\n<li>不过，尽管第三种实现方式性能更高些，但我还是更倾向于选择第二种实现方法。那是因为第三种实现方式实际上是一种过度优化。除非 isValidIpAddress() 函数是影响系统性能的瓶颈代码，否则，这样优化的投入产出比并不高，增加了代码实现的难度、牺牲了代码的可读性，性能上的提升却并不明显。</li>\n</ol>\n<h3 id=\"代码逻辑复杂就违背-KISS-原则吗？\"><a href=\"#代码逻辑复杂就违背-KISS-原则吗？\" class=\"headerlink\" title=\"代码逻辑复杂就违背 KISS 原则吗？\"></a>代码逻辑复杂就违背 KISS 原则吗？</h3><p>刚刚我们提到，并不是代码行数越少就越“简单”，还要考虑逻辑复杂度、实现难度、代码的可读性等。那如果一段代码的逻辑复杂、实现难度大、可读性也不太好，是不是就一定违背 KISS 原则呢？在回答这个问题之前，我们先来看下面这段代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// KMP algorithm: a, b分别是主串和模式串；n, m分别是主串和模式串的长度。</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">kmp</span><span class=\"params\">(<span class=\"type\">char</span>[] a, <span class=\"type\">int</span> n, <span class=\"type\">char</span>[] b, <span class=\"type\">int</span> m)</span> &#123;</span><br><span class=\"line\">  <span class=\"type\">int</span>[] next = getNexts(b, m);</span><br><span class=\"line\">  <span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; n; ++i) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (j &gt; <span class=\"number\">0</span> &amp;&amp; a[i] != b[j]) &#123; <span class=\"comment\">// 一直找到a[i]和b[j]</span></span><br><span class=\"line\">      j = next[j - <span class=\"number\">1</span>] + <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (a[i] == b[j]) &#123;</span><br><span class=\"line\">      ++j;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (j == m) &#123; <span class=\"comment\">// 找到匹配模式串的了</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> i - m + <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// b表示模式串，m表示模式串的长度</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">int</span>[] getNexts(<span class=\"type\">char</span>[] b, <span class=\"type\">int</span> m) &#123;</span><br><span class=\"line\">  <span class=\"type\">int</span>[] next = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[m];</span><br><span class=\"line\">  next[<span class=\"number\">0</span>] = -<span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"type\">int</span> <span class=\"variable\">k</span> <span class=\"operator\">=</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; i &lt; m; ++i) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (k != -<span class=\"number\">1</span> &amp;&amp; b[k + <span class=\"number\">1</span>] != b[i]) &#123;</span><br><span class=\"line\">      k = next[k];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (b[k + <span class=\"number\">1</span>] == b[i]) &#123;</span><br><span class=\"line\">      ++k;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    next[i] = k;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> next;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<ol>\n<li><p>这段代码是KMP 字符串匹配算法的代码实现。这段代码完全符合我们刚提到的逻辑复杂、实现难度大、可读性差的特点，但它并不违反 KISS 原则。为什么这么说呢？</p>\n</li>\n<li><p>KMP 算法以快速高效著称。当我们需要处理长文本字符串匹配问题（几百 MB 大小文本内容的匹配），或者字符串匹配是某个产品的核心功能（比如 Vim、Word 等文本编辑器），又或者字符串匹配算法是系统性能瓶颈的时候，我们就应该选择尽可能高效的 KMP 算法。而 KMP 算法本身具有逻辑复杂、实现难度大、可读性差的特点。本身就复杂的问题，用复杂的方法解决，并不违背 KISS 原则。</p>\n</li>\n<li><p>不过，平时的项目开发中涉及的字符串匹配问题，大部分都是针对比较小的文本。在这种情况下，直接调用编程语言提供的现成的字符串匹配函数就足够了。如果非得用 KMP 算法、BM 算法来实现字符串匹配，那就真的违背 KISS 原则了。也就是说，同样的代码，在某个业务场景下满足 KISS 原则，换一个应用场景可能就不满足了。</p>\n</li>\n</ol>\n<h3 id=\"如何写出满足-KISS-原则的代码？\"><a href=\"#如何写出满足-KISS-原则的代码？\" class=\"headerlink\" title=\"如何写出满足 KISS 原则的代码？\"></a>如何写出满足 KISS 原则的代码？</h3><p>实际上，我们前面已经讲到了一些方法。这里我稍微总结一下。</p>\n<ul>\n<li>不要使用同事可能不懂的技术来实现代码。比如前面例子中的正则表达式，还有一些编程语言中过于高级的语法等。</li>\n<li>不要重复造轮子，要善于使用已经有的工具类库。经验证明，自己去实现这些类库，出 bug 的概率会更高，维护的成本也比较高。</li>\n<li>不要过度优化。不要过度使用一些奇技淫巧（比如，位运算代替算术运算、复杂的条件语句代替 if-else、使用一些过于底层的函数等）来优化代码，牺牲代码的可读性。</li>\n<li>实际上，代码是否足够简单是一个挺主观的评判。同样的代码，有的人觉得简单，有的人觉得不够简单。而往往自己编写的代码，自己都会觉得够简单。所以，评判代码是否简单，还有一个很有效的间接方法，那就是 code review。如果在 code review 的时候，同事对你的代码有很多疑问，那就说明你的代码有可能不够“简单”，需要优化啦。</li>\n</ul>\n<h3 id=\"YAGNI-跟-KISS-说的是一回事吗？\"><a href=\"#YAGNI-跟-KISS-说的是一回事吗？\" class=\"headerlink\" title=\"YAGNI 跟 KISS 说的是一回事吗？\"></a>YAGNI 跟 KISS 说的是一回事吗？</h3><ol>\n<li>YAGNI 原则的英文全称是：You Ain’t Gonna Need It。直译就是：你不会需要它。这条原则也算是万金油了。当用在软件开发中的时候，它的意思是：不要去设计当前用不到的功能；不要去编写当前用不到的代码。实际上，这条原则的核心思想就是：不要做过度设计。</li>\n<li>比如，我们的系统暂时只用 Redis 存储配置信息，以后可能会用到 ZooKeeper。根据 YAGNI 原则，在未用到 ZooKeeper 之前，我们没必要提前编写这部分代码。当然，这并不是说我们就不需要考虑代码的扩展性。我们还是要预留好扩展点，等到需要的时候，再去实现 ZooKeeper 存储配置信息这部分代码。</li>\n<li>再比如，我们不要在项目中提前引入不需要依赖的开发包。对于 Java 程序员来说，我们经常使用 Maven 或者 Gradle 来管理依赖的类库（library）。我发现，有些同事为了避免开发中 library 包缺失而频繁地修改 Maven 或者 Gradle 配置文件，提前往项目里引入大量常用的 library 包。实际上，这样的做法也是违背 YAGNI 原则的。</li>\n<li>从刚刚的分析我们可以看出，YAGNI 原则跟 KISS 原则并非一回事儿。KISS 原则讲的是“如何做”的问题（尽量保持简单），而 YAGNI 原则说的是“要不要做”的问题（当前不需要的就不要做）。</li>\n</ol>\n<h2 id=\"DRY-原则\"><a href=\"#DRY-原则\" class=\"headerlink\" title=\"DRY 原则\"></a>DRY 原则</h2><p>Don’t Repeat Yourself。中文直译为：不要重复自己。将它应用在编程中，可以理解为：不要写重复的代码。DRY 原则的定义非常简单，我就不再过度解读。今天，我们主要讲三种典型的代码重复情况，它们分别是：实现逻辑重复、功能语义重复和代码执行重复。这三种代码重复，有的看似违反 DRY，实际上并不违反；有的看似不违反，实际上却违反了。</p>\n<h3 id=\"实现逻辑重复\"><a href=\"#实现逻辑重复\" class=\"headerlink\" title=\"实现逻辑重复\"></a>实现逻辑重复</h3><p>我们先来看下面这样一段代码是否违反了 DRY 原则。如果违反了，你觉得应该如何重构，才能让它满足 DRY 原则？如果没有违反，那又是为什么呢？</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">UserAuthenticator</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">authenticate</span><span class=\"params\">(String username, String password)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!isValidUsername(username)) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// ...throw InvalidUsernameException...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!isValidPassword(password)) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// ...throw InvalidPasswordException...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//...省略其他代码...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"type\">boolean</span> <span class=\"title function_\">isValidUsername</span><span class=\"params\">(String username)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// check not null, not empty</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (StringUtils.isBlank(username)) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// check length: 4~64</span></span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">length</span> <span class=\"operator\">=</span> username.length();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (length &lt; <span class=\"number\">4</span> || length &gt; <span class=\"number\">64</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// contains only lowcase characters</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!StringUtils.isAllLowerCase(username)) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// contains only a~z,0~9,dot</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; length; ++i) &#123;</span><br><span class=\"line\">      <span class=\"type\">char</span> <span class=\"variable\">c</span> <span class=\"operator\">=</span> username.charAt(i);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!(c &gt;= <span class=\"string\">&#x27;a&#x27;</span> &amp;&amp; c &lt;= <span class=\"string\">&#x27;z&#x27;</span>) || (c &gt;= <span class=\"string\">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class=\"string\">&#x27;9&#x27;</span>) || c == <span class=\"string\">&#x27;.&#x27;</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"type\">boolean</span> <span class=\"title function_\">isValidPassword</span><span class=\"params\">(String password)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// check not null, not empty</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (StringUtils.isBlank(password)) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// check length: 4~64</span></span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">length</span> <span class=\"operator\">=</span> password.length();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (length &lt; <span class=\"number\">4</span> || length &gt; <span class=\"number\">64</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// contains only lowcase characters</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!StringUtils.isAllLowerCase(password)) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// contains only a~z,0~9,dot</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; length; ++i) &#123;</span><br><span class=\"line\">      <span class=\"type\">char</span> <span class=\"variable\">c</span> <span class=\"operator\">=</span> password.charAt(i);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!(c &gt;= <span class=\"string\">&#x27;a&#x27;</span> &amp;&amp; c &lt;= <span class=\"string\">&#x27;z&#x27;</span>) || (c &gt;= <span class=\"string\">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class=\"string\">&#x27;9&#x27;</span>) || c == <span class=\"string\">&#x27;.&#x27;</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>代码很简单，我就不做过多解释了。在代码中，有两处非常明显的重复的代码片段：isValidUserName() 函数和 isValidPassword() 函数。重复的代码被敲了两遍，或者简单 copy-paste 了一下，看起来明显违反 DRY 原则。为了移除重复的代码，我们对上面的代码做下重构，将 isValidUserName() 函数和 isValidPassword() 函数，合并为一个更通用的函数 isValidUserNameOrPassword()。重构后的代码如下所示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">UserAuthenticatorV2</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">authenticate</span><span class=\"params\">(String userName, String password)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!isValidUsernameOrPassword(userName)) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// ...throw InvalidUsernameException...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!isValidUsernameOrPassword(password)) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// ...throw InvalidPasswordException...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"type\">boolean</span> <span class=\"title function_\">isValidUsernameOrPassword</span><span class=\"params\">(String usernameOrPassword)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//省略实现逻辑</span></span><br><span class=\"line\">    <span class=\"comment\">//跟原来的isValidUsername()或isValidPassword()的实现逻辑一样...</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>经过重构之后，代码行数减少了，也没有重复的代码了，是不是更好了呢？答案是否定的，这可能跟你预期的不一样，我来解释一下为什么。</li>\n<li>单从名字上看，我们就能发现，合并之后的 isValidUserNameOrPassword() 函数，负责两件事情：验证用户名和验证密码，违反了“单一职责原则”和“接口隔离原则”。实际上，即便将两个函数合并成 isValidUserNameOrPassword()，代码仍然存在问题。</li>\n<li>因为 isValidUserName() 和 isValidPassword() 两个函数，虽然从代码实现逻辑上看起来是重复的，但是从语义上并不重复。所谓“语义不重复”指的是：从功能上来看，这两个函数干的是完全不重复的两件事情，一个是校验用户名，另一个是校验密码。尽管在目前的设计中，两个校验逻辑是完全一样的，但如果按照第二种写法，将两个函数的合并，那就会存在潜在的问题。在未来的某一天，如果我们修改了密码的校验逻辑，比如，允许密码包含大写字符，允许密码的长度为 8 到 64 个字符，那这个时候，isValidUserName() 和 isValidPassword() 的实现逻辑就会不相同。我们就要把合并后的函数，重新拆成合并前的那两个函数。</li>\n<li>尽管代码的实现逻辑是相同的，但语义不同，我们判定它并不违反 DRY 原则。对于包含重复代码的问题，我们可以通过抽象成更细粒度函数的方式来解决。比如将校验只包含 a<del>z、0</del>9、dot 的逻辑封装成 boolean onlyContains(String str, String charlist); 函数。</li>\n</ol>\n<h3 id=\"功能语义重复\"><a href=\"#功能语义重复\" class=\"headerlink\" title=\"功能语义重复\"></a>功能语义重复</h3><ol>\n<li>现在我们再来看另外一个例子。在同一个项目代码中有下面两个函数：isValidIp() 和 checkIfIpValid()。尽管两个函数的命名不同，实现逻辑不同，但功能是相同的，都是用来判定 IP 地址是否合法的。</li>\n<li>之所以在同一个项目中会有两个功能相同的函数，那是因为这两个函数是由两个不同的同事开发的，其中一个同事在不知道已经有了 isValidIp() 的情况下，自己又定义并实现了同样用来校验 IP 地址是否合法的 checkIfIpValid() 函数。那在同一项目代码中，存在如下两个函数，是否违反 DRY 原则呢？</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">isValidIp</span><span class=\"params\">(String ipAddress)</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (StringUtils.isBlank(ipAddress)) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  <span class=\"type\">String</span> <span class=\"variable\">regex</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;^(1\\\\d&#123;2&#125;|2[0-4]\\\\d|25[0-5]|[1-9]\\\\d|[1-9])\\\\.&quot;</span></span><br><span class=\"line\">          + <span class=\"string\">&quot;(1\\\\d&#123;2&#125;|2[0-4]\\\\d|25[0-5]|[1-9]\\\\d|\\\\d)\\\\.&quot;</span></span><br><span class=\"line\">          + <span class=\"string\">&quot;(1\\\\d&#123;2&#125;|2[0-4]\\\\d|25[0-5]|[1-9]\\\\d|\\\\d)\\\\.&quot;</span></span><br><span class=\"line\">          + <span class=\"string\">&quot;(1\\\\d&#123;2&#125;|2[0-4]\\\\d|25[0-5]|[1-9]\\\\d|\\\\d)$&quot;</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> ipAddress.matches(regex);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">checkIfIpValid</span><span class=\"params\">(String ipAddress)</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (StringUtils.isBlank(ipAddress)) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  String[] ipUnits = StringUtils.split(ipAddress, <span class=\"string\">&#x27;.&#x27;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (ipUnits.length != <span class=\"number\">4</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">4</span>; ++i) &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> ipUnitIntValue;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      ipUnitIntValue = Integer.parseInt(ipUnits[i]);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (NumberFormatException e) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ipUnitIntValue &lt; <span class=\"number\">0</span> || ipUnitIntValue &gt; <span class=\"number\">255</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (i == <span class=\"number\">0</span> &amp;&amp; ipUnitIntValue == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>这个例子跟上个例子正好相反。上一个例子是代码实现逻辑重复，但语义不重复，我们并不认为它违反了 DRY 原则。而在这个例子中，尽管两段代码的实现逻辑不重复，但语义重复，也就是功能重复，我们认为它违反了 DRY 原则。我们应该在项目中，统一一种实现思路，所有用到判断 IP 地址是否合法的地方，都统一调用同一个函数。</li>\n<li>假设我们不统一实现思路，那有些地方调用了 isValidIp() 函数，有些地方又调用了 checkIfIpValid() 函数，这就会导致代码看起来很奇怪，相当于给代码“埋坑”，给不熟悉这部分代码的同事增加了阅读的难度。同事有可能研究了半天，觉得功能是一样的，但又有点疑惑，觉得是不是有更高深的考量，才定义了两个功能类似的函数，最终发现居然是代码设计的问题。</li>\n<li>除此之外，如果哪天项目中 IP 地址是否合法的判定规则改变了，比如：255.255.255.255 不再被判定为合法的了，相应地，我们对 isValidIp() 的实现逻辑做了相应的修改，但却忘记了修改 checkIfIpValid() 函数。又或者，我们压根就不知道还存在一个功能相同的 checkIfIpValid() 函数，这样就会导致有些代码仍然使用老的 IP 地址判断逻辑，导致出现一些莫名其妙的 bug。</li>\n</ol>\n<h3 id=\"代码执行重复\"><a href=\"#代码执行重复\" class=\"headerlink\" title=\"代码执行重复\"></a>代码执行重复</h3><p>前两个例子一个是实现逻辑重复，一个是语义重复，我们再来看第三个例子。其中，UserService 中 login() 函数用来校验用户登录是否成功。如果失败，就返回异常；如果成功，就返回用户信息。具体代码如下所示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">UserService</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> UserRepo userRepo;<span class=\"comment\">//通过依赖注入或者IOC框架注入</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> User <span class=\"title function_\">login</span><span class=\"params\">(String email, String password)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">boolean</span> <span class=\"variable\">existed</span> <span class=\"operator\">=</span> userRepo.checkIfUserExisted(email, password);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!existed) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// ... throw AuthenticationFailureException...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">User</span> <span class=\"variable\">user</span> <span class=\"operator\">=</span> userRepo.getUserByEmail(email);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> user;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">UserRepo</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">checkIfUserExisted</span><span class=\"params\">(String email, String password)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!EmailValidation.validate(email)) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// ... throw InvalidEmailException...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!PasswordValidation.validate(password)) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// ... throw InvalidPasswordException...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//...query db to check if email&amp;password exists...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> User <span class=\"title function_\">getUserByEmail</span><span class=\"params\">(String email)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!EmailValidation.validate(email)) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// ... throw InvalidEmailException...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//...query db to get user by email...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>上面这段代码，既没有逻辑重复，也没有语义重复，但仍然违反了 DRY 原则。这是因为代码中存在“执行重复”。我们一块儿来看下，到底哪些代码被重复执行了？</li>\n<li>重复执行最明显的一个地方，就是在 login() 函数中，email 的校验逻辑被执行了两次。一次是在调用 checkIfUserExisted() 函数的时候，另一次是调用 getUserByEmail() 函数的时候。这个问题解决起来比较简单，我们只需要将校验逻辑从 UserRepo 中移除，统一放到 UserService 中就可以了。</li>\n<li>除此之外，代码中还有一处比较隐蔽的执行重复，不知道你发现了没有？实际上，login() 函数并不需要调用 checkIfUserExisted() 函数，只需要调用一次 getUserByEmail() 函数，从数据库中获取到用户的 email、password 等信息，然后跟用户输入的 email、password 信息做对比，依次判断是否登录成功。</li>\n<li>实际上，这样的优化是很有必要的。因为 checkIfUserExisted() 函数和 getUserByEmail() 函数都需要查询数据库，而数据库这类的 I&#x2F;O 操作是比较耗时的。我们在写代码的时候，应当尽量减少这类 I&#x2F;O 操作。</li>\n<li>按照刚刚的修改思路，我们把代码重构一下，移除“重复执行”的代码，只校验一次 email 和 password，并且只查询一次数据库。重构之后的代码如下所示：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">UserService</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> UserRepo userRepo;<span class=\"comment\">//通过依赖注入或者IOC框架注入</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> User <span class=\"title function_\">login</span><span class=\"params\">(String email, String password)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!EmailValidation.validate(email)) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// ... throw InvalidEmailException...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!PasswordValidation.validate(password)) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// ... throw InvalidPasswordException...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">User</span> <span class=\"variable\">user</span> <span class=\"operator\">=</span> userRepo.getUserByEmail(email);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (user == <span class=\"literal\">null</span> || !password.equals(user.getPassword()) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// ... throw AuthenticationFailureException...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> user;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">UserRepo</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">checkIfUserExisted</span><span class=\"params\">(String email, String password)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//...query db to check if email&amp;password exists</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> User <span class=\"title function_\">getUserByEmail</span><span class=\"params\">(String email)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//...query db to get user by email...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"代码复用性（Code-Reusability）\"><a href=\"#代码复用性（Code-Reusability）\" class=\"headerlink\" title=\"代码复用性（Code Reusability）\"></a>代码复用性（Code Reusability）</h3><ol>\n<li><p>我们首先来区分三个概念：代码复用性（Code Reusability）、代码复用（Code Resue）和 DRY 原则。代码复用表示一种行为：我们在开发新功能的时候，尽量复用已经存在的代码。代码的可复用性表示一段代码可被复用的特性或能力：我们在编写代码的时候，让代码尽量可复用。DRY 原则是一条原则：不要写重复的代码。从定义描述上，它们好像有点类似，但深究起来，三者的区别还是蛮大的。</p>\n</li>\n<li><p>首先，“不重复”并不代表“可复用”。在一个项目代码中，可能不存在任何重复的代码，但也并不表示里面有可复用的代码，不重复和可复用完全是两个概念。所以，从这个角度来说，DRY 原则跟代码的可复用性讲的是两回事。</p>\n</li>\n<li><p>其次，“复用”和“可复用性”关注角度不同。代码“可复用性”是从代码开发者的角度来讲的，“复用”是从代码使用者的角度来讲的。比如，A 同事编写了一个 UrlUtils 类，代码的“可复用性”很好。B 同事在开发新功能的时候，直接“复用”A 同事编写的 UrlUtils 类。尽管复用、可复用性、DRY 原则这三者从理解上有所区别，但实际上要达到的目的都是类似的，都是为了减少代码量，提高代码的可读性、可维护性。除此之外，复用已经经过测试的老代码，bug 会比从零重新开发要少。</p>\n</li>\n<li><p>“复用”这个概念不仅可以指导细粒度的模块、类、函数的设计开发，实际上，一些框架、类库、组件等的产生也都是为了达到复用的目的。比如，Spring 框架、Google Guava 类库、UI 组件等等。</p>\n</li>\n</ol>\n<h3 id=\"怎么提高代码复用性？\"><a href=\"#怎么提高代码复用性？\" class=\"headerlink\" title=\"怎么提高代码复用性？\"></a>怎么提高代码复用性？</h3><p>实际上，我们前面已经讲到过很多提高代码可复用性的手段，今天算是集中总结一下，我总结了 7 条，具体如下。</p>\n<blockquote>\n<p>减少代码耦合</p>\n</blockquote>\n<p>对于高度耦合的代码，当我们希望复用其中的一个功能，想把这个功能的代码抽取出来成为一个独立的模块、类或者函数的时候，往往会发现牵一发而动全身。移动一点代码，就要牵连到很多其他相关的代码。所以，高度耦合的代码会影响到代码的复用性，我们要尽量减少代码耦合。</p>\n<blockquote>\n<p>满足单一职责原则</p>\n</blockquote>\n<p>我们前面讲过，如果职责不够单一，模块、类设计得大而全，那依赖它的代码或者它依赖的代码就会比较多，进而增加了代码的耦合。根据上一点，也就会影响到代码的复用性。相反，越细粒度的代码，代码的通用性会越好，越容易被复用。</p>\n<blockquote>\n<p>模块化</p>\n</blockquote>\n<p>这里的“模块”，不单单指一组类构成的模块，还可以理解为单个类、函数。我们要善于将功能独立的代码，封装成模块。独立的模块就像一块一块的积木，更加容易复用，可以直接拿来搭建更加复杂的系统。</p>\n<blockquote>\n<p>业务与非业务逻辑分离</p>\n</blockquote>\n<p>越是跟业务无关的代码越是容易复用，越是针对特定业务的代码越难复用。所以，为了复用跟业务无关的代码，我们将业务和非业务逻辑代码分离，抽取成一些通用的框架、类库、组件等。</p>\n<blockquote>\n<p>通用代码下沉</p>\n</blockquote>\n<p>从分层的角度来看，越底层的代码越通用、会被越多的模块调用，越应该设计得足够可复用。一般情况下，在代码分层之后，为了避免交叉调用导致调用关系混乱，我们只允许上层代码调用下层代码及同层代码之间的调用，杜绝下层代码调用上层代码。所以，通用的代码我们尽量下沉到更下层。</p>\n<blockquote>\n<p>继承、多态、抽象、封装</p>\n</blockquote>\n<p>在讲面向对象特性的时候，利用继承，可以将公共的代码抽取到父类，子类复用父类的属性和方法。利用多态，我们可以动态地替换一段代码的部分逻辑，让这段代码可复用。除此之外，抽象和封装，从更加广义的层面、而非狭义的面向对象特性的层面来理解的话，越抽象、越不依赖具体的实现，越容易复用。代码封装成模块，隐藏可变的细节、暴露不变的接口，就越容易复用。</p>\n<blockquote>\n<p>应用模板等设计模式</p>\n</blockquote>\n<p>一些设计模式，也能提高代码的复用性。比如，模板模式利用了多态来实现，可以灵活地替换其中的部分代码，整个流程模板代码可复用。关于应用设计模式提高代码复用性这一部分，我们留在后面慢慢来讲解。除了刚刚我们讲到的几点，还有一些跟编程语言相关的特性，也能提高代码的复用性，比如泛型编程等。实际上，除了上面讲到的这些方法之外，复用意识也非常重要。在写代码的时候，我们要多去思考一下，这</p>\n<h2 id=\"迪米特法则\"><a href=\"#迪米特法则\" class=\"headerlink\" title=\"迪米特法则\"></a>迪米特法则</h2><p>我们讲最后一个设计原则：迪米特法则。尽管它不像 SOLID、KISS、DRY 原则那样，人尽皆知，但它却非常实用。利用这个原则，能够帮我们实现代码的“高内聚、松耦合”。今天，我们就围绕下面几个问题，并结合两个代码实战案例，来深入地学习这个法则。</p>\n<ul>\n<li>什么是“高内聚、松耦合”？</li>\n<li>如何利用迪米特法则来实现“高内聚、松耦合”？</li>\n<li>有哪些代码设计是明显违背迪米特法则的？对此又该如何重构？</li>\n</ul>\n<h3 id=\"何为“高内聚、松耦合”？\"><a href=\"#何为“高内聚、松耦合”？\" class=\"headerlink\" title=\"何为“高内聚、松耦合”？\"></a>何为“高内聚、松耦合”？</h3><ol>\n<li>“高内聚、松耦合”是一个非常重要的设计思想，能够有效地提高代码的可读性和可维护性，缩小功能改动导致的代码改动范围。</li>\n<li>实际上，在前面的章节中，我们已经多次提到过这个设计思想。很多设计原则都以实现代码的“高内聚、松耦合”为目的，比如单一职责原则、基于接口而非实现编程等。实际上，“高内聚、松耦合”是一个比较通用的设计思想，可以用来指导不同粒度代码的设计与开发，比如系统、模块、类，甚至是函数，也可以应用到不同的开发场景中，比如微服务、框架、组件、类库等。为了方便我讲解，接下来我以“类”作为这个设计思想的应用对象来展开讲解，其他应用场景你可以自行类比。</li>\n<li>在这个设计思想中，“高内聚”用来指导类本身的设计，“松耦合”用来指导类与类之间依赖关系的设计。不过，这两者并非完全独立不相干。高内聚有助于松耦合，松耦合又需要高内聚的支持。</li>\n</ol>\n<blockquote>\n<p>那到底什么是“高内聚”呢？</p>\n</blockquote>\n<p>所谓高内聚，就是指相近的功能应该放到同一个类中，不相近的功能不要放到同一个类中。相近的功能往往会被同时修改，放到同一个类中，修改会比较集中，代码容易维护。实际上，我们前面讲过的单一职责原则是实现代码高内聚非常有效的设计原则。</p>\n<blockquote>\n<p>我们再来看一下，什么是“松耦合”？</p>\n</blockquote>\n<p>所谓松耦合是说，在代码中，类与类之间的依赖关系简单清晰。即使两个类有依赖关系，一个类的代码改动不会或者很少导致依赖类的代码改动。实际上，我们前面讲的依赖注入、接口隔离、基于接口而非实现编程，以及今天讲的迪米特法则，都是为了实现代码的松耦合</p>\n<blockquote>\n<p>最后，我们来看一下，“内聚”和“耦合”之间的关系</p>\n</blockquote>\n<p>前面也提到，“高内聚”有助于“松耦合”，同理，“低内聚”也会导致“紧耦合”。关于这一点，我画了一张对比图来解释。图中左边部分的代码结构是“高内聚、松耦合”；右边部分正好相反，是“低内聚、紧耦合”。</p>\n<img src=\"https://npm.elemecdn.com/youthlql@1.0.0/design_patterns/design_principles/0001.png\" />\n\n\n\n\n\n<ol>\n<li>图中左边部分的代码设计中，类的粒度比较小，每个类的职责都比较单一。相近的功能都放到了一个类中，不相近的功能被分割到了多个类中。这样类更加独立，代码的内聚性更好。因为职责单一，所以每个类被依赖的类就会比较少，代码低耦合。一个类的修改，只会影响到一个依赖类的代码改动。我们只需要测试这一个依赖类是否还能正常工作就行了。</li>\n<li>图中右边部分的代码设计中，类粒度比较大，低内聚，功能大而全，不相近的功能放到了一个类中。这就导致很多其他类都依赖这个类。当我们修改这个类的某一个功能代码的时候，会影响依赖它的多个类。我们需要测试这三个依赖类，是否还能正常工作。这也就是所谓的“牵一发而动全身”。</li>\n<li>除此之外，从图中我们也可以看出，高内聚、低耦合的代码结构更加简单、清晰，相应地，在可维护性和可读性上确实要好很多。</li>\n</ol>\n<h3 id=\"“迪米特法则”理论描述\"><a href=\"#“迪米特法则”理论描述\" class=\"headerlink\" title=\"“迪米特法则”理论描述\"></a>“迪米特法则”理论描述</h3><ol>\n<li><p>迪米特法则的英文翻译是：Law of Demeter，缩写是 LOD。单从这个名字上来看，我们完全猜不出这个原则讲的是什么。不过，它还有另外一个更加达意的名字，叫作最小知识原则，英文翻译为：The Least Knowledge Principle。</p>\n</li>\n<li><p>关于这个设计原则，我们先来看一下它最原汁原味的英文定义：</p>\n<blockquote>\n<p>Each unit should have only limited knowledge about other units: only units “closely” related to the current unit. Or: Each unit should only talk to its friends; Don’t talk to strangers.</p>\n</blockquote>\n<p>我们把它直译成中文，就是下面这个样子：</p>\n<blockquote>\n<p>每个模块（unit）只应该了解那些与它关系密切的模块（units: only units “closely” related to the current unit）的有限知识（knowledge）。或者说，每个模块只和自己的朋友“说话”（talk），不和陌生人“说话”（talk）。</p>\n</blockquote>\n<p>我们之前讲过，大部分设计原则和思想都非常抽象，有各种各样的解读，要想灵活地应用到实际的开发中，需要有实战经验的积累。迪米特法则也不例外。所以，我结合我自己的理解和经验，对刚刚的定义重新描述一下。注意，为了统一讲解，我把定义描述中的“模块”替换成了“类”。</p>\n<blockquote>\n<p>不该有直接依赖关系的类之间，不要有依赖；有依赖关系的类之间，尽量只依赖必要的接口（也就是定义中的“有限知识”）。从上面的描述中，我们可以看出，迪米特法则包含前后两部分，这两部分讲的是两件事情，我用两个实战案例分别来解读一下。</p>\n</blockquote>\n</li>\n</ol>\n<h3 id=\"理论解读与代码实战一\"><a href=\"#理论解读与代码实战一\" class=\"headerlink\" title=\"理论解读与代码实战一\"></a>理论解读与代码实战一</h3><ol>\n<li>我们先来看这条原则中的前半部分，<strong>“不该有直接依赖关系的类之间，不要有依赖”</strong>。我举个例子解释一下。</li>\n<li>这个例子实现了简化版的搜索引擎爬取网页的功能。代码中包含三个主要的类。其中，NetworkTransporter 类负责底层网络通信，根据请求获取数据；HtmlDownloader 类用来通过 URL 获取网页；Document 表示网页文档，后续的网页内容抽取、分词、索引都是以此为处理对象。具体的代码实现如下所示：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">NetworkTransporter</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 省略属性和其他方法...</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Byte[] send(HtmlRequest htmlRequest) &#123;</span><br><span class=\"line\">      <span class=\"comment\">//...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">HtmlDownloader</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> NetworkTransporter transporter;<span class=\"comment\">//通过构造函数或IOC注入</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">public</span> Html <span class=\"title function_\">downloadHtml</span><span class=\"params\">(String url)</span> &#123;</span><br><span class=\"line\">    Byte[] rawHtml = transporter.send(<span class=\"keyword\">new</span> <span class=\"title class_\">HtmlRequest</span>(url));</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Html</span>(rawHtml);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Document</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> Html html;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> String url;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"title function_\">Document</span><span class=\"params\">(String url)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.url = url;</span><br><span class=\"line\">    <span class=\"type\">HtmlDownloader</span> <span class=\"variable\">downloader</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">HtmlDownloader</span>();</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.html = downloader.downloadHtml(url);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>这段代码虽然“能用”，能实现我们想要的功能，但是它不够“好用”，有比较多的设计缺陷。你可以先试着思考一下，看看都有哪些缺陷，然后再来看我下面的讲解。</li>\n<li>首先，我们来看 NetworkTransporter 类。作为一个底层网络通信类，我们希望它的功能尽可能通用，而不只是服务于下载 HTML，所以，我们不应该直接依赖太具体的发送对象 HtmlRequest。从这一点上讲，NetworkTransporter 类的设计违背迪米特法则，依赖了不该有直接依赖关系的 HtmlRequest 类。</li>\n<li>我们应该如何进行重构，让 NetworkTransporter 类满足迪米特法则呢？我这里有个形象的比喻。假如你现在要去商店买东西，你肯定不会直接把钱包给收银员，让收银员自己从里面拿钱，而是你从钱包里把钱拿出来交给收银员。这里的 HtmlRequest 对象就相当于钱包，HtmlRequest 里的 address 和 content 对象就相当于钱。我们应该把 address 和 content 交给 NetworkTransporter，而非是直接把 HtmlRequest 交给 NetworkTransporter。根据这个思路，NetworkTransporter 重构之后的代码如下所示：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">NetworkTransporter</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 省略属性和其他方法...</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Byte[] send(String address, Byte[] data) &#123;</span><br><span class=\"line\">      <span class=\"comment\">//...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>我们再来看 HtmlDownloader 类。这个类的设计没有问题。不过，我们修改了 NetworkTransporter 的 send() 函数的定义，而这个类用到了 send() 函数，所以我们需要对它做相应的修改，修改后的代码如下所示</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">HtmlDownloader</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> NetworkTransporter transporter;<span class=\"comment\">//通过构造函数或IOC注入</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">// HtmlDownloader这里也要有相应的修改</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> Html <span class=\"title function_\">downloadHtml</span><span class=\"params\">(String url)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">HtmlRequest</span> <span class=\"variable\">htmlRequest</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">HtmlRequest</span>(url);</span><br><span class=\"line\">    Byte[] rawHtml = transporter.send(</span><br><span class=\"line\">      htmlRequest.getAddress(), htmlRequest.getContent().getBytes());</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Html</span>(rawHtml);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>最后，我们来看下 Document 类。这个类的问题比较多，主要有三点。第一，构造函数中的 downloader.downloadHtml() 逻辑复杂，耗时长，不应该放到构造函数中，会影响代码的可测试性。代码的可测试性我们后面会讲到，这里你先知道有这回事就可以了。第二，HtmlDownloader 对象在构造函数中通过 new 来创建，违反了基于接口而非实现编程的设计思想，也会影响到代码的可测试性。第三，从业务含义上来讲，Document 网页文档没必要依赖 HtmlDownloader 类，违背了迪米特法则。</p>\n<p>虽然 Document 类的问题很多，但修改起来比较简单，只要一处改动就可以解决所有问题。修改之后的代码如下所示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Document</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> Html html;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> String url;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"title function_\">Document</span><span class=\"params\">(String url, Html html)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.html = html;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.url = url;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 通过一个工厂方法来创建Document</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">DocumentFactory</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> HtmlDownloader downloader;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"title function_\">DocumentFactory</span><span class=\"params\">(HtmlDownloader downloader)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.downloader = downloader;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">public</span> Document <span class=\"title function_\">createDocument</span><span class=\"params\">(String url)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">Html</span> <span class=\"variable\">html</span> <span class=\"operator\">=</span> downloader.downloadHtml(url);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Document</span>(url, html);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h3 id=\"理论解读与代码实战二\"><a href=\"#理论解读与代码实战二\" class=\"headerlink\" title=\"理论解读与代码实战二\"></a>理论解读与代码实战二</h3><p>现在，我们再来看一下这条原则中的后半部分：“有依赖关系的类之间，尽量只依赖必要的接口”。我们还是结合一个例子来讲解。下面这段代码非常简单，Serialization 类负责对象的序列化和反序列化</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Serialization</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> String <span class=\"title function_\">serialize</span><span class=\"params\">(Object object)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">serializedResult</span> <span class=\"operator\">=</span> ...;</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> serializedResult;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">public</span> Object <span class=\"title function_\">deserialize</span><span class=\"params\">(String str)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">Object</span> <span class=\"variable\">deserializedResult</span> <span class=\"operator\">=</span> ...;</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> deserializedResult;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<ol>\n<li>单看这个类的设计，没有一点问题。不过，如果我们把它放到一定的应用场景里，那就还有继续优化的空间。假设在我们的项目中，有些类只用到了序列化操作，而另一些类只用到反序列化操作。那基于迪米特法则后半部分“有依赖关系的类之间，尽量只依赖必要的接口”，只用到序列化操作的那部分类不应该依赖反序列化接口。同理，只用到反序列化操作的那部分类不应该依赖序列化接口。</li>\n<li>根据这个思路，我们应该将 Serialization 类拆分为两个更小粒度的类，一个只负责序列化（Serializer 类），一个只负责反序列化（Deserializer 类）。拆分之后，使用序列化操作的类只需要依赖 Serializer 类，使用反序列化操作的类只需要依赖 Deserializer 类。拆分之后的代码如下所示：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Serializer</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> String <span class=\"title function_\">serialize</span><span class=\"params\">(Object object)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">serializedResult</span> <span class=\"operator\">=</span> ...;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">return</span> serializedResult;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Deserializer</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> Object <span class=\"title function_\">deserialize</span><span class=\"params\">(String str)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">Object</span> <span class=\"variable\">deserializedResult</span> <span class=\"operator\">=</span> ...;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">return</span> deserializedResult;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<ol>\n<li>不知道你有没有看出来，尽管拆分之后的代码更能满足迪米特法则，但却违背了高内聚的设计思想。高内聚要求相近的功能要放到同一个类中，这样可以方便功能修改的时候，修改的地方不至于过于分散。对于刚刚这个例子来说，如果我们修改了序列化的实现方式，比如从 JSON 换成了 XML，那反序列化的实现逻辑也需要一并修改。在未拆分的情况下，我们只需要修改一个类即可。在拆分之后，我们需要修改两个类。显然，这种设计思路的代码改动范围变大了。</li>\n<li>如果我们既不想违背高内聚的设计思想，也不想违背迪米特法则，那我们该如何解决这个问题呢？实际上，通过引入两个接口就能轻松解决这个问题，具体的代码如下所示。实际上，我们在讲到“接口隔离原则”的时候，第三个例子就使用了类似的实现思路，你可以结合着一块儿来看。</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">Serializable</span> &#123;</span><br><span class=\"line\">  String <span class=\"title function_\">serialize</span><span class=\"params\">(Object object)</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">Deserializable</span> &#123;</span><br><span class=\"line\">  Object <span class=\"title function_\">deserialize</span><span class=\"params\">(String text)</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Serialization</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Serializable</span>, Deserializable &#123;</span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> String <span class=\"title function_\">serialize</span><span class=\"params\">(Object object)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">serializedResult</span> <span class=\"operator\">=</span> ...;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">return</span> serializedResult;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> Object <span class=\"title function_\">deserialize</span><span class=\"params\">(String str)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">Object</span> <span class=\"variable\">deserializedResult</span> <span class=\"operator\">=</span> ...;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">return</span> deserializedResult;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">DemoClass_1</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> Serializable serializer;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"title function_\">Demo</span><span class=\"params\">(Serializable serializer)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.serializer = serializer;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">DemoClass_2</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> Deserializable deserializer;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"title function_\">Demo</span><span class=\"params\">(Deserializable deserializer)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.deserializer = deserializer;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>尽管我们还是要往 DemoClass_1 的构造函数中，传入包含序列化和反序列化的 Serialization 实现类，但是，我们依赖的 Serializable 接口只包含序列化操作，DemoClass_1 无法使用 Serialization 类中的反序列化接口，对反序列化操作无感知，这也就符合了迪米特法则后半部分所说的“依赖有限接口”的要求。</li>\n<li>实际上，上面的的代码实现思路，也体现了“基于接口而非实现编程”的设计原则，结合迪米特法则，我们可以总结出一条新的设计原则，那就是“基于最小接口而非最大实现编程”。有些同学之前问，新的设计模式和设计原则是怎么创造出来的，实际上，就是在大量的实践中，针对开发痛点总结归纳出来的套路。</li>\n</ol>\n<h3 id=\"辩证思考与灵活应用\"><a href=\"#辩证思考与灵活应用\" class=\"headerlink\" title=\"辩证思考与灵活应用\"></a>辩证思考与灵活应用</h3><ol>\n<li>对于实战二最终的设计思路，你有没有什么不同的观点呢？</li>\n<li>整个类只包含序列化和反序列化两个操作，只用到序列化操作的使用者，即便能够感知到仅有的一个反序列化函数，问题也不大。那为了满足迪米特法则，我们将一个非常简单的类，拆分出两个接口，是否有点过度设计的意思呢？</li>\n<li>设计原则本身没有对错，只有能否用对之说。不要为了应用设计原则而应用设计原则，我们在应用设计原则的时候，一定要具体问题具体分析。</li>\n<li>对于刚刚这个 Serialization 类来说，只包含两个操作，确实没有太大必要拆分成两个接口。但是，如果我们对 Serialization 类添加更多的功能，实现更多更好用的序列化、反序列化函数，我们来重新考虑一下这个问题。修改之后的具体的代码如下</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Serializer</span> &#123; <span class=\"comment\">// 参看JSON的接口定义</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> String <span class=\"title function_\">serialize</span><span class=\"params\">(Object object)</span> &#123; <span class=\"comment\">//... &#125;</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> String <span class=\"title function_\">serializeMap</span><span class=\"params\">(Map map)</span> &#123; <span class=\"comment\">//... &#125;</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> String <span class=\"title function_\">serializeList</span><span class=\"params\">(List list)</span> &#123; <span class=\"comment\">//... &#125;</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">public</span> Object <span class=\"title function_\">deserialize</span><span class=\"params\">(String objectString)</span> &#123; <span class=\"comment\">//... &#125;</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> Map <span class=\"title function_\">deserializeMap</span><span class=\"params\">(String mapString)</span> &#123; <span class=\"comment\">//... &#125;</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> List <span class=\"title function_\">deserializeList</span><span class=\"params\">(String listString)</span> &#123; <span class=\"comment\">//... &#125;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在这种场景下，第二种设计思路要更好些。因为基于之前的应用场景来说，大部分代码只需要用到序列化的功能。对于这部分使用者，没必要了解反序列化的“知识”，而修改之后的 Serialization 类，反序列化的“知识”，从一个函数变成了三个。一旦任一反序列化操作有代码改动，我们都需要检查、测试所有依赖 Serialization 类的代码是否还能正常工作。为了减少耦合和测试工作量，我们应该按照迪米特法则，将反序列化和序列化的功能隔离开来。</p>\n","site":{"data":{}},"cover_type":"img","excerpt":"","more":"<h1 id=\"声明\"><a href=\"#声明\" class=\"headerlink\" title=\"声明\"></a>声明</h1><blockquote>\n<ol>\n<li>此系列文章非本人原创，是学习笔记。</li>\n<li>设计模式系列以后会持续更新，包括已经发布的设计模式文章，因为后续还要再多看一下书，教程和开源项目等，继续润色文章。</li>\n</ol>\n</blockquote>\n<h1 id=\"设计模式经典设计原则-第二节\"><a href=\"#设计模式经典设计原则-第二节\" class=\"headerlink\" title=\"设计模式经典设计原则-第二节\"></a>设计模式经典设计原则-第二节</h1><h2 id=\"依赖反转原则（DIP）\"><a href=\"#依赖反转原则（DIP）\" class=\"headerlink\" title=\"依赖反转原则（DIP）\"></a>依赖反转原则（DIP）</h2><p>关于 SOLID 原则，我们已经学过单一职责、开闭、里式替换、接口隔离这四个原则。今天，我们再来学习最后一个原则：依赖反转原则。在前面，我们讲到，单一职责原则和开闭原则的原理比较简单，但是，想要在实践中用好却比较难。而今天我们要讲到的依赖反转原则正好相反。这个原则用起来比较简单，但概念理解起来比较难。比如，下面这几个问题，你看看能否清晰地回答出来：</p>\n<ul>\n<li>“依赖反转”这个概念指的是“谁跟谁”的“什么依赖”被反转了？“反转”两个字该如何理解？</li>\n<li>我们还经常听到另外两个概念：“控制反转”和“依赖注入”。这两个概念跟“依赖反转”有什么区别和联系呢？它们说的是同一个事情吗？</li>\n<li>如果你熟悉 Java 语言，那 Spring 框架中的 IOC 跟这些概念又有什么关系呢？</li>\n</ul>\n<h3 id=\"控制反转（IOC）\"><a href=\"#控制反转（IOC）\" class=\"headerlink\" title=\"控制反转（IOC）\"></a>控制反转（IOC）</h3><p>在讲“依赖反转原则”之前，我们先讲一讲“控制反转”。控制反转的英文翻译是 Inversion Of Control，缩写为 IOC。此处我要强调一下，暂时别把这个“IOC”跟 Spring 框架的 IOC 联系在一起。关于 Spring 的 IOC，我们待会儿还会讲到。我们先通过一个例子来看一下，什么是控制反转。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">UserServiceTest</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"type\">boolean</span> <span class=\"title function_\">doTest</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ... </span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;<span class=\"comment\">//这部分逻辑可以放到框架中</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (doTest()) &#123;</span><br><span class=\"line\">      System.out.println(<span class=\"string\">&quot;Test succeed.&quot;</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      System.out.println(<span class=\"string\">&quot;Test failed.&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在上面的代码中，所有的流程都由程序员来控制。如果我们抽象出一个下面这样一个框架，我们再来看，如何利用框架来实现同样的功能。具体的代码实现如下所示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">class</span> <span class=\"title class_\">TestCase</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (doTest()) &#123;</span><br><span class=\"line\">      System.out.println(<span class=\"string\">&quot;Test succeed.&quot;</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      System.out.println(<span class=\"string\">&quot;Test failed.&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"type\">boolean</span> <span class=\"title function_\">doTest</span><span class=\"params\">()</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">JunitApplication</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> List&lt;TestCase&gt; testCases = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">register</span><span class=\"params\">(TestCase testCase)</span> &#123;</span><br><span class=\"line\">    testCases.add(testCase);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (TestCase <span class=\"keyword\">case</span>: testCases) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">case</span>.run();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n<p>把这个简化版本的测试框架引入到工程中之后，我们只需要在框架预留的扩展点，也就是 TestCase 类中的 doTest() 抽象函数中，填充具体的测试代码就可以实现之前的功能了，完全不需要写负责执行流程的 main() 函数了。 具体的代码如下所示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">UserServiceTest</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">TestCase</span> &#123;</span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">doTest</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ... </span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 注册操作还可以通过配置的方式来实现，不需要程序员显示调用register()</span></span><br><span class=\"line\">JunitApplication.register(<span class=\"keyword\">new</span> <span class=\"title class_\">UserServiceTest</span>();</span><br></pre></td></tr></table></figure>\n\n\n\n<ol>\n<li>刚刚举的这个例子，就是典型的通过框架来实现“控制反转”的例子。框架提供了一个可扩展的代码骨架，用来组装对象、管理整个执行流程。程序员利用框架进行开发的时候，只需要往预留的扩展点上，添加跟自己业务相关的代码，就可以利用框架来驱动整个程序流程的执行。</li>\n<li>这里的“控制”指的是对程序执行流程的控制，而“反转”指的是在没有使用框架之前，程序员自己控制整个程序的执行。在使用框架之后，整个程序的执行流程可以通过框架来控制。流程的控制权从程序员“反转”到了框架。</li>\n<li>实际上，实现控制反转的方法有很多，除了刚才例子中所示的类似于模板设计模式的方法之外，还有马上要讲到的依赖注入等方法，所以，控制反转并不是一种具体的实现技巧，而是一个比较笼统的设计思想，一般用来指导框架层面的设计。</li>\n</ol>\n<h3 id=\"依赖注入（DI）\"><a href=\"#依赖注入（DI）\" class=\"headerlink\" title=\"依赖注入（DI）\"></a>依赖注入（DI）</h3><ol>\n<li>接下来，我们再来看依赖注入。依赖注入跟控制反转恰恰相反，它是一种具体的编码技巧。那到底什么是依赖注入呢？我们用一句话来概括就是：不通过 new() 的方式在类内部创建依赖类对象，而是将依赖的类对象在外部创建好之后，通过构造函数、函数参数等方式传递（或注入）给类使用。</li>\n<li>我们还是通过一个例子来解释一下。在这个例子中，Notification 类负责消息推送，依赖 MessageSender 类实现推送商品促销、验证码等消息给用户。我们分别用依赖注入和非依赖注入两种方式来实现一下。具体的实现代码如下所示：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 非依赖注入实现方式</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Notification</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> MessageSender messageSender;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"title function_\">Notification</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.messageSender = <span class=\"keyword\">new</span> <span class=\"title class_\">MessageSender</span>(); <span class=\"comment\">//此处有点像hardcode</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">sendMessage</span><span class=\"params\">(String cellphone, String message)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//...省略校验逻辑等...</span></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.messageSender.send(cellphone, message);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">MessageSender</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">send</span><span class=\"params\">(String cellphone, String message)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//....</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 使用Notification</span></span><br><span class=\"line\"><span class=\"type\">Notification</span> <span class=\"variable\">notification</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Notification</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 依赖注入的实现方式</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Notification</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> MessageSender messageSender;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">// 通过构造函数将messageSender传递进来</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"title function_\">Notification</span><span class=\"params\">(MessageSender messageSender)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.messageSender = messageSender;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">sendMessage</span><span class=\"params\">(String cellphone, String message)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//...省略校验逻辑等...</span></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.messageSender.send(cellphone, message);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//使用Notification</span></span><br><span class=\"line\"><span class=\"type\">MessageSender</span> <span class=\"variable\">messageSender</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">MessageSender</span>();</span><br><span class=\"line\"><span class=\"type\">Notification</span> <span class=\"variable\">notification</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Notification</span>(messageSender);</span><br></pre></td></tr></table></figure>\n\n<p>通过依赖注入的方式来将依赖的类对象传递进来，这样就提高了代码的扩展性，我们可以灵活地替换依赖的类。这一点在我们之前讲“开闭原则”的时候也提到过。当然，上面代码还有继续优化的空间，我们还可以把 MessageSender 定义成接口，基于接口而非实现编程。改造后的代码如下所示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Notification</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> MessageSender messageSender;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"title function_\">Notification</span><span class=\"params\">(MessageSender messageSender)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.messageSender = messageSender;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">sendMessage</span><span class=\"params\">(String cellphone, String message)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.messageSender.send(cellphone, message);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">MessageSender</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">void</span> <span class=\"title function_\">send</span><span class=\"params\">(String cellphone, String message)</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 短信发送类</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">SmsSender</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">MessageSender</span> &#123;</span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">send</span><span class=\"params\">(String cellphone, String message)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//....</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 站内信发送类</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">InboxSender</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">MessageSender</span> &#123;</span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">send</span><span class=\"params\">(String cellphone, String message)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//....</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//使用Notification</span></span><br><span class=\"line\"><span class=\"type\">MessageSender</span> <span class=\"variable\">messageSender</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">SmsSender</span>();</span><br><span class=\"line\"><span class=\"type\">Notification</span> <span class=\"variable\">notification</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Notification</span>(messageSender);</span><br></pre></td></tr></table></figure>\n\n\n\n<p>实际上，你只需要掌握刚刚举的这个例子，就等于完全掌握了依赖注入。尽管依赖注入非常简单，但却非常有用，</p>\n<h3 id=\"依赖注入框架（DI-Framework）\"><a href=\"#依赖注入框架（DI-Framework）\" class=\"headerlink\" title=\"依赖注入框架（DI Framework）\"></a>依赖注入框架（DI Framework）</h3><p>弄懂了什么是“依赖注入”，我们再来看一下，什么是“依赖注入框架”。我们还是借用刚刚的例子来解释。在采用依赖注入实现的 Notification 类中，虽然我们不需要用类似 hard code 的方式，在类内部通过 new 来创建 MessageSender 对象，但是，这个创建对象、组装（或注入）对象的工作仅仅是被移动到了更上层代码而已，还是需要我们程序员自己来实现。具体代码如下所示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Demo</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String args[])</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">MessageSender</span> <span class=\"variable\">sender</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">SmsSender</span>(); <span class=\"comment\">//创建对象</span></span><br><span class=\"line\">    <span class=\"type\">Notification</span> <span class=\"variable\">notification</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Notification</span>(sender);<span class=\"comment\">//依赖注入</span></span><br><span class=\"line\">    notification.sendMessage(<span class=\"string\">&quot;13918942177&quot;</span>, <span class=\"string\">&quot;短信验证码：2346&quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>在实际的软件开发中，一些项目可能会涉及几十、上百、甚至几百个类，类对象的创建和依赖注入会变得非常复杂。如果这部分工作都是靠程序员自己写代码来完成，容易出错且开发成本也比较高。而对象创建和依赖注入的工作，本身跟具体的业务无关，我们完全可以抽象成框架来自动完成。</li>\n<li>你可能已经猜到，这个框架就是“依赖注入框架”。我们只需要通过依赖注入框架提供的扩展点，简单配置一下所有需要创建的类对象、类与类之间的依赖关系，就可以实现由框架来自动创建对象、管理对象的生命周期、依赖注入等原本需要程序员来做的事情。</li>\n<li>实际上，现成的依赖注入框架有很多，比如 Google Guice、Java Spring、Pico Container、Butterfly Container 等。不过，如果你熟悉 Java Spring 框架，你可能会说，Spring 框架自己声称是控制反转容器（Inversion Of Control Container）。</li>\n<li>实际上，这两种说法都没错。只是控制反转容器这种表述是一种非常宽泛的描述，DI 依赖注入框架的表述更具体、更有针对性。因为我们前面讲到实现控制反转的方式有很多，除了依赖注入，还有模板模式等，而 Spring 框架的控制反转主要是通过依赖注入来实现的。不过这点区分并不是很明显，也不是很重要，你稍微了解一下就可以了。</li>\n</ol>\n<h3 id=\"什么是依赖反转原则？\"><a href=\"#什么是依赖反转原则？\" class=\"headerlink\" title=\"什么是依赖反转原则？\"></a>什么是依赖反转原则？</h3><ol>\n<li>前面讲了控制反转、依赖注入、依赖注入框架，现在，我们来讲一讲今天的主角：依赖反转原则。依赖反转原则的英文翻译是 Dependency Inversion Principle，缩写为 DIP。中文翻译有时候也叫依赖倒置原则。</li>\n<li>英文描述：High-level modules shouldn’t depend on low-level modules. Both modules should depend on abstractions. In addition, abstractions shouldn’t depend on details. Details depend on abstractions.</li>\n<li>我们将它翻译成中文，大概意思就是：高层模块（high-level modules）不要依赖低层模块（low-level）。高层模块和低层模块应该通过抽象（abstractions）来互相依赖。除此之外，抽象（abstractions）不要依赖具体实现细节（details），具体实现细节（details）依赖抽象（abstractions）。</li>\n<li>所谓高层模块和低层模块的划分，简单来说就是，在调用链上，调用者属于高层，被调用者属于低层。在平时的业务代码开发中，高层模块依赖底层模块是没有任何问题的。实际上，这条原则主要还是用来指导框架层面的设计，跟前面讲到的控制反转类似。我们拿 Tomcat 这个 Servlet 容器作为例子来解释一下。</li>\n<li>Tomcat 是运行 Java Web 应用程序的容器。我们编写的 Web 应用程序代码只需要部署在 Tomcat 容器下，便可以被 Tomcat 容器调用执行。按照之前的划分原则，Tomcat 就是高层模块，我们编写的 Web 应用程序代码就是低层模块。Tomcat 和应用程序代码之间并没有直接的依赖关系，两者都依赖同一个“抽象”，也就是 Servlet 规范。Servlet 规范不依赖具体的 Tomcat 容器和应用程序的实现细节，而 Tomcat 容器和应用程序依赖 Servlet 规范。</li>\n</ol>\n<h2 id=\"KISS原则和YAGNI原则\"><a href=\"#KISS原则和YAGNI原则\" class=\"headerlink\" title=\"KISS原则和YAGNI原则\"></a>KISS原则和YAGNI原则</h2><ol>\n<li>我们学习了经典的 SOLID 原则。今天，我们讲两个设计原则：KISS 原则和 YAGNI 原则。其中，KISS 原则比较经典，耳熟能详，但 YAGNI 你可能没怎么听过，不过它理解起来也不难。</li>\n<li>理解这两个原则时候，经常会有一个共同的问题，那就是，看一眼就感觉懂了，但深究的话，又有很多细节问题不是很清楚。比如，怎么理解 KISS 原则中“简单”两个字？什么样的代码才算“简单”？怎样的代码才算“复杂”？如何才能写出“简单”的代码？YAGNI 原则跟 KISS 原则说的是一回事吗？</li>\n</ol>\n<p>KISS 原则的英文描述有好几个版本，比如下面这几个。</p>\n<ul>\n<li>Keep It Simple and Stupid.</li>\n<li>Keep It Short and Simple.</li>\n<li>Keep It Simple and Straightforward.</li>\n</ul>\n<ol>\n<li><p>不过，仔细看你就会发现，它们要表达的意思其实差不多，翻译成中文就是：尽量保持简单。</p>\n</li>\n<li><p>我们知道，代码的可读性和可维护性是衡量代码质量非常重要的两个标准。而 KISS 原则就是保持代码可读和可维护的重要手段。代码足够简单，也就意味着很容易读懂，bug 比较难隐藏。即便出现 bug，修复起来也比较简单。不过，这条原则只是告诉我们，要保持代码“Simple and Stupid”，但并没有讲到，什么样的代码才是“Simple and Stupid”的，更没有给出特别明确的方法论，来指导如何开发出“Simple and Stupid”的代码。</p>\n</li>\n<li><p>所以，接下来，为了能让这条原则切实地落地，能够指导实际的项目开发，我就针对刚刚的这些问题来进一步讲讲我的理解。</p>\n</li>\n</ol>\n<h3 id=\"代码行数越少就越“简单”吗？\"><a href=\"#代码行数越少就越“简单”吗？\" class=\"headerlink\" title=\"代码行数越少就越“简单”吗？\"></a>代码行数越少就越“简单”吗？</h3><p>我们先一起看一个例子。下面这三段代码可以实现同样一个功能：检查输入的字符串 ipAddress 是否是合法的 IP 地址。一个合法的 IP 地址由四个数字组成，并且通过“.”来进行分割。每组数字的取值范围是 0~255。第一组数字比较特殊，不允许为 0。对比这三段代码，你觉得哪一段代码最符合 KISS 原则呢？如果让你来实现这个功能，你会选择用哪种实现方法呢？你可以先自己思考一下，然后再看我下面的讲解。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 第一种实现方式: 使用正则表达式</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">isValidIpAddressV1</span><span class=\"params\">(String ipAddress)</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (StringUtils.isBlank(ipAddress)) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  <span class=\"type\">String</span> <span class=\"variable\">regex</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;^(1\\\\d&#123;2&#125;|2[0-4]\\\\d|25[0-5]|[1-9]\\\\d|[1-9])\\\\.&quot;</span></span><br><span class=\"line\">          + <span class=\"string\">&quot;(1\\\\d&#123;2&#125;|2[0-4]\\\\d|25[0-5]|[1-9]\\\\d|\\\\d)\\\\.&quot;</span></span><br><span class=\"line\">          + <span class=\"string\">&quot;(1\\\\d&#123;2&#125;|2[0-4]\\\\d|25[0-5]|[1-9]\\\\d|\\\\d)\\\\.&quot;</span></span><br><span class=\"line\">          + <span class=\"string\">&quot;(1\\\\d&#123;2&#125;|2[0-4]\\\\d|25[0-5]|[1-9]\\\\d|\\\\d)$&quot;</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> ipAddress.matches(regex);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 第二种实现方式: 使用现成的工具类</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">isValidIpAddressV2</span><span class=\"params\">(String ipAddress)</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (StringUtils.isBlank(ipAddress)) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  String[] ipUnits = StringUtils.split(ipAddress, <span class=\"string\">&#x27;.&#x27;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (ipUnits.length != <span class=\"number\">4</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">4</span>; ++i) &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> ipUnitIntValue;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      ipUnitIntValue = Integer.parseInt(ipUnits[i]);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (NumberFormatException e) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ipUnitIntValue &lt; <span class=\"number\">0</span> || ipUnitIntValue &gt; <span class=\"number\">255</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (i == <span class=\"number\">0</span> &amp;&amp; ipUnitIntValue == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 第三种实现方式: 不使用任何工具类</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">isValidIpAddressV3</span><span class=\"params\">(String ipAddress)</span> &#123;</span><br><span class=\"line\">  <span class=\"type\">char</span>[] ipChars = ipAddress.toCharArray();</span><br><span class=\"line\">  <span class=\"type\">int</span> <span class=\"variable\">length</span> <span class=\"operator\">=</span> ipChars.length;</span><br><span class=\"line\">  <span class=\"type\">int</span> <span class=\"variable\">ipUnitIntValue</span> <span class=\"operator\">=</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"type\">boolean</span> <span class=\"variable\">isFirstUnit</span> <span class=\"operator\">=</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">  <span class=\"type\">int</span> <span class=\"variable\">unitsCount</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; length; ++i) &#123;</span><br><span class=\"line\">    <span class=\"type\">char</span> <span class=\"variable\">c</span> <span class=\"operator\">=</span> ipChars[i];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (c == <span class=\"string\">&#x27;.&#x27;</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (ipUnitIntValue &lt; <span class=\"number\">0</span> || ipUnitIntValue &gt; <span class=\"number\">255</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (isFirstUnit &amp;&amp; ipUnitIntValue == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (isFirstUnit) isFirstUnit = <span class=\"literal\">false</span>;</span><br><span class=\"line\">      ipUnitIntValue = -<span class=\"number\">1</span>;</span><br><span class=\"line\">      unitsCount++;</span><br><span class=\"line\">      <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (c &lt; <span class=\"string\">&#x27;0&#x27;</span> || c &gt; <span class=\"string\">&#x27;9&#x27;</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ipUnitIntValue == -<span class=\"number\">1</span>) ipUnitIntValue = <span class=\"number\">0</span>;</span><br><span class=\"line\">    ipUnitIntValue = ipUnitIntValue * <span class=\"number\">10</span> + (c - <span class=\"string\">&#x27;0&#x27;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (ipUnitIntValue &lt; <span class=\"number\">0</span> || ipUnitIntValue &gt; <span class=\"number\">255</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (unitsCount != <span class=\"number\">3</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<ol>\n<li>第一种实现方式利用的是正则表达式，只用三行代码就把这个问题搞定了。它的代码行数最少，那是不是就最符合 KISS 原则呢？答案是否定的。虽然代码行数最少，看似最简单，实际上却很复杂。这正是因为它使用了正则表达式。</li>\n<li>一方面，正则表达式本身是比较复杂的，写出完全没有 bug 的正则表达本身就比较有挑战；另一方面，并不是每个程序员都精通正则表达式。对于不怎么懂正则表达式的同事来说，看懂并且维护这段正则表达式是比较困难的。这种实现方式会导致代码的可读性和可维护性变差，所以，从 KISS 原则的设计初衷上来讲，这种实现方式并不符合 KISS 原则。</li>\n<li>讲完了第一种实现方式，我们再来看下其他两种实现方式。</li>\n<li>第二种实现方式使用了 StringUtils 类、Integer 类提供的一些现成的工具函数，来处理 IP 地址字符串。第三种实现方式，不使用任何工具函数，而是通过逐一处理 IP 地址中的字符，来判断是否合法。从代码行数上来说，这两种方式差不多。但是，第三种要比第二种更加有难度，更容易写出 bug。从可读性上来说，第二种实现方式的代码逻辑更清晰、更好理解。所以，在这两种实现方式中，第二种实现方式更加“简单”，更加符合 KISS 原则。</li>\n<li>不过，你可能会说，第三种实现方式虽然实现起来稍微有点复杂，但性能要比第二种实现方式高一些啊。从性能的角度来说，选择第三种实现方式是不是更好些呢？在回答这个问题之前，我先解释一下，为什么说第三种实现方式性能会更高一些。一般来说，工具类的功能都比较通用和全面，所以，在代码实现上，需要考虑和处理更多的细节，执行效率就会有所影响。而第三种实现方式，完全是自己操作底层字符，只针对 IP 地址这一种格式的数据输入来做处理，没有太多多余的函数调用和其他不必要的处理逻辑，所以，在执行效率上，这种类似定制化的处理代码方式肯定比通用的工具类要高些。</li>\n<li>不过，尽管第三种实现方式性能更高些，但我还是更倾向于选择第二种实现方法。那是因为第三种实现方式实际上是一种过度优化。除非 isValidIpAddress() 函数是影响系统性能的瓶颈代码，否则，这样优化的投入产出比并不高，增加了代码实现的难度、牺牲了代码的可读性，性能上的提升却并不明显。</li>\n</ol>\n<h3 id=\"代码逻辑复杂就违背-KISS-原则吗？\"><a href=\"#代码逻辑复杂就违背-KISS-原则吗？\" class=\"headerlink\" title=\"代码逻辑复杂就违背 KISS 原则吗？\"></a>代码逻辑复杂就违背 KISS 原则吗？</h3><p>刚刚我们提到，并不是代码行数越少就越“简单”，还要考虑逻辑复杂度、实现难度、代码的可读性等。那如果一段代码的逻辑复杂、实现难度大、可读性也不太好，是不是就一定违背 KISS 原则呢？在回答这个问题之前，我们先来看下面这段代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// KMP algorithm: a, b分别是主串和模式串；n, m分别是主串和模式串的长度。</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">kmp</span><span class=\"params\">(<span class=\"type\">char</span>[] a, <span class=\"type\">int</span> n, <span class=\"type\">char</span>[] b, <span class=\"type\">int</span> m)</span> &#123;</span><br><span class=\"line\">  <span class=\"type\">int</span>[] next = getNexts(b, m);</span><br><span class=\"line\">  <span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; n; ++i) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (j &gt; <span class=\"number\">0</span> &amp;&amp; a[i] != b[j]) &#123; <span class=\"comment\">// 一直找到a[i]和b[j]</span></span><br><span class=\"line\">      j = next[j - <span class=\"number\">1</span>] + <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (a[i] == b[j]) &#123;</span><br><span class=\"line\">      ++j;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (j == m) &#123; <span class=\"comment\">// 找到匹配模式串的了</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> i - m + <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// b表示模式串，m表示模式串的长度</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">int</span>[] getNexts(<span class=\"type\">char</span>[] b, <span class=\"type\">int</span> m) &#123;</span><br><span class=\"line\">  <span class=\"type\">int</span>[] next = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[m];</span><br><span class=\"line\">  next[<span class=\"number\">0</span>] = -<span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"type\">int</span> <span class=\"variable\">k</span> <span class=\"operator\">=</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; i &lt; m; ++i) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (k != -<span class=\"number\">1</span> &amp;&amp; b[k + <span class=\"number\">1</span>] != b[i]) &#123;</span><br><span class=\"line\">      k = next[k];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (b[k + <span class=\"number\">1</span>] == b[i]) &#123;</span><br><span class=\"line\">      ++k;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    next[i] = k;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> next;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<ol>\n<li><p>这段代码是KMP 字符串匹配算法的代码实现。这段代码完全符合我们刚提到的逻辑复杂、实现难度大、可读性差的特点，但它并不违反 KISS 原则。为什么这么说呢？</p>\n</li>\n<li><p>KMP 算法以快速高效著称。当我们需要处理长文本字符串匹配问题（几百 MB 大小文本内容的匹配），或者字符串匹配是某个产品的核心功能（比如 Vim、Word 等文本编辑器），又或者字符串匹配算法是系统性能瓶颈的时候，我们就应该选择尽可能高效的 KMP 算法。而 KMP 算法本身具有逻辑复杂、实现难度大、可读性差的特点。本身就复杂的问题，用复杂的方法解决，并不违背 KISS 原则。</p>\n</li>\n<li><p>不过，平时的项目开发中涉及的字符串匹配问题，大部分都是针对比较小的文本。在这种情况下，直接调用编程语言提供的现成的字符串匹配函数就足够了。如果非得用 KMP 算法、BM 算法来实现字符串匹配，那就真的违背 KISS 原则了。也就是说，同样的代码，在某个业务场景下满足 KISS 原则，换一个应用场景可能就不满足了。</p>\n</li>\n</ol>\n<h3 id=\"如何写出满足-KISS-原则的代码？\"><a href=\"#如何写出满足-KISS-原则的代码？\" class=\"headerlink\" title=\"如何写出满足 KISS 原则的代码？\"></a>如何写出满足 KISS 原则的代码？</h3><p>实际上，我们前面已经讲到了一些方法。这里我稍微总结一下。</p>\n<ul>\n<li>不要使用同事可能不懂的技术来实现代码。比如前面例子中的正则表达式，还有一些编程语言中过于高级的语法等。</li>\n<li>不要重复造轮子，要善于使用已经有的工具类库。经验证明，自己去实现这些类库，出 bug 的概率会更高，维护的成本也比较高。</li>\n<li>不要过度优化。不要过度使用一些奇技淫巧（比如，位运算代替算术运算、复杂的条件语句代替 if-else、使用一些过于底层的函数等）来优化代码，牺牲代码的可读性。</li>\n<li>实际上，代码是否足够简单是一个挺主观的评判。同样的代码，有的人觉得简单，有的人觉得不够简单。而往往自己编写的代码，自己都会觉得够简单。所以，评判代码是否简单，还有一个很有效的间接方法，那就是 code review。如果在 code review 的时候，同事对你的代码有很多疑问，那就说明你的代码有可能不够“简单”，需要优化啦。</li>\n</ul>\n<h3 id=\"YAGNI-跟-KISS-说的是一回事吗？\"><a href=\"#YAGNI-跟-KISS-说的是一回事吗？\" class=\"headerlink\" title=\"YAGNI 跟 KISS 说的是一回事吗？\"></a>YAGNI 跟 KISS 说的是一回事吗？</h3><ol>\n<li>YAGNI 原则的英文全称是：You Ain’t Gonna Need It。直译就是：你不会需要它。这条原则也算是万金油了。当用在软件开发中的时候，它的意思是：不要去设计当前用不到的功能；不要去编写当前用不到的代码。实际上，这条原则的核心思想就是：不要做过度设计。</li>\n<li>比如，我们的系统暂时只用 Redis 存储配置信息，以后可能会用到 ZooKeeper。根据 YAGNI 原则，在未用到 ZooKeeper 之前，我们没必要提前编写这部分代码。当然，这并不是说我们就不需要考虑代码的扩展性。我们还是要预留好扩展点，等到需要的时候，再去实现 ZooKeeper 存储配置信息这部分代码。</li>\n<li>再比如，我们不要在项目中提前引入不需要依赖的开发包。对于 Java 程序员来说，我们经常使用 Maven 或者 Gradle 来管理依赖的类库（library）。我发现，有些同事为了避免开发中 library 包缺失而频繁地修改 Maven 或者 Gradle 配置文件，提前往项目里引入大量常用的 library 包。实际上，这样的做法也是违背 YAGNI 原则的。</li>\n<li>从刚刚的分析我们可以看出，YAGNI 原则跟 KISS 原则并非一回事儿。KISS 原则讲的是“如何做”的问题（尽量保持简单），而 YAGNI 原则说的是“要不要做”的问题（当前不需要的就不要做）。</li>\n</ol>\n<h2 id=\"DRY-原则\"><a href=\"#DRY-原则\" class=\"headerlink\" title=\"DRY 原则\"></a>DRY 原则</h2><p>Don’t Repeat Yourself。中文直译为：不要重复自己。将它应用在编程中，可以理解为：不要写重复的代码。DRY 原则的定义非常简单，我就不再过度解读。今天，我们主要讲三种典型的代码重复情况，它们分别是：实现逻辑重复、功能语义重复和代码执行重复。这三种代码重复，有的看似违反 DRY，实际上并不违反；有的看似不违反，实际上却违反了。</p>\n<h3 id=\"实现逻辑重复\"><a href=\"#实现逻辑重复\" class=\"headerlink\" title=\"实现逻辑重复\"></a>实现逻辑重复</h3><p>我们先来看下面这样一段代码是否违反了 DRY 原则。如果违反了，你觉得应该如何重构，才能让它满足 DRY 原则？如果没有违反，那又是为什么呢？</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">UserAuthenticator</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">authenticate</span><span class=\"params\">(String username, String password)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!isValidUsername(username)) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// ...throw InvalidUsernameException...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!isValidPassword(password)) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// ...throw InvalidPasswordException...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//...省略其他代码...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"type\">boolean</span> <span class=\"title function_\">isValidUsername</span><span class=\"params\">(String username)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// check not null, not empty</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (StringUtils.isBlank(username)) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// check length: 4~64</span></span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">length</span> <span class=\"operator\">=</span> username.length();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (length &lt; <span class=\"number\">4</span> || length &gt; <span class=\"number\">64</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// contains only lowcase characters</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!StringUtils.isAllLowerCase(username)) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// contains only a~z,0~9,dot</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; length; ++i) &#123;</span><br><span class=\"line\">      <span class=\"type\">char</span> <span class=\"variable\">c</span> <span class=\"operator\">=</span> username.charAt(i);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!(c &gt;= <span class=\"string\">&#x27;a&#x27;</span> &amp;&amp; c &lt;= <span class=\"string\">&#x27;z&#x27;</span>) || (c &gt;= <span class=\"string\">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class=\"string\">&#x27;9&#x27;</span>) || c == <span class=\"string\">&#x27;.&#x27;</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"type\">boolean</span> <span class=\"title function_\">isValidPassword</span><span class=\"params\">(String password)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// check not null, not empty</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (StringUtils.isBlank(password)) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// check length: 4~64</span></span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">length</span> <span class=\"operator\">=</span> password.length();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (length &lt; <span class=\"number\">4</span> || length &gt; <span class=\"number\">64</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// contains only lowcase characters</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!StringUtils.isAllLowerCase(password)) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// contains only a~z,0~9,dot</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; length; ++i) &#123;</span><br><span class=\"line\">      <span class=\"type\">char</span> <span class=\"variable\">c</span> <span class=\"operator\">=</span> password.charAt(i);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!(c &gt;= <span class=\"string\">&#x27;a&#x27;</span> &amp;&amp; c &lt;= <span class=\"string\">&#x27;z&#x27;</span>) || (c &gt;= <span class=\"string\">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class=\"string\">&#x27;9&#x27;</span>) || c == <span class=\"string\">&#x27;.&#x27;</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>代码很简单，我就不做过多解释了。在代码中，有两处非常明显的重复的代码片段：isValidUserName() 函数和 isValidPassword() 函数。重复的代码被敲了两遍，或者简单 copy-paste 了一下，看起来明显违反 DRY 原则。为了移除重复的代码，我们对上面的代码做下重构，将 isValidUserName() 函数和 isValidPassword() 函数，合并为一个更通用的函数 isValidUserNameOrPassword()。重构后的代码如下所示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">UserAuthenticatorV2</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">authenticate</span><span class=\"params\">(String userName, String password)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!isValidUsernameOrPassword(userName)) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// ...throw InvalidUsernameException...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!isValidUsernameOrPassword(password)) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// ...throw InvalidPasswordException...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"type\">boolean</span> <span class=\"title function_\">isValidUsernameOrPassword</span><span class=\"params\">(String usernameOrPassword)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//省略实现逻辑</span></span><br><span class=\"line\">    <span class=\"comment\">//跟原来的isValidUsername()或isValidPassword()的实现逻辑一样...</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>经过重构之后，代码行数减少了，也没有重复的代码了，是不是更好了呢？答案是否定的，这可能跟你预期的不一样，我来解释一下为什么。</li>\n<li>单从名字上看，我们就能发现，合并之后的 isValidUserNameOrPassword() 函数，负责两件事情：验证用户名和验证密码，违反了“单一职责原则”和“接口隔离原则”。实际上，即便将两个函数合并成 isValidUserNameOrPassword()，代码仍然存在问题。</li>\n<li>因为 isValidUserName() 和 isValidPassword() 两个函数，虽然从代码实现逻辑上看起来是重复的，但是从语义上并不重复。所谓“语义不重复”指的是：从功能上来看，这两个函数干的是完全不重复的两件事情，一个是校验用户名，另一个是校验密码。尽管在目前的设计中，两个校验逻辑是完全一样的，但如果按照第二种写法，将两个函数的合并，那就会存在潜在的问题。在未来的某一天，如果我们修改了密码的校验逻辑，比如，允许密码包含大写字符，允许密码的长度为 8 到 64 个字符，那这个时候，isValidUserName() 和 isValidPassword() 的实现逻辑就会不相同。我们就要把合并后的函数，重新拆成合并前的那两个函数。</li>\n<li>尽管代码的实现逻辑是相同的，但语义不同，我们判定它并不违反 DRY 原则。对于包含重复代码的问题，我们可以通过抽象成更细粒度函数的方式来解决。比如将校验只包含 a<del>z、0</del>9、dot 的逻辑封装成 boolean onlyContains(String str, String charlist); 函数。</li>\n</ol>\n<h3 id=\"功能语义重复\"><a href=\"#功能语义重复\" class=\"headerlink\" title=\"功能语义重复\"></a>功能语义重复</h3><ol>\n<li>现在我们再来看另外一个例子。在同一个项目代码中有下面两个函数：isValidIp() 和 checkIfIpValid()。尽管两个函数的命名不同，实现逻辑不同，但功能是相同的，都是用来判定 IP 地址是否合法的。</li>\n<li>之所以在同一个项目中会有两个功能相同的函数，那是因为这两个函数是由两个不同的同事开发的，其中一个同事在不知道已经有了 isValidIp() 的情况下，自己又定义并实现了同样用来校验 IP 地址是否合法的 checkIfIpValid() 函数。那在同一项目代码中，存在如下两个函数，是否违反 DRY 原则呢？</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">isValidIp</span><span class=\"params\">(String ipAddress)</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (StringUtils.isBlank(ipAddress)) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  <span class=\"type\">String</span> <span class=\"variable\">regex</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;^(1\\\\d&#123;2&#125;|2[0-4]\\\\d|25[0-5]|[1-9]\\\\d|[1-9])\\\\.&quot;</span></span><br><span class=\"line\">          + <span class=\"string\">&quot;(1\\\\d&#123;2&#125;|2[0-4]\\\\d|25[0-5]|[1-9]\\\\d|\\\\d)\\\\.&quot;</span></span><br><span class=\"line\">          + <span class=\"string\">&quot;(1\\\\d&#123;2&#125;|2[0-4]\\\\d|25[0-5]|[1-9]\\\\d|\\\\d)\\\\.&quot;</span></span><br><span class=\"line\">          + <span class=\"string\">&quot;(1\\\\d&#123;2&#125;|2[0-4]\\\\d|25[0-5]|[1-9]\\\\d|\\\\d)$&quot;</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> ipAddress.matches(regex);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">checkIfIpValid</span><span class=\"params\">(String ipAddress)</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (StringUtils.isBlank(ipAddress)) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  String[] ipUnits = StringUtils.split(ipAddress, <span class=\"string\">&#x27;.&#x27;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (ipUnits.length != <span class=\"number\">4</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">4</span>; ++i) &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> ipUnitIntValue;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      ipUnitIntValue = Integer.parseInt(ipUnits[i]);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (NumberFormatException e) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ipUnitIntValue &lt; <span class=\"number\">0</span> || ipUnitIntValue &gt; <span class=\"number\">255</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (i == <span class=\"number\">0</span> &amp;&amp; ipUnitIntValue == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>这个例子跟上个例子正好相反。上一个例子是代码实现逻辑重复，但语义不重复，我们并不认为它违反了 DRY 原则。而在这个例子中，尽管两段代码的实现逻辑不重复，但语义重复，也就是功能重复，我们认为它违反了 DRY 原则。我们应该在项目中，统一一种实现思路，所有用到判断 IP 地址是否合法的地方，都统一调用同一个函数。</li>\n<li>假设我们不统一实现思路，那有些地方调用了 isValidIp() 函数，有些地方又调用了 checkIfIpValid() 函数，这就会导致代码看起来很奇怪，相当于给代码“埋坑”，给不熟悉这部分代码的同事增加了阅读的难度。同事有可能研究了半天，觉得功能是一样的，但又有点疑惑，觉得是不是有更高深的考量，才定义了两个功能类似的函数，最终发现居然是代码设计的问题。</li>\n<li>除此之外，如果哪天项目中 IP 地址是否合法的判定规则改变了，比如：255.255.255.255 不再被判定为合法的了，相应地，我们对 isValidIp() 的实现逻辑做了相应的修改，但却忘记了修改 checkIfIpValid() 函数。又或者，我们压根就不知道还存在一个功能相同的 checkIfIpValid() 函数，这样就会导致有些代码仍然使用老的 IP 地址判断逻辑，导致出现一些莫名其妙的 bug。</li>\n</ol>\n<h3 id=\"代码执行重复\"><a href=\"#代码执行重复\" class=\"headerlink\" title=\"代码执行重复\"></a>代码执行重复</h3><p>前两个例子一个是实现逻辑重复，一个是语义重复，我们再来看第三个例子。其中，UserService 中 login() 函数用来校验用户登录是否成功。如果失败，就返回异常；如果成功，就返回用户信息。具体代码如下所示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">UserService</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> UserRepo userRepo;<span class=\"comment\">//通过依赖注入或者IOC框架注入</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> User <span class=\"title function_\">login</span><span class=\"params\">(String email, String password)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">boolean</span> <span class=\"variable\">existed</span> <span class=\"operator\">=</span> userRepo.checkIfUserExisted(email, password);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!existed) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// ... throw AuthenticationFailureException...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">User</span> <span class=\"variable\">user</span> <span class=\"operator\">=</span> userRepo.getUserByEmail(email);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> user;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">UserRepo</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">checkIfUserExisted</span><span class=\"params\">(String email, String password)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!EmailValidation.validate(email)) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// ... throw InvalidEmailException...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!PasswordValidation.validate(password)) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// ... throw InvalidPasswordException...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//...query db to check if email&amp;password exists...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> User <span class=\"title function_\">getUserByEmail</span><span class=\"params\">(String email)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!EmailValidation.validate(email)) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// ... throw InvalidEmailException...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//...query db to get user by email...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>上面这段代码，既没有逻辑重复，也没有语义重复，但仍然违反了 DRY 原则。这是因为代码中存在“执行重复”。我们一块儿来看下，到底哪些代码被重复执行了？</li>\n<li>重复执行最明显的一个地方，就是在 login() 函数中，email 的校验逻辑被执行了两次。一次是在调用 checkIfUserExisted() 函数的时候，另一次是调用 getUserByEmail() 函数的时候。这个问题解决起来比较简单，我们只需要将校验逻辑从 UserRepo 中移除，统一放到 UserService 中就可以了。</li>\n<li>除此之外，代码中还有一处比较隐蔽的执行重复，不知道你发现了没有？实际上，login() 函数并不需要调用 checkIfUserExisted() 函数，只需要调用一次 getUserByEmail() 函数，从数据库中获取到用户的 email、password 等信息，然后跟用户输入的 email、password 信息做对比，依次判断是否登录成功。</li>\n<li>实际上，这样的优化是很有必要的。因为 checkIfUserExisted() 函数和 getUserByEmail() 函数都需要查询数据库，而数据库这类的 I&#x2F;O 操作是比较耗时的。我们在写代码的时候，应当尽量减少这类 I&#x2F;O 操作。</li>\n<li>按照刚刚的修改思路，我们把代码重构一下，移除“重复执行”的代码，只校验一次 email 和 password，并且只查询一次数据库。重构之后的代码如下所示：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">UserService</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> UserRepo userRepo;<span class=\"comment\">//通过依赖注入或者IOC框架注入</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> User <span class=\"title function_\">login</span><span class=\"params\">(String email, String password)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!EmailValidation.validate(email)) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// ... throw InvalidEmailException...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!PasswordValidation.validate(password)) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// ... throw InvalidPasswordException...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">User</span> <span class=\"variable\">user</span> <span class=\"operator\">=</span> userRepo.getUserByEmail(email);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (user == <span class=\"literal\">null</span> || !password.equals(user.getPassword()) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// ... throw AuthenticationFailureException...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> user;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">UserRepo</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">checkIfUserExisted</span><span class=\"params\">(String email, String password)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//...query db to check if email&amp;password exists</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> User <span class=\"title function_\">getUserByEmail</span><span class=\"params\">(String email)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//...query db to get user by email...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"代码复用性（Code-Reusability）\"><a href=\"#代码复用性（Code-Reusability）\" class=\"headerlink\" title=\"代码复用性（Code Reusability）\"></a>代码复用性（Code Reusability）</h3><ol>\n<li><p>我们首先来区分三个概念：代码复用性（Code Reusability）、代码复用（Code Resue）和 DRY 原则。代码复用表示一种行为：我们在开发新功能的时候，尽量复用已经存在的代码。代码的可复用性表示一段代码可被复用的特性或能力：我们在编写代码的时候，让代码尽量可复用。DRY 原则是一条原则：不要写重复的代码。从定义描述上，它们好像有点类似，但深究起来，三者的区别还是蛮大的。</p>\n</li>\n<li><p>首先，“不重复”并不代表“可复用”。在一个项目代码中，可能不存在任何重复的代码，但也并不表示里面有可复用的代码，不重复和可复用完全是两个概念。所以，从这个角度来说，DRY 原则跟代码的可复用性讲的是两回事。</p>\n</li>\n<li><p>其次，“复用”和“可复用性”关注角度不同。代码“可复用性”是从代码开发者的角度来讲的，“复用”是从代码使用者的角度来讲的。比如，A 同事编写了一个 UrlUtils 类，代码的“可复用性”很好。B 同事在开发新功能的时候，直接“复用”A 同事编写的 UrlUtils 类。尽管复用、可复用性、DRY 原则这三者从理解上有所区别，但实际上要达到的目的都是类似的，都是为了减少代码量，提高代码的可读性、可维护性。除此之外，复用已经经过测试的老代码，bug 会比从零重新开发要少。</p>\n</li>\n<li><p>“复用”这个概念不仅可以指导细粒度的模块、类、函数的设计开发，实际上，一些框架、类库、组件等的产生也都是为了达到复用的目的。比如，Spring 框架、Google Guava 类库、UI 组件等等。</p>\n</li>\n</ol>\n<h3 id=\"怎么提高代码复用性？\"><a href=\"#怎么提高代码复用性？\" class=\"headerlink\" title=\"怎么提高代码复用性？\"></a>怎么提高代码复用性？</h3><p>实际上，我们前面已经讲到过很多提高代码可复用性的手段，今天算是集中总结一下，我总结了 7 条，具体如下。</p>\n<blockquote>\n<p>减少代码耦合</p>\n</blockquote>\n<p>对于高度耦合的代码，当我们希望复用其中的一个功能，想把这个功能的代码抽取出来成为一个独立的模块、类或者函数的时候，往往会发现牵一发而动全身。移动一点代码，就要牵连到很多其他相关的代码。所以，高度耦合的代码会影响到代码的复用性，我们要尽量减少代码耦合。</p>\n<blockquote>\n<p>满足单一职责原则</p>\n</blockquote>\n<p>我们前面讲过，如果职责不够单一，模块、类设计得大而全，那依赖它的代码或者它依赖的代码就会比较多，进而增加了代码的耦合。根据上一点，也就会影响到代码的复用性。相反，越细粒度的代码，代码的通用性会越好，越容易被复用。</p>\n<blockquote>\n<p>模块化</p>\n</blockquote>\n<p>这里的“模块”，不单单指一组类构成的模块，还可以理解为单个类、函数。我们要善于将功能独立的代码，封装成模块。独立的模块就像一块一块的积木，更加容易复用，可以直接拿来搭建更加复杂的系统。</p>\n<blockquote>\n<p>业务与非业务逻辑分离</p>\n</blockquote>\n<p>越是跟业务无关的代码越是容易复用，越是针对特定业务的代码越难复用。所以，为了复用跟业务无关的代码，我们将业务和非业务逻辑代码分离，抽取成一些通用的框架、类库、组件等。</p>\n<blockquote>\n<p>通用代码下沉</p>\n</blockquote>\n<p>从分层的角度来看，越底层的代码越通用、会被越多的模块调用，越应该设计得足够可复用。一般情况下，在代码分层之后，为了避免交叉调用导致调用关系混乱，我们只允许上层代码调用下层代码及同层代码之间的调用，杜绝下层代码调用上层代码。所以，通用的代码我们尽量下沉到更下层。</p>\n<blockquote>\n<p>继承、多态、抽象、封装</p>\n</blockquote>\n<p>在讲面向对象特性的时候，利用继承，可以将公共的代码抽取到父类，子类复用父类的属性和方法。利用多态，我们可以动态地替换一段代码的部分逻辑，让这段代码可复用。除此之外，抽象和封装，从更加广义的层面、而非狭义的面向对象特性的层面来理解的话，越抽象、越不依赖具体的实现，越容易复用。代码封装成模块，隐藏可变的细节、暴露不变的接口，就越容易复用。</p>\n<blockquote>\n<p>应用模板等设计模式</p>\n</blockquote>\n<p>一些设计模式，也能提高代码的复用性。比如，模板模式利用了多态来实现，可以灵活地替换其中的部分代码，整个流程模板代码可复用。关于应用设计模式提高代码复用性这一部分，我们留在后面慢慢来讲解。除了刚刚我们讲到的几点，还有一些跟编程语言相关的特性，也能提高代码的复用性，比如泛型编程等。实际上，除了上面讲到的这些方法之外，复用意识也非常重要。在写代码的时候，我们要多去思考一下，这</p>\n<h2 id=\"迪米特法则\"><a href=\"#迪米特法则\" class=\"headerlink\" title=\"迪米特法则\"></a>迪米特法则</h2><p>我们讲最后一个设计原则：迪米特法则。尽管它不像 SOLID、KISS、DRY 原则那样，人尽皆知，但它却非常实用。利用这个原则，能够帮我们实现代码的“高内聚、松耦合”。今天，我们就围绕下面几个问题，并结合两个代码实战案例，来深入地学习这个法则。</p>\n<ul>\n<li>什么是“高内聚、松耦合”？</li>\n<li>如何利用迪米特法则来实现“高内聚、松耦合”？</li>\n<li>有哪些代码设计是明显违背迪米特法则的？对此又该如何重构？</li>\n</ul>\n<h3 id=\"何为“高内聚、松耦合”？\"><a href=\"#何为“高内聚、松耦合”？\" class=\"headerlink\" title=\"何为“高内聚、松耦合”？\"></a>何为“高内聚、松耦合”？</h3><ol>\n<li>“高内聚、松耦合”是一个非常重要的设计思想，能够有效地提高代码的可读性和可维护性，缩小功能改动导致的代码改动范围。</li>\n<li>实际上，在前面的章节中，我们已经多次提到过这个设计思想。很多设计原则都以实现代码的“高内聚、松耦合”为目的，比如单一职责原则、基于接口而非实现编程等。实际上，“高内聚、松耦合”是一个比较通用的设计思想，可以用来指导不同粒度代码的设计与开发，比如系统、模块、类，甚至是函数，也可以应用到不同的开发场景中，比如微服务、框架、组件、类库等。为了方便我讲解，接下来我以“类”作为这个设计思想的应用对象来展开讲解，其他应用场景你可以自行类比。</li>\n<li>在这个设计思想中，“高内聚”用来指导类本身的设计，“松耦合”用来指导类与类之间依赖关系的设计。不过，这两者并非完全独立不相干。高内聚有助于松耦合，松耦合又需要高内聚的支持。</li>\n</ol>\n<blockquote>\n<p>那到底什么是“高内聚”呢？</p>\n</blockquote>\n<p>所谓高内聚，就是指相近的功能应该放到同一个类中，不相近的功能不要放到同一个类中。相近的功能往往会被同时修改，放到同一个类中，修改会比较集中，代码容易维护。实际上，我们前面讲过的单一职责原则是实现代码高内聚非常有效的设计原则。</p>\n<blockquote>\n<p>我们再来看一下，什么是“松耦合”？</p>\n</blockquote>\n<p>所谓松耦合是说，在代码中，类与类之间的依赖关系简单清晰。即使两个类有依赖关系，一个类的代码改动不会或者很少导致依赖类的代码改动。实际上，我们前面讲的依赖注入、接口隔离、基于接口而非实现编程，以及今天讲的迪米特法则，都是为了实现代码的松耦合</p>\n<blockquote>\n<p>最后，我们来看一下，“内聚”和“耦合”之间的关系</p>\n</blockquote>\n<p>前面也提到，“高内聚”有助于“松耦合”，同理，“低内聚”也会导致“紧耦合”。关于这一点，我画了一张对比图来解释。图中左边部分的代码结构是“高内聚、松耦合”；右边部分正好相反，是“低内聚、紧耦合”。</p>\n<img src=\"https://npm.elemecdn.com/youthlql@1.0.0/design_patterns/design_principles/0001.png\" />\n\n\n\n\n\n<ol>\n<li>图中左边部分的代码设计中，类的粒度比较小，每个类的职责都比较单一。相近的功能都放到了一个类中，不相近的功能被分割到了多个类中。这样类更加独立，代码的内聚性更好。因为职责单一，所以每个类被依赖的类就会比较少，代码低耦合。一个类的修改，只会影响到一个依赖类的代码改动。我们只需要测试这一个依赖类是否还能正常工作就行了。</li>\n<li>图中右边部分的代码设计中，类粒度比较大，低内聚，功能大而全，不相近的功能放到了一个类中。这就导致很多其他类都依赖这个类。当我们修改这个类的某一个功能代码的时候，会影响依赖它的多个类。我们需要测试这三个依赖类，是否还能正常工作。这也就是所谓的“牵一发而动全身”。</li>\n<li>除此之外，从图中我们也可以看出，高内聚、低耦合的代码结构更加简单、清晰，相应地，在可维护性和可读性上确实要好很多。</li>\n</ol>\n<h3 id=\"“迪米特法则”理论描述\"><a href=\"#“迪米特法则”理论描述\" class=\"headerlink\" title=\"“迪米特法则”理论描述\"></a>“迪米特法则”理论描述</h3><ol>\n<li><p>迪米特法则的英文翻译是：Law of Demeter，缩写是 LOD。单从这个名字上来看，我们完全猜不出这个原则讲的是什么。不过，它还有另外一个更加达意的名字，叫作最小知识原则，英文翻译为：The Least Knowledge Principle。</p>\n</li>\n<li><p>关于这个设计原则，我们先来看一下它最原汁原味的英文定义：</p>\n<blockquote>\n<p>Each unit should have only limited knowledge about other units: only units “closely” related to the current unit. Or: Each unit should only talk to its friends; Don’t talk to strangers.</p>\n</blockquote>\n<p>我们把它直译成中文，就是下面这个样子：</p>\n<blockquote>\n<p>每个模块（unit）只应该了解那些与它关系密切的模块（units: only units “closely” related to the current unit）的有限知识（knowledge）。或者说，每个模块只和自己的朋友“说话”（talk），不和陌生人“说话”（talk）。</p>\n</blockquote>\n<p>我们之前讲过，大部分设计原则和思想都非常抽象，有各种各样的解读，要想灵活地应用到实际的开发中，需要有实战经验的积累。迪米特法则也不例外。所以，我结合我自己的理解和经验，对刚刚的定义重新描述一下。注意，为了统一讲解，我把定义描述中的“模块”替换成了“类”。</p>\n<blockquote>\n<p>不该有直接依赖关系的类之间，不要有依赖；有依赖关系的类之间，尽量只依赖必要的接口（也就是定义中的“有限知识”）。从上面的描述中，我们可以看出，迪米特法则包含前后两部分，这两部分讲的是两件事情，我用两个实战案例分别来解读一下。</p>\n</blockquote>\n</li>\n</ol>\n<h3 id=\"理论解读与代码实战一\"><a href=\"#理论解读与代码实战一\" class=\"headerlink\" title=\"理论解读与代码实战一\"></a>理论解读与代码实战一</h3><ol>\n<li>我们先来看这条原则中的前半部分，<strong>“不该有直接依赖关系的类之间，不要有依赖”</strong>。我举个例子解释一下。</li>\n<li>这个例子实现了简化版的搜索引擎爬取网页的功能。代码中包含三个主要的类。其中，NetworkTransporter 类负责底层网络通信，根据请求获取数据；HtmlDownloader 类用来通过 URL 获取网页；Document 表示网页文档，后续的网页内容抽取、分词、索引都是以此为处理对象。具体的代码实现如下所示：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">NetworkTransporter</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 省略属性和其他方法...</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Byte[] send(HtmlRequest htmlRequest) &#123;</span><br><span class=\"line\">      <span class=\"comment\">//...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">HtmlDownloader</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> NetworkTransporter transporter;<span class=\"comment\">//通过构造函数或IOC注入</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">public</span> Html <span class=\"title function_\">downloadHtml</span><span class=\"params\">(String url)</span> &#123;</span><br><span class=\"line\">    Byte[] rawHtml = transporter.send(<span class=\"keyword\">new</span> <span class=\"title class_\">HtmlRequest</span>(url));</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Html</span>(rawHtml);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Document</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> Html html;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> String url;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"title function_\">Document</span><span class=\"params\">(String url)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.url = url;</span><br><span class=\"line\">    <span class=\"type\">HtmlDownloader</span> <span class=\"variable\">downloader</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">HtmlDownloader</span>();</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.html = downloader.downloadHtml(url);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>这段代码虽然“能用”，能实现我们想要的功能，但是它不够“好用”，有比较多的设计缺陷。你可以先试着思考一下，看看都有哪些缺陷，然后再来看我下面的讲解。</li>\n<li>首先，我们来看 NetworkTransporter 类。作为一个底层网络通信类，我们希望它的功能尽可能通用，而不只是服务于下载 HTML，所以，我们不应该直接依赖太具体的发送对象 HtmlRequest。从这一点上讲，NetworkTransporter 类的设计违背迪米特法则，依赖了不该有直接依赖关系的 HtmlRequest 类。</li>\n<li>我们应该如何进行重构，让 NetworkTransporter 类满足迪米特法则呢？我这里有个形象的比喻。假如你现在要去商店买东西，你肯定不会直接把钱包给收银员，让收银员自己从里面拿钱，而是你从钱包里把钱拿出来交给收银员。这里的 HtmlRequest 对象就相当于钱包，HtmlRequest 里的 address 和 content 对象就相当于钱。我们应该把 address 和 content 交给 NetworkTransporter，而非是直接把 HtmlRequest 交给 NetworkTransporter。根据这个思路，NetworkTransporter 重构之后的代码如下所示：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">NetworkTransporter</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 省略属性和其他方法...</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Byte[] send(String address, Byte[] data) &#123;</span><br><span class=\"line\">      <span class=\"comment\">//...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>我们再来看 HtmlDownloader 类。这个类的设计没有问题。不过，我们修改了 NetworkTransporter 的 send() 函数的定义，而这个类用到了 send() 函数，所以我们需要对它做相应的修改，修改后的代码如下所示</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">HtmlDownloader</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> NetworkTransporter transporter;<span class=\"comment\">//通过构造函数或IOC注入</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">// HtmlDownloader这里也要有相应的修改</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> Html <span class=\"title function_\">downloadHtml</span><span class=\"params\">(String url)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">HtmlRequest</span> <span class=\"variable\">htmlRequest</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">HtmlRequest</span>(url);</span><br><span class=\"line\">    Byte[] rawHtml = transporter.send(</span><br><span class=\"line\">      htmlRequest.getAddress(), htmlRequest.getContent().getBytes());</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Html</span>(rawHtml);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>最后，我们来看下 Document 类。这个类的问题比较多，主要有三点。第一，构造函数中的 downloader.downloadHtml() 逻辑复杂，耗时长，不应该放到构造函数中，会影响代码的可测试性。代码的可测试性我们后面会讲到，这里你先知道有这回事就可以了。第二，HtmlDownloader 对象在构造函数中通过 new 来创建，违反了基于接口而非实现编程的设计思想，也会影响到代码的可测试性。第三，从业务含义上来讲，Document 网页文档没必要依赖 HtmlDownloader 类，违背了迪米特法则。</p>\n<p>虽然 Document 类的问题很多，但修改起来比较简单，只要一处改动就可以解决所有问题。修改之后的代码如下所示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Document</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> Html html;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> String url;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"title function_\">Document</span><span class=\"params\">(String url, Html html)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.html = html;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.url = url;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 通过一个工厂方法来创建Document</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">DocumentFactory</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> HtmlDownloader downloader;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"title function_\">DocumentFactory</span><span class=\"params\">(HtmlDownloader downloader)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.downloader = downloader;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">public</span> Document <span class=\"title function_\">createDocument</span><span class=\"params\">(String url)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">Html</span> <span class=\"variable\">html</span> <span class=\"operator\">=</span> downloader.downloadHtml(url);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Document</span>(url, html);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h3 id=\"理论解读与代码实战二\"><a href=\"#理论解读与代码实战二\" class=\"headerlink\" title=\"理论解读与代码实战二\"></a>理论解读与代码实战二</h3><p>现在，我们再来看一下这条原则中的后半部分：“有依赖关系的类之间，尽量只依赖必要的接口”。我们还是结合一个例子来讲解。下面这段代码非常简单，Serialization 类负责对象的序列化和反序列化</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Serialization</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> String <span class=\"title function_\">serialize</span><span class=\"params\">(Object object)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">serializedResult</span> <span class=\"operator\">=</span> ...;</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> serializedResult;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">public</span> Object <span class=\"title function_\">deserialize</span><span class=\"params\">(String str)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">Object</span> <span class=\"variable\">deserializedResult</span> <span class=\"operator\">=</span> ...;</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> deserializedResult;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<ol>\n<li>单看这个类的设计，没有一点问题。不过，如果我们把它放到一定的应用场景里，那就还有继续优化的空间。假设在我们的项目中，有些类只用到了序列化操作，而另一些类只用到反序列化操作。那基于迪米特法则后半部分“有依赖关系的类之间，尽量只依赖必要的接口”，只用到序列化操作的那部分类不应该依赖反序列化接口。同理，只用到反序列化操作的那部分类不应该依赖序列化接口。</li>\n<li>根据这个思路，我们应该将 Serialization 类拆分为两个更小粒度的类，一个只负责序列化（Serializer 类），一个只负责反序列化（Deserializer 类）。拆分之后，使用序列化操作的类只需要依赖 Serializer 类，使用反序列化操作的类只需要依赖 Deserializer 类。拆分之后的代码如下所示：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Serializer</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> String <span class=\"title function_\">serialize</span><span class=\"params\">(Object object)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">serializedResult</span> <span class=\"operator\">=</span> ...;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">return</span> serializedResult;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Deserializer</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> Object <span class=\"title function_\">deserialize</span><span class=\"params\">(String str)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">Object</span> <span class=\"variable\">deserializedResult</span> <span class=\"operator\">=</span> ...;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">return</span> deserializedResult;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<ol>\n<li>不知道你有没有看出来，尽管拆分之后的代码更能满足迪米特法则，但却违背了高内聚的设计思想。高内聚要求相近的功能要放到同一个类中，这样可以方便功能修改的时候，修改的地方不至于过于分散。对于刚刚这个例子来说，如果我们修改了序列化的实现方式，比如从 JSON 换成了 XML，那反序列化的实现逻辑也需要一并修改。在未拆分的情况下，我们只需要修改一个类即可。在拆分之后，我们需要修改两个类。显然，这种设计思路的代码改动范围变大了。</li>\n<li>如果我们既不想违背高内聚的设计思想，也不想违背迪米特法则，那我们该如何解决这个问题呢？实际上，通过引入两个接口就能轻松解决这个问题，具体的代码如下所示。实际上，我们在讲到“接口隔离原则”的时候，第三个例子就使用了类似的实现思路，你可以结合着一块儿来看。</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">Serializable</span> &#123;</span><br><span class=\"line\">  String <span class=\"title function_\">serialize</span><span class=\"params\">(Object object)</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">Deserializable</span> &#123;</span><br><span class=\"line\">  Object <span class=\"title function_\">deserialize</span><span class=\"params\">(String text)</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Serialization</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Serializable</span>, Deserializable &#123;</span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> String <span class=\"title function_\">serialize</span><span class=\"params\">(Object object)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">serializedResult</span> <span class=\"operator\">=</span> ...;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">return</span> serializedResult;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> Object <span class=\"title function_\">deserialize</span><span class=\"params\">(String str)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">Object</span> <span class=\"variable\">deserializedResult</span> <span class=\"operator\">=</span> ...;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">return</span> deserializedResult;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">DemoClass_1</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> Serializable serializer;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"title function_\">Demo</span><span class=\"params\">(Serializable serializer)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.serializer = serializer;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">DemoClass_2</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> Deserializable deserializer;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"title function_\">Demo</span><span class=\"params\">(Deserializable deserializer)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.deserializer = deserializer;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>尽管我们还是要往 DemoClass_1 的构造函数中，传入包含序列化和反序列化的 Serialization 实现类，但是，我们依赖的 Serializable 接口只包含序列化操作，DemoClass_1 无法使用 Serialization 类中的反序列化接口，对反序列化操作无感知，这也就符合了迪米特法则后半部分所说的“依赖有限接口”的要求。</li>\n<li>实际上，上面的的代码实现思路，也体现了“基于接口而非实现编程”的设计原则，结合迪米特法则，我们可以总结出一条新的设计原则，那就是“基于最小接口而非最大实现编程”。有些同学之前问，新的设计模式和设计原则是怎么创造出来的，实际上，就是在大量的实践中，针对开发痛点总结归纳出来的套路。</li>\n</ol>\n<h3 id=\"辩证思考与灵活应用\"><a href=\"#辩证思考与灵活应用\" class=\"headerlink\" title=\"辩证思考与灵活应用\"></a>辩证思考与灵活应用</h3><ol>\n<li>对于实战二最终的设计思路，你有没有什么不同的观点呢？</li>\n<li>整个类只包含序列化和反序列化两个操作，只用到序列化操作的使用者，即便能够感知到仅有的一个反序列化函数，问题也不大。那为了满足迪米特法则，我们将一个非常简单的类，拆分出两个接口，是否有点过度设计的意思呢？</li>\n<li>设计原则本身没有对错，只有能否用对之说。不要为了应用设计原则而应用设计原则，我们在应用设计原则的时候，一定要具体问题具体分析。</li>\n<li>对于刚刚这个 Serialization 类来说，只包含两个操作，确实没有太大必要拆分成两个接口。但是，如果我们对 Serialization 类添加更多的功能，实现更多更好用的序列化、反序列化函数，我们来重新考虑一下这个问题。修改之后的具体的代码如下</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Serializer</span> &#123; <span class=\"comment\">// 参看JSON的接口定义</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> String <span class=\"title function_\">serialize</span><span class=\"params\">(Object object)</span> &#123; <span class=\"comment\">//... &#125;</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> String <span class=\"title function_\">serializeMap</span><span class=\"params\">(Map map)</span> &#123; <span class=\"comment\">//... &#125;</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> String <span class=\"title function_\">serializeList</span><span class=\"params\">(List list)</span> &#123; <span class=\"comment\">//... &#125;</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">public</span> Object <span class=\"title function_\">deserialize</span><span class=\"params\">(String objectString)</span> &#123; <span class=\"comment\">//... &#125;</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> Map <span class=\"title function_\">deserializeMap</span><span class=\"params\">(String mapString)</span> &#123; <span class=\"comment\">//... &#125;</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> List <span class=\"title function_\">deserializeList</span><span class=\"params\">(String listString)</span> &#123; <span class=\"comment\">//... &#125;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在这种场景下，第二种设计思路要更好些。因为基于之前的应用场景来说，大部分代码只需要用到序列化的功能。对于这部分使用者，没必要了解反序列化的“知识”，而修改之后的 Serialization 类，反序列化的“知识”，从一个函数变成了三个。一旦任一反序列化操作有代码改动，我们都需要检查、测试所有依赖 Serialization 类的代码是否还能正常工作。为了减少耦合和测试工作量，我们应该按照迪米特法则，将反序列化和序列化的功能隔离开来。</p>\n"},{"title":"设计模式-03.01-创建型-单例","keywords":"设计模式，单例","description":"详解了单例设计模式。","cover":"https://npm.elemecdn.com/lql_static@latest/logo/design_patterns.jpg","abbrlink":"b5a1ed4a","date":"2024-05-11T13:51:58.000Z","_content":"\n# 声明\n\n> 1. 此系列文章非本人原创，是学习笔记。\n> 2. 设计模式系列以后会持续更新，包括已经发布的设计模式文章，因为后续还要再多看一下书，教程和开源项目等，继续润色文章。\n\n\n# 前言\n\n23 种经典的设计模式。它们又可以分为三大类：创建型、结构型、行为型。对于这 23 种设计模式的学习，我们要有侧重点，因为有些模式是比较常用的，有些模式是很少被用到的。对于常用的设计模式，我们要花多点时间理解掌握。对于不常用的设计模式，我们只需要稍微了解即可。按照类型和是否常用，对这些设计模式，进行了简单的分类，具体如下所示。\n\n### 创建型\n\n常用的有：单例模式、工厂模式（工厂方法和抽象工厂）、建造者模式。\n\n不常用的有：原型模式。\n\n\n\n### 结构型\n\n常用的有：代理模式、桥接模式、装饰者模式、适配器模式。\n\n不常用的有：门面模式、组合模式、享元模式。 \n\n\n\n### 行为型\n\n常用的有：观察者模式、模板模式、策略模式、职责链模式、迭代器模式、状态模式。\n\n不常用的有：访问者模式、备忘录模式、命令模式、解释器模式、中介模式。\n\n\n\n\n\n# 单例模式【常用】\n\n网上有很多讲解单例模式的文章，但大部分都侧重讲解，如何来实现一个线程安全的单例。今天也会讲到各种单例的实现方法，但是，重点还是希望带你搞清楚下面这样几个问题。\n\n- 为什么要使用单例？\n- 单例存在哪些问题？\n- 单例与静态类的区别？\n- 有何替代的解决方案？\n\n\n\n## 为什么要使用单例？\n\n单例设计模式（Singleton Design Pattern）理解起来非常简单。一个类只允许创建一个对象（或者实例），那这个类就是一个单例类，这种设计模式就叫作单例设计模式，简称单例模式。\n\n对于单例的概念，我觉得没必要解释太多，你一看就能明白。我们重点看一下，为什么我们需要单例这种设计模式？它能解决哪些问题？接下来我通过两个实战案例来讲解。\n\n\n\n### 实战案例一：处理资源访问冲突\n\n我们先来看第一个例子。在这个例子中，我们自定义实现了一个往文件中打印日志的 Logger 类。具体的代码实现如下所示：\n\n```java\npublic class Logger {\n  private FileWriter writer;\n  \n  public Logger() {\n    File file = new File(\"/Users/wangzheng/log.txt\");\n    writer = new FileWriter(file, true); //true表示追加写入\n  }\n  \n  public void log(String message) {\n    writer.write(message);\n  }\n}\n\n// Logger类的应用示例：\npublic class UserController {\n  private Logger logger = new Logger();\n  \n  public void login(String username, String password) {\n    // ...省略业务逻辑代码...\n    logger.log(username + \" logined!\");\n  }\n}\n\npublic class OrderController {\n  private Logger logger = new Logger();\n  \n  public void create(OrderVo order) {\n    // ...省略业务逻辑代码...\n    logger.log(\"Created an order: \" + order.toString());\n  }\n}\n```\n\n在上面的代码中，我们注意到，所有的日志都写入到同一个文件 /Users/wangzheng/log.txt 中。在 UserController 和 OrderController 中，我们分别创建两个 Logger 对象。在 Web 容器的 Servlet 多线程环境下，如果两个 Servlet 线程同时分别执行 login() 和 create() 两个函数，并且同时写日志到 log.txt 文件中，那就有可能存在日志信息互相覆盖的情况。【这属于并发的知识点，看不懂的可以看笔者的并发系列】\n\n\n\n那如何来解决这个问题呢？我们最先想到的就是通过加锁的方式：给 log() 函数加互斥锁，同一时刻只允许一个线程调用执行 log() 函数。\n\n```java\npublic class Logger {\n  private FileWriter writer;\n\n  public Logger() {\n    File file = new File(\"/Users/wangzheng/log.txt\");\n    writer = new FileWriter(file, true); //true表示追加写入\n  }\n  \n  public void log(String message) {\n    synchronized(this) {\n      writer.write(mesasge);\n    }\n  }\n}\n```\n\n`synchronized(this)`这种对象级别的锁，锁不住，因为不同的对象之间并不共享同一把锁。所以我们换成类级别的锁。\n\n```java\npublic class Logger {\n  private FileWriter writer;\n\n  public Logger() {\n    File file = new File(\"/Users/wangzheng/log.txt\");\n    writer = new FileWriter(file, true); //true表示追加写入\n  }\n  \n  public void log(String message) {\n    synchronized(Logger.class) { // 类级别的锁\n      writer.write(mesasge);\n    }\n  }\n}\n```\n\n除了使用类级别锁之外，实际上，解决资源竞争问题的办法还有很多，分布式锁是最常听到的一种解决方案。不过，实现一个安全可靠、无 bug、高性能的分布式锁，并不是件容易的事情。除此之外，并发队列（比如 Java 中的 BlockingQueue）也可以解决这个问题：多个线程同时往并发队列里写日志，一个单独的线程负责将并发队列中的数据，写入到日志文件。这种方式实现起来也稍微有点复杂。\n\n\n\n相对于这两种解决方案，单例模式的解决思路就简单一些了。单例模式相对于之前类级别锁的好处是，不用创建那么多 Logger 对象，一方面节省内存空间，另一方面节省系统文件句柄（对于操作系统来说，文件句柄也是一种资源，不能随便浪费）。\n\n我们将 Logger 设计成一个单例类，程序中只允许创建一个 Logger 对象，所有的线程共享使用的这一个 Logger 对象，共享一个 FileWriter 对象，而 FileWriter 本身是对象级别线程安全的，也就避免了多线程情况下写日志会互相覆盖的问题。按照这个设计思路，我们实现了 Logger 单例类。具体代码如下所示：\n\n```java\npublic class Logger {\n  private FileWriter writer;\n  private static final Logger instance = new Logger();\n\n  private Logger() {\n    File file = new File(\"/Users/wangzheng/log.txt\");\n    writer = new FileWriter(file, true); //true表示追加写入\n  }\n  \n  public static Logger getInstance() {\n    return instance;\n  }\n  \n  public void log(String message) {\n    writer.write(mesasge);\n  }\n}\n\n// Logger类的应用示例：\npublic class UserController {\n  public void login(String username, String password) {\n    // ...省略业务逻辑代码...\n    Logger.getInstance().log(username + \" logined!\");\n  }\n}\n\npublic class OrderController {  \n  public void create(OrderVo order) {\n    // ...省略业务逻辑代码...\n    Logger.getInstance().log(\"Created a order: \" + order.toString());\n  }\n}\n```\n\n\n\n### 实战案例二：表示全局唯一类\n\n从业务概念上，如果有些数据在系统中只应保存一份，那就比较适合设计为单例类。比如，配置信息类。在系统中，我们只有一个配置文件，当配置文件被加载到内存之后，以对象的形式存在，也理所应当只有一份。\n\n再比如，唯一递增 ID 号码生成器。如果程序中有两个对象，那就会存在生成重复 ID 的情况，所以，我们应该将 ID 生成器类设计为单例。\n\n```java\npublic class IdGenerator {\n  // AtomicLong是一个Java并发库中提供的一个原子变量类型,\n  // 它将一些线程不安全需要加锁的复合操作封装为了线程安全的原子操作，\n  // 比如下面会用到的incrementAndGet().\n  private AtomicLong id = new AtomicLong(0);\n  private static final IdGenerator instance = new IdGenerator();\n  private IdGenerator() {}\n  public static IdGenerator getInstance() {\n    return instance;\n  }\n  public long getId() { \n    return id.incrementAndGet();\n  }\n}\n\n// IdGenerator使用举例\nlong id = IdGenerator.getInstance().getId();\n```\n\n\n\n## 如何实现一个单例？\n\n尽管介绍如何实现一个单例模式的文章已经有很多了，但为了保证内容的完整性，我这里还是简单介绍一下几种经典实现方式。概括起来，要实现一个单例，我们需要关注的点无外乎下面几个：\n\n- 构造函数需要是 private 访问权限的，这样才能避免外部通过 new 创建实例；\n\n- 考虑对象创建时的线程安全问题；\n\n- 考虑是否支持延迟加载；\n\n- 考虑 getInstance() 性能是否高（是否加锁）。\n\n\n\n### 饿汉式(静态变量)\n\n饿汉式的实现方式比较简单。在类加载的时候，instance 静态实例就已经创建并初始化好了，所以，instance 实例的创建过程是线程安全的。不过，这样的实现方式不支持延迟加载（在真正用到 IdGenerator 的时候，再创建实例），从名字中我们也可以看出这一点。具体的代码实现如下所示：\n\n```java\npublic class IdGenerator { \n  private AtomicLong id = new AtomicLong(0);\n  private static final IdGenerator instance = new IdGenerator();\n  private IdGenerator() {}\n  public static IdGenerator getInstance() {\n    return instance;\n  }\n  public long getId() { \n    return id.incrementAndGet();\n  }\n}\n```\n\n\n\n1. 有人觉得这种实现方式不好，因为不支持延迟加载，如果实例占用资源多（比如占用内存多）或初始化耗时长（比如需要加载各种配置文件），提前初始化实例是一种浪费资源的行为。最好的方法应该在用到的时候再去初始化。不过，我个人并不认同这样的观点\n2. 如果初始化耗时长，那我们最好不要等到真正要用它的时候，才去执行这个耗时长的初始化过程，这会影响到系统的性能（比如，在响应客户端接口请求的时候，做这个初始化操作，会导致此请求的响应时间变长，甚至超时）。采用饿汉式实现方式，将耗时的初始化操作，提前到程序启动的时候完成，这样就能避免在程序运行的时候，再去初始化导致的性能问题。\n3. 如果实例占用资源多，按照 fail-fast 的设计原则（有问题及早暴露），那我们也希望在程序启动时就将这个实例初始化好。如果资源不够，就会在程序启动的时候触发报错（比如 Java 中的 PermGen Space OOM），我们可以立即去修复。这样也能避免在程序运行一段时间后，突然因为初始化这个实例占用资源过多，导致系统崩溃，影响系统的可用性。(如果初始化消耗资源过多，反而推荐懒汉式，早日发现问题)\n\n\n\n### 饿汉式(静态代码块)\n\n```java\n\npublic class SingletonTest02 {\n\n  public static void main(String[] args) {\n    // 测试\n    Singleton instance = Singleton.getInstance();\n    Singleton instance2 = Singleton.getInstance();\n    System.out.println(instance == instance2); // true\n    System.out.println(\"instance.hashCode=\" + instance.hashCode());\n    System.out.println(\"instance2.hashCode=\" + instance2.hashCode());\n  }\n}\n\n// 饿汉式(静态变量)\n\nclass Singleton {\n\n  // 1. 构造器私有化\n  private Singleton() {}\n\n  // 2.本类内部创建对象实例\n  private static Singleton instance;\n\n  static { // 在静态代码块中，创建单例对象\n    instance = new Singleton();\n  }\n\n  // 3. 提供一个公有的静态方法，返回实例对象\n  public static Singleton getInstance() {\n    return instance;\n  }\n}\n\n```\n\n没什么好说的，就是静态变量换成了静态代码块。\n\n\n\n\n\n### 懒汉式(线程安全，同步方法)\n\n懒汉式相对于饿汉式的优势是支持延迟加载。具体的代码实现如下所示：\n\n```java\npublic class IdGenerator { \n  private AtomicLong id = new AtomicLong(0);\n  private static IdGenerator instance;\n  private IdGenerator() {}\n  public static synchronized IdGenerator getInstance() {\n    if (instance == null) {\n      instance = new IdGenerator();\n    }\n    return instance;\n  }\n  public long getId() { \n    return id.incrementAndGet();\n  }\n}\n```\n\n不过懒汉式的缺点也很明显，我们给 getInstance() 这个方法加了一把大锁（synchronzed），导致这个函数的并发度很低。而这个函数是在单例使用期间，一直会被调用。如果这个单例类偶尔会被用到，那这种实现方式还可以接受。但是，如果频繁地用到，那频繁加锁、释放锁及并发度低等问题，会导致性能瓶颈，这种实现方式就不可取了。\n\n\n\n### 懒汉式(线程安全，同步代码块)\n\n```java\n// 懒汉式(线程安全，同步代码块)\nclass Singleton {\n  private static Singleton instance;\n\n  private Singleton() {}\n\n  public static Singleton getInstance() {\n    if (instance == null) {\n      synchronized (Singleton.class) {\n        instance = new Singleton();\n      }\n    }\n    return instance;\n  }\n}\n```\n\n\n\n### 懒汉式(线程不安全)\n\n\n\n```java\nclass Singleton {\n  private static Singleton instance;\n\n  private Singleton() {}\n\n  // 提供一个静态的公有方法，当使用到该方法时，才去创建 instance\n  // 即懒汉式\n  public static Singleton getInstance() {\n    if (instance == null) {\n      instance = new Singleton();\n    }\n    return instance;\n  }\n```\n\n只是为了完整性，写了出来，实际开发不推荐用线程不安全的\n\n### 双重检测\n\n饿汉式不支持延迟加载，懒汉式有性能问题，不支持高并发。那我们再来看一种既支持延迟加载、又支持高并发的单例实现方式，也就是双重检测实现方式。在这种实现方式中，只要 instance 被创建之后，即便再调用 getInstance() 函数也不会再进入到加锁逻辑中了。所以，这种实现方式解决了懒汉式并发度低的问题。具体的代码实现如下所示：\n\n```java\npublic class IdGenerator { \n  private AtomicLong id = new AtomicLong(0);\n  private static IdGenerator instance;\n  private IdGenerator() {}\n  public static IdGenerator getInstance() {\n    if (instance == null) {\n      synchronized(IdGenerator.class) { // 此处为类级别的锁\n        if (instance == null) {\n          instance = new IdGenerator();\n        }\n      }\n    }\n    return instance;\n  }\n  public long getId() { \n    return id.incrementAndGet();\n  }\n}\n```\n\n\n\n这种实现方式有些问题。因为指令重排序，可能会导致 IdGenerator 对象被 new 出来，并且赋值给 instance 之后，还没来得及初始化（执行构造函数中的代码逻辑），就被另一个线程使用了。要解决这个问题，我们需要给 instance 成员变量加上 volatile 关键字，禁止指令重排序才行。\n\n据说，只有很低版本的 Java 才会有这个问题。我们现在用的高版本的 Java 已经在 JDK 内部实现中解决了这个问题（解决的方法很简单，只要把对象 new 操作和初始化操作设计为原子操作，就自然能禁止重排序）。\n\n\n\n### 静态内部类\n\n我们再来看一种比双重检测更加简单的实现方法，那就是利用 Java 的静态内部类。它有点类似饿汉式，但又能做到了延迟加载。具体是怎么做到的呢？我们先来看它的代码实现\n\n```java\npublic class IdGenerator { \n  private AtomicLong id = new AtomicLong(0);\n  private IdGenerator() {}\n\n  private static class SingletonHolder{\n    private static final IdGenerator instance = new IdGenerator();\n  }\n  \n  public static IdGenerator getInstance() {\n    return SingletonHolder.instance;\n  }\n \n  public long getId() { \n    return id.incrementAndGet();\n  }\n}\n```\n\nSingletonHolder 是一个静态内部类，当外部类 IdGenerator 被加载的时候，并不会创建 SingletonHolder 实例对象。只有当调用 getInstance() 方法时，SingletonHolder 才会被加载，这个时候才会创建 instance。instance 的唯一性、创建过程的线程安全性，都由 JVM 来保证。所以，这种实现方法既保证了线程安全，又能做到延迟加载。\n\n\n\n### 枚举\n\n最后，我们介绍一种最简单的实现方式，基于枚举类型的单例实现。这种实现方式通过 Java 枚举类型本身的特性，保证了实例创建的线程安全性和实例的唯一性。具体的代码如下所示：\n\n```java\npublic enum IdGenerator {\n  INSTANCE;\n  private AtomicLong id = new AtomicLong(0);\n \n  public long getId() { \n    return id.incrementAndGet();\n  }\n}\n```\n\n\n\n## 单例存在哪些问题?\n\n尽管单例是一个很常用的设计模式，在实际的开发中，我们也确实经常用到它，但是，有些人认为单例是一种反模式（anti-pattern），并不推荐使用。大部分情况下，我们在项目中使用单例，都是用它来表示一些全局唯一类，比如配置信息类、连接池类、ID 生成器类。单例模式书写简洁、使用方便，在代码中，我们不需要创建对象，直接通过类似 IdGenerator.getInstance().getId() 这样的方法来调用就可以了。但是，这种使用方法有点类似硬编码（hard code），会带来诸多问题。接下来，我们就具体看看到底有哪些问题。\n\n\n\n### 单例对 OOP 特性的支持不友好\n\n我们知道，OOP 的四大特性是封装、抽象、继承、多态。单例这种设计模式对于其中的抽象、继承、多态都支持得不好。为什么这么说呢？我们还是通过 IdGenerator 这个例子来讲解。\n\n```java\npublic class Order {\n  public void create(...) {\n    //...\n    long id = IdGenerator.getInstance().getId();\n    //...\n  }\n}\n\npublic class User {\n  public void create(...) {\n    // ...\n    long id = IdGenerator.getInstance().getId();\n    //...\n  }\n}\n```\n\nIdGenerator 的使用方式违背了基于接口而非实现的设计原则，也就违背了广义上理解的 OOP 的抽象特性。如果未来某一天，我们希望针对不同的业务采用不同的 ID 生成算法。比如，订单 ID 和用户 ID 采用不同的 ID 生成器来生成。为了应对这个需求变化，我们需要修改所有用到 IdGenerator 类的地方，这样代码的改动就会比较大。\n\n```java\npublic class Order {\n  public void create(...) {\n    //...\n    long id = IdGenerator.getInstance().getId();\n    // 需要将上面一行代码，替换为下面一行代码\n    long id = OrderIdGenerator.getIntance().getId();\n    //...\n  }\n}\n\npublic class User {\n  public void create(...) {\n    // ...\n    long id = IdGenerator.getInstance().getId();\n    // 需要将上面一行代码，替换为下面一行代码\n    long id = UserIdGenerator.getIntance().getId();\n  }\n}\n```\n\n除此之外，单例对继承、多态特性的支持也不友好。这里我之所以会用“不友好”这个词，而非“完全不支持”，是因为从理论上来讲，单例类也可以被继承、也可以实现多态，只是实现起来会非常奇怪，会导致代码的可读性变差。不明白设计意图的人，看到这样的设计，会觉得莫名其妙。所以，一旦你选择将某个类设计成到单例类，也就意味着放弃了继承和多态这两个强有力的面向对象特性，也就相当于损失了可以应对未来需求变化的扩展性\n\n\n\n### 单例会隐藏类之间的依赖关系\n\n我们知道，代码的可读性非常重要。在阅读代码的时候，我们希望一眼就能看出类与类之间的依赖关系，搞清楚这个类依赖了哪些外部类。通过构造函数、参数传递等方式声明的类之间的依赖关系，我们通过查看函数的定义，就能很容易识别出来。但是，单例类不需要显示创建、不需要依赖参数传递，在函数中直接调用就可以了。如果代码比较复杂，这种调用关系就会非常隐蔽。在阅读代码的时候，我们就需要仔细查看每个函数的代码实现，才能知道这个类到底依赖了哪些单例类。\n\n\n\n\n\n### 单例对代码的扩展性不友好\n\n1. 我们知道，单例类只能有一个对象实例。如果未来某一天，我们需要在代码中创建两个实例或多个实例，那就要对代码有比较大的改动。你可能会说，会有这样的需求吗？既然单例类大部分情况下都用来表示全局类，怎么会需要两个或者多个实例呢？\n2. 实际上，这样的需求并不少见。我们拿数据库连接池来举例解释一下。\n3. 在系统设计初期，我们觉得系统中只应该有一个数据库连接池，这样能方便我们控制对数据库连接资源的消耗。所以，我们把数据库连接池类设计成了单例类。但之后我们发现，系统中有些 SQL 语句运行得非常慢。这些 SQL 语句在执行的时候，长时间占用数据库连接资源，导致其他 SQL 请求无法响应。为了解决这个问题，我们希望将慢 SQL 与其他 SQL 隔离开来执行。为了实现这样的目的，我们可以在系统中创建两个数据库连接池，慢 SQL 独享一个数据库连接池，其他 SQL 独享另外一个数据库连接池，这样就能避免慢 SQL 影响到其他 SQL 的执行。\n4. 如果我们将数据库连接池设计成单例类，显然就无法适应这样的需求变更，也就是说，单例类在某些情况下会影响代码的扩展性、灵活性。所以，数据库连接池、线程池这类的资源池，最好还是不要设计成单例类。实际上，一些开源的数据库连接池、线程池也确实没有设计成单例类。\n\n\n\n### 单例对代码的可测试性不友好\n\n1. 单例模式的使用会影响到代码的可测试性。如果单例类依赖比较重的外部资源，比如 DB，我们在写单元测试的时候，希望能通过 mock 的方式将它替换掉。而单例类这种硬编码式的使用方式，导致无法实现 mock 替换。\n\n2. 除此之外，如果单例类持有成员变量（比如 IdGenerator 中的 id 成员变量），那它实际上相当于一种全局变量，被所有的代码共享。如果这个全局变量是一个可变全局变量，也就是说，它的成员变量是可以被修改的，那我们在编写单元测试的时候，还需要注意不同测试用例之间，修改了单例类中的同一个成员变量的值，从而导致测试结果互相影响的问题。\n\n\n\n\n\n### 单例不支持有参数的构造函数\n\n单例不支持有参数的构造函数，比如我们创建一个连接池的单例对象，我们没法通过参数来指定连接池的大小。针对这个问题，我们来看下都有哪些解决方案。\n\n\n\n**第一种解决思路是**：创建完实例之后，再调用 init() 函数传递参数。需要注意的是，我们在使用这个单例类的时候，要先调用 init() 方法，然后才能调用 getInstance() 方法，否则代码会抛出异常。具体的代码实现如下所示：\n\n```java\npublic class Singleton {\n  private static Singleton instance = null;\n  private final int paramA;\n  private final int paramB;\n\n  private Singleton(int paramA, int paramB) {\n    this.paramA = paramA;\n    this.paramB = paramB;\n  }\n\n  public static Singleton getInstance() {\n    if (instance == null) {\n       throw new RuntimeException(\"Run init() first.\");\n    }\n    return instance;\n  }\n\n  public synchronized static Singleton init(int paramA, int paramB) {\n    if (instance != null){\n       throw new RuntimeException(\"Singleton has been created!\");\n    }\n    instance = new Singleton(paramA, paramB);\n    return instance;\n  }\n}\n\nSingleton.init(10, 50); // 先init，再使用\nSingleton singleton = Singleton.getInstance();\n```\n\n\n\n**第二种解决思路是**：将参数放到 getIntance() 方法中。具体的代码实现如下所示：\n\n```java\npublic class Singleton {\n  private static Singleton instance = null;\n  private final int paramA;\n  private final int paramB;\n\n  private Singleton(int paramA, int paramB) {\n    this.paramA = paramA;\n    this.paramB = paramB;\n  }\n\n  public synchronized static Singleton getInstance(int paramA, int paramB) {\n    if (instance == null) {\n      instance = new Singleton(paramA, paramB);\n    }\n    return instance;\n  }\n}\n\nSingleton singleton = Singleton.getInstance(10, 50);\n```\n\n\n\n不知道你有没有发现，上面的代码实现稍微有点问题。如果我们如下两次执行 getInstance() 方法，那获取到的 singleton1 和 signleton2 的 paramA 和 paramB 都是 10 和 50。也就是说，第二次的参数（20，30）没有起作用，而构建的过程也没有给与提示，这样就会误导用户。\n\n```java\nSingleton singleton1 = Singleton.getInstance(10, 50);\nSingleton singleton2 = Singleton.getInstance(20, 30);\n```\n\n\n\n\n\n**第三种解决思路是**：将参数放到另外一个全局变量中。具体的代码实现如下。Config 是一个存储了 paramA 和 paramB 值的全局变量。里面的值既可以像下面的代码那样通过静态常量来定义，也可以从配置文件中加载得到。**实际上，这种方式是最值得推荐的。**\n\n```java\npublic class Config {\n  public static final int PARAM_A = 123;\n  public static final int PARAM_B = 245;\n}\n\npublic class Singleton {\n  private static Singleton instance = null;\n  private final int paramA;\n  private final int paramB;\n\n  private Singleton() {\n    this.paramA = Config.PARAM_A;\n    this.paramB = Config.PARAM_B;\n  }\n\n  public synchronized static Singleton getInstance() {\n    if (instance == null) {\n      instance = new Singleton();\n    }\n    return instance;\n  }\n}\n```\n\n\n\n## 有何替代解决方案？\n\n刚刚我们提到了单例的很多问题，你可能会说，即便单例有这么多问题，但我不用不行啊。我业务上有表示全局唯一类的需求，如果不用单例，我怎么才能保证这个类的对象全局唯一呢？为了保证全局唯一，除了使用单例，我们还可以用静态方法来实现。这也是项目开发中经常用到的一种实现思路。比如， ID 唯一递增生成器的例子，用静态方法实现一下，就是下面这个样子：\n\n```java\n// 静态方法实现方式\npublic class IdGenerator {\n  private static AtomicLong id = new AtomicLong(0);\n  \n  public static long getId() { \n    return id.incrementAndGet();\n  }\n}\n// 使用举例\nlong id = IdGenerator.getId();\n```\n\n不过，静态方法这种实现思路，并不能解决我们之前提到的问题。实际上，它比单例更加不灵活，比如，它无法支持延迟加载。我们再来看看有没有其他办法。实际上，单例除了我们之前讲到的使用方法之外，还有另外一种使用方法。具体的代码如下所示：\n\n```java\n// 1. 老的使用方式\npublic demofunction() {\n  //...\n  long id = IdGenerator.getInstance().getId();\n  //...\n}\n\n// 2. 新的使用方式：依赖注入\npublic demofunction(IdGenerator idGenerator) {\n  long id = idGenerator.getId();\n}\n// 外部调用demofunction()的时候，传入idGenerator\nIdGenerator idGenerator = IdGenerator.getInsance();\ndemofunction(idGenerator);\n```\n\n\n\n1. 基于新的使用方式，我们将单例生成的对象，作为参数传递给函数（也可以通过构造函数传递给类的成员变量），可以解决单例隐藏类之间依赖关系的问题。不过，对于单例存在的其他问题，比如对 OOP 特性、扩展性、可测性不友好等问题，还是无法解决。\n2. 所以，如果要完全解决这些问题，我们可能要从根上，寻找其他方式来实现全局唯一类。实际上，类对象的全局唯一性可以通过多种不同的方式来保证。我们既可以通过单例模式来强制保证，也可以通过工厂模式、IOC 容器（比如 Spring IOC 容器）来保证，还可以通过程序员自己来保证（自己在编写代码的时候自己保证不要创建两个类对象）。这就类似 Java 中内存对象的释放由 JVM 来负责，而 C++ 中由程序员自己负责，道理是一样的。\n3. 对于替代方案工厂模式、IOC 容器的详细讲解，我们放到后面讲解。\n\n\n\n## 如何理解单例模式中的唯一性？\n\n1. 首先，我们重新看一下单例的定义：“一个类只允许创建唯一一个对象（或者实例），那这个类就是一个单例类，这种设计模式就叫作单例设计模式，简称单例模式。\n2. ”定义中提到，“一个类只允许创建唯一一个对象”。那对象的唯一性的作用范围是什么呢？是指线程内只允许创建一个对象，还是指进程内只允许创建一个对象？答案是后者，也就是说，单例模式创建的对象是进程唯一的。这里有点不好理解，我来详细地解释一下。\n3. 我们编写的代码，通过编译、链接，组织在一起，就构成了一个操作系统可以执行的文件，也就是我们平时所说的“可执行文件”（比如 Windows 下的 exe 文件）。可执行文件实际上就是代码被翻译成操作系统可理解的一组指令，你完全可以简单地理解为就是代码本身。\n4. 当我们使用命令行或者双击运行这个可执行文件的时候，操作系统会启动一个进程，将这个执行文件从磁盘加载到自己的进程地址空间（可以理解操作系统为进程分配的内存存储区，用来存储代码和数据）。接着，进程就一条一条地执行可执行文件中包含的代码。比如，当进程读到代码中的 User user = new User(); 这条语句的时候，它就在自己的地址空间中创建一个 user 临时变量和一个 User 对象。进程之间是不共享地址空间的，如果我们在一个进程中创建另外一个进程（比如，代码中有一个 fork() 语句，进程执行到这条语句的时候会创建一个新的进程），操作系统会给新进程分配新的地址空间，并且将老进程地址空间的所有内容，重新拷贝一份到新进程的地址空间中，这些内容包括代码、数据（比如 user 临时变量、User 对象）。\n5. 所以，单例类在老进程中存在且只能存在一个对象，在新进程中也会存在且只能存在一个对象。而且，这两个对象并不是同一个对象，这也就说，单例类中对象的唯一性的作用范围是进程内的，在进程间是不唯一的。\n\n\n\n## 如何实现线程唯一的单例？\n\n1. 刚刚我们讲了单例类对象是进程唯一的，一个进程只能有一个单例对象。那如何实现一个线程唯一的单例呢？\n\n2. 我们先来看一下，什么是线程唯一的单例，以及“线程唯一”和“进程唯一”的区别。\n\n3. “进程唯一”指的是进程内唯一，进程间不唯一。类比一下，“线程唯一”指的是线程内唯一，线程间可以不唯一。实际上，“进程唯一”还代表了线程内、线程间都唯一，这也是“进程唯一”和“线程唯一”的区别之处。这段话听起来有点像绕口令，我举个例子来解释一下。\n\n4. 假设 IdGenerator 是一个线程唯一的单例类。在线程 A 内，我们可以创建一个单例对象 a。因为线程内唯一，在线程 A 内就不能再创建新的 IdGenerator 对象了，而线程间可以不唯一，所以，在另外一个线程 B 内，我们还可以重新创建一个新的单例对象 b。\n\n5. 尽管概念理解起来比较复杂，但线程唯一单例的代码实现很简单，如下所示。在代码中，我们通过一个 HashMap 来存储对象，其中 key 是线程 ID，value 是对象。这样我们就可以做到，不同的线程对应不同的对象，同一个线程只能对应一个对象。实际上，Java 语言本身提供了 ThreadLocal 工具类，可以更加轻松地实现线程唯一单例。不过，ThreadLocal 底层实现原理也是基于下面代码中所示的 HashMap。\n\n   \n\n```java\npublic class IdGenerator {\n  private AtomicLong id = new AtomicLong(0);\n\n  private static final ConcurrentHashMap<Long, IdGenerator> instances\n          = new ConcurrentHashMap<>();\n\n  private IdGenerator() {}\n\n  public static IdGenerator getInstance() {\n    Long currentThreadId = Thread.currentThread().getId();\n    instances.putIfAbsent(currentThreadId, new IdGenerator());\n    return instances.get(currentThreadId);\n  }\n\n  public long getId() {\n    return id.incrementAndGet();\n  }\n}\n```\n\n\n\n\n\n## 如何实现集群环境下的单例？\n\n1. 刚刚我们讲了“进程唯一”的单例和“线程唯一”的单例，现在，我们再来看下，“集群唯一”的单例。\n2. 首先，我们还是先来解释一下，什么是“集群唯一”的单例。\n3. 我们还是将它跟“进程唯一”“线程唯一”做个对比。“进程唯一”指的是进程内唯一、进程间不唯一。“线程唯一”指的是线程内唯一、线程间不唯一。集群相当于多个进程构成的一个集合，“集群唯一”就相当于是进程内唯一、进程间也唯一。也就是说，不同的进程间共享同一个对象，不能创建同一个类的多个对象。\n4. 我们知道，经典的单例模式是进程内唯一的，那如何实现一个进程间也唯一的单例呢？如果严格按照不同的进程间共享同一个对象来实现，那集群唯一的单例实现起来就有点难度了。\n5. 具体来说，我们需要把这个单例对象序列化并存储到外部共享存储区（比如文件）。进程在使用这个单例对象的时候，需要先从外部共享存储区中将它读取到内存，并反序列化成对象，然后再使用，使用完成之后还需要再存储回外部共享存储区。\n6. 为了保证任何时刻，在进程间都只有一份对象存在，一个进程在获取到对象之后，需要对对象加锁，避免其他进程再将其获取。在进程使用完这个对象之后，还需要显式地将对象从内存中删除，并且释放对对象的加锁。按照这个思路，\n7. 我用伪代码实现了一下这个过程，具体如下所示：\n\n```java\npublic class IdGenerator {\n  private AtomicLong id = new AtomicLong(0);\n  private static IdGenerator instance;\n  private static SharedObjectStorage storage = FileSharedObjectStorage(/*入参省略，比如文件地址*/);\n  private static DistributedLock lock = new DistributedLock();\n  \n  private IdGenerator() {}\n\n  public synchronized static IdGenerator getInstance() \n    if (instance == null) {\n      lock.lock();\n      instance = storage.load(IdGenerator.class);\n    }\n    return instance;\n  }\n  \n  public synchroinzed void freeInstance() {\n    storage.save(this, IdGeneator.class);\n    instance = null; //释放对象\n    lock.unlock();\n  }\n  \n  public long getId() { \n    return id.incrementAndGet();\n  }\n}\n\n// IdGenerator使用举例\nIdGenerator idGeneator = IdGenerator.getInstance();\nlong id = idGenerator.getId();\nIdGenerator.freeInstance();\n```\n\n\n\n## 如何实现一个多例模式？\n\n跟单例模式概念相对应的还有一个多例模式。那如何实现一个多例模式呢？“单例”指的是，一个类只能创建一个对象。对应地，“多例”指的就是，一个类可以创建多个对象，但是个数是有限制的，比如只能创建 3 个对象。如果用代码来简单示例一下的话，就是下面这个样子：\n\n```java\npublic class BackendServer {\n  private long serverNo;\n  private String serverAddress;\n\n  private static final int SERVER_COUNT = 3;\n  private static final Map<Long, BackendServer> serverInstances = new HashMap<>();\n\n  static {\n    serverInstances.put(1L, new BackendServer(1L, \"192.134.22.138:8080\"));\n    serverInstances.put(2L, new BackendServer(2L, \"192.134.22.139:8080\"));\n    serverInstances.put(3L, new BackendServer(3L, \"192.134.22.140:8080\"));\n  }\n\n  private BackendServer(long serverNo, String serverAddress) {\n    this.serverNo = serverNo;\n    this.serverAddress = serverAddress;\n  }\n\n  public BackendServer getInstance(long serverNo) {\n    return serverInstances.get(serverNo);\n  }\n\n  public BackendServer getRandomInstance() {\n    Random r = new Random();\n    int no = r.nextInt(SERVER_COUNT)+1;\n    return serverInstances.get(no);\n  }\n}\n```\n\n\n\n实际上，对于多例模式，还有一种理解方式：同一类型的只能创建一个对象，不同类型的可以创建多个对象。这里的“类型”如何理解呢？我们还是通过一个例子来解释一下，具体代码如下所示。在代码中，logger name 就是刚刚说的“类型”，同一个 logger name 获取到的对象实例是相同的，不同的 logger name 获取到的对象实例是不同的。\n\n```java\npublic class Logger {\n  private static final ConcurrentHashMap<String, Logger> instances\n          = new ConcurrentHashMap<>();\n\n  private Logger() {}\n\n  public static Logger getInstance(String loggerName) {\n    instances.putIfAbsent(loggerName, new Logger());\n    return instances.get(loggerName);\n  }\n\n  public void log() {\n    //...\n  }\n}\n\n//l1==l2, l1!=l3\nLogger l1 = Logger.getInstance(\"User.class\");\nLogger l2 = Logger.getInstance(\"User.class\");\nLogger l3 = Logger.getInstance(\"Order.class\");\n```\n\n\n\n这种多例模式的理解方式有点类似工厂模式。它跟工厂模式的不同之处是，多例模式创建的对象都是同一个类的对象，而工厂模式创建的是不同子类的对象，关于这一点，后面就会讲到。实际上，它还有点类似享元模式，两者的区别等到我们讲到享元模式的时候再来分析。除此之外，实际上，枚举类型也相当于多例模式，一个类型只能对应一个对象，一个类可以创建多个对象。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/2024-05-11-设计模式-03.01-创建型-单例.md","raw":"---\ntitle: 设计模式-03.01-创建型-单例\ntags:\n  - 设计模式\n  - 单例\ncategories:\n  - 设计模式\n  - 03.创建型\nkeywords: 设计模式，单例\ndescription: 详解了单例设计模式。\ncover: 'https://npm.elemecdn.com/lql_static@latest/logo/design_patterns.jpg'\nabbrlink: b5a1ed4a\ndate: 2024-05-11 21:51:58\n---\n\n# 声明\n\n> 1. 此系列文章非本人原创，是学习笔记。\n> 2. 设计模式系列以后会持续更新，包括已经发布的设计模式文章，因为后续还要再多看一下书，教程和开源项目等，继续润色文章。\n\n\n# 前言\n\n23 种经典的设计模式。它们又可以分为三大类：创建型、结构型、行为型。对于这 23 种设计模式的学习，我们要有侧重点，因为有些模式是比较常用的，有些模式是很少被用到的。对于常用的设计模式，我们要花多点时间理解掌握。对于不常用的设计模式，我们只需要稍微了解即可。按照类型和是否常用，对这些设计模式，进行了简单的分类，具体如下所示。\n\n### 创建型\n\n常用的有：单例模式、工厂模式（工厂方法和抽象工厂）、建造者模式。\n\n不常用的有：原型模式。\n\n\n\n### 结构型\n\n常用的有：代理模式、桥接模式、装饰者模式、适配器模式。\n\n不常用的有：门面模式、组合模式、享元模式。 \n\n\n\n### 行为型\n\n常用的有：观察者模式、模板模式、策略模式、职责链模式、迭代器模式、状态模式。\n\n不常用的有：访问者模式、备忘录模式、命令模式、解释器模式、中介模式。\n\n\n\n\n\n# 单例模式【常用】\n\n网上有很多讲解单例模式的文章，但大部分都侧重讲解，如何来实现一个线程安全的单例。今天也会讲到各种单例的实现方法，但是，重点还是希望带你搞清楚下面这样几个问题。\n\n- 为什么要使用单例？\n- 单例存在哪些问题？\n- 单例与静态类的区别？\n- 有何替代的解决方案？\n\n\n\n## 为什么要使用单例？\n\n单例设计模式（Singleton Design Pattern）理解起来非常简单。一个类只允许创建一个对象（或者实例），那这个类就是一个单例类，这种设计模式就叫作单例设计模式，简称单例模式。\n\n对于单例的概念，我觉得没必要解释太多，你一看就能明白。我们重点看一下，为什么我们需要单例这种设计模式？它能解决哪些问题？接下来我通过两个实战案例来讲解。\n\n\n\n### 实战案例一：处理资源访问冲突\n\n我们先来看第一个例子。在这个例子中，我们自定义实现了一个往文件中打印日志的 Logger 类。具体的代码实现如下所示：\n\n```java\npublic class Logger {\n  private FileWriter writer;\n  \n  public Logger() {\n    File file = new File(\"/Users/wangzheng/log.txt\");\n    writer = new FileWriter(file, true); //true表示追加写入\n  }\n  \n  public void log(String message) {\n    writer.write(message);\n  }\n}\n\n// Logger类的应用示例：\npublic class UserController {\n  private Logger logger = new Logger();\n  \n  public void login(String username, String password) {\n    // ...省略业务逻辑代码...\n    logger.log(username + \" logined!\");\n  }\n}\n\npublic class OrderController {\n  private Logger logger = new Logger();\n  \n  public void create(OrderVo order) {\n    // ...省略业务逻辑代码...\n    logger.log(\"Created an order: \" + order.toString());\n  }\n}\n```\n\n在上面的代码中，我们注意到，所有的日志都写入到同一个文件 /Users/wangzheng/log.txt 中。在 UserController 和 OrderController 中，我们分别创建两个 Logger 对象。在 Web 容器的 Servlet 多线程环境下，如果两个 Servlet 线程同时分别执行 login() 和 create() 两个函数，并且同时写日志到 log.txt 文件中，那就有可能存在日志信息互相覆盖的情况。【这属于并发的知识点，看不懂的可以看笔者的并发系列】\n\n\n\n那如何来解决这个问题呢？我们最先想到的就是通过加锁的方式：给 log() 函数加互斥锁，同一时刻只允许一个线程调用执行 log() 函数。\n\n```java\npublic class Logger {\n  private FileWriter writer;\n\n  public Logger() {\n    File file = new File(\"/Users/wangzheng/log.txt\");\n    writer = new FileWriter(file, true); //true表示追加写入\n  }\n  \n  public void log(String message) {\n    synchronized(this) {\n      writer.write(mesasge);\n    }\n  }\n}\n```\n\n`synchronized(this)`这种对象级别的锁，锁不住，因为不同的对象之间并不共享同一把锁。所以我们换成类级别的锁。\n\n```java\npublic class Logger {\n  private FileWriter writer;\n\n  public Logger() {\n    File file = new File(\"/Users/wangzheng/log.txt\");\n    writer = new FileWriter(file, true); //true表示追加写入\n  }\n  \n  public void log(String message) {\n    synchronized(Logger.class) { // 类级别的锁\n      writer.write(mesasge);\n    }\n  }\n}\n```\n\n除了使用类级别锁之外，实际上，解决资源竞争问题的办法还有很多，分布式锁是最常听到的一种解决方案。不过，实现一个安全可靠、无 bug、高性能的分布式锁，并不是件容易的事情。除此之外，并发队列（比如 Java 中的 BlockingQueue）也可以解决这个问题：多个线程同时往并发队列里写日志，一个单独的线程负责将并发队列中的数据，写入到日志文件。这种方式实现起来也稍微有点复杂。\n\n\n\n相对于这两种解决方案，单例模式的解决思路就简单一些了。单例模式相对于之前类级别锁的好处是，不用创建那么多 Logger 对象，一方面节省内存空间，另一方面节省系统文件句柄（对于操作系统来说，文件句柄也是一种资源，不能随便浪费）。\n\n我们将 Logger 设计成一个单例类，程序中只允许创建一个 Logger 对象，所有的线程共享使用的这一个 Logger 对象，共享一个 FileWriter 对象，而 FileWriter 本身是对象级别线程安全的，也就避免了多线程情况下写日志会互相覆盖的问题。按照这个设计思路，我们实现了 Logger 单例类。具体代码如下所示：\n\n```java\npublic class Logger {\n  private FileWriter writer;\n  private static final Logger instance = new Logger();\n\n  private Logger() {\n    File file = new File(\"/Users/wangzheng/log.txt\");\n    writer = new FileWriter(file, true); //true表示追加写入\n  }\n  \n  public static Logger getInstance() {\n    return instance;\n  }\n  \n  public void log(String message) {\n    writer.write(mesasge);\n  }\n}\n\n// Logger类的应用示例：\npublic class UserController {\n  public void login(String username, String password) {\n    // ...省略业务逻辑代码...\n    Logger.getInstance().log(username + \" logined!\");\n  }\n}\n\npublic class OrderController {  \n  public void create(OrderVo order) {\n    // ...省略业务逻辑代码...\n    Logger.getInstance().log(\"Created a order: \" + order.toString());\n  }\n}\n```\n\n\n\n### 实战案例二：表示全局唯一类\n\n从业务概念上，如果有些数据在系统中只应保存一份，那就比较适合设计为单例类。比如，配置信息类。在系统中，我们只有一个配置文件，当配置文件被加载到内存之后，以对象的形式存在，也理所应当只有一份。\n\n再比如，唯一递增 ID 号码生成器。如果程序中有两个对象，那就会存在生成重复 ID 的情况，所以，我们应该将 ID 生成器类设计为单例。\n\n```java\npublic class IdGenerator {\n  // AtomicLong是一个Java并发库中提供的一个原子变量类型,\n  // 它将一些线程不安全需要加锁的复合操作封装为了线程安全的原子操作，\n  // 比如下面会用到的incrementAndGet().\n  private AtomicLong id = new AtomicLong(0);\n  private static final IdGenerator instance = new IdGenerator();\n  private IdGenerator() {}\n  public static IdGenerator getInstance() {\n    return instance;\n  }\n  public long getId() { \n    return id.incrementAndGet();\n  }\n}\n\n// IdGenerator使用举例\nlong id = IdGenerator.getInstance().getId();\n```\n\n\n\n## 如何实现一个单例？\n\n尽管介绍如何实现一个单例模式的文章已经有很多了，但为了保证内容的完整性，我这里还是简单介绍一下几种经典实现方式。概括起来，要实现一个单例，我们需要关注的点无外乎下面几个：\n\n- 构造函数需要是 private 访问权限的，这样才能避免外部通过 new 创建实例；\n\n- 考虑对象创建时的线程安全问题；\n\n- 考虑是否支持延迟加载；\n\n- 考虑 getInstance() 性能是否高（是否加锁）。\n\n\n\n### 饿汉式(静态变量)\n\n饿汉式的实现方式比较简单。在类加载的时候，instance 静态实例就已经创建并初始化好了，所以，instance 实例的创建过程是线程安全的。不过，这样的实现方式不支持延迟加载（在真正用到 IdGenerator 的时候，再创建实例），从名字中我们也可以看出这一点。具体的代码实现如下所示：\n\n```java\npublic class IdGenerator { \n  private AtomicLong id = new AtomicLong(0);\n  private static final IdGenerator instance = new IdGenerator();\n  private IdGenerator() {}\n  public static IdGenerator getInstance() {\n    return instance;\n  }\n  public long getId() { \n    return id.incrementAndGet();\n  }\n}\n```\n\n\n\n1. 有人觉得这种实现方式不好，因为不支持延迟加载，如果实例占用资源多（比如占用内存多）或初始化耗时长（比如需要加载各种配置文件），提前初始化实例是一种浪费资源的行为。最好的方法应该在用到的时候再去初始化。不过，我个人并不认同这样的观点\n2. 如果初始化耗时长，那我们最好不要等到真正要用它的时候，才去执行这个耗时长的初始化过程，这会影响到系统的性能（比如，在响应客户端接口请求的时候，做这个初始化操作，会导致此请求的响应时间变长，甚至超时）。采用饿汉式实现方式，将耗时的初始化操作，提前到程序启动的时候完成，这样就能避免在程序运行的时候，再去初始化导致的性能问题。\n3. 如果实例占用资源多，按照 fail-fast 的设计原则（有问题及早暴露），那我们也希望在程序启动时就将这个实例初始化好。如果资源不够，就会在程序启动的时候触发报错（比如 Java 中的 PermGen Space OOM），我们可以立即去修复。这样也能避免在程序运行一段时间后，突然因为初始化这个实例占用资源过多，导致系统崩溃，影响系统的可用性。(如果初始化消耗资源过多，反而推荐懒汉式，早日发现问题)\n\n\n\n### 饿汉式(静态代码块)\n\n```java\n\npublic class SingletonTest02 {\n\n  public static void main(String[] args) {\n    // 测试\n    Singleton instance = Singleton.getInstance();\n    Singleton instance2 = Singleton.getInstance();\n    System.out.println(instance == instance2); // true\n    System.out.println(\"instance.hashCode=\" + instance.hashCode());\n    System.out.println(\"instance2.hashCode=\" + instance2.hashCode());\n  }\n}\n\n// 饿汉式(静态变量)\n\nclass Singleton {\n\n  // 1. 构造器私有化\n  private Singleton() {}\n\n  // 2.本类内部创建对象实例\n  private static Singleton instance;\n\n  static { // 在静态代码块中，创建单例对象\n    instance = new Singleton();\n  }\n\n  // 3. 提供一个公有的静态方法，返回实例对象\n  public static Singleton getInstance() {\n    return instance;\n  }\n}\n\n```\n\n没什么好说的，就是静态变量换成了静态代码块。\n\n\n\n\n\n### 懒汉式(线程安全，同步方法)\n\n懒汉式相对于饿汉式的优势是支持延迟加载。具体的代码实现如下所示：\n\n```java\npublic class IdGenerator { \n  private AtomicLong id = new AtomicLong(0);\n  private static IdGenerator instance;\n  private IdGenerator() {}\n  public static synchronized IdGenerator getInstance() {\n    if (instance == null) {\n      instance = new IdGenerator();\n    }\n    return instance;\n  }\n  public long getId() { \n    return id.incrementAndGet();\n  }\n}\n```\n\n不过懒汉式的缺点也很明显，我们给 getInstance() 这个方法加了一把大锁（synchronzed），导致这个函数的并发度很低。而这个函数是在单例使用期间，一直会被调用。如果这个单例类偶尔会被用到，那这种实现方式还可以接受。但是，如果频繁地用到，那频繁加锁、释放锁及并发度低等问题，会导致性能瓶颈，这种实现方式就不可取了。\n\n\n\n### 懒汉式(线程安全，同步代码块)\n\n```java\n// 懒汉式(线程安全，同步代码块)\nclass Singleton {\n  private static Singleton instance;\n\n  private Singleton() {}\n\n  public static Singleton getInstance() {\n    if (instance == null) {\n      synchronized (Singleton.class) {\n        instance = new Singleton();\n      }\n    }\n    return instance;\n  }\n}\n```\n\n\n\n### 懒汉式(线程不安全)\n\n\n\n```java\nclass Singleton {\n  private static Singleton instance;\n\n  private Singleton() {}\n\n  // 提供一个静态的公有方法，当使用到该方法时，才去创建 instance\n  // 即懒汉式\n  public static Singleton getInstance() {\n    if (instance == null) {\n      instance = new Singleton();\n    }\n    return instance;\n  }\n```\n\n只是为了完整性，写了出来，实际开发不推荐用线程不安全的\n\n### 双重检测\n\n饿汉式不支持延迟加载，懒汉式有性能问题，不支持高并发。那我们再来看一种既支持延迟加载、又支持高并发的单例实现方式，也就是双重检测实现方式。在这种实现方式中，只要 instance 被创建之后，即便再调用 getInstance() 函数也不会再进入到加锁逻辑中了。所以，这种实现方式解决了懒汉式并发度低的问题。具体的代码实现如下所示：\n\n```java\npublic class IdGenerator { \n  private AtomicLong id = new AtomicLong(0);\n  private static IdGenerator instance;\n  private IdGenerator() {}\n  public static IdGenerator getInstance() {\n    if (instance == null) {\n      synchronized(IdGenerator.class) { // 此处为类级别的锁\n        if (instance == null) {\n          instance = new IdGenerator();\n        }\n      }\n    }\n    return instance;\n  }\n  public long getId() { \n    return id.incrementAndGet();\n  }\n}\n```\n\n\n\n这种实现方式有些问题。因为指令重排序，可能会导致 IdGenerator 对象被 new 出来，并且赋值给 instance 之后，还没来得及初始化（执行构造函数中的代码逻辑），就被另一个线程使用了。要解决这个问题，我们需要给 instance 成员变量加上 volatile 关键字，禁止指令重排序才行。\n\n据说，只有很低版本的 Java 才会有这个问题。我们现在用的高版本的 Java 已经在 JDK 内部实现中解决了这个问题（解决的方法很简单，只要把对象 new 操作和初始化操作设计为原子操作，就自然能禁止重排序）。\n\n\n\n### 静态内部类\n\n我们再来看一种比双重检测更加简单的实现方法，那就是利用 Java 的静态内部类。它有点类似饿汉式，但又能做到了延迟加载。具体是怎么做到的呢？我们先来看它的代码实现\n\n```java\npublic class IdGenerator { \n  private AtomicLong id = new AtomicLong(0);\n  private IdGenerator() {}\n\n  private static class SingletonHolder{\n    private static final IdGenerator instance = new IdGenerator();\n  }\n  \n  public static IdGenerator getInstance() {\n    return SingletonHolder.instance;\n  }\n \n  public long getId() { \n    return id.incrementAndGet();\n  }\n}\n```\n\nSingletonHolder 是一个静态内部类，当外部类 IdGenerator 被加载的时候，并不会创建 SingletonHolder 实例对象。只有当调用 getInstance() 方法时，SingletonHolder 才会被加载，这个时候才会创建 instance。instance 的唯一性、创建过程的线程安全性，都由 JVM 来保证。所以，这种实现方法既保证了线程安全，又能做到延迟加载。\n\n\n\n### 枚举\n\n最后，我们介绍一种最简单的实现方式，基于枚举类型的单例实现。这种实现方式通过 Java 枚举类型本身的特性，保证了实例创建的线程安全性和实例的唯一性。具体的代码如下所示：\n\n```java\npublic enum IdGenerator {\n  INSTANCE;\n  private AtomicLong id = new AtomicLong(0);\n \n  public long getId() { \n    return id.incrementAndGet();\n  }\n}\n```\n\n\n\n## 单例存在哪些问题?\n\n尽管单例是一个很常用的设计模式，在实际的开发中，我们也确实经常用到它，但是，有些人认为单例是一种反模式（anti-pattern），并不推荐使用。大部分情况下，我们在项目中使用单例，都是用它来表示一些全局唯一类，比如配置信息类、连接池类、ID 生成器类。单例模式书写简洁、使用方便，在代码中，我们不需要创建对象，直接通过类似 IdGenerator.getInstance().getId() 这样的方法来调用就可以了。但是，这种使用方法有点类似硬编码（hard code），会带来诸多问题。接下来，我们就具体看看到底有哪些问题。\n\n\n\n### 单例对 OOP 特性的支持不友好\n\n我们知道，OOP 的四大特性是封装、抽象、继承、多态。单例这种设计模式对于其中的抽象、继承、多态都支持得不好。为什么这么说呢？我们还是通过 IdGenerator 这个例子来讲解。\n\n```java\npublic class Order {\n  public void create(...) {\n    //...\n    long id = IdGenerator.getInstance().getId();\n    //...\n  }\n}\n\npublic class User {\n  public void create(...) {\n    // ...\n    long id = IdGenerator.getInstance().getId();\n    //...\n  }\n}\n```\n\nIdGenerator 的使用方式违背了基于接口而非实现的设计原则，也就违背了广义上理解的 OOP 的抽象特性。如果未来某一天，我们希望针对不同的业务采用不同的 ID 生成算法。比如，订单 ID 和用户 ID 采用不同的 ID 生成器来生成。为了应对这个需求变化，我们需要修改所有用到 IdGenerator 类的地方，这样代码的改动就会比较大。\n\n```java\npublic class Order {\n  public void create(...) {\n    //...\n    long id = IdGenerator.getInstance().getId();\n    // 需要将上面一行代码，替换为下面一行代码\n    long id = OrderIdGenerator.getIntance().getId();\n    //...\n  }\n}\n\npublic class User {\n  public void create(...) {\n    // ...\n    long id = IdGenerator.getInstance().getId();\n    // 需要将上面一行代码，替换为下面一行代码\n    long id = UserIdGenerator.getIntance().getId();\n  }\n}\n```\n\n除此之外，单例对继承、多态特性的支持也不友好。这里我之所以会用“不友好”这个词，而非“完全不支持”，是因为从理论上来讲，单例类也可以被继承、也可以实现多态，只是实现起来会非常奇怪，会导致代码的可读性变差。不明白设计意图的人，看到这样的设计，会觉得莫名其妙。所以，一旦你选择将某个类设计成到单例类，也就意味着放弃了继承和多态这两个强有力的面向对象特性，也就相当于损失了可以应对未来需求变化的扩展性\n\n\n\n### 单例会隐藏类之间的依赖关系\n\n我们知道，代码的可读性非常重要。在阅读代码的时候，我们希望一眼就能看出类与类之间的依赖关系，搞清楚这个类依赖了哪些外部类。通过构造函数、参数传递等方式声明的类之间的依赖关系，我们通过查看函数的定义，就能很容易识别出来。但是，单例类不需要显示创建、不需要依赖参数传递，在函数中直接调用就可以了。如果代码比较复杂，这种调用关系就会非常隐蔽。在阅读代码的时候，我们就需要仔细查看每个函数的代码实现，才能知道这个类到底依赖了哪些单例类。\n\n\n\n\n\n### 单例对代码的扩展性不友好\n\n1. 我们知道，单例类只能有一个对象实例。如果未来某一天，我们需要在代码中创建两个实例或多个实例，那就要对代码有比较大的改动。你可能会说，会有这样的需求吗？既然单例类大部分情况下都用来表示全局类，怎么会需要两个或者多个实例呢？\n2. 实际上，这样的需求并不少见。我们拿数据库连接池来举例解释一下。\n3. 在系统设计初期，我们觉得系统中只应该有一个数据库连接池，这样能方便我们控制对数据库连接资源的消耗。所以，我们把数据库连接池类设计成了单例类。但之后我们发现，系统中有些 SQL 语句运行得非常慢。这些 SQL 语句在执行的时候，长时间占用数据库连接资源，导致其他 SQL 请求无法响应。为了解决这个问题，我们希望将慢 SQL 与其他 SQL 隔离开来执行。为了实现这样的目的，我们可以在系统中创建两个数据库连接池，慢 SQL 独享一个数据库连接池，其他 SQL 独享另外一个数据库连接池，这样就能避免慢 SQL 影响到其他 SQL 的执行。\n4. 如果我们将数据库连接池设计成单例类，显然就无法适应这样的需求变更，也就是说，单例类在某些情况下会影响代码的扩展性、灵活性。所以，数据库连接池、线程池这类的资源池，最好还是不要设计成单例类。实际上，一些开源的数据库连接池、线程池也确实没有设计成单例类。\n\n\n\n### 单例对代码的可测试性不友好\n\n1. 单例模式的使用会影响到代码的可测试性。如果单例类依赖比较重的外部资源，比如 DB，我们在写单元测试的时候，希望能通过 mock 的方式将它替换掉。而单例类这种硬编码式的使用方式，导致无法实现 mock 替换。\n\n2. 除此之外，如果单例类持有成员变量（比如 IdGenerator 中的 id 成员变量），那它实际上相当于一种全局变量，被所有的代码共享。如果这个全局变量是一个可变全局变量，也就是说，它的成员变量是可以被修改的，那我们在编写单元测试的时候，还需要注意不同测试用例之间，修改了单例类中的同一个成员变量的值，从而导致测试结果互相影响的问题。\n\n\n\n\n\n### 单例不支持有参数的构造函数\n\n单例不支持有参数的构造函数，比如我们创建一个连接池的单例对象，我们没法通过参数来指定连接池的大小。针对这个问题，我们来看下都有哪些解决方案。\n\n\n\n**第一种解决思路是**：创建完实例之后，再调用 init() 函数传递参数。需要注意的是，我们在使用这个单例类的时候，要先调用 init() 方法，然后才能调用 getInstance() 方法，否则代码会抛出异常。具体的代码实现如下所示：\n\n```java\npublic class Singleton {\n  private static Singleton instance = null;\n  private final int paramA;\n  private final int paramB;\n\n  private Singleton(int paramA, int paramB) {\n    this.paramA = paramA;\n    this.paramB = paramB;\n  }\n\n  public static Singleton getInstance() {\n    if (instance == null) {\n       throw new RuntimeException(\"Run init() first.\");\n    }\n    return instance;\n  }\n\n  public synchronized static Singleton init(int paramA, int paramB) {\n    if (instance != null){\n       throw new RuntimeException(\"Singleton has been created!\");\n    }\n    instance = new Singleton(paramA, paramB);\n    return instance;\n  }\n}\n\nSingleton.init(10, 50); // 先init，再使用\nSingleton singleton = Singleton.getInstance();\n```\n\n\n\n**第二种解决思路是**：将参数放到 getIntance() 方法中。具体的代码实现如下所示：\n\n```java\npublic class Singleton {\n  private static Singleton instance = null;\n  private final int paramA;\n  private final int paramB;\n\n  private Singleton(int paramA, int paramB) {\n    this.paramA = paramA;\n    this.paramB = paramB;\n  }\n\n  public synchronized static Singleton getInstance(int paramA, int paramB) {\n    if (instance == null) {\n      instance = new Singleton(paramA, paramB);\n    }\n    return instance;\n  }\n}\n\nSingleton singleton = Singleton.getInstance(10, 50);\n```\n\n\n\n不知道你有没有发现，上面的代码实现稍微有点问题。如果我们如下两次执行 getInstance() 方法，那获取到的 singleton1 和 signleton2 的 paramA 和 paramB 都是 10 和 50。也就是说，第二次的参数（20，30）没有起作用，而构建的过程也没有给与提示，这样就会误导用户。\n\n```java\nSingleton singleton1 = Singleton.getInstance(10, 50);\nSingleton singleton2 = Singleton.getInstance(20, 30);\n```\n\n\n\n\n\n**第三种解决思路是**：将参数放到另外一个全局变量中。具体的代码实现如下。Config 是一个存储了 paramA 和 paramB 值的全局变量。里面的值既可以像下面的代码那样通过静态常量来定义，也可以从配置文件中加载得到。**实际上，这种方式是最值得推荐的。**\n\n```java\npublic class Config {\n  public static final int PARAM_A = 123;\n  public static final int PARAM_B = 245;\n}\n\npublic class Singleton {\n  private static Singleton instance = null;\n  private final int paramA;\n  private final int paramB;\n\n  private Singleton() {\n    this.paramA = Config.PARAM_A;\n    this.paramB = Config.PARAM_B;\n  }\n\n  public synchronized static Singleton getInstance() {\n    if (instance == null) {\n      instance = new Singleton();\n    }\n    return instance;\n  }\n}\n```\n\n\n\n## 有何替代解决方案？\n\n刚刚我们提到了单例的很多问题，你可能会说，即便单例有这么多问题，但我不用不行啊。我业务上有表示全局唯一类的需求，如果不用单例，我怎么才能保证这个类的对象全局唯一呢？为了保证全局唯一，除了使用单例，我们还可以用静态方法来实现。这也是项目开发中经常用到的一种实现思路。比如， ID 唯一递增生成器的例子，用静态方法实现一下，就是下面这个样子：\n\n```java\n// 静态方法实现方式\npublic class IdGenerator {\n  private static AtomicLong id = new AtomicLong(0);\n  \n  public static long getId() { \n    return id.incrementAndGet();\n  }\n}\n// 使用举例\nlong id = IdGenerator.getId();\n```\n\n不过，静态方法这种实现思路，并不能解决我们之前提到的问题。实际上，它比单例更加不灵活，比如，它无法支持延迟加载。我们再来看看有没有其他办法。实际上，单例除了我们之前讲到的使用方法之外，还有另外一种使用方法。具体的代码如下所示：\n\n```java\n// 1. 老的使用方式\npublic demofunction() {\n  //...\n  long id = IdGenerator.getInstance().getId();\n  //...\n}\n\n// 2. 新的使用方式：依赖注入\npublic demofunction(IdGenerator idGenerator) {\n  long id = idGenerator.getId();\n}\n// 外部调用demofunction()的时候，传入idGenerator\nIdGenerator idGenerator = IdGenerator.getInsance();\ndemofunction(idGenerator);\n```\n\n\n\n1. 基于新的使用方式，我们将单例生成的对象，作为参数传递给函数（也可以通过构造函数传递给类的成员变量），可以解决单例隐藏类之间依赖关系的问题。不过，对于单例存在的其他问题，比如对 OOP 特性、扩展性、可测性不友好等问题，还是无法解决。\n2. 所以，如果要完全解决这些问题，我们可能要从根上，寻找其他方式来实现全局唯一类。实际上，类对象的全局唯一性可以通过多种不同的方式来保证。我们既可以通过单例模式来强制保证，也可以通过工厂模式、IOC 容器（比如 Spring IOC 容器）来保证，还可以通过程序员自己来保证（自己在编写代码的时候自己保证不要创建两个类对象）。这就类似 Java 中内存对象的释放由 JVM 来负责，而 C++ 中由程序员自己负责，道理是一样的。\n3. 对于替代方案工厂模式、IOC 容器的详细讲解，我们放到后面讲解。\n\n\n\n## 如何理解单例模式中的唯一性？\n\n1. 首先，我们重新看一下单例的定义：“一个类只允许创建唯一一个对象（或者实例），那这个类就是一个单例类，这种设计模式就叫作单例设计模式，简称单例模式。\n2. ”定义中提到，“一个类只允许创建唯一一个对象”。那对象的唯一性的作用范围是什么呢？是指线程内只允许创建一个对象，还是指进程内只允许创建一个对象？答案是后者，也就是说，单例模式创建的对象是进程唯一的。这里有点不好理解，我来详细地解释一下。\n3. 我们编写的代码，通过编译、链接，组织在一起，就构成了一个操作系统可以执行的文件，也就是我们平时所说的“可执行文件”（比如 Windows 下的 exe 文件）。可执行文件实际上就是代码被翻译成操作系统可理解的一组指令，你完全可以简单地理解为就是代码本身。\n4. 当我们使用命令行或者双击运行这个可执行文件的时候，操作系统会启动一个进程，将这个执行文件从磁盘加载到自己的进程地址空间（可以理解操作系统为进程分配的内存存储区，用来存储代码和数据）。接着，进程就一条一条地执行可执行文件中包含的代码。比如，当进程读到代码中的 User user = new User(); 这条语句的时候，它就在自己的地址空间中创建一个 user 临时变量和一个 User 对象。进程之间是不共享地址空间的，如果我们在一个进程中创建另外一个进程（比如，代码中有一个 fork() 语句，进程执行到这条语句的时候会创建一个新的进程），操作系统会给新进程分配新的地址空间，并且将老进程地址空间的所有内容，重新拷贝一份到新进程的地址空间中，这些内容包括代码、数据（比如 user 临时变量、User 对象）。\n5. 所以，单例类在老进程中存在且只能存在一个对象，在新进程中也会存在且只能存在一个对象。而且，这两个对象并不是同一个对象，这也就说，单例类中对象的唯一性的作用范围是进程内的，在进程间是不唯一的。\n\n\n\n## 如何实现线程唯一的单例？\n\n1. 刚刚我们讲了单例类对象是进程唯一的，一个进程只能有一个单例对象。那如何实现一个线程唯一的单例呢？\n\n2. 我们先来看一下，什么是线程唯一的单例，以及“线程唯一”和“进程唯一”的区别。\n\n3. “进程唯一”指的是进程内唯一，进程间不唯一。类比一下，“线程唯一”指的是线程内唯一，线程间可以不唯一。实际上，“进程唯一”还代表了线程内、线程间都唯一，这也是“进程唯一”和“线程唯一”的区别之处。这段话听起来有点像绕口令，我举个例子来解释一下。\n\n4. 假设 IdGenerator 是一个线程唯一的单例类。在线程 A 内，我们可以创建一个单例对象 a。因为线程内唯一，在线程 A 内就不能再创建新的 IdGenerator 对象了，而线程间可以不唯一，所以，在另外一个线程 B 内，我们还可以重新创建一个新的单例对象 b。\n\n5. 尽管概念理解起来比较复杂，但线程唯一单例的代码实现很简单，如下所示。在代码中，我们通过一个 HashMap 来存储对象，其中 key 是线程 ID，value 是对象。这样我们就可以做到，不同的线程对应不同的对象，同一个线程只能对应一个对象。实际上，Java 语言本身提供了 ThreadLocal 工具类，可以更加轻松地实现线程唯一单例。不过，ThreadLocal 底层实现原理也是基于下面代码中所示的 HashMap。\n\n   \n\n```java\npublic class IdGenerator {\n  private AtomicLong id = new AtomicLong(0);\n\n  private static final ConcurrentHashMap<Long, IdGenerator> instances\n          = new ConcurrentHashMap<>();\n\n  private IdGenerator() {}\n\n  public static IdGenerator getInstance() {\n    Long currentThreadId = Thread.currentThread().getId();\n    instances.putIfAbsent(currentThreadId, new IdGenerator());\n    return instances.get(currentThreadId);\n  }\n\n  public long getId() {\n    return id.incrementAndGet();\n  }\n}\n```\n\n\n\n\n\n## 如何实现集群环境下的单例？\n\n1. 刚刚我们讲了“进程唯一”的单例和“线程唯一”的单例，现在，我们再来看下，“集群唯一”的单例。\n2. 首先，我们还是先来解释一下，什么是“集群唯一”的单例。\n3. 我们还是将它跟“进程唯一”“线程唯一”做个对比。“进程唯一”指的是进程内唯一、进程间不唯一。“线程唯一”指的是线程内唯一、线程间不唯一。集群相当于多个进程构成的一个集合，“集群唯一”就相当于是进程内唯一、进程间也唯一。也就是说，不同的进程间共享同一个对象，不能创建同一个类的多个对象。\n4. 我们知道，经典的单例模式是进程内唯一的，那如何实现一个进程间也唯一的单例呢？如果严格按照不同的进程间共享同一个对象来实现，那集群唯一的单例实现起来就有点难度了。\n5. 具体来说，我们需要把这个单例对象序列化并存储到外部共享存储区（比如文件）。进程在使用这个单例对象的时候，需要先从外部共享存储区中将它读取到内存，并反序列化成对象，然后再使用，使用完成之后还需要再存储回外部共享存储区。\n6. 为了保证任何时刻，在进程间都只有一份对象存在，一个进程在获取到对象之后，需要对对象加锁，避免其他进程再将其获取。在进程使用完这个对象之后，还需要显式地将对象从内存中删除，并且释放对对象的加锁。按照这个思路，\n7. 我用伪代码实现了一下这个过程，具体如下所示：\n\n```java\npublic class IdGenerator {\n  private AtomicLong id = new AtomicLong(0);\n  private static IdGenerator instance;\n  private static SharedObjectStorage storage = FileSharedObjectStorage(/*入参省略，比如文件地址*/);\n  private static DistributedLock lock = new DistributedLock();\n  \n  private IdGenerator() {}\n\n  public synchronized static IdGenerator getInstance() \n    if (instance == null) {\n      lock.lock();\n      instance = storage.load(IdGenerator.class);\n    }\n    return instance;\n  }\n  \n  public synchroinzed void freeInstance() {\n    storage.save(this, IdGeneator.class);\n    instance = null; //释放对象\n    lock.unlock();\n  }\n  \n  public long getId() { \n    return id.incrementAndGet();\n  }\n}\n\n// IdGenerator使用举例\nIdGenerator idGeneator = IdGenerator.getInstance();\nlong id = idGenerator.getId();\nIdGenerator.freeInstance();\n```\n\n\n\n## 如何实现一个多例模式？\n\n跟单例模式概念相对应的还有一个多例模式。那如何实现一个多例模式呢？“单例”指的是，一个类只能创建一个对象。对应地，“多例”指的就是，一个类可以创建多个对象，但是个数是有限制的，比如只能创建 3 个对象。如果用代码来简单示例一下的话，就是下面这个样子：\n\n```java\npublic class BackendServer {\n  private long serverNo;\n  private String serverAddress;\n\n  private static final int SERVER_COUNT = 3;\n  private static final Map<Long, BackendServer> serverInstances = new HashMap<>();\n\n  static {\n    serverInstances.put(1L, new BackendServer(1L, \"192.134.22.138:8080\"));\n    serverInstances.put(2L, new BackendServer(2L, \"192.134.22.139:8080\"));\n    serverInstances.put(3L, new BackendServer(3L, \"192.134.22.140:8080\"));\n  }\n\n  private BackendServer(long serverNo, String serverAddress) {\n    this.serverNo = serverNo;\n    this.serverAddress = serverAddress;\n  }\n\n  public BackendServer getInstance(long serverNo) {\n    return serverInstances.get(serverNo);\n  }\n\n  public BackendServer getRandomInstance() {\n    Random r = new Random();\n    int no = r.nextInt(SERVER_COUNT)+1;\n    return serverInstances.get(no);\n  }\n}\n```\n\n\n\n实际上，对于多例模式，还有一种理解方式：同一类型的只能创建一个对象，不同类型的可以创建多个对象。这里的“类型”如何理解呢？我们还是通过一个例子来解释一下，具体代码如下所示。在代码中，logger name 就是刚刚说的“类型”，同一个 logger name 获取到的对象实例是相同的，不同的 logger name 获取到的对象实例是不同的。\n\n```java\npublic class Logger {\n  private static final ConcurrentHashMap<String, Logger> instances\n          = new ConcurrentHashMap<>();\n\n  private Logger() {}\n\n  public static Logger getInstance(String loggerName) {\n    instances.putIfAbsent(loggerName, new Logger());\n    return instances.get(loggerName);\n  }\n\n  public void log() {\n    //...\n  }\n}\n\n//l1==l2, l1!=l3\nLogger l1 = Logger.getInstance(\"User.class\");\nLogger l2 = Logger.getInstance(\"User.class\");\nLogger l3 = Logger.getInstance(\"Order.class\");\n```\n\n\n\n这种多例模式的理解方式有点类似工厂模式。它跟工厂模式的不同之处是，多例模式创建的对象都是同一个类的对象，而工厂模式创建的是不同子类的对象，关于这一点，后面就会讲到。实际上，它还有点类似享元模式，两者的区别等到我们讲到享元模式的时候再来分析。除此之外，实际上，枚举类型也相当于多例模式，一个类型只能对应一个对象，一个类可以创建多个对象。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"2024-05-11-设计模式-03.01-创建型-单例","published":1,"updated":"2024-05-11T14:06:48.257Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clxjyo3cg000qisvd0tkd2c17","content":"<h1 id=\"声明\"><a href=\"#声明\" class=\"headerlink\" title=\"声明\"></a>声明</h1><blockquote>\n<ol>\n<li>此系列文章非本人原创，是学习笔记。</li>\n<li>设计模式系列以后会持续更新，包括已经发布的设计模式文章，因为后续还要再多看一下书，教程和开源项目等，继续润色文章。</li>\n</ol>\n</blockquote>\n<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>23 种经典的设计模式。它们又可以分为三大类：创建型、结构型、行为型。对于这 23 种设计模式的学习，我们要有侧重点，因为有些模式是比较常用的，有些模式是很少被用到的。对于常用的设计模式，我们要花多点时间理解掌握。对于不常用的设计模式，我们只需要稍微了解即可。按照类型和是否常用，对这些设计模式，进行了简单的分类，具体如下所示。</p>\n<h3 id=\"创建型\"><a href=\"#创建型\" class=\"headerlink\" title=\"创建型\"></a>创建型</h3><p>常用的有：单例模式、工厂模式（工厂方法和抽象工厂）、建造者模式。</p>\n<p>不常用的有：原型模式。</p>\n<h3 id=\"结构型\"><a href=\"#结构型\" class=\"headerlink\" title=\"结构型\"></a>结构型</h3><p>常用的有：代理模式、桥接模式、装饰者模式、适配器模式。</p>\n<p>不常用的有：门面模式、组合模式、享元模式。 </p>\n<h3 id=\"行为型\"><a href=\"#行为型\" class=\"headerlink\" title=\"行为型\"></a>行为型</h3><p>常用的有：观察者模式、模板模式、策略模式、职责链模式、迭代器模式、状态模式。</p>\n<p>不常用的有：访问者模式、备忘录模式、命令模式、解释器模式、中介模式。</p>\n<h1 id=\"单例模式【常用】\"><a href=\"#单例模式【常用】\" class=\"headerlink\" title=\"单例模式【常用】\"></a>单例模式【常用】</h1><p>网上有很多讲解单例模式的文章，但大部分都侧重讲解，如何来实现一个线程安全的单例。今天也会讲到各种单例的实现方法，但是，重点还是希望带你搞清楚下面这样几个问题。</p>\n<ul>\n<li>为什么要使用单例？</li>\n<li>单例存在哪些问题？</li>\n<li>单例与静态类的区别？</li>\n<li>有何替代的解决方案？</li>\n</ul>\n<h2 id=\"为什么要使用单例？\"><a href=\"#为什么要使用单例？\" class=\"headerlink\" title=\"为什么要使用单例？\"></a>为什么要使用单例？</h2><p>单例设计模式（Singleton Design Pattern）理解起来非常简单。一个类只允许创建一个对象（或者实例），那这个类就是一个单例类，这种设计模式就叫作单例设计模式，简称单例模式。</p>\n<p>对于单例的概念，我觉得没必要解释太多，你一看就能明白。我们重点看一下，为什么我们需要单例这种设计模式？它能解决哪些问题？接下来我通过两个实战案例来讲解。</p>\n<h3 id=\"实战案例一：处理资源访问冲突\"><a href=\"#实战案例一：处理资源访问冲突\" class=\"headerlink\" title=\"实战案例一：处理资源访问冲突\"></a>实战案例一：处理资源访问冲突</h3><p>我们先来看第一个例子。在这个例子中，我们自定义实现了一个往文件中打印日志的 Logger 类。具体的代码实现如下所示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Logger</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> FileWriter writer;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"title function_\">Logger</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">File</span> <span class=\"variable\">file</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">File</span>(<span class=\"string\">&quot;/Users/wangzheng/log.txt&quot;</span>);</span><br><span class=\"line\">    writer = <span class=\"keyword\">new</span> <span class=\"title class_\">FileWriter</span>(file, <span class=\"literal\">true</span>); <span class=\"comment\">//true表示追加写入</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">log</span><span class=\"params\">(String message)</span> &#123;</span><br><span class=\"line\">    writer.write(message);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Logger类的应用示例：</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">UserController</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"type\">Logger</span> <span class=\"variable\">logger</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Logger</span>();</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">login</span><span class=\"params\">(String username, String password)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...省略业务逻辑代码...</span></span><br><span class=\"line\">    logger.log(username + <span class=\"string\">&quot; logined!&quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">OrderController</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"type\">Logger</span> <span class=\"variable\">logger</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Logger</span>();</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">create</span><span class=\"params\">(OrderVo order)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...省略业务逻辑代码...</span></span><br><span class=\"line\">    logger.log(<span class=\"string\">&quot;Created an order: &quot;</span> + order.toString());</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在上面的代码中，我们注意到，所有的日志都写入到同一个文件 &#x2F;Users&#x2F;wangzheng&#x2F;log.txt 中。在 UserController 和 OrderController 中，我们分别创建两个 Logger 对象。在 Web 容器的 Servlet 多线程环境下，如果两个 Servlet 线程同时分别执行 login() 和 create() 两个函数，并且同时写日志到 log.txt 文件中，那就有可能存在日志信息互相覆盖的情况。【这属于并发的知识点，看不懂的可以看笔者的并发系列】</p>\n<p>那如何来解决这个问题呢？我们最先想到的就是通过加锁的方式：给 log() 函数加互斥锁，同一时刻只允许一个线程调用执行 log() 函数。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Logger</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> FileWriter writer;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"title function_\">Logger</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">File</span> <span class=\"variable\">file</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">File</span>(<span class=\"string\">&quot;/Users/wangzheng/log.txt&quot;</span>);</span><br><span class=\"line\">    writer = <span class=\"keyword\">new</span> <span class=\"title class_\">FileWriter</span>(file, <span class=\"literal\">true</span>); <span class=\"comment\">//true表示追加写入</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">log</span><span class=\"params\">(String message)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span>(<span class=\"built_in\">this</span>) &#123;</span><br><span class=\"line\">      writer.write(mesasge);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>synchronized(this)</code>这种对象级别的锁，锁不住，因为不同的对象之间并不共享同一把锁。所以我们换成类级别的锁。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Logger</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> FileWriter writer;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"title function_\">Logger</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">File</span> <span class=\"variable\">file</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">File</span>(<span class=\"string\">&quot;/Users/wangzheng/log.txt&quot;</span>);</span><br><span class=\"line\">    writer = <span class=\"keyword\">new</span> <span class=\"title class_\">FileWriter</span>(file, <span class=\"literal\">true</span>); <span class=\"comment\">//true表示追加写入</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">log</span><span class=\"params\">(String message)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span>(Logger.class) &#123; <span class=\"comment\">// 类级别的锁</span></span><br><span class=\"line\">      writer.write(mesasge);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>除了使用类级别锁之外，实际上，解决资源竞争问题的办法还有很多，分布式锁是最常听到的一种解决方案。不过，实现一个安全可靠、无 bug、高性能的分布式锁，并不是件容易的事情。除此之外，并发队列（比如 Java 中的 BlockingQueue）也可以解决这个问题：多个线程同时往并发队列里写日志，一个单独的线程负责将并发队列中的数据，写入到日志文件。这种方式实现起来也稍微有点复杂。</p>\n<p>相对于这两种解决方案，单例模式的解决思路就简单一些了。单例模式相对于之前类级别锁的好处是，不用创建那么多 Logger 对象，一方面节省内存空间，另一方面节省系统文件句柄（对于操作系统来说，文件句柄也是一种资源，不能随便浪费）。</p>\n<p>我们将 Logger 设计成一个单例类，程序中只允许创建一个 Logger 对象，所有的线程共享使用的这一个 Logger 对象，共享一个 FileWriter 对象，而 FileWriter 本身是对象级别线程安全的，也就避免了多线程情况下写日志会互相覆盖的问题。按照这个设计思路，我们实现了 Logger 单例类。具体代码如下所示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Logger</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> FileWriter writer;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">Logger</span> <span class=\"variable\">instance</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Logger</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"title function_\">Logger</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">File</span> <span class=\"variable\">file</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">File</span>(<span class=\"string\">&quot;/Users/wangzheng/log.txt&quot;</span>);</span><br><span class=\"line\">    writer = <span class=\"keyword\">new</span> <span class=\"title class_\">FileWriter</span>(file, <span class=\"literal\">true</span>); <span class=\"comment\">//true表示追加写入</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Logger <span class=\"title function_\">getInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">log</span><span class=\"params\">(String message)</span> &#123;</span><br><span class=\"line\">    writer.write(mesasge);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Logger类的应用示例：</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">UserController</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">login</span><span class=\"params\">(String username, String password)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...省略业务逻辑代码...</span></span><br><span class=\"line\">    Logger.getInstance().log(username + <span class=\"string\">&quot; logined!&quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">OrderController</span> &#123;  </span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">create</span><span class=\"params\">(OrderVo order)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...省略业务逻辑代码...</span></span><br><span class=\"line\">    Logger.getInstance().log(<span class=\"string\">&quot;Created a order: &quot;</span> + order.toString());</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"实战案例二：表示全局唯一类\"><a href=\"#实战案例二：表示全局唯一类\" class=\"headerlink\" title=\"实战案例二：表示全局唯一类\"></a>实战案例二：表示全局唯一类</h3><p>从业务概念上，如果有些数据在系统中只应保存一份，那就比较适合设计为单例类。比如，配置信息类。在系统中，我们只有一个配置文件，当配置文件被加载到内存之后，以对象的形式存在，也理所应当只有一份。</p>\n<p>再比如，唯一递增 ID 号码生成器。如果程序中有两个对象，那就会存在生成重复 ID 的情况，所以，我们应该将 ID 生成器类设计为单例。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">IdGenerator</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// AtomicLong是一个Java并发库中提供的一个原子变量类型,</span></span><br><span class=\"line\">  <span class=\"comment\">// 它将一些线程不安全需要加锁的复合操作封装为了线程安全的原子操作，</span></span><br><span class=\"line\">  <span class=\"comment\">// 比如下面会用到的incrementAndGet().</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"type\">AtomicLong</span> <span class=\"variable\">id</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">AtomicLong</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">IdGenerator</span> <span class=\"variable\">instance</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IdGenerator</span>();</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"title function_\">IdGenerator</span><span class=\"params\">()</span> &#123;&#125;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> IdGenerator <span class=\"title function_\">getInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"type\">long</span> <span class=\"title function_\">getId</span><span class=\"params\">()</span> &#123; </span><br><span class=\"line\">    <span class=\"keyword\">return</span> id.incrementAndGet();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// IdGenerator使用举例</span></span><br><span class=\"line\"><span class=\"type\">long</span> <span class=\"variable\">id</span> <span class=\"operator\">=</span> IdGenerator.getInstance().getId();</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"如何实现一个单例？\"><a href=\"#如何实现一个单例？\" class=\"headerlink\" title=\"如何实现一个单例？\"></a>如何实现一个单例？</h2><p>尽管介绍如何实现一个单例模式的文章已经有很多了，但为了保证内容的完整性，我这里还是简单介绍一下几种经典实现方式。概括起来，要实现一个单例，我们需要关注的点无外乎下面几个：</p>\n<ul>\n<li><p>构造函数需要是 private 访问权限的，这样才能避免外部通过 new 创建实例；</p>\n</li>\n<li><p>考虑对象创建时的线程安全问题；</p>\n</li>\n<li><p>考虑是否支持延迟加载；</p>\n</li>\n<li><p>考虑 getInstance() 性能是否高（是否加锁）。</p>\n</li>\n</ul>\n<h3 id=\"饿汉式-静态变量\"><a href=\"#饿汉式-静态变量\" class=\"headerlink\" title=\"饿汉式(静态变量)\"></a>饿汉式(静态变量)</h3><p>饿汉式的实现方式比较简单。在类加载的时候，instance 静态实例就已经创建并初始化好了，所以，instance 实例的创建过程是线程安全的。不过，这样的实现方式不支持延迟加载（在真正用到 IdGenerator 的时候，再创建实例），从名字中我们也可以看出这一点。具体的代码实现如下所示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">IdGenerator</span> &#123; </span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"type\">AtomicLong</span> <span class=\"variable\">id</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">AtomicLong</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">IdGenerator</span> <span class=\"variable\">instance</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IdGenerator</span>();</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"title function_\">IdGenerator</span><span class=\"params\">()</span> &#123;&#125;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> IdGenerator <span class=\"title function_\">getInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"type\">long</span> <span class=\"title function_\">getId</span><span class=\"params\">()</span> &#123; </span><br><span class=\"line\">    <span class=\"keyword\">return</span> id.incrementAndGet();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<ol>\n<li>有人觉得这种实现方式不好，因为不支持延迟加载，如果实例占用资源多（比如占用内存多）或初始化耗时长（比如需要加载各种配置文件），提前初始化实例是一种浪费资源的行为。最好的方法应该在用到的时候再去初始化。不过，我个人并不认同这样的观点</li>\n<li>如果初始化耗时长，那我们最好不要等到真正要用它的时候，才去执行这个耗时长的初始化过程，这会影响到系统的性能（比如，在响应客户端接口请求的时候，做这个初始化操作，会导致此请求的响应时间变长，甚至超时）。采用饿汉式实现方式，将耗时的初始化操作，提前到程序启动的时候完成，这样就能避免在程序运行的时候，再去初始化导致的性能问题。</li>\n<li>如果实例占用资源多，按照 fail-fast 的设计原则（有问题及早暴露），那我们也希望在程序启动时就将这个实例初始化好。如果资源不够，就会在程序启动的时候触发报错（比如 Java 中的 PermGen Space OOM），我们可以立即去修复。这样也能避免在程序运行一段时间后，突然因为初始化这个实例占用资源过多，导致系统崩溃，影响系统的可用性。(如果初始化消耗资源过多，反而推荐懒汉式，早日发现问题)</li>\n</ol>\n<h3 id=\"饿汉式-静态代码块\"><a href=\"#饿汉式-静态代码块\" class=\"headerlink\" title=\"饿汉式(静态代码块)\"></a>饿汉式(静态代码块)</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">SingletonTest02</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 测试</span></span><br><span class=\"line\">    <span class=\"type\">Singleton</span> <span class=\"variable\">instance</span> <span class=\"operator\">=</span> Singleton.getInstance();</span><br><span class=\"line\">    <span class=\"type\">Singleton</span> <span class=\"variable\">instance2</span> <span class=\"operator\">=</span> Singleton.getInstance();</span><br><span class=\"line\">    System.out.println(instance == instance2); <span class=\"comment\">// true</span></span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;instance.hashCode=&quot;</span> + instance.hashCode());</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;instance2.hashCode=&quot;</span> + instance2.hashCode());</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 饿汉式(静态变量)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Singleton</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 1. 构造器私有化</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"title function_\">Singleton</span><span class=\"params\">()</span> &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 2.本类内部创建对象实例</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Singleton instance;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">static</span> &#123; <span class=\"comment\">// 在静态代码块中，创建单例对象</span></span><br><span class=\"line\">    instance = <span class=\"keyword\">new</span> <span class=\"title class_\">Singleton</span>();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 3. 提供一个公有的静态方法，返回实例对象</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title function_\">getInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>没什么好说的，就是静态变量换成了静态代码块。</p>\n<h3 id=\"懒汉式-线程安全，同步方法\"><a href=\"#懒汉式-线程安全，同步方法\" class=\"headerlink\" title=\"懒汉式(线程安全，同步方法)\"></a>懒汉式(线程安全，同步方法)</h3><p>懒汉式相对于饿汉式的优势是支持延迟加载。具体的代码实现如下所示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">IdGenerator</span> &#123; </span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"type\">AtomicLong</span> <span class=\"variable\">id</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">AtomicLong</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> IdGenerator instance;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"title function_\">IdGenerator</span><span class=\"params\">()</span> &#123;&#125;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">synchronized</span> IdGenerator <span class=\"title function_\">getInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (instance == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      instance = <span class=\"keyword\">new</span> <span class=\"title class_\">IdGenerator</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"type\">long</span> <span class=\"title function_\">getId</span><span class=\"params\">()</span> &#123; </span><br><span class=\"line\">    <span class=\"keyword\">return</span> id.incrementAndGet();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>不过懒汉式的缺点也很明显，我们给 getInstance() 这个方法加了一把大锁（synchronzed），导致这个函数的并发度很低。而这个函数是在单例使用期间，一直会被调用。如果这个单例类偶尔会被用到，那这种实现方式还可以接受。但是，如果频繁地用到，那频繁加锁、释放锁及并发度低等问题，会导致性能瓶颈，这种实现方式就不可取了。</p>\n<h3 id=\"懒汉式-线程安全，同步代码块\"><a href=\"#懒汉式-线程安全，同步代码块\" class=\"headerlink\" title=\"懒汉式(线程安全，同步代码块)\"></a>懒汉式(线程安全，同步代码块)</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 懒汉式(线程安全，同步代码块)</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Singleton</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Singleton instance;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"title function_\">Singleton</span><span class=\"params\">()</span> &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title function_\">getInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (instance == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">synchronized</span> (Singleton.class) &#123;</span><br><span class=\"line\">        instance = <span class=\"keyword\">new</span> <span class=\"title class_\">Singleton</span>();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"懒汉式-线程不安全\"><a href=\"#懒汉式-线程不安全\" class=\"headerlink\" title=\"懒汉式(线程不安全)\"></a>懒汉式(线程不安全)</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Singleton</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Singleton instance;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"title function_\">Singleton</span><span class=\"params\">()</span> &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 提供一个静态的公有方法，当使用到该方法时，才去创建 instance</span></span><br><span class=\"line\">  <span class=\"comment\">// 即懒汉式</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title function_\">getInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (instance == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      instance = <span class=\"keyword\">new</span> <span class=\"title class_\">Singleton</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n<p>只是为了完整性，写了出来，实际开发不推荐用线程不安全的</p>\n<h3 id=\"双重检测\"><a href=\"#双重检测\" class=\"headerlink\" title=\"双重检测\"></a>双重检测</h3><p>饿汉式不支持延迟加载，懒汉式有性能问题，不支持高并发。那我们再来看一种既支持延迟加载、又支持高并发的单例实现方式，也就是双重检测实现方式。在这种实现方式中，只要 instance 被创建之后，即便再调用 getInstance() 函数也不会再进入到加锁逻辑中了。所以，这种实现方式解决了懒汉式并发度低的问题。具体的代码实现如下所示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">IdGenerator</span> &#123; </span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"type\">AtomicLong</span> <span class=\"variable\">id</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">AtomicLong</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> IdGenerator instance;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"title function_\">IdGenerator</span><span class=\"params\">()</span> &#123;&#125;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> IdGenerator <span class=\"title function_\">getInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (instance == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">synchronized</span>(IdGenerator.class) &#123; <span class=\"comment\">// 此处为类级别的锁</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (instance == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">          instance = <span class=\"keyword\">new</span> <span class=\"title class_\">IdGenerator</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"type\">long</span> <span class=\"title function_\">getId</span><span class=\"params\">()</span> &#123; </span><br><span class=\"line\">    <span class=\"keyword\">return</span> id.incrementAndGet();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>这种实现方式有些问题。因为指令重排序，可能会导致 IdGenerator 对象被 new 出来，并且赋值给 instance 之后，还没来得及初始化（执行构造函数中的代码逻辑），就被另一个线程使用了。要解决这个问题，我们需要给 instance 成员变量加上 volatile 关键字，禁止指令重排序才行。</p>\n<p>据说，只有很低版本的 Java 才会有这个问题。我们现在用的高版本的 Java 已经在 JDK 内部实现中解决了这个问题（解决的方法很简单，只要把对象 new 操作和初始化操作设计为原子操作，就自然能禁止重排序）。</p>\n<h3 id=\"静态内部类\"><a href=\"#静态内部类\" class=\"headerlink\" title=\"静态内部类\"></a>静态内部类</h3><p>我们再来看一种比双重检测更加简单的实现方法，那就是利用 Java 的静态内部类。它有点类似饿汉式，但又能做到了延迟加载。具体是怎么做到的呢？我们先来看它的代码实现</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">IdGenerator</span> &#123; </span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"type\">AtomicLong</span> <span class=\"variable\">id</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">AtomicLong</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"title function_\">IdGenerator</span><span class=\"params\">()</span> &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">SingletonHolder</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">IdGenerator</span> <span class=\"variable\">instance</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IdGenerator</span>();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> IdGenerator <span class=\"title function_\">getInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> SingletonHolder.instance;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"type\">long</span> <span class=\"title function_\">getId</span><span class=\"params\">()</span> &#123; </span><br><span class=\"line\">    <span class=\"keyword\">return</span> id.incrementAndGet();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>SingletonHolder 是一个静态内部类，当外部类 IdGenerator 被加载的时候，并不会创建 SingletonHolder 实例对象。只有当调用 getInstance() 方法时，SingletonHolder 才会被加载，这个时候才会创建 instance。instance 的唯一性、创建过程的线程安全性，都由 JVM 来保证。所以，这种实现方法既保证了线程安全，又能做到延迟加载。</p>\n<h3 id=\"枚举\"><a href=\"#枚举\" class=\"headerlink\" title=\"枚举\"></a>枚举</h3><p>最后，我们介绍一种最简单的实现方式，基于枚举类型的单例实现。这种实现方式通过 Java 枚举类型本身的特性，保证了实例创建的线程安全性和实例的唯一性。具体的代码如下所示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">enum</span> <span class=\"title class_\">IdGenerator</span> &#123;</span><br><span class=\"line\">  INSTANCE;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"type\">AtomicLong</span> <span class=\"variable\">id</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">AtomicLong</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"type\">long</span> <span class=\"title function_\">getId</span><span class=\"params\">()</span> &#123; </span><br><span class=\"line\">    <span class=\"keyword\">return</span> id.incrementAndGet();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"单例存在哪些问题\"><a href=\"#单例存在哪些问题\" class=\"headerlink\" title=\"单例存在哪些问题?\"></a>单例存在哪些问题?</h2><p>尽管单例是一个很常用的设计模式，在实际的开发中，我们也确实经常用到它，但是，有些人认为单例是一种反模式（anti-pattern），并不推荐使用。大部分情况下，我们在项目中使用单例，都是用它来表示一些全局唯一类，比如配置信息类、连接池类、ID 生成器类。单例模式书写简洁、使用方便，在代码中，我们不需要创建对象，直接通过类似 IdGenerator.getInstance().getId() 这样的方法来调用就可以了。但是，这种使用方法有点类似硬编码（hard code），会带来诸多问题。接下来，我们就具体看看到底有哪些问题。</p>\n<h3 id=\"单例对-OOP-特性的支持不友好\"><a href=\"#单例对-OOP-特性的支持不友好\" class=\"headerlink\" title=\"单例对 OOP 特性的支持不友好\"></a>单例对 OOP 特性的支持不友好</h3><p>我们知道，OOP 的四大特性是封装、抽象、继承、多态。单例这种设计模式对于其中的抽象、继承、多态都支持得不好。为什么这么说呢？我们还是通过 IdGenerator 这个例子来讲解。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Order</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">create</span><span class=\"params\">(...)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"variable\">id</span> <span class=\"operator\">=</span> IdGenerator.getInstance().getId();</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">User</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">create</span><span class=\"params\">(...)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"variable\">id</span> <span class=\"operator\">=</span> IdGenerator.getInstance().getId();</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>IdGenerator 的使用方式违背了基于接口而非实现的设计原则，也就违背了广义上理解的 OOP 的抽象特性。如果未来某一天，我们希望针对不同的业务采用不同的 ID 生成算法。比如，订单 ID 和用户 ID 采用不同的 ID 生成器来生成。为了应对这个需求变化，我们需要修改所有用到 IdGenerator 类的地方，这样代码的改动就会比较大。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Order</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">create</span><span class=\"params\">(...)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"variable\">id</span> <span class=\"operator\">=</span> IdGenerator.getInstance().getId();</span><br><span class=\"line\">    <span class=\"comment\">// 需要将上面一行代码，替换为下面一行代码</span></span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"variable\">id</span> <span class=\"operator\">=</span> OrderIdGenerator.getIntance().getId();</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">User</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">create</span><span class=\"params\">(...)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"variable\">id</span> <span class=\"operator\">=</span> IdGenerator.getInstance().getId();</span><br><span class=\"line\">    <span class=\"comment\">// 需要将上面一行代码，替换为下面一行代码</span></span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"variable\">id</span> <span class=\"operator\">=</span> UserIdGenerator.getIntance().getId();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>除此之外，单例对继承、多态特性的支持也不友好。这里我之所以会用“不友好”这个词，而非“完全不支持”，是因为从理论上来讲，单例类也可以被继承、也可以实现多态，只是实现起来会非常奇怪，会导致代码的可读性变差。不明白设计意图的人，看到这样的设计，会觉得莫名其妙。所以，一旦你选择将某个类设计成到单例类，也就意味着放弃了继承和多态这两个强有力的面向对象特性，也就相当于损失了可以应对未来需求变化的扩展性</p>\n<h3 id=\"单例会隐藏类之间的依赖关系\"><a href=\"#单例会隐藏类之间的依赖关系\" class=\"headerlink\" title=\"单例会隐藏类之间的依赖关系\"></a>单例会隐藏类之间的依赖关系</h3><p>我们知道，代码的可读性非常重要。在阅读代码的时候，我们希望一眼就能看出类与类之间的依赖关系，搞清楚这个类依赖了哪些外部类。通过构造函数、参数传递等方式声明的类之间的依赖关系，我们通过查看函数的定义，就能很容易识别出来。但是，单例类不需要显示创建、不需要依赖参数传递，在函数中直接调用就可以了。如果代码比较复杂，这种调用关系就会非常隐蔽。在阅读代码的时候，我们就需要仔细查看每个函数的代码实现，才能知道这个类到底依赖了哪些单例类。</p>\n<h3 id=\"单例对代码的扩展性不友好\"><a href=\"#单例对代码的扩展性不友好\" class=\"headerlink\" title=\"单例对代码的扩展性不友好\"></a>单例对代码的扩展性不友好</h3><ol>\n<li>我们知道，单例类只能有一个对象实例。如果未来某一天，我们需要在代码中创建两个实例或多个实例，那就要对代码有比较大的改动。你可能会说，会有这样的需求吗？既然单例类大部分情况下都用来表示全局类，怎么会需要两个或者多个实例呢？</li>\n<li>实际上，这样的需求并不少见。我们拿数据库连接池来举例解释一下。</li>\n<li>在系统设计初期，我们觉得系统中只应该有一个数据库连接池，这样能方便我们控制对数据库连接资源的消耗。所以，我们把数据库连接池类设计成了单例类。但之后我们发现，系统中有些 SQL 语句运行得非常慢。这些 SQL 语句在执行的时候，长时间占用数据库连接资源，导致其他 SQL 请求无法响应。为了解决这个问题，我们希望将慢 SQL 与其他 SQL 隔离开来执行。为了实现这样的目的，我们可以在系统中创建两个数据库连接池，慢 SQL 独享一个数据库连接池，其他 SQL 独享另外一个数据库连接池，这样就能避免慢 SQL 影响到其他 SQL 的执行。</li>\n<li>如果我们将数据库连接池设计成单例类，显然就无法适应这样的需求变更，也就是说，单例类在某些情况下会影响代码的扩展性、灵活性。所以，数据库连接池、线程池这类的资源池，最好还是不要设计成单例类。实际上，一些开源的数据库连接池、线程池也确实没有设计成单例类。</li>\n</ol>\n<h3 id=\"单例对代码的可测试性不友好\"><a href=\"#单例对代码的可测试性不友好\" class=\"headerlink\" title=\"单例对代码的可测试性不友好\"></a>单例对代码的可测试性不友好</h3><ol>\n<li><p>单例模式的使用会影响到代码的可测试性。如果单例类依赖比较重的外部资源，比如 DB，我们在写单元测试的时候，希望能通过 mock 的方式将它替换掉。而单例类这种硬编码式的使用方式，导致无法实现 mock 替换。</p>\n</li>\n<li><p>除此之外，如果单例类持有成员变量（比如 IdGenerator 中的 id 成员变量），那它实际上相当于一种全局变量，被所有的代码共享。如果这个全局变量是一个可变全局变量，也就是说，它的成员变量是可以被修改的，那我们在编写单元测试的时候，还需要注意不同测试用例之间，修改了单例类中的同一个成员变量的值，从而导致测试结果互相影响的问题。</p>\n</li>\n</ol>\n<h3 id=\"单例不支持有参数的构造函数\"><a href=\"#单例不支持有参数的构造函数\" class=\"headerlink\" title=\"单例不支持有参数的构造函数\"></a>单例不支持有参数的构造函数</h3><p>单例不支持有参数的构造函数，比如我们创建一个连接池的单例对象，我们没法通过参数来指定连接池的大小。针对这个问题，我们来看下都有哪些解决方案。</p>\n<p><strong>第一种解决思路是</strong>：创建完实例之后，再调用 init() 函数传递参数。需要注意的是，我们在使用这个单例类的时候，要先调用 init() 方法，然后才能调用 getInstance() 方法，否则代码会抛出异常。具体的代码实现如下所示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Singleton</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">Singleton</span> <span class=\"variable\">instance</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> paramA;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> paramB;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"title function_\">Singleton</span><span class=\"params\">(<span class=\"type\">int</span> paramA, <span class=\"type\">int</span> paramB)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.paramA = paramA;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.paramB = paramB;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title function_\">getInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (instance == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">       <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RuntimeException</span>(<span class=\"string\">&quot;Run init() first.&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">static</span> Singleton <span class=\"title function_\">init</span><span class=\"params\">(<span class=\"type\">int</span> paramA, <span class=\"type\">int</span> paramB)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (instance != <span class=\"literal\">null</span>)&#123;</span><br><span class=\"line\">       <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RuntimeException</span>(<span class=\"string\">&quot;Singleton has been created!&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    instance = <span class=\"keyword\">new</span> <span class=\"title class_\">Singleton</span>(paramA, paramB);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Singleton.init(<span class=\"number\">10</span>, <span class=\"number\">50</span>); <span class=\"comment\">// 先init，再使用</span></span><br><span class=\"line\"><span class=\"type\">Singleton</span> <span class=\"variable\">singleton</span> <span class=\"operator\">=</span> Singleton.getInstance();</span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>第二种解决思路是</strong>：将参数放到 getIntance() 方法中。具体的代码实现如下所示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Singleton</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">Singleton</span> <span class=\"variable\">instance</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> paramA;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> paramB;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"title function_\">Singleton</span><span class=\"params\">(<span class=\"type\">int</span> paramA, <span class=\"type\">int</span> paramB)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.paramA = paramA;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.paramB = paramB;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">static</span> Singleton <span class=\"title function_\">getInstance</span><span class=\"params\">(<span class=\"type\">int</span> paramA, <span class=\"type\">int</span> paramB)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (instance == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      instance = <span class=\"keyword\">new</span> <span class=\"title class_\">Singleton</span>(paramA, paramB);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">Singleton</span> <span class=\"variable\">singleton</span> <span class=\"operator\">=</span> Singleton.getInstance(<span class=\"number\">10</span>, <span class=\"number\">50</span>);</span><br></pre></td></tr></table></figure>\n\n\n\n<p>不知道你有没有发现，上面的代码实现稍微有点问题。如果我们如下两次执行 getInstance() 方法，那获取到的 singleton1 和 signleton2 的 paramA 和 paramB 都是 10 和 50。也就是说，第二次的参数（20，30）没有起作用，而构建的过程也没有给与提示，这样就会误导用户。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Singleton</span> <span class=\"variable\">singleton1</span> <span class=\"operator\">=</span> Singleton.getInstance(<span class=\"number\">10</span>, <span class=\"number\">50</span>);</span><br><span class=\"line\"><span class=\"type\">Singleton</span> <span class=\"variable\">singleton2</span> <span class=\"operator\">=</span> Singleton.getInstance(<span class=\"number\">20</span>, <span class=\"number\">30</span>);</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<p><strong>第三种解决思路是</strong>：将参数放到另外一个全局变量中。具体的代码实现如下。Config 是一个存储了 paramA 和 paramB 值的全局变量。里面的值既可以像下面的代码那样通过静态常量来定义，也可以从配置文件中加载得到。<strong>实际上，这种方式是最值得推荐的。</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Config</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">PARAM_A</span> <span class=\"operator\">=</span> <span class=\"number\">123</span>;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">PARAM_B</span> <span class=\"operator\">=</span> <span class=\"number\">245</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Singleton</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">Singleton</span> <span class=\"variable\">instance</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> paramA;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> paramB;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"title function_\">Singleton</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.paramA = Config.PARAM_A;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.paramB = Config.PARAM_B;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">static</span> Singleton <span class=\"title function_\">getInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (instance == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      instance = <span class=\"keyword\">new</span> <span class=\"title class_\">Singleton</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"有何替代解决方案？\"><a href=\"#有何替代解决方案？\" class=\"headerlink\" title=\"有何替代解决方案？\"></a>有何替代解决方案？</h2><p>刚刚我们提到了单例的很多问题，你可能会说，即便单例有这么多问题，但我不用不行啊。我业务上有表示全局唯一类的需求，如果不用单例，我怎么才能保证这个类的对象全局唯一呢？为了保证全局唯一，除了使用单例，我们还可以用静态方法来实现。这也是项目开发中经常用到的一种实现思路。比如， ID 唯一递增生成器的例子，用静态方法实现一下，就是下面这个样子：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 静态方法实现方式</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">IdGenerator</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">AtomicLong</span> <span class=\"variable\">id</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">AtomicLong</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"type\">long</span> <span class=\"title function_\">getId</span><span class=\"params\">()</span> &#123; </span><br><span class=\"line\">    <span class=\"keyword\">return</span> id.incrementAndGet();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 使用举例</span></span><br><span class=\"line\"><span class=\"type\">long</span> <span class=\"variable\">id</span> <span class=\"operator\">=</span> IdGenerator.getId();</span><br></pre></td></tr></table></figure>\n\n<p>不过，静态方法这种实现思路，并不能解决我们之前提到的问题。实际上，它比单例更加不灵活，比如，它无法支持延迟加载。我们再来看看有没有其他办法。实际上，单例除了我们之前讲到的使用方法之外，还有另外一种使用方法。具体的代码如下所示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 1. 老的使用方式</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"title function_\">demofunction</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">//...</span></span><br><span class=\"line\">  <span class=\"type\">long</span> <span class=\"variable\">id</span> <span class=\"operator\">=</span> IdGenerator.getInstance().getId();</span><br><span class=\"line\">  <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 2. 新的使用方式：依赖注入</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"title function_\">demofunction</span><span class=\"params\">(IdGenerator idGenerator)</span> &#123;</span><br><span class=\"line\">  <span class=\"type\">long</span> <span class=\"variable\">id</span> <span class=\"operator\">=</span> idGenerator.getId();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 外部调用demofunction()的时候，传入idGenerator</span></span><br><span class=\"line\"><span class=\"type\">IdGenerator</span> <span class=\"variable\">idGenerator</span> <span class=\"operator\">=</span> IdGenerator.getInsance();</span><br><span class=\"line\">demofunction(idGenerator);</span><br></pre></td></tr></table></figure>\n\n\n\n<ol>\n<li>基于新的使用方式，我们将单例生成的对象，作为参数传递给函数（也可以通过构造函数传递给类的成员变量），可以解决单例隐藏类之间依赖关系的问题。不过，对于单例存在的其他问题，比如对 OOP 特性、扩展性、可测性不友好等问题，还是无法解决。</li>\n<li>所以，如果要完全解决这些问题，我们可能要从根上，寻找其他方式来实现全局唯一类。实际上，类对象的全局唯一性可以通过多种不同的方式来保证。我们既可以通过单例模式来强制保证，也可以通过工厂模式、IOC 容器（比如 Spring IOC 容器）来保证，还可以通过程序员自己来保证（自己在编写代码的时候自己保证不要创建两个类对象）。这就类似 Java 中内存对象的释放由 JVM 来负责，而 C++ 中由程序员自己负责，道理是一样的。</li>\n<li>对于替代方案工厂模式、IOC 容器的详细讲解，我们放到后面讲解。</li>\n</ol>\n<h2 id=\"如何理解单例模式中的唯一性？\"><a href=\"#如何理解单例模式中的唯一性？\" class=\"headerlink\" title=\"如何理解单例模式中的唯一性？\"></a>如何理解单例模式中的唯一性？</h2><ol>\n<li>首先，我们重新看一下单例的定义：“一个类只允许创建唯一一个对象（或者实例），那这个类就是一个单例类，这种设计模式就叫作单例设计模式，简称单例模式。</li>\n<li>”定义中提到，“一个类只允许创建唯一一个对象”。那对象的唯一性的作用范围是什么呢？是指线程内只允许创建一个对象，还是指进程内只允许创建一个对象？答案是后者，也就是说，单例模式创建的对象是进程唯一的。这里有点不好理解，我来详细地解释一下。</li>\n<li>我们编写的代码，通过编译、链接，组织在一起，就构成了一个操作系统可以执行的文件，也就是我们平时所说的“可执行文件”（比如 Windows 下的 exe 文件）。可执行文件实际上就是代码被翻译成操作系统可理解的一组指令，你完全可以简单地理解为就是代码本身。</li>\n<li>当我们使用命令行或者双击运行这个可执行文件的时候，操作系统会启动一个进程，将这个执行文件从磁盘加载到自己的进程地址空间（可以理解操作系统为进程分配的内存存储区，用来存储代码和数据）。接着，进程就一条一条地执行可执行文件中包含的代码。比如，当进程读到代码中的 User user &#x3D; new User(); 这条语句的时候，它就在自己的地址空间中创建一个 user 临时变量和一个 User 对象。进程之间是不共享地址空间的，如果我们在一个进程中创建另外一个进程（比如，代码中有一个 fork() 语句，进程执行到这条语句的时候会创建一个新的进程），操作系统会给新进程分配新的地址空间，并且将老进程地址空间的所有内容，重新拷贝一份到新进程的地址空间中，这些内容包括代码、数据（比如 user 临时变量、User 对象）。</li>\n<li>所以，单例类在老进程中存在且只能存在一个对象，在新进程中也会存在且只能存在一个对象。而且，这两个对象并不是同一个对象，这也就说，单例类中对象的唯一性的作用范围是进程内的，在进程间是不唯一的。</li>\n</ol>\n<h2 id=\"如何实现线程唯一的单例？\"><a href=\"#如何实现线程唯一的单例？\" class=\"headerlink\" title=\"如何实现线程唯一的单例？\"></a>如何实现线程唯一的单例？</h2><ol>\n<li><p>刚刚我们讲了单例类对象是进程唯一的，一个进程只能有一个单例对象。那如何实现一个线程唯一的单例呢？</p>\n</li>\n<li><p>我们先来看一下，什么是线程唯一的单例，以及“线程唯一”和“进程唯一”的区别。</p>\n</li>\n<li><p>“进程唯一”指的是进程内唯一，进程间不唯一。类比一下，“线程唯一”指的是线程内唯一，线程间可以不唯一。实际上，“进程唯一”还代表了线程内、线程间都唯一，这也是“进程唯一”和“线程唯一”的区别之处。这段话听起来有点像绕口令，我举个例子来解释一下。</p>\n</li>\n<li><p>假设 IdGenerator 是一个线程唯一的单例类。在线程 A 内，我们可以创建一个单例对象 a。因为线程内唯一，在线程 A 内就不能再创建新的 IdGenerator 对象了，而线程间可以不唯一，所以，在另外一个线程 B 内，我们还可以重新创建一个新的单例对象 b。</p>\n</li>\n<li><p>尽管概念理解起来比较复杂，但线程唯一单例的代码实现很简单，如下所示。在代码中，我们通过一个 HashMap 来存储对象，其中 key 是线程 ID，value 是对象。这样我们就可以做到，不同的线程对应不同的对象，同一个线程只能对应一个对象。实际上，Java 语言本身提供了 ThreadLocal 工具类，可以更加轻松地实现线程唯一单例。不过，ThreadLocal 底层实现原理也是基于下面代码中所示的 HashMap。</p>\n</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">IdGenerator</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"type\">AtomicLong</span> <span class=\"variable\">id</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">AtomicLong</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> ConcurrentHashMap&lt;Long, IdGenerator&gt; instances</span><br><span class=\"line\">          = <span class=\"keyword\">new</span> <span class=\"title class_\">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"title function_\">IdGenerator</span><span class=\"params\">()</span> &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> IdGenerator <span class=\"title function_\">getInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">Long</span> <span class=\"variable\">currentThreadId</span> <span class=\"operator\">=</span> Thread.currentThread().getId();</span><br><span class=\"line\">    instances.putIfAbsent(currentThreadId, <span class=\"keyword\">new</span> <span class=\"title class_\">IdGenerator</span>());</span><br><span class=\"line\">    <span class=\"keyword\">return</span> instances.get(currentThreadId);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"type\">long</span> <span class=\"title function_\">getId</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> id.incrementAndGet();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h2 id=\"如何实现集群环境下的单例？\"><a href=\"#如何实现集群环境下的单例？\" class=\"headerlink\" title=\"如何实现集群环境下的单例？\"></a>如何实现集群环境下的单例？</h2><ol>\n<li>刚刚我们讲了“进程唯一”的单例和“线程唯一”的单例，现在，我们再来看下，“集群唯一”的单例。</li>\n<li>首先，我们还是先来解释一下，什么是“集群唯一”的单例。</li>\n<li>我们还是将它跟“进程唯一”“线程唯一”做个对比。“进程唯一”指的是进程内唯一、进程间不唯一。“线程唯一”指的是线程内唯一、线程间不唯一。集群相当于多个进程构成的一个集合，“集群唯一”就相当于是进程内唯一、进程间也唯一。也就是说，不同的进程间共享同一个对象，不能创建同一个类的多个对象。</li>\n<li>我们知道，经典的单例模式是进程内唯一的，那如何实现一个进程间也唯一的单例呢？如果严格按照不同的进程间共享同一个对象来实现，那集群唯一的单例实现起来就有点难度了。</li>\n<li>具体来说，我们需要把这个单例对象序列化并存储到外部共享存储区（比如文件）。进程在使用这个单例对象的时候，需要先从外部共享存储区中将它读取到内存，并反序列化成对象，然后再使用，使用完成之后还需要再存储回外部共享存储区。</li>\n<li>为了保证任何时刻，在进程间都只有一份对象存在，一个进程在获取到对象之后，需要对对象加锁，避免其他进程再将其获取。在进程使用完这个对象之后，还需要显式地将对象从内存中删除，并且释放对对象的加锁。按照这个思路，</li>\n<li>我用伪代码实现了一下这个过程，具体如下所示：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">IdGenerator</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"type\">AtomicLong</span> <span class=\"variable\">id</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">AtomicLong</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> IdGenerator instance;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">SharedObjectStorage</span> <span class=\"variable\">storage</span> <span class=\"operator\">=</span> FileSharedObjectStorage(<span class=\"comment\">/*入参省略，比如文件地址*/</span>);</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">DistributedLock</span> <span class=\"variable\">lock</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">DistributedLock</span>();</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"title function_\">IdGenerator</span><span class=\"params\">()</span> &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">static</span> IdGenerator <span class=\"title function_\">getInstance</span><span class=\"params\">()</span> </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (instance == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      lock.lock();</span><br><span class=\"line\">      instance = storage.load(IdGenerator.class);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">public</span> synchroinzed <span class=\"keyword\">void</span> <span class=\"title function_\">freeInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    storage.save(<span class=\"built_in\">this</span>, IdGeneator.class);</span><br><span class=\"line\">    instance = <span class=\"literal\">null</span>; <span class=\"comment\">//释放对象</span></span><br><span class=\"line\">    lock.unlock();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"type\">long</span> <span class=\"title function_\">getId</span><span class=\"params\">()</span> &#123; </span><br><span class=\"line\">    <span class=\"keyword\">return</span> id.incrementAndGet();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// IdGenerator使用举例</span></span><br><span class=\"line\"><span class=\"type\">IdGenerator</span> <span class=\"variable\">idGeneator</span> <span class=\"operator\">=</span> IdGenerator.getInstance();</span><br><span class=\"line\"><span class=\"type\">long</span> <span class=\"variable\">id</span> <span class=\"operator\">=</span> idGenerator.getId();</span><br><span class=\"line\">IdGenerator.freeInstance();</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"如何实现一个多例模式？\"><a href=\"#如何实现一个多例模式？\" class=\"headerlink\" title=\"如何实现一个多例模式？\"></a>如何实现一个多例模式？</h2><p>跟单例模式概念相对应的还有一个多例模式。那如何实现一个多例模式呢？“单例”指的是，一个类只能创建一个对象。对应地，“多例”指的就是，一个类可以创建多个对象，但是个数是有限制的，比如只能创建 3 个对象。如果用代码来简单示例一下的话，就是下面这个样子：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">BackendServer</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"type\">long</span> serverNo;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> String serverAddress;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">SERVER_COUNT</span> <span class=\"operator\">=</span> <span class=\"number\">3</span>;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Map&lt;Long, BackendServer&gt; serverInstances = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">    serverInstances.put(<span class=\"number\">1L</span>, <span class=\"keyword\">new</span> <span class=\"title class_\">BackendServer</span>(<span class=\"number\">1L</span>, <span class=\"string\">&quot;192.134.22.138:8080&quot;</span>));</span><br><span class=\"line\">    serverInstances.put(<span class=\"number\">2L</span>, <span class=\"keyword\">new</span> <span class=\"title class_\">BackendServer</span>(<span class=\"number\">2L</span>, <span class=\"string\">&quot;192.134.22.139:8080&quot;</span>));</span><br><span class=\"line\">    serverInstances.put(<span class=\"number\">3L</span>, <span class=\"keyword\">new</span> <span class=\"title class_\">BackendServer</span>(<span class=\"number\">3L</span>, <span class=\"string\">&quot;192.134.22.140:8080&quot;</span>));</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"title function_\">BackendServer</span><span class=\"params\">(<span class=\"type\">long</span> serverNo, String serverAddress)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.serverNo = serverNo;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.serverAddress = serverAddress;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> BackendServer <span class=\"title function_\">getInstance</span><span class=\"params\">(<span class=\"type\">long</span> serverNo)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> serverInstances.get(serverNo);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> BackendServer <span class=\"title function_\">getRandomInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">Random</span> <span class=\"variable\">r</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Random</span>();</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">no</span> <span class=\"operator\">=</span> r.nextInt(SERVER_COUNT)+<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> serverInstances.get(no);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>实际上，对于多例模式，还有一种理解方式：同一类型的只能创建一个对象，不同类型的可以创建多个对象。这里的“类型”如何理解呢？我们还是通过一个例子来解释一下，具体代码如下所示。在代码中，logger name 就是刚刚说的“类型”，同一个 logger name 获取到的对象实例是相同的，不同的 logger name 获取到的对象实例是不同的。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Logger</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> ConcurrentHashMap&lt;String, Logger&gt; instances</span><br><span class=\"line\">          = <span class=\"keyword\">new</span> <span class=\"title class_\">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"title function_\">Logger</span><span class=\"params\">()</span> &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Logger <span class=\"title function_\">getInstance</span><span class=\"params\">(String loggerName)</span> &#123;</span><br><span class=\"line\">    instances.putIfAbsent(loggerName, <span class=\"keyword\">new</span> <span class=\"title class_\">Logger</span>());</span><br><span class=\"line\">    <span class=\"keyword\">return</span> instances.get(loggerName);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">log</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//l1==l2, l1!=l3</span></span><br><span class=\"line\"><span class=\"type\">Logger</span> <span class=\"variable\">l1</span> <span class=\"operator\">=</span> Logger.getInstance(<span class=\"string\">&quot;User.class&quot;</span>);</span><br><span class=\"line\"><span class=\"type\">Logger</span> <span class=\"variable\">l2</span> <span class=\"operator\">=</span> Logger.getInstance(<span class=\"string\">&quot;User.class&quot;</span>);</span><br><span class=\"line\"><span class=\"type\">Logger</span> <span class=\"variable\">l3</span> <span class=\"operator\">=</span> Logger.getInstance(<span class=\"string\">&quot;Order.class&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n\n\n<p>这种多例模式的理解方式有点类似工厂模式。它跟工厂模式的不同之处是，多例模式创建的对象都是同一个类的对象，而工厂模式创建的是不同子类的对象，关于这一点，后面就会讲到。实际上，它还有点类似享元模式，两者的区别等到我们讲到享元模式的时候再来分析。除此之外，实际上，枚举类型也相当于多例模式，一个类型只能对应一个对象，一个类可以创建多个对象。</p>\n","site":{"data":{}},"cover_type":"img","excerpt":"","more":"<h1 id=\"声明\"><a href=\"#声明\" class=\"headerlink\" title=\"声明\"></a>声明</h1><blockquote>\n<ol>\n<li>此系列文章非本人原创，是学习笔记。</li>\n<li>设计模式系列以后会持续更新，包括已经发布的设计模式文章，因为后续还要再多看一下书，教程和开源项目等，继续润色文章。</li>\n</ol>\n</blockquote>\n<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>23 种经典的设计模式。它们又可以分为三大类：创建型、结构型、行为型。对于这 23 种设计模式的学习，我们要有侧重点，因为有些模式是比较常用的，有些模式是很少被用到的。对于常用的设计模式，我们要花多点时间理解掌握。对于不常用的设计模式，我们只需要稍微了解即可。按照类型和是否常用，对这些设计模式，进行了简单的分类，具体如下所示。</p>\n<h3 id=\"创建型\"><a href=\"#创建型\" class=\"headerlink\" title=\"创建型\"></a>创建型</h3><p>常用的有：单例模式、工厂模式（工厂方法和抽象工厂）、建造者模式。</p>\n<p>不常用的有：原型模式。</p>\n<h3 id=\"结构型\"><a href=\"#结构型\" class=\"headerlink\" title=\"结构型\"></a>结构型</h3><p>常用的有：代理模式、桥接模式、装饰者模式、适配器模式。</p>\n<p>不常用的有：门面模式、组合模式、享元模式。 </p>\n<h3 id=\"行为型\"><a href=\"#行为型\" class=\"headerlink\" title=\"行为型\"></a>行为型</h3><p>常用的有：观察者模式、模板模式、策略模式、职责链模式、迭代器模式、状态模式。</p>\n<p>不常用的有：访问者模式、备忘录模式、命令模式、解释器模式、中介模式。</p>\n<h1 id=\"单例模式【常用】\"><a href=\"#单例模式【常用】\" class=\"headerlink\" title=\"单例模式【常用】\"></a>单例模式【常用】</h1><p>网上有很多讲解单例模式的文章，但大部分都侧重讲解，如何来实现一个线程安全的单例。今天也会讲到各种单例的实现方法，但是，重点还是希望带你搞清楚下面这样几个问题。</p>\n<ul>\n<li>为什么要使用单例？</li>\n<li>单例存在哪些问题？</li>\n<li>单例与静态类的区别？</li>\n<li>有何替代的解决方案？</li>\n</ul>\n<h2 id=\"为什么要使用单例？\"><a href=\"#为什么要使用单例？\" class=\"headerlink\" title=\"为什么要使用单例？\"></a>为什么要使用单例？</h2><p>单例设计模式（Singleton Design Pattern）理解起来非常简单。一个类只允许创建一个对象（或者实例），那这个类就是一个单例类，这种设计模式就叫作单例设计模式，简称单例模式。</p>\n<p>对于单例的概念，我觉得没必要解释太多，你一看就能明白。我们重点看一下，为什么我们需要单例这种设计模式？它能解决哪些问题？接下来我通过两个实战案例来讲解。</p>\n<h3 id=\"实战案例一：处理资源访问冲突\"><a href=\"#实战案例一：处理资源访问冲突\" class=\"headerlink\" title=\"实战案例一：处理资源访问冲突\"></a>实战案例一：处理资源访问冲突</h3><p>我们先来看第一个例子。在这个例子中，我们自定义实现了一个往文件中打印日志的 Logger 类。具体的代码实现如下所示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Logger</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> FileWriter writer;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"title function_\">Logger</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">File</span> <span class=\"variable\">file</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">File</span>(<span class=\"string\">&quot;/Users/wangzheng/log.txt&quot;</span>);</span><br><span class=\"line\">    writer = <span class=\"keyword\">new</span> <span class=\"title class_\">FileWriter</span>(file, <span class=\"literal\">true</span>); <span class=\"comment\">//true表示追加写入</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">log</span><span class=\"params\">(String message)</span> &#123;</span><br><span class=\"line\">    writer.write(message);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Logger类的应用示例：</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">UserController</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"type\">Logger</span> <span class=\"variable\">logger</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Logger</span>();</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">login</span><span class=\"params\">(String username, String password)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...省略业务逻辑代码...</span></span><br><span class=\"line\">    logger.log(username + <span class=\"string\">&quot; logined!&quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">OrderController</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"type\">Logger</span> <span class=\"variable\">logger</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Logger</span>();</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">create</span><span class=\"params\">(OrderVo order)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...省略业务逻辑代码...</span></span><br><span class=\"line\">    logger.log(<span class=\"string\">&quot;Created an order: &quot;</span> + order.toString());</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在上面的代码中，我们注意到，所有的日志都写入到同一个文件 &#x2F;Users&#x2F;wangzheng&#x2F;log.txt 中。在 UserController 和 OrderController 中，我们分别创建两个 Logger 对象。在 Web 容器的 Servlet 多线程环境下，如果两个 Servlet 线程同时分别执行 login() 和 create() 两个函数，并且同时写日志到 log.txt 文件中，那就有可能存在日志信息互相覆盖的情况。【这属于并发的知识点，看不懂的可以看笔者的并发系列】</p>\n<p>那如何来解决这个问题呢？我们最先想到的就是通过加锁的方式：给 log() 函数加互斥锁，同一时刻只允许一个线程调用执行 log() 函数。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Logger</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> FileWriter writer;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"title function_\">Logger</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">File</span> <span class=\"variable\">file</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">File</span>(<span class=\"string\">&quot;/Users/wangzheng/log.txt&quot;</span>);</span><br><span class=\"line\">    writer = <span class=\"keyword\">new</span> <span class=\"title class_\">FileWriter</span>(file, <span class=\"literal\">true</span>); <span class=\"comment\">//true表示追加写入</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">log</span><span class=\"params\">(String message)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span>(<span class=\"built_in\">this</span>) &#123;</span><br><span class=\"line\">      writer.write(mesasge);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>synchronized(this)</code>这种对象级别的锁，锁不住，因为不同的对象之间并不共享同一把锁。所以我们换成类级别的锁。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Logger</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> FileWriter writer;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"title function_\">Logger</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">File</span> <span class=\"variable\">file</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">File</span>(<span class=\"string\">&quot;/Users/wangzheng/log.txt&quot;</span>);</span><br><span class=\"line\">    writer = <span class=\"keyword\">new</span> <span class=\"title class_\">FileWriter</span>(file, <span class=\"literal\">true</span>); <span class=\"comment\">//true表示追加写入</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">log</span><span class=\"params\">(String message)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span>(Logger.class) &#123; <span class=\"comment\">// 类级别的锁</span></span><br><span class=\"line\">      writer.write(mesasge);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>除了使用类级别锁之外，实际上，解决资源竞争问题的办法还有很多，分布式锁是最常听到的一种解决方案。不过，实现一个安全可靠、无 bug、高性能的分布式锁，并不是件容易的事情。除此之外，并发队列（比如 Java 中的 BlockingQueue）也可以解决这个问题：多个线程同时往并发队列里写日志，一个单独的线程负责将并发队列中的数据，写入到日志文件。这种方式实现起来也稍微有点复杂。</p>\n<p>相对于这两种解决方案，单例模式的解决思路就简单一些了。单例模式相对于之前类级别锁的好处是，不用创建那么多 Logger 对象，一方面节省内存空间，另一方面节省系统文件句柄（对于操作系统来说，文件句柄也是一种资源，不能随便浪费）。</p>\n<p>我们将 Logger 设计成一个单例类，程序中只允许创建一个 Logger 对象，所有的线程共享使用的这一个 Logger 对象，共享一个 FileWriter 对象，而 FileWriter 本身是对象级别线程安全的，也就避免了多线程情况下写日志会互相覆盖的问题。按照这个设计思路，我们实现了 Logger 单例类。具体代码如下所示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Logger</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> FileWriter writer;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">Logger</span> <span class=\"variable\">instance</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Logger</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"title function_\">Logger</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">File</span> <span class=\"variable\">file</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">File</span>(<span class=\"string\">&quot;/Users/wangzheng/log.txt&quot;</span>);</span><br><span class=\"line\">    writer = <span class=\"keyword\">new</span> <span class=\"title class_\">FileWriter</span>(file, <span class=\"literal\">true</span>); <span class=\"comment\">//true表示追加写入</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Logger <span class=\"title function_\">getInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">log</span><span class=\"params\">(String message)</span> &#123;</span><br><span class=\"line\">    writer.write(mesasge);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Logger类的应用示例：</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">UserController</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">login</span><span class=\"params\">(String username, String password)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...省略业务逻辑代码...</span></span><br><span class=\"line\">    Logger.getInstance().log(username + <span class=\"string\">&quot; logined!&quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">OrderController</span> &#123;  </span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">create</span><span class=\"params\">(OrderVo order)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...省略业务逻辑代码...</span></span><br><span class=\"line\">    Logger.getInstance().log(<span class=\"string\">&quot;Created a order: &quot;</span> + order.toString());</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"实战案例二：表示全局唯一类\"><a href=\"#实战案例二：表示全局唯一类\" class=\"headerlink\" title=\"实战案例二：表示全局唯一类\"></a>实战案例二：表示全局唯一类</h3><p>从业务概念上，如果有些数据在系统中只应保存一份，那就比较适合设计为单例类。比如，配置信息类。在系统中，我们只有一个配置文件，当配置文件被加载到内存之后，以对象的形式存在，也理所应当只有一份。</p>\n<p>再比如，唯一递增 ID 号码生成器。如果程序中有两个对象，那就会存在生成重复 ID 的情况，所以，我们应该将 ID 生成器类设计为单例。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">IdGenerator</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// AtomicLong是一个Java并发库中提供的一个原子变量类型,</span></span><br><span class=\"line\">  <span class=\"comment\">// 它将一些线程不安全需要加锁的复合操作封装为了线程安全的原子操作，</span></span><br><span class=\"line\">  <span class=\"comment\">// 比如下面会用到的incrementAndGet().</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"type\">AtomicLong</span> <span class=\"variable\">id</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">AtomicLong</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">IdGenerator</span> <span class=\"variable\">instance</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IdGenerator</span>();</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"title function_\">IdGenerator</span><span class=\"params\">()</span> &#123;&#125;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> IdGenerator <span class=\"title function_\">getInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"type\">long</span> <span class=\"title function_\">getId</span><span class=\"params\">()</span> &#123; </span><br><span class=\"line\">    <span class=\"keyword\">return</span> id.incrementAndGet();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// IdGenerator使用举例</span></span><br><span class=\"line\"><span class=\"type\">long</span> <span class=\"variable\">id</span> <span class=\"operator\">=</span> IdGenerator.getInstance().getId();</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"如何实现一个单例？\"><a href=\"#如何实现一个单例？\" class=\"headerlink\" title=\"如何实现一个单例？\"></a>如何实现一个单例？</h2><p>尽管介绍如何实现一个单例模式的文章已经有很多了，但为了保证内容的完整性，我这里还是简单介绍一下几种经典实现方式。概括起来，要实现一个单例，我们需要关注的点无外乎下面几个：</p>\n<ul>\n<li><p>构造函数需要是 private 访问权限的，这样才能避免外部通过 new 创建实例；</p>\n</li>\n<li><p>考虑对象创建时的线程安全问题；</p>\n</li>\n<li><p>考虑是否支持延迟加载；</p>\n</li>\n<li><p>考虑 getInstance() 性能是否高（是否加锁）。</p>\n</li>\n</ul>\n<h3 id=\"饿汉式-静态变量\"><a href=\"#饿汉式-静态变量\" class=\"headerlink\" title=\"饿汉式(静态变量)\"></a>饿汉式(静态变量)</h3><p>饿汉式的实现方式比较简单。在类加载的时候，instance 静态实例就已经创建并初始化好了，所以，instance 实例的创建过程是线程安全的。不过，这样的实现方式不支持延迟加载（在真正用到 IdGenerator 的时候，再创建实例），从名字中我们也可以看出这一点。具体的代码实现如下所示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">IdGenerator</span> &#123; </span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"type\">AtomicLong</span> <span class=\"variable\">id</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">AtomicLong</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">IdGenerator</span> <span class=\"variable\">instance</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IdGenerator</span>();</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"title function_\">IdGenerator</span><span class=\"params\">()</span> &#123;&#125;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> IdGenerator <span class=\"title function_\">getInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"type\">long</span> <span class=\"title function_\">getId</span><span class=\"params\">()</span> &#123; </span><br><span class=\"line\">    <span class=\"keyword\">return</span> id.incrementAndGet();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<ol>\n<li>有人觉得这种实现方式不好，因为不支持延迟加载，如果实例占用资源多（比如占用内存多）或初始化耗时长（比如需要加载各种配置文件），提前初始化实例是一种浪费资源的行为。最好的方法应该在用到的时候再去初始化。不过，我个人并不认同这样的观点</li>\n<li>如果初始化耗时长，那我们最好不要等到真正要用它的时候，才去执行这个耗时长的初始化过程，这会影响到系统的性能（比如，在响应客户端接口请求的时候，做这个初始化操作，会导致此请求的响应时间变长，甚至超时）。采用饿汉式实现方式，将耗时的初始化操作，提前到程序启动的时候完成，这样就能避免在程序运行的时候，再去初始化导致的性能问题。</li>\n<li>如果实例占用资源多，按照 fail-fast 的设计原则（有问题及早暴露），那我们也希望在程序启动时就将这个实例初始化好。如果资源不够，就会在程序启动的时候触发报错（比如 Java 中的 PermGen Space OOM），我们可以立即去修复。这样也能避免在程序运行一段时间后，突然因为初始化这个实例占用资源过多，导致系统崩溃，影响系统的可用性。(如果初始化消耗资源过多，反而推荐懒汉式，早日发现问题)</li>\n</ol>\n<h3 id=\"饿汉式-静态代码块\"><a href=\"#饿汉式-静态代码块\" class=\"headerlink\" title=\"饿汉式(静态代码块)\"></a>饿汉式(静态代码块)</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">SingletonTest02</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 测试</span></span><br><span class=\"line\">    <span class=\"type\">Singleton</span> <span class=\"variable\">instance</span> <span class=\"operator\">=</span> Singleton.getInstance();</span><br><span class=\"line\">    <span class=\"type\">Singleton</span> <span class=\"variable\">instance2</span> <span class=\"operator\">=</span> Singleton.getInstance();</span><br><span class=\"line\">    System.out.println(instance == instance2); <span class=\"comment\">// true</span></span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;instance.hashCode=&quot;</span> + instance.hashCode());</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;instance2.hashCode=&quot;</span> + instance2.hashCode());</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 饿汉式(静态变量)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Singleton</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 1. 构造器私有化</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"title function_\">Singleton</span><span class=\"params\">()</span> &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 2.本类内部创建对象实例</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Singleton instance;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">static</span> &#123; <span class=\"comment\">// 在静态代码块中，创建单例对象</span></span><br><span class=\"line\">    instance = <span class=\"keyword\">new</span> <span class=\"title class_\">Singleton</span>();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 3. 提供一个公有的静态方法，返回实例对象</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title function_\">getInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>没什么好说的，就是静态变量换成了静态代码块。</p>\n<h3 id=\"懒汉式-线程安全，同步方法\"><a href=\"#懒汉式-线程安全，同步方法\" class=\"headerlink\" title=\"懒汉式(线程安全，同步方法)\"></a>懒汉式(线程安全，同步方法)</h3><p>懒汉式相对于饿汉式的优势是支持延迟加载。具体的代码实现如下所示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">IdGenerator</span> &#123; </span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"type\">AtomicLong</span> <span class=\"variable\">id</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">AtomicLong</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> IdGenerator instance;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"title function_\">IdGenerator</span><span class=\"params\">()</span> &#123;&#125;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">synchronized</span> IdGenerator <span class=\"title function_\">getInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (instance == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      instance = <span class=\"keyword\">new</span> <span class=\"title class_\">IdGenerator</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"type\">long</span> <span class=\"title function_\">getId</span><span class=\"params\">()</span> &#123; </span><br><span class=\"line\">    <span class=\"keyword\">return</span> id.incrementAndGet();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>不过懒汉式的缺点也很明显，我们给 getInstance() 这个方法加了一把大锁（synchronzed），导致这个函数的并发度很低。而这个函数是在单例使用期间，一直会被调用。如果这个单例类偶尔会被用到，那这种实现方式还可以接受。但是，如果频繁地用到，那频繁加锁、释放锁及并发度低等问题，会导致性能瓶颈，这种实现方式就不可取了。</p>\n<h3 id=\"懒汉式-线程安全，同步代码块\"><a href=\"#懒汉式-线程安全，同步代码块\" class=\"headerlink\" title=\"懒汉式(线程安全，同步代码块)\"></a>懒汉式(线程安全，同步代码块)</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 懒汉式(线程安全，同步代码块)</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Singleton</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Singleton instance;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"title function_\">Singleton</span><span class=\"params\">()</span> &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title function_\">getInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (instance == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">synchronized</span> (Singleton.class) &#123;</span><br><span class=\"line\">        instance = <span class=\"keyword\">new</span> <span class=\"title class_\">Singleton</span>();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"懒汉式-线程不安全\"><a href=\"#懒汉式-线程不安全\" class=\"headerlink\" title=\"懒汉式(线程不安全)\"></a>懒汉式(线程不安全)</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Singleton</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Singleton instance;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"title function_\">Singleton</span><span class=\"params\">()</span> &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 提供一个静态的公有方法，当使用到该方法时，才去创建 instance</span></span><br><span class=\"line\">  <span class=\"comment\">// 即懒汉式</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title function_\">getInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (instance == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      instance = <span class=\"keyword\">new</span> <span class=\"title class_\">Singleton</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n<p>只是为了完整性，写了出来，实际开发不推荐用线程不安全的</p>\n<h3 id=\"双重检测\"><a href=\"#双重检测\" class=\"headerlink\" title=\"双重检测\"></a>双重检测</h3><p>饿汉式不支持延迟加载，懒汉式有性能问题，不支持高并发。那我们再来看一种既支持延迟加载、又支持高并发的单例实现方式，也就是双重检测实现方式。在这种实现方式中，只要 instance 被创建之后，即便再调用 getInstance() 函数也不会再进入到加锁逻辑中了。所以，这种实现方式解决了懒汉式并发度低的问题。具体的代码实现如下所示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">IdGenerator</span> &#123; </span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"type\">AtomicLong</span> <span class=\"variable\">id</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">AtomicLong</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> IdGenerator instance;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"title function_\">IdGenerator</span><span class=\"params\">()</span> &#123;&#125;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> IdGenerator <span class=\"title function_\">getInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (instance == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">synchronized</span>(IdGenerator.class) &#123; <span class=\"comment\">// 此处为类级别的锁</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (instance == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">          instance = <span class=\"keyword\">new</span> <span class=\"title class_\">IdGenerator</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"type\">long</span> <span class=\"title function_\">getId</span><span class=\"params\">()</span> &#123; </span><br><span class=\"line\">    <span class=\"keyword\">return</span> id.incrementAndGet();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>这种实现方式有些问题。因为指令重排序，可能会导致 IdGenerator 对象被 new 出来，并且赋值给 instance 之后，还没来得及初始化（执行构造函数中的代码逻辑），就被另一个线程使用了。要解决这个问题，我们需要给 instance 成员变量加上 volatile 关键字，禁止指令重排序才行。</p>\n<p>据说，只有很低版本的 Java 才会有这个问题。我们现在用的高版本的 Java 已经在 JDK 内部实现中解决了这个问题（解决的方法很简单，只要把对象 new 操作和初始化操作设计为原子操作，就自然能禁止重排序）。</p>\n<h3 id=\"静态内部类\"><a href=\"#静态内部类\" class=\"headerlink\" title=\"静态内部类\"></a>静态内部类</h3><p>我们再来看一种比双重检测更加简单的实现方法，那就是利用 Java 的静态内部类。它有点类似饿汉式，但又能做到了延迟加载。具体是怎么做到的呢？我们先来看它的代码实现</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">IdGenerator</span> &#123; </span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"type\">AtomicLong</span> <span class=\"variable\">id</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">AtomicLong</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"title function_\">IdGenerator</span><span class=\"params\">()</span> &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">SingletonHolder</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">IdGenerator</span> <span class=\"variable\">instance</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IdGenerator</span>();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> IdGenerator <span class=\"title function_\">getInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> SingletonHolder.instance;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"type\">long</span> <span class=\"title function_\">getId</span><span class=\"params\">()</span> &#123; </span><br><span class=\"line\">    <span class=\"keyword\">return</span> id.incrementAndGet();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>SingletonHolder 是一个静态内部类，当外部类 IdGenerator 被加载的时候，并不会创建 SingletonHolder 实例对象。只有当调用 getInstance() 方法时，SingletonHolder 才会被加载，这个时候才会创建 instance。instance 的唯一性、创建过程的线程安全性，都由 JVM 来保证。所以，这种实现方法既保证了线程安全，又能做到延迟加载。</p>\n<h3 id=\"枚举\"><a href=\"#枚举\" class=\"headerlink\" title=\"枚举\"></a>枚举</h3><p>最后，我们介绍一种最简单的实现方式，基于枚举类型的单例实现。这种实现方式通过 Java 枚举类型本身的特性，保证了实例创建的线程安全性和实例的唯一性。具体的代码如下所示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">enum</span> <span class=\"title class_\">IdGenerator</span> &#123;</span><br><span class=\"line\">  INSTANCE;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"type\">AtomicLong</span> <span class=\"variable\">id</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">AtomicLong</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"type\">long</span> <span class=\"title function_\">getId</span><span class=\"params\">()</span> &#123; </span><br><span class=\"line\">    <span class=\"keyword\">return</span> id.incrementAndGet();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"单例存在哪些问题\"><a href=\"#单例存在哪些问题\" class=\"headerlink\" title=\"单例存在哪些问题?\"></a>单例存在哪些问题?</h2><p>尽管单例是一个很常用的设计模式，在实际的开发中，我们也确实经常用到它，但是，有些人认为单例是一种反模式（anti-pattern），并不推荐使用。大部分情况下，我们在项目中使用单例，都是用它来表示一些全局唯一类，比如配置信息类、连接池类、ID 生成器类。单例模式书写简洁、使用方便，在代码中，我们不需要创建对象，直接通过类似 IdGenerator.getInstance().getId() 这样的方法来调用就可以了。但是，这种使用方法有点类似硬编码（hard code），会带来诸多问题。接下来，我们就具体看看到底有哪些问题。</p>\n<h3 id=\"单例对-OOP-特性的支持不友好\"><a href=\"#单例对-OOP-特性的支持不友好\" class=\"headerlink\" title=\"单例对 OOP 特性的支持不友好\"></a>单例对 OOP 特性的支持不友好</h3><p>我们知道，OOP 的四大特性是封装、抽象、继承、多态。单例这种设计模式对于其中的抽象、继承、多态都支持得不好。为什么这么说呢？我们还是通过 IdGenerator 这个例子来讲解。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Order</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">create</span><span class=\"params\">(...)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"variable\">id</span> <span class=\"operator\">=</span> IdGenerator.getInstance().getId();</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">User</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">create</span><span class=\"params\">(...)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"variable\">id</span> <span class=\"operator\">=</span> IdGenerator.getInstance().getId();</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>IdGenerator 的使用方式违背了基于接口而非实现的设计原则，也就违背了广义上理解的 OOP 的抽象特性。如果未来某一天，我们希望针对不同的业务采用不同的 ID 生成算法。比如，订单 ID 和用户 ID 采用不同的 ID 生成器来生成。为了应对这个需求变化，我们需要修改所有用到 IdGenerator 类的地方，这样代码的改动就会比较大。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Order</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">create</span><span class=\"params\">(...)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"variable\">id</span> <span class=\"operator\">=</span> IdGenerator.getInstance().getId();</span><br><span class=\"line\">    <span class=\"comment\">// 需要将上面一行代码，替换为下面一行代码</span></span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"variable\">id</span> <span class=\"operator\">=</span> OrderIdGenerator.getIntance().getId();</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">User</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">create</span><span class=\"params\">(...)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"variable\">id</span> <span class=\"operator\">=</span> IdGenerator.getInstance().getId();</span><br><span class=\"line\">    <span class=\"comment\">// 需要将上面一行代码，替换为下面一行代码</span></span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"variable\">id</span> <span class=\"operator\">=</span> UserIdGenerator.getIntance().getId();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>除此之外，单例对继承、多态特性的支持也不友好。这里我之所以会用“不友好”这个词，而非“完全不支持”，是因为从理论上来讲，单例类也可以被继承、也可以实现多态，只是实现起来会非常奇怪，会导致代码的可读性变差。不明白设计意图的人，看到这样的设计，会觉得莫名其妙。所以，一旦你选择将某个类设计成到单例类，也就意味着放弃了继承和多态这两个强有力的面向对象特性，也就相当于损失了可以应对未来需求变化的扩展性</p>\n<h3 id=\"单例会隐藏类之间的依赖关系\"><a href=\"#单例会隐藏类之间的依赖关系\" class=\"headerlink\" title=\"单例会隐藏类之间的依赖关系\"></a>单例会隐藏类之间的依赖关系</h3><p>我们知道，代码的可读性非常重要。在阅读代码的时候，我们希望一眼就能看出类与类之间的依赖关系，搞清楚这个类依赖了哪些外部类。通过构造函数、参数传递等方式声明的类之间的依赖关系，我们通过查看函数的定义，就能很容易识别出来。但是，单例类不需要显示创建、不需要依赖参数传递，在函数中直接调用就可以了。如果代码比较复杂，这种调用关系就会非常隐蔽。在阅读代码的时候，我们就需要仔细查看每个函数的代码实现，才能知道这个类到底依赖了哪些单例类。</p>\n<h3 id=\"单例对代码的扩展性不友好\"><a href=\"#单例对代码的扩展性不友好\" class=\"headerlink\" title=\"单例对代码的扩展性不友好\"></a>单例对代码的扩展性不友好</h3><ol>\n<li>我们知道，单例类只能有一个对象实例。如果未来某一天，我们需要在代码中创建两个实例或多个实例，那就要对代码有比较大的改动。你可能会说，会有这样的需求吗？既然单例类大部分情况下都用来表示全局类，怎么会需要两个或者多个实例呢？</li>\n<li>实际上，这样的需求并不少见。我们拿数据库连接池来举例解释一下。</li>\n<li>在系统设计初期，我们觉得系统中只应该有一个数据库连接池，这样能方便我们控制对数据库连接资源的消耗。所以，我们把数据库连接池类设计成了单例类。但之后我们发现，系统中有些 SQL 语句运行得非常慢。这些 SQL 语句在执行的时候，长时间占用数据库连接资源，导致其他 SQL 请求无法响应。为了解决这个问题，我们希望将慢 SQL 与其他 SQL 隔离开来执行。为了实现这样的目的，我们可以在系统中创建两个数据库连接池，慢 SQL 独享一个数据库连接池，其他 SQL 独享另外一个数据库连接池，这样就能避免慢 SQL 影响到其他 SQL 的执行。</li>\n<li>如果我们将数据库连接池设计成单例类，显然就无法适应这样的需求变更，也就是说，单例类在某些情况下会影响代码的扩展性、灵活性。所以，数据库连接池、线程池这类的资源池，最好还是不要设计成单例类。实际上，一些开源的数据库连接池、线程池也确实没有设计成单例类。</li>\n</ol>\n<h3 id=\"单例对代码的可测试性不友好\"><a href=\"#单例对代码的可测试性不友好\" class=\"headerlink\" title=\"单例对代码的可测试性不友好\"></a>单例对代码的可测试性不友好</h3><ol>\n<li><p>单例模式的使用会影响到代码的可测试性。如果单例类依赖比较重的外部资源，比如 DB，我们在写单元测试的时候，希望能通过 mock 的方式将它替换掉。而单例类这种硬编码式的使用方式，导致无法实现 mock 替换。</p>\n</li>\n<li><p>除此之外，如果单例类持有成员变量（比如 IdGenerator 中的 id 成员变量），那它实际上相当于一种全局变量，被所有的代码共享。如果这个全局变量是一个可变全局变量，也就是说，它的成员变量是可以被修改的，那我们在编写单元测试的时候，还需要注意不同测试用例之间，修改了单例类中的同一个成员变量的值，从而导致测试结果互相影响的问题。</p>\n</li>\n</ol>\n<h3 id=\"单例不支持有参数的构造函数\"><a href=\"#单例不支持有参数的构造函数\" class=\"headerlink\" title=\"单例不支持有参数的构造函数\"></a>单例不支持有参数的构造函数</h3><p>单例不支持有参数的构造函数，比如我们创建一个连接池的单例对象，我们没法通过参数来指定连接池的大小。针对这个问题，我们来看下都有哪些解决方案。</p>\n<p><strong>第一种解决思路是</strong>：创建完实例之后，再调用 init() 函数传递参数。需要注意的是，我们在使用这个单例类的时候，要先调用 init() 方法，然后才能调用 getInstance() 方法，否则代码会抛出异常。具体的代码实现如下所示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Singleton</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">Singleton</span> <span class=\"variable\">instance</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> paramA;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> paramB;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"title function_\">Singleton</span><span class=\"params\">(<span class=\"type\">int</span> paramA, <span class=\"type\">int</span> paramB)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.paramA = paramA;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.paramB = paramB;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title function_\">getInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (instance == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">       <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RuntimeException</span>(<span class=\"string\">&quot;Run init() first.&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">static</span> Singleton <span class=\"title function_\">init</span><span class=\"params\">(<span class=\"type\">int</span> paramA, <span class=\"type\">int</span> paramB)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (instance != <span class=\"literal\">null</span>)&#123;</span><br><span class=\"line\">       <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RuntimeException</span>(<span class=\"string\">&quot;Singleton has been created!&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    instance = <span class=\"keyword\">new</span> <span class=\"title class_\">Singleton</span>(paramA, paramB);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Singleton.init(<span class=\"number\">10</span>, <span class=\"number\">50</span>); <span class=\"comment\">// 先init，再使用</span></span><br><span class=\"line\"><span class=\"type\">Singleton</span> <span class=\"variable\">singleton</span> <span class=\"operator\">=</span> Singleton.getInstance();</span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>第二种解决思路是</strong>：将参数放到 getIntance() 方法中。具体的代码实现如下所示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Singleton</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">Singleton</span> <span class=\"variable\">instance</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> paramA;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> paramB;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"title function_\">Singleton</span><span class=\"params\">(<span class=\"type\">int</span> paramA, <span class=\"type\">int</span> paramB)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.paramA = paramA;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.paramB = paramB;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">static</span> Singleton <span class=\"title function_\">getInstance</span><span class=\"params\">(<span class=\"type\">int</span> paramA, <span class=\"type\">int</span> paramB)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (instance == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      instance = <span class=\"keyword\">new</span> <span class=\"title class_\">Singleton</span>(paramA, paramB);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">Singleton</span> <span class=\"variable\">singleton</span> <span class=\"operator\">=</span> Singleton.getInstance(<span class=\"number\">10</span>, <span class=\"number\">50</span>);</span><br></pre></td></tr></table></figure>\n\n\n\n<p>不知道你有没有发现，上面的代码实现稍微有点问题。如果我们如下两次执行 getInstance() 方法，那获取到的 singleton1 和 signleton2 的 paramA 和 paramB 都是 10 和 50。也就是说，第二次的参数（20，30）没有起作用，而构建的过程也没有给与提示，这样就会误导用户。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Singleton</span> <span class=\"variable\">singleton1</span> <span class=\"operator\">=</span> Singleton.getInstance(<span class=\"number\">10</span>, <span class=\"number\">50</span>);</span><br><span class=\"line\"><span class=\"type\">Singleton</span> <span class=\"variable\">singleton2</span> <span class=\"operator\">=</span> Singleton.getInstance(<span class=\"number\">20</span>, <span class=\"number\">30</span>);</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<p><strong>第三种解决思路是</strong>：将参数放到另外一个全局变量中。具体的代码实现如下。Config 是一个存储了 paramA 和 paramB 值的全局变量。里面的值既可以像下面的代码那样通过静态常量来定义，也可以从配置文件中加载得到。<strong>实际上，这种方式是最值得推荐的。</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Config</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">PARAM_A</span> <span class=\"operator\">=</span> <span class=\"number\">123</span>;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">PARAM_B</span> <span class=\"operator\">=</span> <span class=\"number\">245</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Singleton</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">Singleton</span> <span class=\"variable\">instance</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> paramA;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> paramB;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"title function_\">Singleton</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.paramA = Config.PARAM_A;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.paramB = Config.PARAM_B;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">static</span> Singleton <span class=\"title function_\">getInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (instance == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      instance = <span class=\"keyword\">new</span> <span class=\"title class_\">Singleton</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"有何替代解决方案？\"><a href=\"#有何替代解决方案？\" class=\"headerlink\" title=\"有何替代解决方案？\"></a>有何替代解决方案？</h2><p>刚刚我们提到了单例的很多问题，你可能会说，即便单例有这么多问题，但我不用不行啊。我业务上有表示全局唯一类的需求，如果不用单例，我怎么才能保证这个类的对象全局唯一呢？为了保证全局唯一，除了使用单例，我们还可以用静态方法来实现。这也是项目开发中经常用到的一种实现思路。比如， ID 唯一递增生成器的例子，用静态方法实现一下，就是下面这个样子：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 静态方法实现方式</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">IdGenerator</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">AtomicLong</span> <span class=\"variable\">id</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">AtomicLong</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"type\">long</span> <span class=\"title function_\">getId</span><span class=\"params\">()</span> &#123; </span><br><span class=\"line\">    <span class=\"keyword\">return</span> id.incrementAndGet();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 使用举例</span></span><br><span class=\"line\"><span class=\"type\">long</span> <span class=\"variable\">id</span> <span class=\"operator\">=</span> IdGenerator.getId();</span><br></pre></td></tr></table></figure>\n\n<p>不过，静态方法这种实现思路，并不能解决我们之前提到的问题。实际上，它比单例更加不灵活，比如，它无法支持延迟加载。我们再来看看有没有其他办法。实际上，单例除了我们之前讲到的使用方法之外，还有另外一种使用方法。具体的代码如下所示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 1. 老的使用方式</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"title function_\">demofunction</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">//...</span></span><br><span class=\"line\">  <span class=\"type\">long</span> <span class=\"variable\">id</span> <span class=\"operator\">=</span> IdGenerator.getInstance().getId();</span><br><span class=\"line\">  <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 2. 新的使用方式：依赖注入</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"title function_\">demofunction</span><span class=\"params\">(IdGenerator idGenerator)</span> &#123;</span><br><span class=\"line\">  <span class=\"type\">long</span> <span class=\"variable\">id</span> <span class=\"operator\">=</span> idGenerator.getId();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 外部调用demofunction()的时候，传入idGenerator</span></span><br><span class=\"line\"><span class=\"type\">IdGenerator</span> <span class=\"variable\">idGenerator</span> <span class=\"operator\">=</span> IdGenerator.getInsance();</span><br><span class=\"line\">demofunction(idGenerator);</span><br></pre></td></tr></table></figure>\n\n\n\n<ol>\n<li>基于新的使用方式，我们将单例生成的对象，作为参数传递给函数（也可以通过构造函数传递给类的成员变量），可以解决单例隐藏类之间依赖关系的问题。不过，对于单例存在的其他问题，比如对 OOP 特性、扩展性、可测性不友好等问题，还是无法解决。</li>\n<li>所以，如果要完全解决这些问题，我们可能要从根上，寻找其他方式来实现全局唯一类。实际上，类对象的全局唯一性可以通过多种不同的方式来保证。我们既可以通过单例模式来强制保证，也可以通过工厂模式、IOC 容器（比如 Spring IOC 容器）来保证，还可以通过程序员自己来保证（自己在编写代码的时候自己保证不要创建两个类对象）。这就类似 Java 中内存对象的释放由 JVM 来负责，而 C++ 中由程序员自己负责，道理是一样的。</li>\n<li>对于替代方案工厂模式、IOC 容器的详细讲解，我们放到后面讲解。</li>\n</ol>\n<h2 id=\"如何理解单例模式中的唯一性？\"><a href=\"#如何理解单例模式中的唯一性？\" class=\"headerlink\" title=\"如何理解单例模式中的唯一性？\"></a>如何理解单例模式中的唯一性？</h2><ol>\n<li>首先，我们重新看一下单例的定义：“一个类只允许创建唯一一个对象（或者实例），那这个类就是一个单例类，这种设计模式就叫作单例设计模式，简称单例模式。</li>\n<li>”定义中提到，“一个类只允许创建唯一一个对象”。那对象的唯一性的作用范围是什么呢？是指线程内只允许创建一个对象，还是指进程内只允许创建一个对象？答案是后者，也就是说，单例模式创建的对象是进程唯一的。这里有点不好理解，我来详细地解释一下。</li>\n<li>我们编写的代码，通过编译、链接，组织在一起，就构成了一个操作系统可以执行的文件，也就是我们平时所说的“可执行文件”（比如 Windows 下的 exe 文件）。可执行文件实际上就是代码被翻译成操作系统可理解的一组指令，你完全可以简单地理解为就是代码本身。</li>\n<li>当我们使用命令行或者双击运行这个可执行文件的时候，操作系统会启动一个进程，将这个执行文件从磁盘加载到自己的进程地址空间（可以理解操作系统为进程分配的内存存储区，用来存储代码和数据）。接着，进程就一条一条地执行可执行文件中包含的代码。比如，当进程读到代码中的 User user &#x3D; new User(); 这条语句的时候，它就在自己的地址空间中创建一个 user 临时变量和一个 User 对象。进程之间是不共享地址空间的，如果我们在一个进程中创建另外一个进程（比如，代码中有一个 fork() 语句，进程执行到这条语句的时候会创建一个新的进程），操作系统会给新进程分配新的地址空间，并且将老进程地址空间的所有内容，重新拷贝一份到新进程的地址空间中，这些内容包括代码、数据（比如 user 临时变量、User 对象）。</li>\n<li>所以，单例类在老进程中存在且只能存在一个对象，在新进程中也会存在且只能存在一个对象。而且，这两个对象并不是同一个对象，这也就说，单例类中对象的唯一性的作用范围是进程内的，在进程间是不唯一的。</li>\n</ol>\n<h2 id=\"如何实现线程唯一的单例？\"><a href=\"#如何实现线程唯一的单例？\" class=\"headerlink\" title=\"如何实现线程唯一的单例？\"></a>如何实现线程唯一的单例？</h2><ol>\n<li><p>刚刚我们讲了单例类对象是进程唯一的，一个进程只能有一个单例对象。那如何实现一个线程唯一的单例呢？</p>\n</li>\n<li><p>我们先来看一下，什么是线程唯一的单例，以及“线程唯一”和“进程唯一”的区别。</p>\n</li>\n<li><p>“进程唯一”指的是进程内唯一，进程间不唯一。类比一下，“线程唯一”指的是线程内唯一，线程间可以不唯一。实际上，“进程唯一”还代表了线程内、线程间都唯一，这也是“进程唯一”和“线程唯一”的区别之处。这段话听起来有点像绕口令，我举个例子来解释一下。</p>\n</li>\n<li><p>假设 IdGenerator 是一个线程唯一的单例类。在线程 A 内，我们可以创建一个单例对象 a。因为线程内唯一，在线程 A 内就不能再创建新的 IdGenerator 对象了，而线程间可以不唯一，所以，在另外一个线程 B 内，我们还可以重新创建一个新的单例对象 b。</p>\n</li>\n<li><p>尽管概念理解起来比较复杂，但线程唯一单例的代码实现很简单，如下所示。在代码中，我们通过一个 HashMap 来存储对象，其中 key 是线程 ID，value 是对象。这样我们就可以做到，不同的线程对应不同的对象，同一个线程只能对应一个对象。实际上，Java 语言本身提供了 ThreadLocal 工具类，可以更加轻松地实现线程唯一单例。不过，ThreadLocal 底层实现原理也是基于下面代码中所示的 HashMap。</p>\n</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">IdGenerator</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"type\">AtomicLong</span> <span class=\"variable\">id</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">AtomicLong</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> ConcurrentHashMap&lt;Long, IdGenerator&gt; instances</span><br><span class=\"line\">          = <span class=\"keyword\">new</span> <span class=\"title class_\">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"title function_\">IdGenerator</span><span class=\"params\">()</span> &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> IdGenerator <span class=\"title function_\">getInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">Long</span> <span class=\"variable\">currentThreadId</span> <span class=\"operator\">=</span> Thread.currentThread().getId();</span><br><span class=\"line\">    instances.putIfAbsent(currentThreadId, <span class=\"keyword\">new</span> <span class=\"title class_\">IdGenerator</span>());</span><br><span class=\"line\">    <span class=\"keyword\">return</span> instances.get(currentThreadId);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"type\">long</span> <span class=\"title function_\">getId</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> id.incrementAndGet();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h2 id=\"如何实现集群环境下的单例？\"><a href=\"#如何实现集群环境下的单例？\" class=\"headerlink\" title=\"如何实现集群环境下的单例？\"></a>如何实现集群环境下的单例？</h2><ol>\n<li>刚刚我们讲了“进程唯一”的单例和“线程唯一”的单例，现在，我们再来看下，“集群唯一”的单例。</li>\n<li>首先，我们还是先来解释一下，什么是“集群唯一”的单例。</li>\n<li>我们还是将它跟“进程唯一”“线程唯一”做个对比。“进程唯一”指的是进程内唯一、进程间不唯一。“线程唯一”指的是线程内唯一、线程间不唯一。集群相当于多个进程构成的一个集合，“集群唯一”就相当于是进程内唯一、进程间也唯一。也就是说，不同的进程间共享同一个对象，不能创建同一个类的多个对象。</li>\n<li>我们知道，经典的单例模式是进程内唯一的，那如何实现一个进程间也唯一的单例呢？如果严格按照不同的进程间共享同一个对象来实现，那集群唯一的单例实现起来就有点难度了。</li>\n<li>具体来说，我们需要把这个单例对象序列化并存储到外部共享存储区（比如文件）。进程在使用这个单例对象的时候，需要先从外部共享存储区中将它读取到内存，并反序列化成对象，然后再使用，使用完成之后还需要再存储回外部共享存储区。</li>\n<li>为了保证任何时刻，在进程间都只有一份对象存在，一个进程在获取到对象之后，需要对对象加锁，避免其他进程再将其获取。在进程使用完这个对象之后，还需要显式地将对象从内存中删除，并且释放对对象的加锁。按照这个思路，</li>\n<li>我用伪代码实现了一下这个过程，具体如下所示：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">IdGenerator</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"type\">AtomicLong</span> <span class=\"variable\">id</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">AtomicLong</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> IdGenerator instance;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">SharedObjectStorage</span> <span class=\"variable\">storage</span> <span class=\"operator\">=</span> FileSharedObjectStorage(<span class=\"comment\">/*入参省略，比如文件地址*/</span>);</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">DistributedLock</span> <span class=\"variable\">lock</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">DistributedLock</span>();</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"title function_\">IdGenerator</span><span class=\"params\">()</span> &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">static</span> IdGenerator <span class=\"title function_\">getInstance</span><span class=\"params\">()</span> </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (instance == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      lock.lock();</span><br><span class=\"line\">      instance = storage.load(IdGenerator.class);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">public</span> synchroinzed <span class=\"keyword\">void</span> <span class=\"title function_\">freeInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    storage.save(<span class=\"built_in\">this</span>, IdGeneator.class);</span><br><span class=\"line\">    instance = <span class=\"literal\">null</span>; <span class=\"comment\">//释放对象</span></span><br><span class=\"line\">    lock.unlock();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"type\">long</span> <span class=\"title function_\">getId</span><span class=\"params\">()</span> &#123; </span><br><span class=\"line\">    <span class=\"keyword\">return</span> id.incrementAndGet();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// IdGenerator使用举例</span></span><br><span class=\"line\"><span class=\"type\">IdGenerator</span> <span class=\"variable\">idGeneator</span> <span class=\"operator\">=</span> IdGenerator.getInstance();</span><br><span class=\"line\"><span class=\"type\">long</span> <span class=\"variable\">id</span> <span class=\"operator\">=</span> idGenerator.getId();</span><br><span class=\"line\">IdGenerator.freeInstance();</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"如何实现一个多例模式？\"><a href=\"#如何实现一个多例模式？\" class=\"headerlink\" title=\"如何实现一个多例模式？\"></a>如何实现一个多例模式？</h2><p>跟单例模式概念相对应的还有一个多例模式。那如何实现一个多例模式呢？“单例”指的是，一个类只能创建一个对象。对应地，“多例”指的就是，一个类可以创建多个对象，但是个数是有限制的，比如只能创建 3 个对象。如果用代码来简单示例一下的话，就是下面这个样子：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">BackendServer</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"type\">long</span> serverNo;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> String serverAddress;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">SERVER_COUNT</span> <span class=\"operator\">=</span> <span class=\"number\">3</span>;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Map&lt;Long, BackendServer&gt; serverInstances = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">    serverInstances.put(<span class=\"number\">1L</span>, <span class=\"keyword\">new</span> <span class=\"title class_\">BackendServer</span>(<span class=\"number\">1L</span>, <span class=\"string\">&quot;192.134.22.138:8080&quot;</span>));</span><br><span class=\"line\">    serverInstances.put(<span class=\"number\">2L</span>, <span class=\"keyword\">new</span> <span class=\"title class_\">BackendServer</span>(<span class=\"number\">2L</span>, <span class=\"string\">&quot;192.134.22.139:8080&quot;</span>));</span><br><span class=\"line\">    serverInstances.put(<span class=\"number\">3L</span>, <span class=\"keyword\">new</span> <span class=\"title class_\">BackendServer</span>(<span class=\"number\">3L</span>, <span class=\"string\">&quot;192.134.22.140:8080&quot;</span>));</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"title function_\">BackendServer</span><span class=\"params\">(<span class=\"type\">long</span> serverNo, String serverAddress)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.serverNo = serverNo;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.serverAddress = serverAddress;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> BackendServer <span class=\"title function_\">getInstance</span><span class=\"params\">(<span class=\"type\">long</span> serverNo)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> serverInstances.get(serverNo);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> BackendServer <span class=\"title function_\">getRandomInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">Random</span> <span class=\"variable\">r</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Random</span>();</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">no</span> <span class=\"operator\">=</span> r.nextInt(SERVER_COUNT)+<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> serverInstances.get(no);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>实际上，对于多例模式，还有一种理解方式：同一类型的只能创建一个对象，不同类型的可以创建多个对象。这里的“类型”如何理解呢？我们还是通过一个例子来解释一下，具体代码如下所示。在代码中，logger name 就是刚刚说的“类型”，同一个 logger name 获取到的对象实例是相同的，不同的 logger name 获取到的对象实例是不同的。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Logger</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> ConcurrentHashMap&lt;String, Logger&gt; instances</span><br><span class=\"line\">          = <span class=\"keyword\">new</span> <span class=\"title class_\">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"title function_\">Logger</span><span class=\"params\">()</span> &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Logger <span class=\"title function_\">getInstance</span><span class=\"params\">(String loggerName)</span> &#123;</span><br><span class=\"line\">    instances.putIfAbsent(loggerName, <span class=\"keyword\">new</span> <span class=\"title class_\">Logger</span>());</span><br><span class=\"line\">    <span class=\"keyword\">return</span> instances.get(loggerName);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">log</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//l1==l2, l1!=l3</span></span><br><span class=\"line\"><span class=\"type\">Logger</span> <span class=\"variable\">l1</span> <span class=\"operator\">=</span> Logger.getInstance(<span class=\"string\">&quot;User.class&quot;</span>);</span><br><span class=\"line\"><span class=\"type\">Logger</span> <span class=\"variable\">l2</span> <span class=\"operator\">=</span> Logger.getInstance(<span class=\"string\">&quot;User.class&quot;</span>);</span><br><span class=\"line\"><span class=\"type\">Logger</span> <span class=\"variable\">l3</span> <span class=\"operator\">=</span> Logger.getInstance(<span class=\"string\">&quot;Order.class&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n\n\n<p>这种多例模式的理解方式有点类似工厂模式。它跟工厂模式的不同之处是，多例模式创建的对象都是同一个类的对象，而工厂模式创建的是不同子类的对象，关于这一点，后面就会讲到。实际上，它还有点类似享元模式，两者的区别等到我们讲到享元模式的时候再来分析。除此之外，实际上，枚举类型也相当于多例模式，一个类型只能对应一个对象，一个类可以创建多个对象。</p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"clxjyo3b80000isvd9uo99zq7","category_id":"clxjyo3bp0002isvdhrs32o7u","_id":"clxjyo3c00006isvd4fd726hz"},{"post_id":"clxjyo3bm0001isvd8jyu0twj","category_id":"clxjyo3bp0002isvdhrs32o7u","_id":"clxjyo3c4000disvdexo2ehg4"},{"post_id":"clxjyo3bm0001isvd8jyu0twj","category_id":"clxjyo3c20008isvd05bz6o1x","_id":"clxjyo3c4000fisvd9k56dapo"},{"post_id":"clxjyo3c9000kisvddw186wnh","category_id":"clxjyo3cc000misvd92n20lgk","_id":"clxjyo3cj000tisvd24cz78fc"},{"post_id":"clxjyo3cb000lisvddzkx05s0","category_id":"clxjyo3ci000risvdane945di","_id":"clxjyo3cs0019isvde9bf0298"},{"post_id":"clxjyo3cb000lisvddzkx05s0","category_id":"clxjyo3co0014isvd9ucobzjb","_id":"clxjyo3cs001cisvd10mv8dxt"},{"post_id":"clxjyo3cd000oisvd7aqahe1m","category_id":"clxjyo3ci000risvdane945di","_id":"clxjyo3ct001disvd1h064eof"},{"post_id":"clxjyo3cd000oisvd7aqahe1m","category_id":"clxjyo3cr0017isvdfuou91mr","_id":"clxjyo3cu001gisvd9ojcdwv9"},{"post_id":"clxjyo3ce000pisvd3at1bmdq","category_id":"clxjyo3ci000risvdane945di","_id":"clxjyo3cu001iisvd06km9nml"},{"post_id":"clxjyo3ce000pisvd3at1bmdq","category_id":"clxjyo3cs001aisvd79644lhy","_id":"clxjyo3cv001lisvd1d8d428k"},{"post_id":"clxjyo3cg000qisvd0tkd2c17","category_id":"clxjyo3ci000risvdane945di","_id":"clxjyo3cv001nisvdcom6fehu"},{"post_id":"clxjyo3cg000qisvd0tkd2c17","category_id":"clxjyo3cr0017isvdfuou91mr","_id":"clxjyo3cw001qisvday51czur"}],"PostTag":[{"post_id":"clxjyo3b80000isvd9uo99zq7","tag_id":"clxjyo3bu0003isvde7r96yxa","_id":"clxjyo3c3000aisvdbmrq51zl"},{"post_id":"clxjyo3b80000isvd9uo99zq7","tag_id":"clxjyo3bv0005isvdhusv1fva","_id":"clxjyo3c4000bisvd84yufeb5"},{"post_id":"clxjyo3b80000isvd9uo99zq7","tag_id":"clxjyo3c00007isvdaiicahk7","_id":"clxjyo3c4000eisvd9tyn0bpp"},{"post_id":"clxjyo3bm0001isvd8jyu0twj","tag_id":"clxjyo3c30009isvdakt8d59u","_id":"clxjyo3c5000hisvdcrrwebqi"},{"post_id":"clxjyo3bm0001isvd8jyu0twj","tag_id":"clxjyo3c4000cisvdfkdl7l55","_id":"clxjyo3c5000iisvd559j9ihr"},{"post_id":"clxjyo3bm0001isvd8jyu0twj","tag_id":"clxjyo3c4000gisvd3dgzb66p","_id":"clxjyo3c5000jisvd4wqmd58t"},{"post_id":"clxjyo3c9000kisvddw186wnh","tag_id":"clxjyo3bu0003isvde7r96yxa","_id":"clxjyo3cl000wisvddvw4ca1k"},{"post_id":"clxjyo3c9000kisvddw186wnh","tag_id":"clxjyo3cd000nisvd31pvggpa","_id":"clxjyo3cl000xisvdfv6hc13z"},{"post_id":"clxjyo3c9000kisvddw186wnh","tag_id":"clxjyo3cj000sisvd2m2vfpc0","_id":"clxjyo3cm0010isvdfp65h47x"},{"post_id":"clxjyo3cb000lisvddzkx05s0","tag_id":"clxjyo3ck000visvdf2h3g0bg","_id":"clxjyo3co0013isvder6acol0"},{"post_id":"clxjyo3cb000lisvddzkx05s0","tag_id":"clxjyo3cl000zisvd9wsv5cwc","_id":"clxjyo3cp0015isvd5wef4b86"},{"post_id":"clxjyo3cd000oisvd7aqahe1m","tag_id":"clxjyo3ck000visvdf2h3g0bg","_id":"clxjyo3cu001hisvd6z7lbk20"},{"post_id":"clxjyo3cd000oisvd7aqahe1m","tag_id":"clxjyo3cq0016isvddlsd54bd","_id":"clxjyo3cu001jisvddd2z55ky"},{"post_id":"clxjyo3cd000oisvd7aqahe1m","tag_id":"clxjyo3cr0018isvda02u7zsl","_id":"clxjyo3cv001misvd2nsn8udo"},{"post_id":"clxjyo3cd000oisvd7aqahe1m","tag_id":"clxjyo3cs001bisvd00bzeqto","_id":"clxjyo3cv001oisvda11828v0"},{"post_id":"clxjyo3ce000pisvd3at1bmdq","tag_id":"clxjyo3ck000visvdf2h3g0bg","_id":"clxjyo3cw001risvd21uofaxa"},{"post_id":"clxjyo3ce000pisvd3at1bmdq","tag_id":"clxjyo3cu001kisvd2p0leho4","_id":"clxjyo3cx001sisvd9j978ybh"},{"post_id":"clxjyo3cg000qisvd0tkd2c17","tag_id":"clxjyo3ck000visvdf2h3g0bg","_id":"clxjyo3cx001uisvd08bu48wz"},{"post_id":"clxjyo3cg000qisvd0tkd2c17","tag_id":"clxjyo3cx001tisvd7cxx8aso","_id":"clxjyo3cy001visvd47184wqs"}],"Tag":[{"name":"Java","_id":"clxjyo3bu0003isvde7r96yxa"},{"name":"并发","_id":"clxjyo3bv0005isvdhusv1fva"},{"name":"CompletableFuture","_id":"clxjyo3c00007isvdaiicahk7"},{"name":"Java8","_id":"clxjyo3c30009isvdakt8d59u"},{"name":"JDK8","_id":"clxjyo3c4000cisvdfkdl7l55"},{"name":"新特性","_id":"clxjyo3c4000gisvd3dgzb66p"},{"name":"对象储存","_id":"clxjyo3cd000nisvd31pvggpa"},{"name":"Minio","_id":"clxjyo3cj000sisvd2m2vfpc0"},{"name":"设计模式","_id":"clxjyo3ck000visvdf2h3g0bg"},{"name":"设计思想","_id":"clxjyo3cl000zisvd9wsv5cwc"},{"name":"工厂","_id":"clxjyo3cq0016isvddlsd54bd"},{"name":"建造者","_id":"clxjyo3cr0018isvda02u7zsl"},{"name":"原型","_id":"clxjyo3cs001bisvd00bzeqto"},{"name":"设计原则","_id":"clxjyo3cu001kisvd2p0leho4"},{"name":"单例","_id":"clxjyo3cx001tisvd7cxx8aso"}]}}