{"meta":{"version":1,"warehouse":"4.0.2"},"models":{"Asset":[{"_id":"themes/butterfly/source/css/index.styl","path":"css/index.styl","modified":0,"renderable":1},{"_id":"themes/butterfly/source/css/var.styl","path":"css/var.styl","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/404.jpg","path":"img/404.jpg","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/favicon.png","path":"img/favicon.png","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/friend_404.gif","path":"img/friend_404.gif","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/main.js","path":"js/main.js","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/tw_cn.js","path":"js/tw_cn.js","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/utils.js","path":"js/utils.js","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/search/algolia.js","path":"js/search/algolia.js","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/search/local-search.js","path":"js/search/local-search.js","modified":0,"renderable":1},{"_id":"source/img/home/Alisinngai Lynn Home page image.jpg","path":"img/home/Alisinngai Lynn Home page image.jpg","modified":0,"renderable":0},{"_id":"source/img/home/homePageImage_01.webp","path":"img/home/homePageImage_01.webp","modified":0,"renderable":0},{"_id":"source/img/minio/minio.svg","path":"img/minio/minio.svg","modified":0,"renderable":0},{"_id":"source/img/Java/Thread/Thread.svg","path":"img/Java/Thread/Thread.svg","modified":0,"renderable":0}],"Cache":[{"_id":"source/_posts/2021-04-14-Java8新特性.md","hash":"f279b63a22e592a59a26b17b3158edb1174fa876","modified":1713105183956},{"_id":"source/_posts/2024-04-13-单节点单硬盘部署MinIO.md","hash":"5da5218b50729ff2a3eb761386921c20af52e873","modified":1713018448772},{"_id":"source/_posts/2023-08-10-CompletableFuture的使用.md","hash":"e6370ffcdc7d67a62f192529507ddcd38d8981d0","modified":1713018352438},{"_id":"source/_posts/2024-05-11-设计模式-03.01-创建型-单例.md","hash":"c5c62ea565ceb15aad2a3476d0e5444becccf013","modified":1715436408257},{"_id":"source/_posts/2024-06-18-设计模式-03.02-创建型-工厂&建造者&原型.md","hash":"4dfb76fd54389b78efbe0b17128aba49ac88c5d7","modified":1718688321165},{"_id":"source/img/home/homePageImage_01.webp","hash":"f384889a2089e35f5989d2857a96a1cb7c79decf","modified":1713022157558},{"_id":"source/_posts/2024-04-21-设计模式-01.设计思想.md","hash":"cca292377c704c2063258958dc720d7f7805ad94","modified":1714541379556},{"_id":"source/img/Java/Thread/Thread.svg","hash":"2d6bd166c0c268a795256d212dc0bfce6f93004a","modified":1713018282072},{"_id":"source/img/minio/minio.svg","hash":"283133390bffe6ded2a4ca732b6b1f259270e7c6","modified":1713018435644},{"_id":"source/_posts/2024-05-01-设计模式-02.经典设计原则-第二节[必读].md","hash":"bd164e52b34e5209e873adecc15d48c6229ca0be","modified":1714541319562},{"_id":"source/_posts/2024-07-01-设计模式-04.01-结构型-代理&桥接&装饰器&适配器.md","hash":"afb8b93e74c86a9fbb75e9768f66854cba8ea810","modified":1719799270002},{"_id":"themes/butterfly/LICENSE","hash":"c8bc7df08db9dd3b39c2c2259a163a36cf2f6808","modified":1712942298256},{"_id":"themes/butterfly/README.md","hash":"20a91bea7f7ada8b8195d2abff106a7ce21bba20","modified":1712942298259},{"_id":"themes/butterfly/package.json","hash":"2b6fb6f62b9fa6a829311ffd532ae760fbd0a7db","modified":1712942298479},{"_id":"themes/butterfly/README_CN.md","hash":"9d729ee2ffc5e5f703ccfbfbbb7b286d59071125","modified":1712942298260},{"_id":"themes/butterfly/_config.yml","hash":"c6fab3700a6502b5790ca20d20113020544ea048","modified":1712942298263},{"_id":"themes/butterfly/languages/default.yml","hash":"90e9e2f36dc51aa77eb7804ae048b4876035b12d","modified":1712942298266},{"_id":"themes/butterfly/plugins.yml","hash":"7bb2c7350c0c57850aa30213cd0f26553a614702","modified":1712942298481},{"_id":"themes/butterfly/layout/index.pug","hash":"648dcbdb3d145a710de81c909e000e8664d2ac9c","modified":1712942298472},{"_id":"themes/butterfly/languages/en.yml","hash":"68127be0e6b44cfc5f31353d8b275c02939b3ff9","modified":1712942298268},{"_id":"themes/butterfly/layout/archive.pug","hash":"bc77220dfc269b8faad0930e1a4142ebf68165e5","modified":1712942298276},{"_id":"themes/butterfly/languages/zh-CN.yml","hash":"2dcc70a011b37890215ae0fd6d8f8c78aa8af6b0","modified":1712942298270},{"_id":"themes/butterfly/layout/category.pug","hash":"bf979aec88d78b644fc5d31518f8679ad7625792","modified":1712942298277},{"_id":"themes/butterfly/layout/page.pug","hash":"bf2d6c6d2d156777b55292e51be02b0b3acf0af8","modified":1712942298474},{"_id":"themes/butterfly/.github/FUNDING.yml","hash":"3b572099a992e30267f5fe4cd3c582ff7ac9f083","modified":1712942298241},{"_id":"themes/butterfly/layout/tag.pug","hash":"4bb5efc6dabdf1626685bf6771aaa1467155ae86","modified":1712942298478},{"_id":"themes/butterfly/languages/zh-TW.yml","hash":"1392e7b8c678cdfb54f55523693e66abc7d80538","modified":1712942298272},{"_id":"themes/butterfly/.github/ISSUE_TEMPLATE/feature_request.yml","hash":"6e0f9470b18bd37d4891282ac73d61676b040e8c","modified":1712942298249},{"_id":"themes/butterfly/.github/ISSUE_TEMPLATE/config.yml","hash":"63ad2249ad09fb3fe21bd5ff9adefb304a7ab24a","modified":1712942298247},{"_id":"themes/butterfly/.github/ISSUE_TEMPLATE/bug_report.yml","hash":"eed9190301095b35081aa2658204cc3f15b9f5e1","modified":1712942298245},{"_id":"themes/butterfly/layout/includes/404.pug","hash":"aace9ddff469de4226e47a52ede1c81e66d66d5c","modified":1712942298280},{"_id":"themes/butterfly/.github/workflows/publish.yml","hash":"e320b40c051bae1549156cd5ea4a51383cf78598","modified":1712942298252},{"_id":"themes/butterfly/layout/post.pug","hash":"fdbb508b5e6dec30fb8753c5a7fdd494410c4fc0","modified":1712942298476},{"_id":"themes/butterfly/layout/includes/additional-js.pug","hash":"50eea5aa78cdeb6c72dd22f0aeabc407cc0f712e","modified":1712942298281},{"_id":"themes/butterfly/layout/includes/footer.pug","hash":"8715948b93e7508b84d913be1969b28c6b067b9b","modified":1712942298283},{"_id":"themes/butterfly/.github/workflows/stale.yml","hash":"4040c76547e270aaf184e9b219a44ca41bbb1b9f","modified":1712942298254},{"_id":"themes/butterfly/layout/includes/sidebar.pug","hash":"9277fead4c29dbe93976f078adaa26e8f9253da3","modified":1712942298342},{"_id":"themes/butterfly/layout/includes/head.pug","hash":"ea8d4e8ac6af93cd268ba8f6ffcb80417bc2501e","modified":1712942298285},{"_id":"themes/butterfly/scripts/events/404.js","hash":"f1d1c378356b776e9b2a8411e6dca88dc8c3245c","modified":1712942298485},{"_id":"themes/butterfly/scripts/events/cdn.js","hash":"7864ba45716c51aef8d8b04fd4bc212e0008ce3b","modified":1712942298487},{"_id":"themes/butterfly/layout/includes/pagination.pug","hash":"c5c58714fb3cb839653e5c32e6094784c8662935","modified":1712942298334},{"_id":"themes/butterfly/scripts/events/init.js","hash":"ce68e84a9ccfcf91100befbaa9afc392a0cd93bb","modified":1712942298491},{"_id":"themes/butterfly/scripts/events/comment.js","hash":"95479790234c291b064d031577d71214cdd1d820","modified":1712942298489},{"_id":"themes/butterfly/scripts/helpers/aside_archives.js","hash":"4f712b4ea383b59a3122683db1d54c04a79ccc5d","modified":1712942298506},{"_id":"themes/butterfly/layout/includes/layout.pug","hash":"96df62e34661d8ca4a45267286127479e5178a79","modified":1712942298313},{"_id":"themes/butterfly/layout/includes/rightside.pug","hash":"f448bf73103b88de4443e52d600e871cf3de3e32","modified":1712942298340},{"_id":"themes/butterfly/scripts/events/stylus.js","hash":"0a336dfe5ed08952fa0df1532421df38a74a20d6","modified":1712942298495},{"_id":"themes/butterfly/scripts/filters/post_lazyload.js","hash":"5ed2d7ef240c927fe1b7a7fb5bf9e55e2bfd55a5","modified":1712942298500},{"_id":"themes/butterfly/scripts/events/merge_config.js","hash":"b1dfc3c898b886eab1241b068fc27d7a26a3b7d2","modified":1712942298493},{"_id":"themes/butterfly/scripts/filters/random_cover.js","hash":"0df22d7dbfa766a65cb6032a1f003348f4307cfe","modified":1712942298502},{"_id":"themes/butterfly/scripts/events/welcome.js","hash":"f59e10305fef59ea3e62a7395106c0927582879d","modified":1712942298497},{"_id":"themes/butterfly/scripts/helpers/aside_categories.js","hash":"cdd992c8577d583c237b6aac9f5077d8200879b2","modified":1712942298509},{"_id":"themes/butterfly/scripts/helpers/findArchiveLength.js","hash":"b12895e0765d596494e5526d121de0dd5a7c23d3","modified":1712942298511},{"_id":"themes/butterfly/scripts/helpers/inject_head_js.js","hash":"b55f71347d2ead097c7f98c0ec792b091433345c","modified":1712942298513},{"_id":"themes/butterfly/scripts/helpers/related_post.js","hash":"76343ac8422c9c8539082e77eda6ffee4b877eb2","modified":1712942298517},{"_id":"themes/butterfly/scripts/helpers/page.js","hash":"c74d6a9b8f71e69447f7847a5f5e81555d68b140","modified":1712942298515},{"_id":"themes/butterfly/scripts/helpers/series.js","hash":"17c0095bc8d612a268cdcab000b1742dc4c6f811","modified":1712942298518},{"_id":"themes/butterfly/source/img/favicon.png","hash":"3cf89864b4f6c9b532522a4d260a2e887971c92d","modified":1712942298660},{"_id":"themes/butterfly/source/css/index.styl","hash":"b13d96924a5534bff91d75566b196ac87b4fac22","modified":1712942298653},{"_id":"themes/butterfly/scripts/tag/flink.js","hash":"3ba7677969ff01fab06fc6713455ddc6861f0024","modified":1712942298523},{"_id":"themes/butterfly/scripts/tag/button.js","hash":"164d5f1c2d1b4cb5a813a6fc574016743a53c019","modified":1712942298521},{"_id":"themes/butterfly/scripts/tag/gallery.js","hash":"7ec77b3093f5de67e7032f40a5b12f1389f6f6ff","modified":1712942298525},{"_id":"themes/butterfly/scripts/tag/hide.js","hash":"5d08c3552f7d3c80a724ca628bff66321abe2e5a","modified":1712942298527},{"_id":"themes/butterfly/scripts/tag/inlineImg.js","hash":"c863d2732ce4bdc084f2d0db92f50f80328c1007","modified":1712942298528},{"_id":"themes/butterfly/scripts/tag/label.js","hash":"b013dc0a3d57d2caa18b89263f23871da9ec456d","modified":1712942298530},{"_id":"themes/butterfly/scripts/tag/score.js","hash":"35d54adc92e717cc32e13515122b025fd1a98ea2","modified":1712942298535},{"_id":"themes/butterfly/scripts/tag/mermaid.js","hash":"289f85847c58f0b2b7d98a68e370a2896edb8949","modified":1712942298531},{"_id":"themes/butterfly/scripts/tag/series.js","hash":"dc56e5182dd3813dc977c9bf8556dcc7615e467b","modified":1712942298537},{"_id":"themes/butterfly/source/css/var.styl","hash":"950250f66faeb611a67540e0fa6cedbcf5a7a321","modified":1712942298655},{"_id":"themes/butterfly/scripts/tag/timeline.js","hash":"e611074a5a7f489a8b04afac0a3f7f882ce26532","modified":1712942298541},{"_id":"themes/butterfly/scripts/tag/note.js","hash":"e68d8d21f3a86e3646907a3685550ee20e8d4a9f","modified":1712942298533},{"_id":"themes/butterfly/scripts/tag/tabs.js","hash":"7c448886f230adb4f4a0208c88fff809abcb5637","modified":1712942298539},{"_id":"themes/butterfly/source/img/404.jpg","hash":"fb4489bc1d30c93d28f7332158c1c6c1416148de","modified":1712942298658},{"_id":"themes/butterfly/layout/includes/head/analytics.pug","hash":"c7666a10448edd93f5ace37296051b7670495f1b","modified":1712942298290},{"_id":"themes/butterfly/source/img/friend_404.gif","hash":"8d2d0ebef70a8eb07329f57e645889b0e420fa48","modified":1712942298663},{"_id":"themes/butterfly/source/js/tw_cn.js","hash":"d776c670e4076ad6049dbb64cdee7a734b51d37f","modified":1712942298676},{"_id":"themes/butterfly/layout/includes/head/Open_Graph.pug","hash":"c8dbdfe6145a0bc6f7691c9551be8169a2698f0a","modified":1712942298288},{"_id":"themes/butterfly/source/js/main.js","hash":"59cd756a94ecdf3ec7b18f50691a8a6305f7a65a","modified":1712942298667},{"_id":"themes/butterfly/source/js/utils.js","hash":"7b871fe0c4456660cff4c7b9cc4ed089adac2caf","modified":1712942298677},{"_id":"themes/butterfly/layout/includes/head/config.pug","hash":"39e1ca0a54eb5fd3688a78737417a1aaa50914c9","modified":1712942298291},{"_id":"themes/butterfly/layout/includes/head/google_adsense.pug","hash":"f29123e603cbbcc6ce277d4e8f600ba67498077c","modified":1712942298295},{"_id":"themes/butterfly/layout/includes/head/config_site.pug","hash":"bd5dd5452e28a4fe94c3241a758ec6f4fdb7a149","modified":1712942298293},{"_id":"themes/butterfly/layout/includes/head/site_verification.pug","hash":"5168caadc4cf541f5d6676a9c5e8ae47a948f9ad","modified":1712942298300},{"_id":"themes/butterfly/layout/includes/head/preconnect.pug","hash":"a7c929b90ae52b78b39b1728e3ab0e3db1cb7b9a","modified":1712942298297},{"_id":"themes/butterfly/layout/includes/head/pwa.pug","hash":"6dc2c9b85df9ab4f5b554305339fd80a90a6cf43","modified":1712942298298},{"_id":"themes/butterfly/layout/includes/header/nav.pug","hash":"962ee70a35e60a13c31eea47d16b9f98069fe417","modified":1712942298308},{"_id":"themes/butterfly/layout/includes/header/index.pug","hash":"1bef867c799ba158c5417272fb137539951aa120","modified":1712942298304},{"_id":"themes/butterfly/layout/includes/loading/pace.pug","hash":"a6fde4835d6460ce7baf792fd5e1977fad73db25","modified":1712942298319},{"_id":"themes/butterfly/layout/includes/header/social.pug","hash":"7a641b5dd45b970e1dafd1433eb32ea149e55cf2","modified":1712942298311},{"_id":"themes/butterfly/layout/includes/header/menu_item.pug","hash":"ca8bcd90ad9467819330bfe7c02b76322754bccf","modified":1712942298306},{"_id":"themes/butterfly/layout/includes/page/categories.pug","hash":"5276a8d2835e05bd535fedc9f593a0ce8c3e8437","modified":1712942298327},{"_id":"themes/butterfly/layout/includes/loading/index.pug","hash":"00ae419f527d8225a2dc03d4f977cec737248423","modified":1712942298317},{"_id":"themes/butterfly/layout/includes/loading/fullpage-loading.pug","hash":"766baca6ddce49d1724a02312387b292ff2d0bdc","modified":1712942298315},{"_id":"themes/butterfly/layout/includes/page/default-page.pug","hash":"e9459f122af7b733398578f9f0f8ab3c5e12a217","modified":1712942298329},{"_id":"themes/butterfly/layout/includes/header/post-info.pug","hash":"cc99b2dc5c6b1f74391b0da609853ebc11de9610","modified":1712942298309},{"_id":"themes/butterfly/layout/includes/mixins/post-ui.pug","hash":"90eb453b14f6b5c25bfd8d28aa67783603a1411d","modified":1712942298324},{"_id":"themes/butterfly/layout/includes/mixins/article-sort.pug","hash":"9155f01d4c644a2e19b2b13b2d3c6d5e34dd0abf","modified":1712942298322},{"_id":"themes/butterfly/layout/includes/page/tags.pug","hash":"12be059c536490af216a397e8f2a7abbf6d4610e","modified":1712942298332},{"_id":"themes/butterfly/layout/includes/third-party/aplayer.pug","hash":"e939344fd389aeb11864ee697d5fd9b036d8325f","modified":1712942298349},{"_id":"themes/butterfly/layout/includes/post/post-copyright.pug","hash":"0abad416b1974a17e5be7817931d5fe799180170","modified":1712942298337},{"_id":"themes/butterfly/layout/includes/page/flink.pug","hash":"e37681bc9c169d4220f26ecda2b3d5c02b6b9a0f","modified":1712942298331},{"_id":"themes/butterfly/layout/includes/post/reward.pug","hash":"912df10a053db3135968e92b6fd1a707ee94c968","modified":1712942298339},{"_id":"themes/butterfly/layout/includes/widget/card_ad.pug","hash":"a8312b527493dabbadbb1280760168d3bc909a3b","modified":1712942298448},{"_id":"themes/butterfly/layout/includes/widget/card_announcement.pug","hash":"21e019bdc3b1e796bb00976bb29af2d51f873624","modified":1712942298450},{"_id":"themes/butterfly/layout/includes/widget/card_archives.pug","hash":"73d33b6930e7944187a4b3403daf25d27077a2dd","modified":1712942298452},{"_id":"themes/butterfly/layout/includes/third-party/pangu.pug","hash":"f0898509da70388b5c532f19e762756d74080200","modified":1712942298426},{"_id":"themes/butterfly/layout/includes/third-party/prismjs.pug","hash":"08979afbfecb4476a5ae8e360947b92624d285b8","modified":1712942298429},{"_id":"themes/butterfly/layout/includes/widget/card_bottom_self.pug","hash":"1dba77d250eeebfb6e293d504352c7e9ea31980b","modified":1712942298456},{"_id":"themes/butterfly/layout/includes/widget/card_categories.pug","hash":"66e383b4ef374951eb87dd1bf4cdb7a667193fb5","modified":1712942298458},{"_id":"themes/butterfly/layout/includes/third-party/effect.pug","hash":"43014bfc63583d3ee8808d526dd165848c0ed52f","modified":1712942298399},{"_id":"themes/butterfly/layout/includes/widget/card_newest_comment.pug","hash":"8e22f53886a57a68286970d8af8b4c950fd4a1d7","modified":1712942298460},{"_id":"themes/butterfly/layout/includes/widget/card_author.pug","hash":"ab037bf5794638bd30da4cf7cf106e5d03b5f696","modified":1712942298454},{"_id":"themes/butterfly/layout/includes/third-party/pjax.pug","hash":"9b734d99963f3e7f562597dcf60485ccbf6e961c","modified":1712942298428},{"_id":"themes/butterfly/layout/includes/third-party/subtitle.pug","hash":"dfb5e16a7e7106bb20b2ac2d0df1251d0fc79609","modified":1712942298445},{"_id":"themes/butterfly/source/css/_global/function.styl","hash":"e920dae9ce00177922468db49240f5aca0af4f64","modified":1712942298546},{"_id":"themes/butterfly/layout/includes/widget/card_post_toc.pug","hash":"d48d77af1670bd568d784794408bf524a448bfcc","modified":1712942298463},{"_id":"themes/butterfly/layout/includes/widget/card_top_self.pug","hash":"7b5ae404a1205546b7de4be42291315cf918f2b3","modified":1712942298467},{"_id":"themes/butterfly/layout/includes/widget/card_post_series.pug","hash":"e0bb72fa0ce15964b11b8fe421cae3432394e35f","modified":1712942298461},{"_id":"themes/butterfly/layout/includes/widget/card_recent_post.pug","hash":"bb842d2aa6469d65bf06af1372f0a19a9e4ef44c","modified":1712942298464},{"_id":"themes/butterfly/layout/includes/widget/card_tags.pug","hash":"842b772a387b576550fa127030e1c2e9bf65716d","modified":1712942298466},{"_id":"themes/butterfly/layout/includes/widget/card_webinfo.pug","hash":"12185713f9ca08984fc74e3b69d8cd6828d23da8","modified":1712942298468},{"_id":"themes/butterfly/layout/includes/widget/index.pug","hash":"8df529f71e25f1c0a00e533de7944ed3d1ba7bd8","modified":1712942298470},{"_id":"themes/butterfly/source/css/_global/index.styl","hash":"0421da07907b3d98df64239e073b23fbb3f04149","modified":1712942298548},{"_id":"themes/butterfly/source/css/_highlight/highlight.styl","hash":"41054740cfbd1357138785464f6859681ca58493","modified":1712942298550},{"_id":"themes/butterfly/source/css/_layout/chat.styl","hash":"792a04d36de32f230ca3256ad87a90fe8392f333","modified":1712942298572},{"_id":"themes/butterfly/source/css/_highlight/theme.styl","hash":"3c178608406c31d768af355ef1d7326da37cc75f","modified":1712942298566},{"_id":"themes/butterfly/source/css/_layout/aside.styl","hash":"aae70ddd126b2e40158e45036abecbfa33cbfbba","modified":1712942298570},{"_id":"themes/butterfly/source/css/_layout/comments.styl","hash":"fbfce4d67cacd1df22fb73d89d008693f59d9d91","modified":1712942298575},{"_id":"themes/butterfly/source/css/_layout/footer.styl","hash":"5e27f7842af82ff7498d4b59787ce9ca90fa9e6f","modified":1712942298577},{"_id":"themes/butterfly/source/css/_layout/head.styl","hash":"964bda8acf4180a15c33e1d8447fc3140baa4c68","modified":1712942298579},{"_id":"themes/butterfly/source/css/_layout/loading.styl","hash":"f0b01bbf321c2c24fdccaee367dd9fd448031a72","modified":1712942298581},{"_id":"themes/butterfly/source/css/_mode/darkmode.styl","hash":"dbc855795a881f8c805bf5c9c5c4d5d542a648ec","modified":1712942298598},{"_id":"themes/butterfly/source/css/_layout/relatedposts.styl","hash":"6dcf19c0933c8828a439f801b0f4b256447dec07","modified":1712942298587},{"_id":"themes/butterfly/source/css/_layout/pagination.styl","hash":"bd099f7d3adef4b7edd24c0a25a07415b156e587","modified":1712942298583},{"_id":"themes/butterfly/source/css/_layout/post.styl","hash":"7ae27854a737a02eca89b0b92db94cb298fef59e","modified":1712942298585},{"_id":"themes/butterfly/source/css/_layout/rightside.styl","hash":"0322237e762db401d7b4aa33168d0b9334a9ec26","modified":1712942298591},{"_id":"themes/butterfly/source/css/_layout/sidebar.styl","hash":"80ee9d0bfe5d38aac1f0cdcea5fc88b71d310041","modified":1712942298592},{"_id":"themes/butterfly/source/css/_layout/reward.styl","hash":"c0b11a1a5f52e3a6af4e312a8134c93eda18a7dd","modified":1712942298589},{"_id":"themes/butterfly/source/css/_layout/third-party.styl","hash":"15ea7564b2e3bf46bc91fb6e49c94d057b37caaf","modified":1712942298594},{"_id":"themes/butterfly/source/css/_page/categories.styl","hash":"68bc8cbea25dbb3cdc170f09f9b43ce130547717","modified":1712942298611},{"_id":"themes/butterfly/source/css/_mode/readmode.styl","hash":"a22fd15048d21452f0015d0765d295d730203308","modified":1712942298601},{"_id":"themes/butterfly/source/css/_page/404.styl","hash":"a7223a8fcc4fa7b81e552c9a2554be7df9de312e","modified":1712942298606},{"_id":"themes/butterfly/source/css/_page/archives.styl","hash":"5dd1ba997741d02894ff846eda939ad8051c0bb2","modified":1712942298609},{"_id":"themes/butterfly/source/css/_page/tags.styl","hash":"9e35f91847773b915c74a78b8aa66c7bdb950ad0","modified":1712942298621},{"_id":"themes/butterfly/source/css/_page/flink.styl","hash":"ecc2b2e28c179eb9406fc2c6f00e141078249cdd","modified":1712942298616},{"_id":"themes/butterfly/source/css/_page/common.styl","hash":"df7a51fcabbadab5aa31770e3202a47c9599bbb7","modified":1712942298613},{"_id":"themes/butterfly/source/css/_page/homepage.styl","hash":"a977cd8161ef4d6ddd5293e81403519076657430","modified":1712942298619},{"_id":"themes/butterfly/source/css/_search/index.styl","hash":"0b23010154e19f37f0c4af0110f9f834d6d41a13","modified":1712942298627},{"_id":"themes/butterfly/source/css/_search/algolia.styl","hash":"37db99299af380e9111dce2a78a5049b301b13e0","modified":1712942298624},{"_id":"themes/butterfly/source/css/_search/local-search.styl","hash":"8a53d7ba5ca2f5eb4124b684e7845b648583f658","modified":1712942298628},{"_id":"themes/butterfly/source/css/_tags/hexo.styl","hash":"985b183db7b7bfd8f9bdb60494549fb7f850348b","modified":1712942298635},{"_id":"themes/butterfly/source/css/_tags/gallery.styl","hash":"3e9355b76f87e2ee90f652855282b37ab5ae0b3e","modified":1712942298633},{"_id":"themes/butterfly/source/css/_tags/button.styl","hash":"62da1de0d5b8453fcecbfacddb16985265638ba5","modified":1712942298632},{"_id":"themes/butterfly/source/css/_tags/label.styl","hash":"2f83bd145b870d80d4b18b0ac603235229a5694e","modified":1712942298641},{"_id":"themes/butterfly/source/css/_tags/inlineImg.styl","hash":"5a873d01fabebcf7ddf7a6b1c2e2e5e2714097f4","modified":1712942298639},{"_id":"themes/butterfly/source/css/_tags/hide.styl","hash":"b7cf7753479fcf2fe07287ffdb0e568adbba4c18","modified":1712942298637},{"_id":"themes/butterfly/source/css/_tags/timeline.styl","hash":"07ea7134db7a66c87658116f089fb1a2a6906563","modified":1712942298647},{"_id":"themes/butterfly/source/css/_tags/note.styl","hash":"4929382bd60788d34752a66e2fe764ef797a72a0","modified":1712942298643},{"_id":"themes/butterfly/source/css/_third-party/normalize.min.css","hash":"8549829fb7d3c21cd9e119884962e8c463a4a267","modified":1712942298651},{"_id":"themes/butterfly/layout/includes/third-party/abcjs/abcjs.pug","hash":"8f95aca305b56ccd7c8c7367b03d26db816ebd5f","modified":1712942298346},{"_id":"themes/butterfly/source/js/search/algolia.js","hash":"a7c2fe73cc05ad3525909b86ad0ede1a9f2d3b48","modified":1712942298671},{"_id":"themes/butterfly/source/css/_tags/tabs.styl","hash":"353b95f9a6c2c1e777d978118cb61f909ccbf89c","modified":1712942298645},{"_id":"themes/butterfly/layout/includes/third-party/abcjs/index.pug","hash":"58f37823f6cd9a194fb50f7ca7c2233e49939034","modified":1712942298347},{"_id":"themes/butterfly/source/js/search/local-search.js","hash":"ab3904451ae1d78903424b8b2ef815c8571e1749","modified":1712942298673},{"_id":"themes/butterfly/layout/includes/third-party/chat/chatra.pug","hash":"08a85e52fc800d3562df869e5e2613313e76fce6","modified":1712942298364},{"_id":"themes/butterfly/layout/includes/third-party/chat/crisp.pug","hash":"09d2ab2570b67e6f09244a898ccab5567cb82ace","modified":1712942298366},{"_id":"themes/butterfly/layout/includes/third-party/chat/index.pug","hash":"1157118db9f5d7c0c5a0fc7c346f6e934ca00d52","modified":1712942298368},{"_id":"themes/butterfly/layout/includes/third-party/chat/daovoice.pug","hash":"0d960849d5b05d27ec87627b983ca35f2411b9e8","modified":1712942298367},{"_id":"themes/butterfly/layout/includes/third-party/chat/tidio.pug","hash":"6d40b521eec4136f6742c548a4445ed593470b1b","modified":1712942298372},{"_id":"themes/butterfly/layout/includes/third-party/chat/messenger.pug","hash":"799da8f3015e6fe440681b21644bcb3810a5518c","modified":1712942298370},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/artalk.pug","hash":"b03ee8625149191f9d5d057bbc9824b68d8dd0c4","modified":1712942298351},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/disqus.pug","hash":"d6fff5a7f84c8b09f282f9ddc0020a68a8aac9ea","modified":1712942298352},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/index.pug","hash":"846cabae287ae31b3bbfac3da022475713dd5ecc","modified":1712942298355},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/fb.pug","hash":"4b98145d6584d586cabf033493282afc72ae816a","modified":1712942298354},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/valine.pug","hash":"cd4fc9c5a61608a5dedf645c1295430a1623040f","modified":1712942298360},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/remark42.pug","hash":"716dc463fe4ef5112e7018ed60804125fdfa5cad","modified":1712942298357},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/twikoo.pug","hash":"7e233f872aea6fd6beccdc9efd86b1bf9ec9f12d","modified":1712942298359},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/waline.pug","hash":"fd2320ee25507bb8ef49f932c2d170586b44ea4d","modified":1712942298362},{"_id":"themes/butterfly/layout/includes/third-party/comments/disqus.pug","hash":"364d1fd655baca9132038ef1e312abde2c0bc7de","modified":1712942298377},{"_id":"themes/butterfly/layout/includes/third-party/comments/artalk.pug","hash":"5373b822aa72ddb96f2f1f4baf6c058b40d705d6","modified":1712942298375},{"_id":"themes/butterfly/layout/includes/third-party/comments/disqusjs.pug","hash":"f78c9c20c86d58c7cf099f6f8d6097103d7d43e5","modified":1712942298378},{"_id":"themes/butterfly/layout/includes/third-party/comments/facebook_comments.pug","hash":"11f5dca1432e59f22955aaf4ac3e9de6b286d887","modified":1712942298380},{"_id":"themes/butterfly/layout/includes/third-party/comments/index.pug","hash":"db6713d2b90eb8183f86ac92c26761a8501c0ddb","modified":1712942298385},{"_id":"themes/butterfly/layout/includes/third-party/comments/gitalk.pug","hash":"1c86c8fc1a28514a02a1f6a25ca9ec05eb3955b7","modified":1712942298383},{"_id":"themes/butterfly/layout/includes/third-party/comments/js.pug","hash":"3abbaaa4ea575c45b3cebffd40bad1acc6ffce84","modified":1712942298387},{"_id":"themes/butterfly/layout/includes/third-party/comments/remark42.pug","hash":"7f450664e6323a076ae59c393b0f22167cfa82e5","modified":1712942298390},{"_id":"themes/butterfly/layout/includes/third-party/comments/livere.pug","hash":"09c2ef4bc6d005f96dfa48b1d9af1ec095c5266d","modified":1712942298388},{"_id":"themes/butterfly/layout/includes/third-party/comments/twikoo.pug","hash":"9942a903227350960c1d0716e59516ae79ac24a8","modified":1712942298392},{"_id":"themes/butterfly/layout/includes/third-party/math/index.pug","hash":"2afa4c21dd19890f47fb568cfb0d90efb676a253","modified":1712942298402},{"_id":"themes/butterfly/layout/includes/third-party/comments/giscus.pug","hash":"1eab7ca1cb16c6786f9c3ca0efef8cc15e444ab4","modified":1712942298382},{"_id":"themes/butterfly/layout/includes/third-party/math/katex.pug","hash":"f0d3eddd2bed68e5517274b3530bfe0fa5057d8e","modified":1712942298404},{"_id":"themes/butterfly/layout/includes/third-party/comments/utterances.pug","hash":"b65a42167df5fb07e2a63f312a58c321d3112a90","modified":1712942298393},{"_id":"themes/butterfly/layout/includes/third-party/comments/valine.pug","hash":"4ed7c74087e81c6fcaf4fca7dced58b4e19f4cb1","modified":1712942298395},{"_id":"themes/butterfly/layout/includes/third-party/math/mermaid.pug","hash":"c682e4d61017fb0dd2e837bfcc242371f1a13364","modified":1712942298408},{"_id":"themes/butterfly/layout/includes/third-party/comments/waline.pug","hash":"efb72547fc2d470a124f5636391128dc59627498","modified":1712942298397},{"_id":"themes/butterfly/layout/includes/third-party/math/mathjax.pug","hash":"bb944185f4bb9f9a9b9d70ee215f66ccd6d4c6cf","modified":1712942298407},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/disqus-comment.pug","hash":"d8898e427acd91ceb97d6a7ee3acb011ca86b9fc","modified":1712942298413},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/artalk.pug","hash":"2e36fac4791e99844cd56676898be0dbf5eb4e99","modified":1712942298411},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/github-issues.pug","hash":"fc8814bd016d039874ec2fc24dcb78587892e2a6","modified":1712942298415},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/index.pug","hash":"f8b65460c399973090c1fb7ab81e3708c252e7cc","modified":1712942298417},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/remark42.pug","hash":"a4e52188b6effeee1df2a01dcbf4105de76a61a8","modified":1712942298419},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/twikoo-comment.pug","hash":"17520a86de12ae585289463c066d3ac91b78a2ff","modified":1712942298421},{"_id":"themes/butterfly/layout/includes/third-party/search/algolia.pug","hash":"90338ac4cd114d324fe1caaaeea8be9ca05d6a46","modified":1712942298432},{"_id":"themes/butterfly/layout/includes/third-party/search/index.pug","hash":"3adcf28a8d205ea3ee19828eda0e668702fac07a","modified":1712942298435},{"_id":"themes/butterfly/layout/includes/third-party/share/addtoany.pug","hash":"1f02a26730e5f36cc2dfec7ff4d5c93a099ed5ba","modified":1712942298439},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/valine.pug","hash":"ecfff55b2c7f6d87ce4d5028fdf9f8c0bf155c73","modified":1712942298422},{"_id":"themes/butterfly/layout/includes/third-party/search/docsearch.pug","hash":"52a06a2e039f44383085333cac69f3f4e7d0ad3a","modified":1712942298433},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/waline.pug","hash":"0544d91c0bc9e26e0fe1b5ff490f4a8540ed1ee1","modified":1712942298425},{"_id":"themes/butterfly/layout/includes/third-party/share/share-js.pug","hash":"8106bd031586f075a994956ee4438eb13be25d7b","modified":1712942298443},{"_id":"themes/butterfly/layout/includes/third-party/share/index.pug","hash":"c16ee69b5ca8db016db0508d014ae0867c4ce929","modified":1712942298442},{"_id":"themes/butterfly/layout/includes/third-party/search/local-search.pug","hash":"420a86e73d0d748ac234fd00d06d9e433ca5e3f2","modified":1712942298436},{"_id":"themes/butterfly/source/css/_highlight/highlight/diff.styl","hash":"6e77f1ca0cfb0db6b028f5c0238780e66d344f3d","modified":1712942298554},{"_id":"themes/butterfly/source/css/_highlight/prismjs/index.styl","hash":"01ff9e77eb1bd454bec65a6ff5972c8e219bc708","modified":1712942298562},{"_id":"themes/butterfly/source/css/_highlight/highlight/index.styl","hash":"fc702a4614d0562a381907b083f71ba63d301d86","modified":1712942298557},{"_id":"themes/butterfly/source/css/_highlight/prismjs/diff.styl","hash":"1309292f1c8c53d96cd7333507b106bcc24ca8fc","modified":1712942298560},{"_id":"themes/butterfly/source/css/_highlight/prismjs/line-number.styl","hash":"7c9cc43e1d2577f7151039d58e603c30860fd281","modified":1712942298564},{"_id":"source/img/home/Alisinngai Lynn Home page image.jpg","hash":"5fe4ce370bc4b0a479429da5f4e66af9bbd40a88","modified":1604041300796},{"_id":"public/2024/07/01/2024-07-01-设计模式-04.01-结构型-代理&桥接&装饰器&适配器/index.html","hash":"eaed2bbb8f944423d35b62279aa704c7e0413382","modified":1719799341529},{"_id":"public/2024/06/18/2024-06-18-设计模式-03.02-创建型-工厂&建造者&原型/index.html","hash":"7ac855f416c8308c7e94e219aabf75d7dd25f56b","modified":1719799341529},{"_id":"public/2024/05/11/2024-05-11-设计模式-03.01-创建型-单例/index.html","hash":"11ba471a8647b39139456dc12a244d74465f04f0","modified":1719799341529},{"_id":"public/2024/05/01/2024-05-01-设计模式-02.经典设计原则-第二节[必读]/index.html","hash":"69cc918704c886e56a96562018e9e43dd9c427a0","modified":1719799341529},{"_id":"public/2024/04/21/2024-04-21-设计模式-01.设计思想/index.html","hash":"8e3a55022b1c99719bf34257fc80b189d9599395","modified":1719799341529},{"_id":"public/2024/04/14/2021-04-14-Java8新特性/index.html","hash":"4d0f1c913d34e1105ff2571865c4e0ca6b3457f6","modified":1719799341529},{"_id":"public/2024/04/13/2024-04-13-单节点单硬盘部署MinIO/index.html","hash":"285b6ab6443c29bec4756e4223f1c858e0765bb9","modified":1719799341529},{"_id":"public/2023/08/10/2023-08-10-CompletableFuture的使用/index.html","hash":"d5a6e4dcf827787663fe3379bb85e709b325c7ef","modified":1719799341529},{"_id":"public/categories/Java/index.html","hash":"3554f9044508081e06df9c64edcfc32fc900f5d2","modified":1719799341529},{"_id":"public/categories/Minio/index.html","hash":"5cd9e386b904b110d58638c87fb6436a018e8de5","modified":1719799341529},{"_id":"public/categories/Java/新特性/index.html","hash":"d23640d3d9beb7d19d5c473ebfff167c8dbb28e6","modified":1719799341529},{"_id":"public/categories/设计模式/index.html","hash":"c03efa36d448f8f0a2f19d900a045a0df76391b8","modified":1719799341529},{"_id":"public/categories/设计模式/01-设计思想/index.html","hash":"a1db5da249b86eaa9a833240999bf47d35971132","modified":1719799341529},{"_id":"public/categories/设计模式/02-经典设计原则/index.html","hash":"31a866d174a9870fe0446c2b92ee9833aa3f282c","modified":1719799341529},{"_id":"public/categories/设计模式/03-创建型/index.html","hash":"01d9f8634581d6047f6f462516ab48a46f7ee08b","modified":1719799341529},{"_id":"public/categories/设计模式/04-结构型/index.html","hash":"1f0012218c6f8164f158934d349c8d740982b36a","modified":1719799341529},{"_id":"public/archives/index.html","hash":"d6f75ea0cf9050b132eb7f2bb3a32475c0eb8a4f","modified":1719799341529},{"_id":"public/archives/2023/index.html","hash":"93129d53dd918e5d4a870f46b57dcd9e6391e05f","modified":1719799341529},{"_id":"public/archives/2023/08/index.html","hash":"e83643960c15aeb8b5ca04dd3bfbb2a16e330a02","modified":1719799341529},{"_id":"public/archives/2024/index.html","hash":"0d55502f8e72cf222407bffeb139498616d643b7","modified":1719799341529},{"_id":"public/archives/2024/04/index.html","hash":"423946cffd45280830481637a6f874e9df3f6940","modified":1719799341529},{"_id":"public/archives/2024/05/index.html","hash":"ad9de453fa813ad716e36bc678f2c5e7c5a707f3","modified":1719799341529},{"_id":"public/archives/2024/06/index.html","hash":"8035d704fee2e2215864b60049c322c314371216","modified":1719799341529},{"_id":"public/index.html","hash":"5108ffccff8f8af62ba38662ce337477f8a1ad21","modified":1719799341529},{"_id":"public/archives/2024/07/index.html","hash":"c00bd062374fbf64d41579064a49f4386639504d","modified":1719799341529},{"_id":"public/tags/Java8/index.html","hash":"9590b4a896d189eea387ae03af349464a04e2287","modified":1719799341529},{"_id":"public/tags/JDK8/index.html","hash":"da19375517bbf895484af142bceb2634865e2604","modified":1719799341529},{"_id":"public/tags/Java/index.html","hash":"b08a93fbc826b75299b430af582022be85786039","modified":1719799341529},{"_id":"public/tags/新特性/index.html","hash":"e6bc3b363fd8c44c4b3489562946a82017885a9b","modified":1719799341529},{"_id":"public/tags/并发/index.html","hash":"a90b1e82dd18d2fe79229a621f7cc0c55e48ae6e","modified":1719799341529},{"_id":"public/tags/CompletableFuture/index.html","hash":"016a5332a9840d45c93678927e89faf9e99ab87f","modified":1719799341529},{"_id":"public/tags/对象储存/index.html","hash":"8322c573d1a7409bca14af4a725b0580ef6ccecb","modified":1719799341529},{"_id":"public/tags/Minio/index.html","hash":"e8fd58e0bd4826cebb39bbf2514abb376271b963","modified":1719799341529},{"_id":"public/tags/设计模式/index.html","hash":"54cc7f8ab5bb85ca99d5cae262a47d00289ee16a","modified":1719799341529},{"_id":"public/tags/设计思想/index.html","hash":"df76759fd6934b3ed2d6a96be871e192d233eec8","modified":1719799341529},{"_id":"public/tags/设计原则/index.html","hash":"1337badd6922bfcc3728c5fdec1bf93e5c502b17","modified":1719799341529},{"_id":"public/tags/工厂/index.html","hash":"905e54bea878fdebe3e1a0554bcb711724b1992b","modified":1719799341529},{"_id":"public/tags/建造者/index.html","hash":"5a9ec1a4fbdce7e1630adc58f9e69f3bcbbe6f8e","modified":1719799341529},{"_id":"public/tags/原型/index.html","hash":"eca7e848377faa07b88f50db53e3a5feded1e4e0","modified":1719799341529},{"_id":"public/tags/单例/index.html","hash":"f3b2211badfef2e75edf7d57df0c30cb9d2ec7c3","modified":1719799341529},{"_id":"public/tags/代理模式/index.html","hash":"24698ee1a7b18e30f11ea84c2cda10d347f68bf3","modified":1719799341529},{"_id":"public/tags/桥接模式/index.html","hash":"bcb4044a92c8abefc288aef18565d6aaf705bc27","modified":1719799341529},{"_id":"public/tags/装饰器模式/index.html","hash":"4fbf9f6274bd8a7cbfa07099e9ca1c5c497031e6","modified":1719799341529},{"_id":"public/tags/适配器模式/index.html","hash":"25e5d558d0be5156a77507979aeb6b78fcb569b9","modified":1719799341529},{"_id":"public/img/favicon.png","hash":"3cf89864b4f6c9b532522a4d260a2e887971c92d","modified":1719799341529},{"_id":"public/img/404.jpg","hash":"fb4489bc1d30c93d28f7332158c1c6c1416148de","modified":1719799341529},{"_id":"public/img/friend_404.gif","hash":"8d2d0ebef70a8eb07329f57e645889b0e420fa48","modified":1719799341529},{"_id":"public/img/home/homePageImage_01.webp","hash":"f384889a2089e35f5989d2857a96a1cb7c79decf","modified":1719799341529},{"_id":"public/img/minio/minio.svg","hash":"283133390bffe6ded2a4ca732b6b1f259270e7c6","modified":1719799341529},{"_id":"public/img/Java/Thread/Thread.svg","hash":"2d6bd166c0c268a795256d212dc0bfce6f93004a","modified":1719799341529},{"_id":"public/css/var.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1719799341529},{"_id":"public/js/utils.js","hash":"8e6b48d294e7aeaba8ff6348c43b2271cf865547","modified":1719799341529},{"_id":"public/js/search/algolia.js","hash":"108988d046da9a4716148df43b3975217c8ceaae","modified":1719799341529},{"_id":"public/js/search/local-search.js","hash":"e1f60ebac53a3f596fd0a4769b4f9275c48c6542","modified":1719799341529},{"_id":"public/css/index.css","hash":"deae12e17dee0ddfb95c9d2ef11a29baa5d56f3d","modified":1719799341529},{"_id":"public/js/main.js","hash":"0dac585446445e0c419b86eec5580bc9b0657dc6","modified":1719799341529},{"_id":"public/js/tw_cn.js","hash":"f8d2e3f31468991a7f5171cbfdb157dfb86d3372","modified":1719799341529},{"_id":"public/img/home/Alisinngai Lynn Home page image.jpg","hash":"5fe4ce370bc4b0a479429da5f4e66af9bbd40a88","modified":1719799341529}],"Category":[{"name":"Java","_id":"cly2c4k3i0002qsvd8i56ajpj"},{"name":"Minio","_id":"cly2c4k3n0007qsvdhh89brbl"},{"name":"新特性","parent":"cly2c4k3i0002qsvd8i56ajpj","_id":"cly2c4k3o000aqsvdeeva25uc"},{"name":"设计模式","_id":"cly2c4k3u000vqsvdhhd87p2i"},{"name":"01.设计思想","parent":"cly2c4k3u000vqsvdhhd87p2i","_id":"cly2c4k3w0013qsvd8q10f75g"},{"name":"02.经典设计原则","parent":"cly2c4k3u000vqsvdhhd87p2i","_id":"cly2c4k3w0016qsvdgiwq2yu5"},{"name":"03.创建型","parent":"cly2c4k3u000vqsvdhhd87p2i","_id":"cly2c4k3x001bqsvdgqto5pbi"},{"name":"04.结构型","parent":"cly2c4k3u000vqsvdhhd87p2i","_id":"cly2c4k42001wqsvd51enb43z"}],"Data":[],"Page":[],"Post":[{"title":"详解JDK8新特性","date":"2024-04-14T14:32:58.000Z","keywords":"Java8，新特性，JDK8","description":"详解JDK8出现的新特性。","cover":"https://npm.elemecdn.com/lql_static@latest/logo/java.png","_content":"\n\n\n# Java8新特性纵览\n\n> 关于Java8新特性的学习与记录，资料来源于互联网。\n\n\n# Lambda表达式\n\n## 为什么使用Lambda表达式？\n\n- Lambda 是一个**匿名函数**，我们可以把 Lambda 表达式理解为是**一段可以传递的代码**（将代码像数据一样进行传递）。使用它可以写出更简洁、更灵活的代码。作为一种更紧凑的代码风格，使Java的语言表达能力得到了提升。\n- 在Java8之后的很多源码里用到了Lambda表达式，不学的话可能看不懂源码。\n\n\n\n## 简单使用\n\n```java\n @Test\n    public void test1(){\n        //原始写法\n        Runnable r1 = new Runnable() {\n            @Override\n            public void run() {\n                System.out.println(\"我爱北京天安门\");\n            }\n        };\n\n        r1.run();\n\n        System.out.println(\"***********************\");\n\n        //lambda表达式，可以表达一样的意思\n        Runnable r2 = () -> System.out.println(\"我爱北京故宫\");\n\n        r2.run();\n    }\n\n\n    @Test\n    public void test2(){\n\n        Comparator<Integer> com1 = new Comparator<Integer>() {\n            @Override\n            public int compare(Integer o1, Integer o2) {\n                return Integer.compare(o1,o2);\n            }\n        };\n\n        int compare1 = com1.compare(12,21);\n        System.out.println(compare1);\n\n        System.out.println(\"***********************\");\n        \n        //Lambda表达式的写法\n        Comparator<Integer> com2 = (o1,o2) -> Integer.compare(o1,o2);\n\n        int compare2 = com2.compare(32,21);\n        System.out.println(compare2);\n\n\n        System.out.println(\"***********************\");\n        //方法引用\n        Comparator<Integer> com3 = Integer :: compare;\n\n        int compare3 = com3.compare(32,21);\n        System.out.println(compare3);\n    }\n```\n\n\n\n## Lambda语法规则\n\n```Java\nimport org.junit.Test;\n\nimport java.util.ArrayList;\nimport java.util.Comparator;\nimport java.util.function.Consumer;\n\n/**\n * Lambda表达式的使用\n * <p>\n * 1.举例： (o1,o2) -> Integer.compare(o1,o2);\n * 2.格式：\n * -> :lambda操作符 或 箭头操作符\n * ->左边：lambda形参列表 （其实就是接口中的抽象方法的形参列表）\n * ->右边：lambda体 （其实就是重写的抽象方法的方法体）\n * <p>\n * 3. Lambda表达式的使用：（分为6种情况介绍）\n * <p>\n * 总结：\n * ->左边：lambda形参列表的参数类型可以省略(类型推断)；如果lambda形参列表只有一个参数，其一对()也\n * 可以省略\n * ->右边：lambda体应该使用一对{}包裹；如果lambda体只有一条执行语句（可能是return语句），省略这一\n 对{}和return关键字\n * <p>\n * 4.Lambda表达式的本质：作为函数式接口的实例\n * <p>\n * 5. 如果一个接口中，只声明了一个抽象方法，则此接口就称为函数式接口。我们可以在一个接口上\n 使用 @FunctionalInterface 注解，\n * 这样做可以检查它是否是一个函数式接口。\n * <p>\n * 6. 所以以前用匿名实现类表示的现在都可以用Lambda表达式来写。\n */\npublic class LambdaTest1 {\n    //语法格式一：无参，无返回值\n    @Test\n    public void test1() {\n        Runnable r1 = new Runnable() {\n            @Override\n            public void run() {\n                System.out.println(\"我爱北京天安门\");\n            }\n        };\n\n        r1.run();\n\n        System.out.println(\"***********************\");\n\n        Runnable r2 = () -> {\n            System.out.println(\"我爱北京故宫\");\n        };\n\n        r2.run();\n    }\n\n    //语法格式二：Lambda 需要一个参数，但是没有返回值。\n    @Test\n    public void test2() {\n\n        Consumer<String> con = new Consumer<String>() {\n            @Override\n            public void accept(String s) {\n                System.out.println(s);\n            }\n        };\n        con.accept(\"谎言和誓言的区别是什么？\");\n\n        System.out.println(\"*******************\");\n\n        Consumer<String> con1 = (String s) -> {\n            System.out.println(s);\n        };\n        con1.accept(\"一个是听得人当真了，一个是说的人当真了\");\n\n    }\n\n    //语法格式三：数据类型可以省略，因为可由编译器推断得出，称为“类型推断”\n    @Test\n    public void test3() {\n\n        Consumer<String> con1 = (String s) -> {\n            System.out.println(s);\n        };\n        con1.accept(\"一个是听得人当真了，一个是说的人当真了\");\n\n        System.out.println(\"*******************\");\n\n        Consumer<String> con2 = (s) -> {\n            System.out.println(s);\n        };\n        con2.accept(\"一个是听得人当真了，一个是说的人当真了\");\n\n    }\n\n    @Test\n    public void test4() {\n\n        ArrayList<String> list = new ArrayList<>();//类型推断\n\n        int[] arr = {1, 2, 3};//类型推断\n\n    }\n\n    //语法格式四：Lambda 若只需要一个参数时，参数的小括号可以省略\n    @Test\n    public void test5() {\n        Consumer<String> con1 = (s) -> {\n            System.out.println(s);\n        };\n        con1.accept(\"一个是听得人当真了，一个是说的人当真了\");\n\n        System.out.println(\"*******************\");\n\n        Consumer<String> con2 = s -> {\n            System.out.println(s);\n        };\n        con2.accept(\"一个是听得人当真了，一个是说的人当真了\");\n\n\n    }\n\n    //语法格式五：Lambda 需要两个或以上的参数，多条执行语句，并且可以有返回值\n    @Test\n    public void test6() {\n\n        Comparator<Integer> com1 = new Comparator<Integer>() {\n            @Override\n            public int compare(Integer o1, Integer o2) {\n                System.out.println(o1);\n                System.out.println(o2);\n                return o1.compareTo(o2);\n            }\n        };\n\n        System.out.println(com1.compare(12, 21));\n\n        System.out.println(\"*****************************\");\n        Comparator<Integer> com2 = (o1, o2) -> {\n            System.out.println(o1);\n            System.out.println(o2);\n            return o1.compareTo(o2);\n        };\n\n        System.out.println(com2.compare(12, 6));\n\n\n    }\n\n    //语法格式六：当 Lambda 体只有一条语句时，return 与大括号若有，都可以省略\n    @Test\n    public void test7() {\n\n        Comparator<Integer> com1 = (o1, o2) -> {\n            return o1.compareTo(o2);\n        };\n\n        System.out.println(com1.compare(12, 6));\n\n        System.out.println(\"*****************************\");\n\n        Comparator<Integer> com2 = (o1, o2) -> o1.compareTo(o2);\n\n        System.out.println(com2.compare(12, 21));\n\n    }\n\n    @Test\n    public void test8() {\n        Consumer<String> con1 = s -> {\n            System.out.println(s);\n        };\n        con1.accept(\"一个是听得人当真了，一个是说的人当真了\");\n\n        System.out.println(\"*****************************\");\n\n        Consumer<String> con2 = s -> System.out.println(s);\n\n        con2.accept(\"一个是听得人当真了，一个是说的人当真了\");\n\n    }\n\n}\n```\n\n\n\n# 函数式接口\n\n\n\n## 什么是函数式(Functional)接口\n\n- 只包含一个抽象方法的接口，称为**函数式接口**。 \n\n- 你可以通过 Lambda 表达式来创建该接口的对象。（若 Lambda 表达式抛出一个受检异常(即：非运行时异常)，那么该异常需要在目标接口的抽象方法上进行声明）。\n\n- 我们可以在一个接口上使用 **@FunctionalInterface** 注解，这样做可以检查它是否是一个函数式接口。同时 javadoc 也会包含一条声明，说明这个接口是一个函数式接口。\n\n- 在java.util.function包下定义了Java 8 的丰富的函数式接口\n\n\n\n## 如何理解函数式接口\n\n- Java从诞生日起就是一直倡导“一切皆对象”，在Java里面面向对象(OOP)编程是一切。但是随着python、scala等语言的兴起和新技术的挑战，Java不得不做出调整以便支持更加广泛的技术要求，也即java不但可以支持OOP还可以支持OOF（面向函数编程） \n- 在函数式编程语言当中，函数被当做一等公民对待。在将函数作为一等公民的编程语言中，Lambda表达式的类型是函数。但是在Java8中，有所不同。在Java8中，Lambda表达式是对象，而不是函数，它们必须依附于一类特别的对象类型——函数式接口。 \n- 简单的说，在Java8中，Lambda表达式就是一个函数式接口的实例。这就是Lambda表达式和函数式接口的关系。也就是说，只要一个对象是函数式接口的实例，那么该对象就可以用Lambda表达式来表示。\n- 所以以前用匿名实现类表示的现在都可以用Lambda表达式来写。\n\n\n\n## Java内置函数式接口\n\n\n\n**核心函数式接口**\n\n<img src=\"https://npm.elemecdn.com/youthlql@1.0.8/Java_Basis/Java8_New_Features/0002.png\">\n\n\n\n**其它函数式接口**\n\n<img src=\"https://npm.elemecdn.com/youthlql@1.0.8/Java_Basis/Java8_New_Features/0003.png\">\n\n\n\n\n\n**Consumer**\n\n```java\n @Test\n    public void test1(){\n\n        happyTime(500, new Consumer<Double>() {\n            @Override\n            public void accept(Double aDouble) {\n                System.out.println(\"学习太累了，去天上人间买了瓶矿泉水，价格为：\" + aDouble);\n            }\n        });\n\n        System.out.println(\"********************\");\n\n        happyTime(400,money -> System.out.println(\"学习太累了，去天上人间喝了口水，价格为：\" + money));\n    }\n\n    public void happyTime(double money, Consumer<Double> con){\n        con.accept(money);\n    }\n```\n\n\n\n**结果：**\n\n```Java\n学习太累了，去天上人间买了瓶矿泉水，价格为：500.0\n********************\n学习太累了，去天上人间喝了口水，价格为：400.0\n\nProcess finished with exit code 0\n```\n\n\n\n**Predicate**\n\n```java\n@Test\n    public void test2(){\n        List<String> list = Arrays.asList(\"北京\",\"南京\",\"天津\",\"东京\",\"西京\",\"普京\");\n\n        List<String> filterStrs = filterString(list, new Predicate<String>() {\n            @Override\n            public boolean test(String s) {//这里是定义一个校验规则\n                return s.contains(\"京\");\n            }\n        });\n\n        System.out.println(filterStrs);\n\n        //用lambda表达式会很简单\n        List<String> filterStrs1 = filterString(list,s -> s.contains(\"京\"));\n        System.out.println(filterStrs1);\n    }\n\n    //根据给定的规则，过滤集合中的字符串。此规则由Predicate的方法决定\n    public List<String> filterString(List<String> list, Predicate<String> pre){\n\n        ArrayList<String> filterList = new ArrayList<>();\n\n        for(String s : list){\n            if(pre.test(s)){\n                filterList.add(s);\n            }\n        }\n\n        return filterList;\n\n    }\n\n```\n\n\n\n**结果：**\n\n```\n[北京, 南京, 东京, 西京, 普京]\n[北京, 南京, 东京, 西京, 普京]\n\nProcess finished with exit code 0\n```\n\n\n\n## 自定义函数式接口\n\n```java\n/**\n * 自定义函数式接口\n * 只是说加上@FunctionalInterface之后可以校验\n */\n@FunctionalInterface\npublic interface MyFunInterface<T> {\n\n    public T getValue(T t);\n\n}\n```\n\n\n\n```java\npublic class Test {\n\n    public static void main(String[] args) {\n        //这个方法的第一个参数是lambda表达式，相当于是实例化了那个函数式接口\n        String s = toUpperString(str -> str.toUpperCase(), \"abcd\");\n        System.out.println(s);\n    }\n\n    public static String toUpperString(MyFunInterface<String> mf,String str){\n        return mf.getValue(str);\n    }\n}\n```\n\n\n\n# 方法引用\n\n- 当要传递给Lambda体的操作，已经有实现的方法了，可以使用方法引用！\n\n- 方法引用可以看做是Lambda表达式深层次的表达。换句话说，方法引用就是Lambda表达式，也就是函数式接口的一个实例，通过方法的名字来指向一个方法，可以认为是Lambda表达式的一个语法糖。\n\n- 要求：实现接口的抽象方法的参数列表和返回值类型，必须与方法引用的方法的参数列表和返回值类型保持一致！\n\n- 格式：使用操作符 “::” 将类(或对象) 与 方法名分隔开来。\n\n- 如下三种主要使用情况： \n\n  - 对象 :: 实例方法名\n\n  - 类 :: 静态方法名\n\n  - 类 :: 实例方法名\n\n\n\n我们直接拿例子来说明情况，先提前准备两个类：\n\n```Java\n\npublic class Employee {\n\n\tprivate int id;\n\tprivate String name;\n\tprivate int age;\n\tprivate double salary;\n\n\tpublic int getId() {\n\t\treturn id;\n\t}\n\n\tpublic void setId(int id) {\n\t\tthis.id = id;\n\t}\n\n\tpublic String getName() {\n\t\treturn name;\n\t}\n\n\tpublic void setName(String name) {\n\t\tthis.name = name;\n\t}\n\n\tpublic int getAge() {\n\t\treturn age;\n\t}\n\n\tpublic void setAge(int age) {\n\t\tthis.age = age;\n\t}\n\n\tpublic double getSalary() {\n\t\treturn salary;\n\t}\n\n\tpublic void setSalary(double salary) {\n\t\tthis.salary = salary;\n\t}\n\n\tpublic Employee() {\n\t\tSystem.out.println(\"Employee().....\");\n\t}\n\n\tpublic Employee(int id) {\n\t\tthis.id = id;\n\t\tSystem.out.println(\"Employee(int id).....\");\n\t}\n\n\tpublic Employee(int id, String name) {\n\t\tthis.id = id;\n\t\tthis.name = name;\n\t}\n\n\tpublic Employee(int id, String name, int age, double salary) {\n\n\t\tthis.id = id;\n\t\tthis.name = name;\n\t\tthis.age = age;\n\t\tthis.salary = salary;\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn \"Employee{\" + \"id=\" + id + \", name='\" + name + '\\'' + \", age=\" + age + \", salary=\" + salary + '}';\n\t}\n\n\t@Override\n\tpublic boolean equals(Object o) {\n\t\tif (this == o)\n\t\t\treturn true;\n\t\tif (o == null || getClass() != o.getClass())\n\t\t\treturn false;\n\n\t\tEmployee employee = (Employee) o;\n\n\t\tif (id != employee.id)\n\t\t\treturn false;\n\t\tif (age != employee.age)\n\t\t\treturn false;\n\t\tif (Double.compare(employee.salary, salary) != 0)\n\t\t\treturn false;\n\t\treturn name != null ? name.equals(employee.name) : employee.name == null;\n\t}\n\n\t@Override\n\tpublic int hashCode() {\n\t\tint result;\n\t\tlong temp;\n\t\tresult = id;\n\t\tresult = 31 * result + (name != null ? name.hashCode() : 0);\n\t\tresult = 31 * result + age;\n\t\ttemp = Double.doubleToLongBits(salary);\n\t\tresult = 31 * result + (int) (temp ^ (temp >>> 32));\n\t\treturn result;\n\t}\n}\n\n```\n\n\n\n```Java\n/**\n * 提供用于测试的数据\n */\npublic class EmployeeData {\n   \n   public static List<Employee> getEmployees(){\n      List<Employee> list = new ArrayList<>();\n      \n      list.add(new Employee(1001, \"马化腾\", 34, 6000.38));\n      list.add(new Employee(1002, \"马云\", 12, 9876.12));\n      list.add(new Employee(1003, \"刘强东\", 33, 3000.82));\n      list.add(new Employee(1004, \"雷军\", 26, 7657.37));\n      list.add(new Employee(1005, \"李彦宏\", 65, 5555.32));\n      list.add(new Employee(1006, \"比尔盖茨\", 42, 9500.43));\n      list.add(new Employee(1007, \"任正非\", 26, 4333.32));\n      list.add(new Employee(1008, \"扎克伯格\", 35, 2500.32));\n      \n      return list;\n   }\n   \n}\n```\n\n\n\n**下面来通过实际例子讲解方法引用：**\n\n```java\n\n\n/**\n * 方法引用的使用\n *\n * 1.使用情境：当要传递给Lambda体的操作，已经有实现的方法了，可以使用方法引用！\n *\n * 2.方法引用，本质上就是Lambda表达式，而Lambda表达式作为函数式接口的实例。所以\n *   方法引用，也是函数式接口的实例。\n *\n * 3. 使用格式：  类(或对象) :: 方法名\n *\n * 4. 具体分为如下的三种情况：\n *    情况1     对象 :: 非静态方法\n *    情况2     类 :: 静态方法\n *\n *    情况3     类 :: 非静态方法\n *\n * 5. 方法引用使用的要求：\n * \t接口中的抽象方法的形参列表和返回值类型\n * \t与\n * \t方法引用的方法的形参列表和返回值类型相同！（针对于情况1和情况2）\n *\n */\npublic class MethodRefTest {\n\n\t// 情况一：对象 :: 实例方法\n\t//Consumer中的void accept(T t)\n\t//PrintStream中的void println(T t)\n\t@Test\n\tpublic void test1() {\n\t\tConsumer<String> con1 = str -> System.out.println(str);\n\t\tcon1.accept(\"北京\");\n\n\t\tSystem.out.println(\"*******************\");\n\t\tPrintStream ps = System.out;\n\t\tConsumer<String> con2 = ps::println;\n\t\tcon2.accept(\"beijing\");\n\t}\n\t\n\t//Supplier中的T get()\n\t//Employee中的String getName()\n\t@Test\n\tpublic void test2() {\n\t\tEmployee emp = new Employee(1001,\"Tom\",23,5600);\n\n\t\tSupplier<String> sup1 = () -> emp.getName();\n\t\tSystem.out.println(sup1.get());\n\n\t\tSystem.out.println(\"*******************\");\n\t\tSupplier<String> sup2 = emp::getName;\n\t\tSystem.out.println(sup2.get());\n\n\t}\n\n\t// 情况二：类 :: 静态方法\n\t//Comparator中的int compare(T t1,T t2)\n\t//Integer中的int compare(T t1,T t2)\n\t@Test\n\tpublic void test3() {\n\t\tComparator<Integer> com1 = (t1,t2) -> Integer.compare(t1,t2);\n\t\tSystem.out.println(com1.compare(12,21));\n\n\t\tSystem.out.println(\"*******************\");\n\n\t\tComparator<Integer> com2 = Integer::compare;\n\t\tSystem.out.println(com2.compare(12,3));\n\n\t}\n\t\n\t//Function中的R apply(T t)\n\t//Math中的Long round(Double d)\n\t@Test\n\tpublic void test4() {\n\t\tFunction<Double,Long> func = new Function<Double, Long>() {\n\t\t\t@Override\n\t\t\tpublic Long apply(Double d) {\n\t\t\t\treturn Math.round(d);\n\t\t\t}\n\t\t};\n\n\t\tSystem.out.println(\"*******************\");\n\n\t\tFunction<Double,Long> func1 = d -> Math.round(d);\n\t\tSystem.out.println(func1.apply(12.3));\n\n\t\tSystem.out.println(\"*******************\");\n\n\t\tFunction<Double,Long> func2 = Math::round;\n\t\tSystem.out.println(func2.apply(12.6));\n\t}\n\n\t// 情况三：类 :: 实例方法  (有难度)\n\t// Comparator中的int comapre(T t1,T t2)  第一个参数T t1,也可以变成方法的调用者\n\t// String中的int t1.compareTo(t2)        看上面说的，t1变成了调用者等价于第一个参数T t1\n\t@Test\n\tpublic void test5() {\n\t\tComparator<String> com1 = (s1,s2) -> s1.compareTo(s2);\n\t\tSystem.out.println(com1.compare(\"abc\",\"abd\"));\n\n\t\tSystem.out.println(\"*******************\");\n\n\t\tComparator<String> com2 = String :: compareTo;\n\t\tSystem.out.println(com2.compare(\"abd\",\"abm\"));\n\t}\n\n\t//BiPredicate中的boolean test(T t1, T t2);\n\t//String中的boolean t1.equals(t2)\n\t@Test\n\tpublic void test6() {\n\t\tBiPredicate<String,String> pre1 = (s1,s2) -> s1.equals(s2);\n\t\tSystem.out.println(pre1.test(\"abc\",\"abc\"));\n\n\t\tSystem.out.println(\"*******************\");\n\t\tBiPredicate<String,String> pre2 = String :: equals;\n\t\tSystem.out.println(pre2.test(\"abc\",\"abd\"));\n\t}\n\t\n\t// Function中的R apply(T t)\n\t// Employee中的String getName();   第一个参数T t相当于方法调用者emp，返回值R和String对应\n\t@Test\n\tpublic void test7() {\n\t\tEmployee employee = new Employee(1001, \"Jerry\", 23, 6000);\n\n\n\t\tFunction<Employee,String> func1 = e -> e.getName();\n\t\tSystem.out.println(func1.apply(employee));\n\n\t\tSystem.out.println(\"*******************\");\n\n\n\t\tFunction<Employee,String> func2 = Employee::getName;\n\t\tSystem.out.println(func2.apply(employee));\n\n\n\t}\n\n}\n\n```\n\n\n\n\n\n# 构造器引用\n\n格式：ClassName :: new\n\n与函数式接口相结合，自动与函数式接口中方法兼容。可以把构造器引用赋值给定义的方法，要求构造器参数列表要与接口中抽象方法的参数列表一致！且方法的返回值即为构造器对应类的对象。\n\n\n\n```Java\n\nimport org.junit.Test;\n\nimport java.util.Arrays;\nimport java.util.function.BiFunction;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\n\n/**\n * 一、构造器引用\n *      和方法引用类似，函数式接口的抽象方法的形参列表和构造器的形参列表一致。\n *      抽象方法的返回值类型即为构造器所属的类的类型\n *\n * 二、数组引用\n *     大家可以把数组看做是一个特殊的类，则写法与构造器引用一致。\n *\n */\npublic class ConstructorRefTest {\n\n    /**\n     * 构造器引用\n     * Supplier中的T get()\n     * Employee的空参构造器：Employee()\n     * 1、和方法引用一样的理解方法，你的get()方法没有参数，我的Employee()也没有参数。\n     * 2、你的get()方法有返回值T，我的Employee()方法返回值也是一个对象\n     * 3、所以刚好可以用  \n     */\n    @Test\n    public void test1(){\n\n        Supplier<Employee> sup = new Supplier<Employee>() {\n            @Override\n            public Employee get() {\n                return new Employee();\n            }\n        };\n        System.out.println(\"*******************\");\n\n        Supplier<Employee>  sup1 = () -> new Employee();\n        System.out.println(sup1.get());\n\n        System.out.println(\"*******************\");\n\n        Supplier<Employee>  sup2 = Employee :: new;\n        System.out.println(sup2.get());\n    }\n\n\t//Function中的R apply(T t)\n    @Test\n    public void test2(){\n        Function<Integer,Employee> func1 = id -> new Employee(id);\n        Employee employee = func1.apply(1001);\n        System.out.println(employee);\n\n        System.out.println(\"*******************\");\n\n        Function<Integer,Employee> func2 = Employee :: new;\n        Employee employee1 = func2.apply(1002);\n        System.out.println(employee1);\n\n    }\n\n\t//BiFunction中的R apply(T t,U u)\n    @Test\n    public void test3(){\n        BiFunction<Integer,String,Employee> func1 = (id,name) -> new Employee(id,name);\n        System.out.println(func1.apply(1001,\"Tom\"));\n\n        System.out.println(\"*******************\");\n\n        BiFunction<Integer,String,Employee> func2 = Employee :: new;\n        System.out.println(func2.apply(1002,\"Tom\"));\n\n    }\n\n\t//数组引用\n    //Function中的R apply(T t)\n    @Test\n    public void test4(){\n        Function<Integer,String[]> func1 = length -> new String[length];\n        String[] arr1 = func1.apply(5);\n        System.out.println(Arrays.toString(arr1));\n\n        System.out.println(\"*******************\");\n\n        Function<Integer,String[]> func2 = String[] :: new;\n        String[] arr2 = func2.apply(10);\n        System.out.println(Arrays.toString(arr2));\n\n    }\n}\n\n```\n\n\n\n# 强大的Stream API\n\n## Stream API说明\n\n- Java8中有两大最为重要的改变。第一个是 **Lambda** **表达式**；另外一个则是 **Stream API**。 \n\n- Stream API ( java.util.stream) 把真正的函数式编程风格引入到Java中。这是目前为止对Java类库最好的补充，因为Stream API可以极大提供Java程序员的生产力，让程序员写出高效率、干净、简洁的代码。\n\n- Stream 是 Java8 中处理集合的关键抽象概念，它可以指定你希望对集合进行的操作，可以执行非常复杂的查找、过滤和映射数据等操作。 **使用Stream API 对集合数据进行操作，就类似于使用 SQL 执行的数据库查询。**也可以使用 Stream API 来并行执行操作。简言之，Stream API 提供了一种高效且易于使用的处理数据的方式\n\n\n\n## 为什么要使用Stream API\n\n- 实际开发中，项目中多数数据源都来自于Mysql，Oracle等，很多一些复杂的数据获取可以直接在sql层面去解决。但现在数据源可以更多了，有MongDB，Radis等，而这些NoSQL的数据本身不支持一些复杂的数据计算，这个时候就需要Java层面去处理。 \n\n- Stream 和 Collection 集合的区别：Collection 是一种静态的内存数据结构，而 Stream 是有关计算的。前者是主要面向内存，存储在内存中，后者主要是面向 CPU，通过 CPU 实现计算。\n\n\n\n## 什么是Stream\n\nStream到底是什么呢？\n\n是数据渠道，用于操作数据源（集合、数组等）所生成的元素序列。\n\n**“集合讲的是数据，Stream讲的是计算！”**\n\n**注意：**\n\n①Stream 自己不会存储元素。\n\n②Stream 不会改变源对象。相反，他们会返回一个持有结果的新Stream。 \n\n③Stream 操作是延迟执行的。这意味着他们会等到需要结果的时候才执行\n\n\n\n\n\n**Stream** **的操作三个步骤**\n\n1、创建Stream\n\n一个数据源（如：集合、数组），获取一个流\n\n2、中间操作\n\n一个中间操作链，对数据源的数据进行处理\n\n3、终止操作(终端操作) \n\n一旦执行终止操作，就执行中间操作链，才产生结果【也就是所谓的延迟执行】。之后，不会再被使用\n\n\n\n<img src=\"https://npm.elemecdn.com/youthlql@1.0.8/Java_Basis/Java8_New_Features/0004.png\">\n\n\n\n\n\n## 创建Stream\n\n\n\n```java\n\npublic class StreamAPITest {\n\n    //创建 Stream方式一：通过集合\n    @Test\n    public void test1(){\n        List<Employee> employees = EmployeeData.getEmployees();\n\n//        default Stream<E> stream() : 返回一个顺序流，顺序流等会中间操作拿数据的时候按顺序拿\n        Stream<Employee> stream = employees.stream();\n\n//        default Stream<E> parallelStream() : 返回一个并行流\n        Stream<Employee> parallelStream = employees.parallelStream();\n\n    }\n\n    //创建 Stream方式二：通过数组\n    @Test\n    public void test2(){\n        int[] arr = new int[]{1,2,3,4,5,6};\n        //调用Arrays类的static <T> Stream<T> stream(T[] array): 返回一个流\n        IntStream stream = Arrays.stream(arr);\n\n        Employee e1 = new Employee(1001,\"Tom\");\n        Employee e2 = new Employee(1002,\"Jerry\");\n        Employee[] arr1 = new Employee[]{e1,e2};\n        Stream<Employee> stream1 = Arrays.stream(arr1);\n\n    }\n    //创建 Stream方式三：通过Stream的of()，通过显示值创建一个流。它可以接收任意数量的参数\n    @Test\n    public void test3(){\n\n        Stream<Integer> stream = Stream.of(1, 2, 3, 4, 5, 6);\n\n    }\n\n    //创建 Stream方式四：创建无限流【用的少，了解下就行】\n    @Test\n    public void test4(){\n\n//      迭代\n//      public static<T> Stream<T> iterate(final T seed, final UnaryOperator<T> f)\n        //遍历前10个偶数\n        Stream.iterate(0, t -> t + 2).limit(10).forEach(System.out::println);\n\n\n//      生成\n//      public static<T> Stream<T> generate(Supplier<T> s)\n        Stream.generate(Math::random).limit(10).forEach(System.out::println);\n\n    }\n\n}\n\n```\n\n\n\n\n\n## 中间操作\n\n```Java\n\n/**\n * 测试Stream的中间操作\n */\npublic class StreamAPITest1 {\n\n    //1-筛选与切片\n    @Test\n    public void test1(){\n        List<Employee> list = EmployeeData.getEmployees();\n//        filter(Predicate p)——过滤   接收 Lambda ， 从流中排除某些元素。\n        Stream<Employee> stream = list.stream();\n        //练习：查询员工表中薪资大于7000的员工信息\n        /**\n         * List<String> filterStrs1 = filterString(list,s -> s.contains(\"京\"));\n         * 跟之前的这个lambda表达式代码是一个意思\n         */\n        stream.filter(e -> e.getSalary() > 7000).forEach(System.out::println);\n\n        System.out.println();\n//        limit(n)——截断流，使其元素不超过给定数量。\n        list.stream().limit(3).forEach(System.out::println);\n        System.out.println();\n\n        /*\n        skip(n) —— 跳过元素，返回一个扔掉了前 n 个元素的流。若流中元素不足 n 个，\n        则返回一个空流。与 limit(n) 互补\n        */\n        list.stream().skip(3).forEach(System.out::println);\n\n        System.out.println();\n//        distinct()——筛选，通过流所生成元素的 hashCode() 和 equals() 去除重复元素\n\n        list.add(new Employee(1010,\"刘强东\",40,8000));\n        list.add(new Employee(1010,\"刘强东\",41,8000));\n        list.add(new Employee(1010,\"刘强东\",40,8000));\n        list.add(new Employee(1010,\"刘强东\",40,8000));\n        list.add(new Employee(1010,\"刘强东\",40,8000));\n\n//        System.out.println(list);\n\n        list.stream().distinct().forEach(System.out::println);\n    }\n\n    //映射\n    @Test\n    public void test2(){\n        /*\n        map(Function f)——接收一个函数作为参数，将元素转换成其他形式或提取信息，该函数会被应\n        用到每个元素上，并将其映射成一个新的元素。\n        */\n        List<String> list = Arrays.asList(\"aa\", \"bb\", \"cc\", \"dd\");\n        list.stream().map(str -> str.toUpperCase()).forEach(System.out::println);\n\n//        练习1：获取员工姓名长度大于3的员工的姓名。\n        List<Employee> employees = EmployeeData.getEmployees();\n        Stream<String> namesStream = employees.stream().map(Employee::getName);\n        namesStream.filter(name -> name.length() > 3).forEach(System.out::println);\n        System.out.println();\n        //练习2：\n        Stream<Stream<Character>> streamStream = list.stream().map(StreamAPITest1::fromStringToStream);\n        //这个还需要两层遍历\n        streamStream.forEach(s ->{\n            s.forEach(System.out::println);\n        });\n        System.out.println();\n        /*\n        flatMap(Function f)——接收一个函数作为参数，将流中的每个值都换成另一个流，然后把所有流连\n        接成一个流。flatMap一层遍历即可拿到想要的结果\n        */\n        Stream<Character> characterStream = list.stream().flatMap(StreamAPITest1::fromStringToStream);\n        characterStream.forEach(System.out::println);\n\n    }\n\n    //将字符串中的多个字符构成的集合转换为对应的Stream的实例\n    public static Stream<Character> fromStringToStream(String str){//aa\n        ArrayList<Character> list = new ArrayList<>();\n        for(Character c : str.toCharArray()){\n            list.add(c);\n        }\n       return list.stream();\n\n    }\n\n\n    //3-排序\n    @Test\n    public void test4(){\n//        sorted()——自然排序\n        List<Integer> list = Arrays.asList(12, 43, 65, 34, 87, 0, -98, 7);\n        list.stream().sorted().forEach(System.out::println);\n        //抛异常，原因:Employee没有实现Comparable接口\n//        List<Employee> employees = EmployeeData.getEmployees();\n//        employees.stream().sorted().forEach(System.out::println);\n\n\n//        sorted(Comparator com)——定制排序\n\n        List<Employee> employees = EmployeeData.getEmployees();\n        employees.stream().sorted( (e1,e2) -> {\n\n           int ageValue = Integer.compare(e1.getAge(),e2.getAge());\n           if(ageValue != 0){\n               return ageValue;\n           }else{\n               return -Double.compare(e1.getSalary(),e2.getSalary());\n           }\n\n        }).forEach(System.out::println);\n    }\n\n}\n\n```\n\n\n\n## 终止操作\n\n\n\n```Java\n\n/**\n * 测试Stream的终止操作\n *\n */\npublic class StreamAPITest2 {\n\n    //1-匹配与查找\n    @Test\n    public void test1(){\n        List<Employee> employees = EmployeeData.getEmployees();\n\n//        allMatch(Predicate p)——检查是否匹配所有元素。\n//          练习：是否所有的员工的年龄都大于18\n        boolean allMatch = employees.stream().allMatch(e -> e.getAge() > 18);\n        System.out.println(allMatch);\n\n//        anyMatch(Predicate p)——检查是否至少匹配一个元素。\n//         练习：是否存在员工的工资大于 10000\n        boolean anyMatch = employees.stream().anyMatch(e -> e.getSalary() > 10000);\n        System.out.println(anyMatch);\n\n//        noneMatch(Predicate p)——检查是否没有匹配的元素。\n//          练习：是否存在员工姓“雷”\n        boolean noneMatch = employees.stream().noneMatch(e -> e.getName().startsWith(\"雷\"));\n        System.out.println(noneMatch);\n//        findFirst——返回第一个元素\n        Optional<Employee> employee = employees.stream().findFirst();\n        System.out.println(employee);\n//        findAny——返回当前流中的任意元素\n        Optional<Employee> employee1 = employees.parallelStream().findAny();\n        System.out.println(employee1);\n\n    }\n\n    @Test\n    public void test2(){\n        List<Employee> employees = EmployeeData.getEmployees();\n        // count——返回流中元素的总个数\n        long count = employees.stream().filter(e -> e.getSalary() > 5000).count();\n        System.out.println(count);\n//        max(Comparator c)——返回流中最大值\n//        练习：返回最高的工资：\n        Stream<Double> salaryStream = employees.stream().map(e -> e.getSalary());\n        Optional<Double> maxSalary = salaryStream.max(Double::compare);\n        System.out.println(maxSalary);\n//        min(Comparator c)——返回流中最小值\n//        练习：返回最低工资的员工\n        Optional<Employee> employee = employees.stream().min((e1, e2) -> Double.compare(e1.getSalary(), e2.getSalary()));\n        System.out.println(employee);\n        System.out.println();\n//        forEach(Consumer c)——内部迭代\n        employees.stream().forEach(System.out::println);\n\n        //使用集合的遍历操作\n        employees.forEach(System.out::println);\n    }\n\n    //2-归约\n    @Test\n    public void test3(){\n//        reduce(T identity, BinaryOperator)——可以将流中元素反复结合起来，得到一个值。返回 T\n//        练习1：计算1-10的自然数的和\n        List<Integer> list = Arrays.asList(1,2,3,4,5,6,7,8,9,10);\n        Integer sum = list.stream().reduce(0, Integer::sum);\n        System.out.println(sum);\n\n\n//        reduce(BinaryOperator) ——可以将流中元素反复结合起来，得到一个值。返回 Optional<T>\n//        练习2：计算公司所有员工工资的总和\n        List<Employee> employees = EmployeeData.getEmployees();\n        Stream<Double> salaryStream = employees.stream().map(Employee::getSalary);\n//        Optional<Double> sumMoney = salaryStream.reduce(Double::sum);\n        Optional<Double> sumMoney = salaryStream.reduce((d1,d2) -> d1 + d2);\n        System.out.println(sumMoney.get());\n\n    }\n\n    //3-收集\n    @Test\n    public void test4(){\n// collect(Collector c)——将流转换为其他形式。接收一个 Collector接口的实现，用于给Stream中元素做汇总的方法\n//        练习1：查找工资大于6000的员工，结果返回为一个List或Set\n\n        List<Employee> employees = EmployeeData.getEmployees();\n        List<Employee> employeeList = employees.stream().filter(e -> e.getSalary() > 6000).collect(Collectors.toList());\n\n        employeeList.forEach(System.out::println);\n        System.out.println();\n        Set<Employee> employeeSet = employees.stream().filter(e -> e.getSalary() > 6000).collect(Collectors.toSet());\n\n        employeeSet.forEach(System.out::println);\n\n\n\n\n    }\n}\n\n```\n\n\n\n# Optional类\n\n## 什么是Optional？\n\n\n\n- 到目前为止，臭名昭著的空指针异常是导致Java应用程序失败的最常见原因。以前，为了解决空指针异常，Google公司著名的Guava项目引入了Optional类，Guava通过使用检查空值的方式来防止代码污染，它鼓励程序员写更干净的代码。受到Google Guava的启发，Optional类已经成为Java 8类库的一部分。\n\n- Optional<T> 类(java.util.Optional) 是一个容器类，它可以保存类型T的值，代表这个值存在。或者仅仅保存null，表示这个值不存在。原来用 null 表示一个值不存在，现在 Optional 可以更好的表达这个概念。并且可以避免空指针异常。 \n\n- Optional类的Javadoc描述如下：这是一个可以为null的容器对象。如果值存在则isPresent()方法会返回true，调用get()方法会返回该对象。\n\n\n\n## 常用API\n\n<img src=\"https://npm.elemecdn.com/youthlql@1.0.8/Java_Basis/Java8_New_Features/0005.png\">\n\n\n\n\n\n## 举例\n\n首先准备两个类\n\n```java\n\npublic class Boy {\n    private Girl girl;\n\n    @Override\n    public String toString() {\n        return \"Boy{\" +\n                \"girl=\" + girl +\n                '}';\n    }\n\n    public Girl getGirl() {\n        return girl;\n    }\n\n    public void setGirl(Girl girl) {\n        this.girl = girl;\n    }\n\n    public Boy() {\n\n    }\n\n    public Boy(Girl girl) {\n\n        this.girl = girl;\n    }\n}\n```\n\n\n\n```java\npublic class Girl {\n\n    private String name;\n\n    @Override\n    public String toString() {\n        return \"Girl{\" +\n                \"name='\" + name + '\\'' +\n                '}';\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public Girl() {\n\n    }\n\n    public Girl(String name) {\n\n        this.name = name;\n    }\n}\n```\n\n\n\n这里只是简单的测试两个API\n\n```Java\n/**\n * Optional类：为了在程序中避免出现空指针异常而创建的。\n *\n * 常用的方法：ofNullable(T t)\n *            orElse(T t)\n *\n */\npublic class OptionalTest {\n\n/*\nOptional.of(T t) : 创建一个 Optional 实例，t必须非空；\nOptional.empty() : 创建一个空的 Optional 实例\nOptional.ofNullable(T t)：t可以为null\n\n */\n    @Test\n    public void test1(){\n        Girl girl = new Girl();\n//        girl = null;\n        //of(T t):保证t是非空的\n        Optional<Girl> optionalGirl = Optional.of(girl);\n\n    }\n\n    @Test\n    public void test2(){\n        Girl girl = new Girl();\n//        girl = null;\n        //ofNullable(T t)：t可以为null\n        Optional<Girl> optionalGirl = Optional.ofNullable(girl);\n        System.out.println(optionalGirl);\n        //orElse(T t1):如果单前的Optional内部封装的t是非空的，则返回内部的t.\n        //如果内部的t是空的，则返回orElse()方法中的参数t1.\n        Girl girl1 = optionalGirl.orElse(new Girl(\"赵丽颖\"));\n        System.out.println(girl1);\n\n    }\n}\n```\n\n\n\n**实际场景使用**\n\n可能出现空指针的例子：\n\n```java\npublic String getGirlName(Boy boy){\n        return boy.getGirl().getName();\n    }\n\n    @Test\n    public void test3(){\n        Boy boy = new Boy();\n        boy = null;\n        String girlName = getGirlName(boy);\n        System.out.println(girlName);\n\n    }\n```\n\n\n\n结果：\n\n```\njava.lang.NullPointerException\n\tat com.atguigu.java4.OptionalTest.getGirlName(OptionalTest.java:47)\n\tat com.atguigu.java4.OptionalTest.test3(OptionalTest.java:54)\n...\n...\n\nProcess finished with exit code -1\n```\n\n\n\n没有Optional的解决办法，但是如果调用层数过多，就得一层一层判断是否为null，写起来很麻烦。\n\n```Java\n//优化以后的getGirlName():\n    public String getGirlName1(Boy boy){\n        if(boy != null){\n            Girl girl = boy.getGirl();\n            if(girl != null){\n                return girl.getName();\n            }\n        }\n\n        return null;\n\n    }\n@Test\n    public void test4(){\n        Boy boy = new Boy();\n        boy = null;\n        String girlName = getGirlName1(boy);\n        System.out.println(girlName);\n\n    }\n```\n\n\n\n使用Optional解决问题：\n\n```Java\n //使用Optional类的getGirlName():\n    public String getGirlName2(Boy boy){\n\n        Optional<Boy> boyOptional = Optional.ofNullable(boy);\n        //此时的boy1一定非空\n        Boy boy1 = boyOptional.orElse(new Boy(new Girl(\"迪丽热巴\")));\n\n        Girl girl = boy1.getGirl();\n\n        Optional<Girl> girlOptional = Optional.ofNullable(girl);\n        //girl1一定非空\n        Girl girl1 = girlOptional.orElse(new Girl(\"古力娜扎\"));\n\n        return girl1.getName();\n    }\n\n    @Test\n    public void test5(){\n        Boy boy = null;\n        boy = new Boy();\n        boy = new Boy(new Girl(\"苍老师\"));\n        String girlName = getGirlName2(boy);\n        System.out.println(girlName);\n\n    }\n```\n\n这种是绝对不会出现空指针的。\n\n\n\n# 接口的增强\n\n```\nJDK7及以前：只能定义全局常量和抽象方法\n  >全局常量：public static final的.但是书写时，可以省略不写\n  >抽象方法：public abstract的\n  \t\t\t\nJDK8：除了定义全局常量和抽象方法之外，还可以定义静态方法、默认方法\n```\n\n\n\n```java\n/*\n * JDK8：除了定义全局常量和抽象方法之外，还可以定义静态方法、默认方法\n */\npublic interface CompareA {\n\n    //静态方法\n    public static void method1() {\n\n        System.out.println(\"CompareA:北京\");\n    }\n\n    //默认方法\n    public default void method2() {\n        System.out.println(\"CompareA：上海\");\n    }\n    //接口中的public 可以省略，自动就是public\n    default void method3() {\n        System.out.println(\"CompareA：上海\");\n    }\n}\n```\n\n\n\n```java\npublic class SuperClass {\n\t\n\tpublic void method3(){\n\t\tSystem.out.println(\"SuperClass:北京\");\n\t}\n\t\n}\n```\n\n\n\n```java\npublic interface CompareB {\n\t\n\tdefault void method3(){\n\t\tSystem.out.println(\"CompareB：上海\");\n\t}\n\t\n}\n```\n\n\n\n\n\n```java\npublic class SubClassTest {\n\t\n\tpublic static void main(String[] args) {\n\t\tSubClass s = new SubClass();\n\t\t\n//\t\ts.method1();\n//\t\tSubClass.method1();\n\t\t//知识点1：接口中定义的静态方法，只能通过接口来调用。实现类用不了\n\t\tCompareA.method1();\n\t\t//知识点2：通过实现类的对象，可以调用接口中的默认方法。\n\t\t//如果实现类重写了接口中的默认方法，调用时，仍然调用的是重写以后的方法\n\t\ts.method2();\n\t\t//知识点3：如果子类(或实现类)继承的父类和实现的接口中声明了同名同参数的默认方法，\n\t\t//那么子类在没有重写此方法的情况下，默认调用的是父类中的同名同参数的方法。-->类优先原则\n\t\t//知识点4：如果实现类实现了多个接口，而这多个接口中定义了同名同参数的默认方法，\n\t\t//那么在实现类没有重写此方法的情况下，报错。-->接口冲突。\n\t\t//这就需要我们必须在实现类中重写此方法\n\t\ts.method3();\n\t\t\n\t}\n\t\n}\n\nclass SubClass extends SuperClass implements CompareA,CompareB{\n\t\n\tpublic void method2(){\n\t\tSystem.out.println(\"SubClass：上海\");\n\t}\n\t\n\tpublic void method3(){\n\t\tSystem.out.println(\"SubClass：深圳\");\n\t}\n\t\n\t//知识点5：如何在子类(或实现类)的方法中调用父类、接口中被重写的方法\n\tpublic void myMethod(){\n\t\tmethod3();//调用自己定义的重写的方法\n\t\tsuper.method3();//调用的是父类中声明的\n\t\t//调用接口中的默认方法\n\t\tCompareA.super.method3();\n\t\tCompareB.super.method3();\n\t}\n}\n```\n","source":"_posts/2021-04-14-Java8新特性.md","raw":"---\ntitle: 详解JDK8新特性\ndate: 2024-04-14 22:32:58\ntags:\n  - Java8\n  - JDK8\n  - 新特性\ncategories:\n  - Java\n  - 新特性\nkeywords: Java8，新特性，JDK8\ndescription: 详解JDK8出现的新特性。\ncover: 'https://npm.elemecdn.com/lql_static@latest/logo/java.png'\n---\n\n\n\n# Java8新特性纵览\n\n> 关于Java8新特性的学习与记录，资料来源于互联网。\n\n\n# Lambda表达式\n\n## 为什么使用Lambda表达式？\n\n- Lambda 是一个**匿名函数**，我们可以把 Lambda 表达式理解为是**一段可以传递的代码**（将代码像数据一样进行传递）。使用它可以写出更简洁、更灵活的代码。作为一种更紧凑的代码风格，使Java的语言表达能力得到了提升。\n- 在Java8之后的很多源码里用到了Lambda表达式，不学的话可能看不懂源码。\n\n\n\n## 简单使用\n\n```java\n @Test\n    public void test1(){\n        //原始写法\n        Runnable r1 = new Runnable() {\n            @Override\n            public void run() {\n                System.out.println(\"我爱北京天安门\");\n            }\n        };\n\n        r1.run();\n\n        System.out.println(\"***********************\");\n\n        //lambda表达式，可以表达一样的意思\n        Runnable r2 = () -> System.out.println(\"我爱北京故宫\");\n\n        r2.run();\n    }\n\n\n    @Test\n    public void test2(){\n\n        Comparator<Integer> com1 = new Comparator<Integer>() {\n            @Override\n            public int compare(Integer o1, Integer o2) {\n                return Integer.compare(o1,o2);\n            }\n        };\n\n        int compare1 = com1.compare(12,21);\n        System.out.println(compare1);\n\n        System.out.println(\"***********************\");\n        \n        //Lambda表达式的写法\n        Comparator<Integer> com2 = (o1,o2) -> Integer.compare(o1,o2);\n\n        int compare2 = com2.compare(32,21);\n        System.out.println(compare2);\n\n\n        System.out.println(\"***********************\");\n        //方法引用\n        Comparator<Integer> com3 = Integer :: compare;\n\n        int compare3 = com3.compare(32,21);\n        System.out.println(compare3);\n    }\n```\n\n\n\n## Lambda语法规则\n\n```Java\nimport org.junit.Test;\n\nimport java.util.ArrayList;\nimport java.util.Comparator;\nimport java.util.function.Consumer;\n\n/**\n * Lambda表达式的使用\n * <p>\n * 1.举例： (o1,o2) -> Integer.compare(o1,o2);\n * 2.格式：\n * -> :lambda操作符 或 箭头操作符\n * ->左边：lambda形参列表 （其实就是接口中的抽象方法的形参列表）\n * ->右边：lambda体 （其实就是重写的抽象方法的方法体）\n * <p>\n * 3. Lambda表达式的使用：（分为6种情况介绍）\n * <p>\n * 总结：\n * ->左边：lambda形参列表的参数类型可以省略(类型推断)；如果lambda形参列表只有一个参数，其一对()也\n * 可以省略\n * ->右边：lambda体应该使用一对{}包裹；如果lambda体只有一条执行语句（可能是return语句），省略这一\n 对{}和return关键字\n * <p>\n * 4.Lambda表达式的本质：作为函数式接口的实例\n * <p>\n * 5. 如果一个接口中，只声明了一个抽象方法，则此接口就称为函数式接口。我们可以在一个接口上\n 使用 @FunctionalInterface 注解，\n * 这样做可以检查它是否是一个函数式接口。\n * <p>\n * 6. 所以以前用匿名实现类表示的现在都可以用Lambda表达式来写。\n */\npublic class LambdaTest1 {\n    //语法格式一：无参，无返回值\n    @Test\n    public void test1() {\n        Runnable r1 = new Runnable() {\n            @Override\n            public void run() {\n                System.out.println(\"我爱北京天安门\");\n            }\n        };\n\n        r1.run();\n\n        System.out.println(\"***********************\");\n\n        Runnable r2 = () -> {\n            System.out.println(\"我爱北京故宫\");\n        };\n\n        r2.run();\n    }\n\n    //语法格式二：Lambda 需要一个参数，但是没有返回值。\n    @Test\n    public void test2() {\n\n        Consumer<String> con = new Consumer<String>() {\n            @Override\n            public void accept(String s) {\n                System.out.println(s);\n            }\n        };\n        con.accept(\"谎言和誓言的区别是什么？\");\n\n        System.out.println(\"*******************\");\n\n        Consumer<String> con1 = (String s) -> {\n            System.out.println(s);\n        };\n        con1.accept(\"一个是听得人当真了，一个是说的人当真了\");\n\n    }\n\n    //语法格式三：数据类型可以省略，因为可由编译器推断得出，称为“类型推断”\n    @Test\n    public void test3() {\n\n        Consumer<String> con1 = (String s) -> {\n            System.out.println(s);\n        };\n        con1.accept(\"一个是听得人当真了，一个是说的人当真了\");\n\n        System.out.println(\"*******************\");\n\n        Consumer<String> con2 = (s) -> {\n            System.out.println(s);\n        };\n        con2.accept(\"一个是听得人当真了，一个是说的人当真了\");\n\n    }\n\n    @Test\n    public void test4() {\n\n        ArrayList<String> list = new ArrayList<>();//类型推断\n\n        int[] arr = {1, 2, 3};//类型推断\n\n    }\n\n    //语法格式四：Lambda 若只需要一个参数时，参数的小括号可以省略\n    @Test\n    public void test5() {\n        Consumer<String> con1 = (s) -> {\n            System.out.println(s);\n        };\n        con1.accept(\"一个是听得人当真了，一个是说的人当真了\");\n\n        System.out.println(\"*******************\");\n\n        Consumer<String> con2 = s -> {\n            System.out.println(s);\n        };\n        con2.accept(\"一个是听得人当真了，一个是说的人当真了\");\n\n\n    }\n\n    //语法格式五：Lambda 需要两个或以上的参数，多条执行语句，并且可以有返回值\n    @Test\n    public void test6() {\n\n        Comparator<Integer> com1 = new Comparator<Integer>() {\n            @Override\n            public int compare(Integer o1, Integer o2) {\n                System.out.println(o1);\n                System.out.println(o2);\n                return o1.compareTo(o2);\n            }\n        };\n\n        System.out.println(com1.compare(12, 21));\n\n        System.out.println(\"*****************************\");\n        Comparator<Integer> com2 = (o1, o2) -> {\n            System.out.println(o1);\n            System.out.println(o2);\n            return o1.compareTo(o2);\n        };\n\n        System.out.println(com2.compare(12, 6));\n\n\n    }\n\n    //语法格式六：当 Lambda 体只有一条语句时，return 与大括号若有，都可以省略\n    @Test\n    public void test7() {\n\n        Comparator<Integer> com1 = (o1, o2) -> {\n            return o1.compareTo(o2);\n        };\n\n        System.out.println(com1.compare(12, 6));\n\n        System.out.println(\"*****************************\");\n\n        Comparator<Integer> com2 = (o1, o2) -> o1.compareTo(o2);\n\n        System.out.println(com2.compare(12, 21));\n\n    }\n\n    @Test\n    public void test8() {\n        Consumer<String> con1 = s -> {\n            System.out.println(s);\n        };\n        con1.accept(\"一个是听得人当真了，一个是说的人当真了\");\n\n        System.out.println(\"*****************************\");\n\n        Consumer<String> con2 = s -> System.out.println(s);\n\n        con2.accept(\"一个是听得人当真了，一个是说的人当真了\");\n\n    }\n\n}\n```\n\n\n\n# 函数式接口\n\n\n\n## 什么是函数式(Functional)接口\n\n- 只包含一个抽象方法的接口，称为**函数式接口**。 \n\n- 你可以通过 Lambda 表达式来创建该接口的对象。（若 Lambda 表达式抛出一个受检异常(即：非运行时异常)，那么该异常需要在目标接口的抽象方法上进行声明）。\n\n- 我们可以在一个接口上使用 **@FunctionalInterface** 注解，这样做可以检查它是否是一个函数式接口。同时 javadoc 也会包含一条声明，说明这个接口是一个函数式接口。\n\n- 在java.util.function包下定义了Java 8 的丰富的函数式接口\n\n\n\n## 如何理解函数式接口\n\n- Java从诞生日起就是一直倡导“一切皆对象”，在Java里面面向对象(OOP)编程是一切。但是随着python、scala等语言的兴起和新技术的挑战，Java不得不做出调整以便支持更加广泛的技术要求，也即java不但可以支持OOP还可以支持OOF（面向函数编程） \n- 在函数式编程语言当中，函数被当做一等公民对待。在将函数作为一等公民的编程语言中，Lambda表达式的类型是函数。但是在Java8中，有所不同。在Java8中，Lambda表达式是对象，而不是函数，它们必须依附于一类特别的对象类型——函数式接口。 \n- 简单的说，在Java8中，Lambda表达式就是一个函数式接口的实例。这就是Lambda表达式和函数式接口的关系。也就是说，只要一个对象是函数式接口的实例，那么该对象就可以用Lambda表达式来表示。\n- 所以以前用匿名实现类表示的现在都可以用Lambda表达式来写。\n\n\n\n## Java内置函数式接口\n\n\n\n**核心函数式接口**\n\n<img src=\"https://npm.elemecdn.com/youthlql@1.0.8/Java_Basis/Java8_New_Features/0002.png\">\n\n\n\n**其它函数式接口**\n\n<img src=\"https://npm.elemecdn.com/youthlql@1.0.8/Java_Basis/Java8_New_Features/0003.png\">\n\n\n\n\n\n**Consumer**\n\n```java\n @Test\n    public void test1(){\n\n        happyTime(500, new Consumer<Double>() {\n            @Override\n            public void accept(Double aDouble) {\n                System.out.println(\"学习太累了，去天上人间买了瓶矿泉水，价格为：\" + aDouble);\n            }\n        });\n\n        System.out.println(\"********************\");\n\n        happyTime(400,money -> System.out.println(\"学习太累了，去天上人间喝了口水，价格为：\" + money));\n    }\n\n    public void happyTime(double money, Consumer<Double> con){\n        con.accept(money);\n    }\n```\n\n\n\n**结果：**\n\n```Java\n学习太累了，去天上人间买了瓶矿泉水，价格为：500.0\n********************\n学习太累了，去天上人间喝了口水，价格为：400.0\n\nProcess finished with exit code 0\n```\n\n\n\n**Predicate**\n\n```java\n@Test\n    public void test2(){\n        List<String> list = Arrays.asList(\"北京\",\"南京\",\"天津\",\"东京\",\"西京\",\"普京\");\n\n        List<String> filterStrs = filterString(list, new Predicate<String>() {\n            @Override\n            public boolean test(String s) {//这里是定义一个校验规则\n                return s.contains(\"京\");\n            }\n        });\n\n        System.out.println(filterStrs);\n\n        //用lambda表达式会很简单\n        List<String> filterStrs1 = filterString(list,s -> s.contains(\"京\"));\n        System.out.println(filterStrs1);\n    }\n\n    //根据给定的规则，过滤集合中的字符串。此规则由Predicate的方法决定\n    public List<String> filterString(List<String> list, Predicate<String> pre){\n\n        ArrayList<String> filterList = new ArrayList<>();\n\n        for(String s : list){\n            if(pre.test(s)){\n                filterList.add(s);\n            }\n        }\n\n        return filterList;\n\n    }\n\n```\n\n\n\n**结果：**\n\n```\n[北京, 南京, 东京, 西京, 普京]\n[北京, 南京, 东京, 西京, 普京]\n\nProcess finished with exit code 0\n```\n\n\n\n## 自定义函数式接口\n\n```java\n/**\n * 自定义函数式接口\n * 只是说加上@FunctionalInterface之后可以校验\n */\n@FunctionalInterface\npublic interface MyFunInterface<T> {\n\n    public T getValue(T t);\n\n}\n```\n\n\n\n```java\npublic class Test {\n\n    public static void main(String[] args) {\n        //这个方法的第一个参数是lambda表达式，相当于是实例化了那个函数式接口\n        String s = toUpperString(str -> str.toUpperCase(), \"abcd\");\n        System.out.println(s);\n    }\n\n    public static String toUpperString(MyFunInterface<String> mf,String str){\n        return mf.getValue(str);\n    }\n}\n```\n\n\n\n# 方法引用\n\n- 当要传递给Lambda体的操作，已经有实现的方法了，可以使用方法引用！\n\n- 方法引用可以看做是Lambda表达式深层次的表达。换句话说，方法引用就是Lambda表达式，也就是函数式接口的一个实例，通过方法的名字来指向一个方法，可以认为是Lambda表达式的一个语法糖。\n\n- 要求：实现接口的抽象方法的参数列表和返回值类型，必须与方法引用的方法的参数列表和返回值类型保持一致！\n\n- 格式：使用操作符 “::” 将类(或对象) 与 方法名分隔开来。\n\n- 如下三种主要使用情况： \n\n  - 对象 :: 实例方法名\n\n  - 类 :: 静态方法名\n\n  - 类 :: 实例方法名\n\n\n\n我们直接拿例子来说明情况，先提前准备两个类：\n\n```Java\n\npublic class Employee {\n\n\tprivate int id;\n\tprivate String name;\n\tprivate int age;\n\tprivate double salary;\n\n\tpublic int getId() {\n\t\treturn id;\n\t}\n\n\tpublic void setId(int id) {\n\t\tthis.id = id;\n\t}\n\n\tpublic String getName() {\n\t\treturn name;\n\t}\n\n\tpublic void setName(String name) {\n\t\tthis.name = name;\n\t}\n\n\tpublic int getAge() {\n\t\treturn age;\n\t}\n\n\tpublic void setAge(int age) {\n\t\tthis.age = age;\n\t}\n\n\tpublic double getSalary() {\n\t\treturn salary;\n\t}\n\n\tpublic void setSalary(double salary) {\n\t\tthis.salary = salary;\n\t}\n\n\tpublic Employee() {\n\t\tSystem.out.println(\"Employee().....\");\n\t}\n\n\tpublic Employee(int id) {\n\t\tthis.id = id;\n\t\tSystem.out.println(\"Employee(int id).....\");\n\t}\n\n\tpublic Employee(int id, String name) {\n\t\tthis.id = id;\n\t\tthis.name = name;\n\t}\n\n\tpublic Employee(int id, String name, int age, double salary) {\n\n\t\tthis.id = id;\n\t\tthis.name = name;\n\t\tthis.age = age;\n\t\tthis.salary = salary;\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn \"Employee{\" + \"id=\" + id + \", name='\" + name + '\\'' + \", age=\" + age + \", salary=\" + salary + '}';\n\t}\n\n\t@Override\n\tpublic boolean equals(Object o) {\n\t\tif (this == o)\n\t\t\treturn true;\n\t\tif (o == null || getClass() != o.getClass())\n\t\t\treturn false;\n\n\t\tEmployee employee = (Employee) o;\n\n\t\tif (id != employee.id)\n\t\t\treturn false;\n\t\tif (age != employee.age)\n\t\t\treturn false;\n\t\tif (Double.compare(employee.salary, salary) != 0)\n\t\t\treturn false;\n\t\treturn name != null ? name.equals(employee.name) : employee.name == null;\n\t}\n\n\t@Override\n\tpublic int hashCode() {\n\t\tint result;\n\t\tlong temp;\n\t\tresult = id;\n\t\tresult = 31 * result + (name != null ? name.hashCode() : 0);\n\t\tresult = 31 * result + age;\n\t\ttemp = Double.doubleToLongBits(salary);\n\t\tresult = 31 * result + (int) (temp ^ (temp >>> 32));\n\t\treturn result;\n\t}\n}\n\n```\n\n\n\n```Java\n/**\n * 提供用于测试的数据\n */\npublic class EmployeeData {\n   \n   public static List<Employee> getEmployees(){\n      List<Employee> list = new ArrayList<>();\n      \n      list.add(new Employee(1001, \"马化腾\", 34, 6000.38));\n      list.add(new Employee(1002, \"马云\", 12, 9876.12));\n      list.add(new Employee(1003, \"刘强东\", 33, 3000.82));\n      list.add(new Employee(1004, \"雷军\", 26, 7657.37));\n      list.add(new Employee(1005, \"李彦宏\", 65, 5555.32));\n      list.add(new Employee(1006, \"比尔盖茨\", 42, 9500.43));\n      list.add(new Employee(1007, \"任正非\", 26, 4333.32));\n      list.add(new Employee(1008, \"扎克伯格\", 35, 2500.32));\n      \n      return list;\n   }\n   \n}\n```\n\n\n\n**下面来通过实际例子讲解方法引用：**\n\n```java\n\n\n/**\n * 方法引用的使用\n *\n * 1.使用情境：当要传递给Lambda体的操作，已经有实现的方法了，可以使用方法引用！\n *\n * 2.方法引用，本质上就是Lambda表达式，而Lambda表达式作为函数式接口的实例。所以\n *   方法引用，也是函数式接口的实例。\n *\n * 3. 使用格式：  类(或对象) :: 方法名\n *\n * 4. 具体分为如下的三种情况：\n *    情况1     对象 :: 非静态方法\n *    情况2     类 :: 静态方法\n *\n *    情况3     类 :: 非静态方法\n *\n * 5. 方法引用使用的要求：\n * \t接口中的抽象方法的形参列表和返回值类型\n * \t与\n * \t方法引用的方法的形参列表和返回值类型相同！（针对于情况1和情况2）\n *\n */\npublic class MethodRefTest {\n\n\t// 情况一：对象 :: 实例方法\n\t//Consumer中的void accept(T t)\n\t//PrintStream中的void println(T t)\n\t@Test\n\tpublic void test1() {\n\t\tConsumer<String> con1 = str -> System.out.println(str);\n\t\tcon1.accept(\"北京\");\n\n\t\tSystem.out.println(\"*******************\");\n\t\tPrintStream ps = System.out;\n\t\tConsumer<String> con2 = ps::println;\n\t\tcon2.accept(\"beijing\");\n\t}\n\t\n\t//Supplier中的T get()\n\t//Employee中的String getName()\n\t@Test\n\tpublic void test2() {\n\t\tEmployee emp = new Employee(1001,\"Tom\",23,5600);\n\n\t\tSupplier<String> sup1 = () -> emp.getName();\n\t\tSystem.out.println(sup1.get());\n\n\t\tSystem.out.println(\"*******************\");\n\t\tSupplier<String> sup2 = emp::getName;\n\t\tSystem.out.println(sup2.get());\n\n\t}\n\n\t// 情况二：类 :: 静态方法\n\t//Comparator中的int compare(T t1,T t2)\n\t//Integer中的int compare(T t1,T t2)\n\t@Test\n\tpublic void test3() {\n\t\tComparator<Integer> com1 = (t1,t2) -> Integer.compare(t1,t2);\n\t\tSystem.out.println(com1.compare(12,21));\n\n\t\tSystem.out.println(\"*******************\");\n\n\t\tComparator<Integer> com2 = Integer::compare;\n\t\tSystem.out.println(com2.compare(12,3));\n\n\t}\n\t\n\t//Function中的R apply(T t)\n\t//Math中的Long round(Double d)\n\t@Test\n\tpublic void test4() {\n\t\tFunction<Double,Long> func = new Function<Double, Long>() {\n\t\t\t@Override\n\t\t\tpublic Long apply(Double d) {\n\t\t\t\treturn Math.round(d);\n\t\t\t}\n\t\t};\n\n\t\tSystem.out.println(\"*******************\");\n\n\t\tFunction<Double,Long> func1 = d -> Math.round(d);\n\t\tSystem.out.println(func1.apply(12.3));\n\n\t\tSystem.out.println(\"*******************\");\n\n\t\tFunction<Double,Long> func2 = Math::round;\n\t\tSystem.out.println(func2.apply(12.6));\n\t}\n\n\t// 情况三：类 :: 实例方法  (有难度)\n\t// Comparator中的int comapre(T t1,T t2)  第一个参数T t1,也可以变成方法的调用者\n\t// String中的int t1.compareTo(t2)        看上面说的，t1变成了调用者等价于第一个参数T t1\n\t@Test\n\tpublic void test5() {\n\t\tComparator<String> com1 = (s1,s2) -> s1.compareTo(s2);\n\t\tSystem.out.println(com1.compare(\"abc\",\"abd\"));\n\n\t\tSystem.out.println(\"*******************\");\n\n\t\tComparator<String> com2 = String :: compareTo;\n\t\tSystem.out.println(com2.compare(\"abd\",\"abm\"));\n\t}\n\n\t//BiPredicate中的boolean test(T t1, T t2);\n\t//String中的boolean t1.equals(t2)\n\t@Test\n\tpublic void test6() {\n\t\tBiPredicate<String,String> pre1 = (s1,s2) -> s1.equals(s2);\n\t\tSystem.out.println(pre1.test(\"abc\",\"abc\"));\n\n\t\tSystem.out.println(\"*******************\");\n\t\tBiPredicate<String,String> pre2 = String :: equals;\n\t\tSystem.out.println(pre2.test(\"abc\",\"abd\"));\n\t}\n\t\n\t// Function中的R apply(T t)\n\t// Employee中的String getName();   第一个参数T t相当于方法调用者emp，返回值R和String对应\n\t@Test\n\tpublic void test7() {\n\t\tEmployee employee = new Employee(1001, \"Jerry\", 23, 6000);\n\n\n\t\tFunction<Employee,String> func1 = e -> e.getName();\n\t\tSystem.out.println(func1.apply(employee));\n\n\t\tSystem.out.println(\"*******************\");\n\n\n\t\tFunction<Employee,String> func2 = Employee::getName;\n\t\tSystem.out.println(func2.apply(employee));\n\n\n\t}\n\n}\n\n```\n\n\n\n\n\n# 构造器引用\n\n格式：ClassName :: new\n\n与函数式接口相结合，自动与函数式接口中方法兼容。可以把构造器引用赋值给定义的方法，要求构造器参数列表要与接口中抽象方法的参数列表一致！且方法的返回值即为构造器对应类的对象。\n\n\n\n```Java\n\nimport org.junit.Test;\n\nimport java.util.Arrays;\nimport java.util.function.BiFunction;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\n\n/**\n * 一、构造器引用\n *      和方法引用类似，函数式接口的抽象方法的形参列表和构造器的形参列表一致。\n *      抽象方法的返回值类型即为构造器所属的类的类型\n *\n * 二、数组引用\n *     大家可以把数组看做是一个特殊的类，则写法与构造器引用一致。\n *\n */\npublic class ConstructorRefTest {\n\n    /**\n     * 构造器引用\n     * Supplier中的T get()\n     * Employee的空参构造器：Employee()\n     * 1、和方法引用一样的理解方法，你的get()方法没有参数，我的Employee()也没有参数。\n     * 2、你的get()方法有返回值T，我的Employee()方法返回值也是一个对象\n     * 3、所以刚好可以用  \n     */\n    @Test\n    public void test1(){\n\n        Supplier<Employee> sup = new Supplier<Employee>() {\n            @Override\n            public Employee get() {\n                return new Employee();\n            }\n        };\n        System.out.println(\"*******************\");\n\n        Supplier<Employee>  sup1 = () -> new Employee();\n        System.out.println(sup1.get());\n\n        System.out.println(\"*******************\");\n\n        Supplier<Employee>  sup2 = Employee :: new;\n        System.out.println(sup2.get());\n    }\n\n\t//Function中的R apply(T t)\n    @Test\n    public void test2(){\n        Function<Integer,Employee> func1 = id -> new Employee(id);\n        Employee employee = func1.apply(1001);\n        System.out.println(employee);\n\n        System.out.println(\"*******************\");\n\n        Function<Integer,Employee> func2 = Employee :: new;\n        Employee employee1 = func2.apply(1002);\n        System.out.println(employee1);\n\n    }\n\n\t//BiFunction中的R apply(T t,U u)\n    @Test\n    public void test3(){\n        BiFunction<Integer,String,Employee> func1 = (id,name) -> new Employee(id,name);\n        System.out.println(func1.apply(1001,\"Tom\"));\n\n        System.out.println(\"*******************\");\n\n        BiFunction<Integer,String,Employee> func2 = Employee :: new;\n        System.out.println(func2.apply(1002,\"Tom\"));\n\n    }\n\n\t//数组引用\n    //Function中的R apply(T t)\n    @Test\n    public void test4(){\n        Function<Integer,String[]> func1 = length -> new String[length];\n        String[] arr1 = func1.apply(5);\n        System.out.println(Arrays.toString(arr1));\n\n        System.out.println(\"*******************\");\n\n        Function<Integer,String[]> func2 = String[] :: new;\n        String[] arr2 = func2.apply(10);\n        System.out.println(Arrays.toString(arr2));\n\n    }\n}\n\n```\n\n\n\n# 强大的Stream API\n\n## Stream API说明\n\n- Java8中有两大最为重要的改变。第一个是 **Lambda** **表达式**；另外一个则是 **Stream API**。 \n\n- Stream API ( java.util.stream) 把真正的函数式编程风格引入到Java中。这是目前为止对Java类库最好的补充，因为Stream API可以极大提供Java程序员的生产力，让程序员写出高效率、干净、简洁的代码。\n\n- Stream 是 Java8 中处理集合的关键抽象概念，它可以指定你希望对集合进行的操作，可以执行非常复杂的查找、过滤和映射数据等操作。 **使用Stream API 对集合数据进行操作，就类似于使用 SQL 执行的数据库查询。**也可以使用 Stream API 来并行执行操作。简言之，Stream API 提供了一种高效且易于使用的处理数据的方式\n\n\n\n## 为什么要使用Stream API\n\n- 实际开发中，项目中多数数据源都来自于Mysql，Oracle等，很多一些复杂的数据获取可以直接在sql层面去解决。但现在数据源可以更多了，有MongDB，Radis等，而这些NoSQL的数据本身不支持一些复杂的数据计算，这个时候就需要Java层面去处理。 \n\n- Stream 和 Collection 集合的区别：Collection 是一种静态的内存数据结构，而 Stream 是有关计算的。前者是主要面向内存，存储在内存中，后者主要是面向 CPU，通过 CPU 实现计算。\n\n\n\n## 什么是Stream\n\nStream到底是什么呢？\n\n是数据渠道，用于操作数据源（集合、数组等）所生成的元素序列。\n\n**“集合讲的是数据，Stream讲的是计算！”**\n\n**注意：**\n\n①Stream 自己不会存储元素。\n\n②Stream 不会改变源对象。相反，他们会返回一个持有结果的新Stream。 \n\n③Stream 操作是延迟执行的。这意味着他们会等到需要结果的时候才执行\n\n\n\n\n\n**Stream** **的操作三个步骤**\n\n1、创建Stream\n\n一个数据源（如：集合、数组），获取一个流\n\n2、中间操作\n\n一个中间操作链，对数据源的数据进行处理\n\n3、终止操作(终端操作) \n\n一旦执行终止操作，就执行中间操作链，才产生结果【也就是所谓的延迟执行】。之后，不会再被使用\n\n\n\n<img src=\"https://npm.elemecdn.com/youthlql@1.0.8/Java_Basis/Java8_New_Features/0004.png\">\n\n\n\n\n\n## 创建Stream\n\n\n\n```java\n\npublic class StreamAPITest {\n\n    //创建 Stream方式一：通过集合\n    @Test\n    public void test1(){\n        List<Employee> employees = EmployeeData.getEmployees();\n\n//        default Stream<E> stream() : 返回一个顺序流，顺序流等会中间操作拿数据的时候按顺序拿\n        Stream<Employee> stream = employees.stream();\n\n//        default Stream<E> parallelStream() : 返回一个并行流\n        Stream<Employee> parallelStream = employees.parallelStream();\n\n    }\n\n    //创建 Stream方式二：通过数组\n    @Test\n    public void test2(){\n        int[] arr = new int[]{1,2,3,4,5,6};\n        //调用Arrays类的static <T> Stream<T> stream(T[] array): 返回一个流\n        IntStream stream = Arrays.stream(arr);\n\n        Employee e1 = new Employee(1001,\"Tom\");\n        Employee e2 = new Employee(1002,\"Jerry\");\n        Employee[] arr1 = new Employee[]{e1,e2};\n        Stream<Employee> stream1 = Arrays.stream(arr1);\n\n    }\n    //创建 Stream方式三：通过Stream的of()，通过显示值创建一个流。它可以接收任意数量的参数\n    @Test\n    public void test3(){\n\n        Stream<Integer> stream = Stream.of(1, 2, 3, 4, 5, 6);\n\n    }\n\n    //创建 Stream方式四：创建无限流【用的少，了解下就行】\n    @Test\n    public void test4(){\n\n//      迭代\n//      public static<T> Stream<T> iterate(final T seed, final UnaryOperator<T> f)\n        //遍历前10个偶数\n        Stream.iterate(0, t -> t + 2).limit(10).forEach(System.out::println);\n\n\n//      生成\n//      public static<T> Stream<T> generate(Supplier<T> s)\n        Stream.generate(Math::random).limit(10).forEach(System.out::println);\n\n    }\n\n}\n\n```\n\n\n\n\n\n## 中间操作\n\n```Java\n\n/**\n * 测试Stream的中间操作\n */\npublic class StreamAPITest1 {\n\n    //1-筛选与切片\n    @Test\n    public void test1(){\n        List<Employee> list = EmployeeData.getEmployees();\n//        filter(Predicate p)——过滤   接收 Lambda ， 从流中排除某些元素。\n        Stream<Employee> stream = list.stream();\n        //练习：查询员工表中薪资大于7000的员工信息\n        /**\n         * List<String> filterStrs1 = filterString(list,s -> s.contains(\"京\"));\n         * 跟之前的这个lambda表达式代码是一个意思\n         */\n        stream.filter(e -> e.getSalary() > 7000).forEach(System.out::println);\n\n        System.out.println();\n//        limit(n)——截断流，使其元素不超过给定数量。\n        list.stream().limit(3).forEach(System.out::println);\n        System.out.println();\n\n        /*\n        skip(n) —— 跳过元素，返回一个扔掉了前 n 个元素的流。若流中元素不足 n 个，\n        则返回一个空流。与 limit(n) 互补\n        */\n        list.stream().skip(3).forEach(System.out::println);\n\n        System.out.println();\n//        distinct()——筛选，通过流所生成元素的 hashCode() 和 equals() 去除重复元素\n\n        list.add(new Employee(1010,\"刘强东\",40,8000));\n        list.add(new Employee(1010,\"刘强东\",41,8000));\n        list.add(new Employee(1010,\"刘强东\",40,8000));\n        list.add(new Employee(1010,\"刘强东\",40,8000));\n        list.add(new Employee(1010,\"刘强东\",40,8000));\n\n//        System.out.println(list);\n\n        list.stream().distinct().forEach(System.out::println);\n    }\n\n    //映射\n    @Test\n    public void test2(){\n        /*\n        map(Function f)——接收一个函数作为参数，将元素转换成其他形式或提取信息，该函数会被应\n        用到每个元素上，并将其映射成一个新的元素。\n        */\n        List<String> list = Arrays.asList(\"aa\", \"bb\", \"cc\", \"dd\");\n        list.stream().map(str -> str.toUpperCase()).forEach(System.out::println);\n\n//        练习1：获取员工姓名长度大于3的员工的姓名。\n        List<Employee> employees = EmployeeData.getEmployees();\n        Stream<String> namesStream = employees.stream().map(Employee::getName);\n        namesStream.filter(name -> name.length() > 3).forEach(System.out::println);\n        System.out.println();\n        //练习2：\n        Stream<Stream<Character>> streamStream = list.stream().map(StreamAPITest1::fromStringToStream);\n        //这个还需要两层遍历\n        streamStream.forEach(s ->{\n            s.forEach(System.out::println);\n        });\n        System.out.println();\n        /*\n        flatMap(Function f)——接收一个函数作为参数，将流中的每个值都换成另一个流，然后把所有流连\n        接成一个流。flatMap一层遍历即可拿到想要的结果\n        */\n        Stream<Character> characterStream = list.stream().flatMap(StreamAPITest1::fromStringToStream);\n        characterStream.forEach(System.out::println);\n\n    }\n\n    //将字符串中的多个字符构成的集合转换为对应的Stream的实例\n    public static Stream<Character> fromStringToStream(String str){//aa\n        ArrayList<Character> list = new ArrayList<>();\n        for(Character c : str.toCharArray()){\n            list.add(c);\n        }\n       return list.stream();\n\n    }\n\n\n    //3-排序\n    @Test\n    public void test4(){\n//        sorted()——自然排序\n        List<Integer> list = Arrays.asList(12, 43, 65, 34, 87, 0, -98, 7);\n        list.stream().sorted().forEach(System.out::println);\n        //抛异常，原因:Employee没有实现Comparable接口\n//        List<Employee> employees = EmployeeData.getEmployees();\n//        employees.stream().sorted().forEach(System.out::println);\n\n\n//        sorted(Comparator com)——定制排序\n\n        List<Employee> employees = EmployeeData.getEmployees();\n        employees.stream().sorted( (e1,e2) -> {\n\n           int ageValue = Integer.compare(e1.getAge(),e2.getAge());\n           if(ageValue != 0){\n               return ageValue;\n           }else{\n               return -Double.compare(e1.getSalary(),e2.getSalary());\n           }\n\n        }).forEach(System.out::println);\n    }\n\n}\n\n```\n\n\n\n## 终止操作\n\n\n\n```Java\n\n/**\n * 测试Stream的终止操作\n *\n */\npublic class StreamAPITest2 {\n\n    //1-匹配与查找\n    @Test\n    public void test1(){\n        List<Employee> employees = EmployeeData.getEmployees();\n\n//        allMatch(Predicate p)——检查是否匹配所有元素。\n//          练习：是否所有的员工的年龄都大于18\n        boolean allMatch = employees.stream().allMatch(e -> e.getAge() > 18);\n        System.out.println(allMatch);\n\n//        anyMatch(Predicate p)——检查是否至少匹配一个元素。\n//         练习：是否存在员工的工资大于 10000\n        boolean anyMatch = employees.stream().anyMatch(e -> e.getSalary() > 10000);\n        System.out.println(anyMatch);\n\n//        noneMatch(Predicate p)——检查是否没有匹配的元素。\n//          练习：是否存在员工姓“雷”\n        boolean noneMatch = employees.stream().noneMatch(e -> e.getName().startsWith(\"雷\"));\n        System.out.println(noneMatch);\n//        findFirst——返回第一个元素\n        Optional<Employee> employee = employees.stream().findFirst();\n        System.out.println(employee);\n//        findAny——返回当前流中的任意元素\n        Optional<Employee> employee1 = employees.parallelStream().findAny();\n        System.out.println(employee1);\n\n    }\n\n    @Test\n    public void test2(){\n        List<Employee> employees = EmployeeData.getEmployees();\n        // count——返回流中元素的总个数\n        long count = employees.stream().filter(e -> e.getSalary() > 5000).count();\n        System.out.println(count);\n//        max(Comparator c)——返回流中最大值\n//        练习：返回最高的工资：\n        Stream<Double> salaryStream = employees.stream().map(e -> e.getSalary());\n        Optional<Double> maxSalary = salaryStream.max(Double::compare);\n        System.out.println(maxSalary);\n//        min(Comparator c)——返回流中最小值\n//        练习：返回最低工资的员工\n        Optional<Employee> employee = employees.stream().min((e1, e2) -> Double.compare(e1.getSalary(), e2.getSalary()));\n        System.out.println(employee);\n        System.out.println();\n//        forEach(Consumer c)——内部迭代\n        employees.stream().forEach(System.out::println);\n\n        //使用集合的遍历操作\n        employees.forEach(System.out::println);\n    }\n\n    //2-归约\n    @Test\n    public void test3(){\n//        reduce(T identity, BinaryOperator)——可以将流中元素反复结合起来，得到一个值。返回 T\n//        练习1：计算1-10的自然数的和\n        List<Integer> list = Arrays.asList(1,2,3,4,5,6,7,8,9,10);\n        Integer sum = list.stream().reduce(0, Integer::sum);\n        System.out.println(sum);\n\n\n//        reduce(BinaryOperator) ——可以将流中元素反复结合起来，得到一个值。返回 Optional<T>\n//        练习2：计算公司所有员工工资的总和\n        List<Employee> employees = EmployeeData.getEmployees();\n        Stream<Double> salaryStream = employees.stream().map(Employee::getSalary);\n//        Optional<Double> sumMoney = salaryStream.reduce(Double::sum);\n        Optional<Double> sumMoney = salaryStream.reduce((d1,d2) -> d1 + d2);\n        System.out.println(sumMoney.get());\n\n    }\n\n    //3-收集\n    @Test\n    public void test4(){\n// collect(Collector c)——将流转换为其他形式。接收一个 Collector接口的实现，用于给Stream中元素做汇总的方法\n//        练习1：查找工资大于6000的员工，结果返回为一个List或Set\n\n        List<Employee> employees = EmployeeData.getEmployees();\n        List<Employee> employeeList = employees.stream().filter(e -> e.getSalary() > 6000).collect(Collectors.toList());\n\n        employeeList.forEach(System.out::println);\n        System.out.println();\n        Set<Employee> employeeSet = employees.stream().filter(e -> e.getSalary() > 6000).collect(Collectors.toSet());\n\n        employeeSet.forEach(System.out::println);\n\n\n\n\n    }\n}\n\n```\n\n\n\n# Optional类\n\n## 什么是Optional？\n\n\n\n- 到目前为止，臭名昭著的空指针异常是导致Java应用程序失败的最常见原因。以前，为了解决空指针异常，Google公司著名的Guava项目引入了Optional类，Guava通过使用检查空值的方式来防止代码污染，它鼓励程序员写更干净的代码。受到Google Guava的启发，Optional类已经成为Java 8类库的一部分。\n\n- Optional<T> 类(java.util.Optional) 是一个容器类，它可以保存类型T的值，代表这个值存在。或者仅仅保存null，表示这个值不存在。原来用 null 表示一个值不存在，现在 Optional 可以更好的表达这个概念。并且可以避免空指针异常。 \n\n- Optional类的Javadoc描述如下：这是一个可以为null的容器对象。如果值存在则isPresent()方法会返回true，调用get()方法会返回该对象。\n\n\n\n## 常用API\n\n<img src=\"https://npm.elemecdn.com/youthlql@1.0.8/Java_Basis/Java8_New_Features/0005.png\">\n\n\n\n\n\n## 举例\n\n首先准备两个类\n\n```java\n\npublic class Boy {\n    private Girl girl;\n\n    @Override\n    public String toString() {\n        return \"Boy{\" +\n                \"girl=\" + girl +\n                '}';\n    }\n\n    public Girl getGirl() {\n        return girl;\n    }\n\n    public void setGirl(Girl girl) {\n        this.girl = girl;\n    }\n\n    public Boy() {\n\n    }\n\n    public Boy(Girl girl) {\n\n        this.girl = girl;\n    }\n}\n```\n\n\n\n```java\npublic class Girl {\n\n    private String name;\n\n    @Override\n    public String toString() {\n        return \"Girl{\" +\n                \"name='\" + name + '\\'' +\n                '}';\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public Girl() {\n\n    }\n\n    public Girl(String name) {\n\n        this.name = name;\n    }\n}\n```\n\n\n\n这里只是简单的测试两个API\n\n```Java\n/**\n * Optional类：为了在程序中避免出现空指针异常而创建的。\n *\n * 常用的方法：ofNullable(T t)\n *            orElse(T t)\n *\n */\npublic class OptionalTest {\n\n/*\nOptional.of(T t) : 创建一个 Optional 实例，t必须非空；\nOptional.empty() : 创建一个空的 Optional 实例\nOptional.ofNullable(T t)：t可以为null\n\n */\n    @Test\n    public void test1(){\n        Girl girl = new Girl();\n//        girl = null;\n        //of(T t):保证t是非空的\n        Optional<Girl> optionalGirl = Optional.of(girl);\n\n    }\n\n    @Test\n    public void test2(){\n        Girl girl = new Girl();\n//        girl = null;\n        //ofNullable(T t)：t可以为null\n        Optional<Girl> optionalGirl = Optional.ofNullable(girl);\n        System.out.println(optionalGirl);\n        //orElse(T t1):如果单前的Optional内部封装的t是非空的，则返回内部的t.\n        //如果内部的t是空的，则返回orElse()方法中的参数t1.\n        Girl girl1 = optionalGirl.orElse(new Girl(\"赵丽颖\"));\n        System.out.println(girl1);\n\n    }\n}\n```\n\n\n\n**实际场景使用**\n\n可能出现空指针的例子：\n\n```java\npublic String getGirlName(Boy boy){\n        return boy.getGirl().getName();\n    }\n\n    @Test\n    public void test3(){\n        Boy boy = new Boy();\n        boy = null;\n        String girlName = getGirlName(boy);\n        System.out.println(girlName);\n\n    }\n```\n\n\n\n结果：\n\n```\njava.lang.NullPointerException\n\tat com.atguigu.java4.OptionalTest.getGirlName(OptionalTest.java:47)\n\tat com.atguigu.java4.OptionalTest.test3(OptionalTest.java:54)\n...\n...\n\nProcess finished with exit code -1\n```\n\n\n\n没有Optional的解决办法，但是如果调用层数过多，就得一层一层判断是否为null，写起来很麻烦。\n\n```Java\n//优化以后的getGirlName():\n    public String getGirlName1(Boy boy){\n        if(boy != null){\n            Girl girl = boy.getGirl();\n            if(girl != null){\n                return girl.getName();\n            }\n        }\n\n        return null;\n\n    }\n@Test\n    public void test4(){\n        Boy boy = new Boy();\n        boy = null;\n        String girlName = getGirlName1(boy);\n        System.out.println(girlName);\n\n    }\n```\n\n\n\n使用Optional解决问题：\n\n```Java\n //使用Optional类的getGirlName():\n    public String getGirlName2(Boy boy){\n\n        Optional<Boy> boyOptional = Optional.ofNullable(boy);\n        //此时的boy1一定非空\n        Boy boy1 = boyOptional.orElse(new Boy(new Girl(\"迪丽热巴\")));\n\n        Girl girl = boy1.getGirl();\n\n        Optional<Girl> girlOptional = Optional.ofNullable(girl);\n        //girl1一定非空\n        Girl girl1 = girlOptional.orElse(new Girl(\"古力娜扎\"));\n\n        return girl1.getName();\n    }\n\n    @Test\n    public void test5(){\n        Boy boy = null;\n        boy = new Boy();\n        boy = new Boy(new Girl(\"苍老师\"));\n        String girlName = getGirlName2(boy);\n        System.out.println(girlName);\n\n    }\n```\n\n这种是绝对不会出现空指针的。\n\n\n\n# 接口的增强\n\n```\nJDK7及以前：只能定义全局常量和抽象方法\n  >全局常量：public static final的.但是书写时，可以省略不写\n  >抽象方法：public abstract的\n  \t\t\t\nJDK8：除了定义全局常量和抽象方法之外，还可以定义静态方法、默认方法\n```\n\n\n\n```java\n/*\n * JDK8：除了定义全局常量和抽象方法之外，还可以定义静态方法、默认方法\n */\npublic interface CompareA {\n\n    //静态方法\n    public static void method1() {\n\n        System.out.println(\"CompareA:北京\");\n    }\n\n    //默认方法\n    public default void method2() {\n        System.out.println(\"CompareA：上海\");\n    }\n    //接口中的public 可以省略，自动就是public\n    default void method3() {\n        System.out.println(\"CompareA：上海\");\n    }\n}\n```\n\n\n\n```java\npublic class SuperClass {\n\t\n\tpublic void method3(){\n\t\tSystem.out.println(\"SuperClass:北京\");\n\t}\n\t\n}\n```\n\n\n\n```java\npublic interface CompareB {\n\t\n\tdefault void method3(){\n\t\tSystem.out.println(\"CompareB：上海\");\n\t}\n\t\n}\n```\n\n\n\n\n\n```java\npublic class SubClassTest {\n\t\n\tpublic static void main(String[] args) {\n\t\tSubClass s = new SubClass();\n\t\t\n//\t\ts.method1();\n//\t\tSubClass.method1();\n\t\t//知识点1：接口中定义的静态方法，只能通过接口来调用。实现类用不了\n\t\tCompareA.method1();\n\t\t//知识点2：通过实现类的对象，可以调用接口中的默认方法。\n\t\t//如果实现类重写了接口中的默认方法，调用时，仍然调用的是重写以后的方法\n\t\ts.method2();\n\t\t//知识点3：如果子类(或实现类)继承的父类和实现的接口中声明了同名同参数的默认方法，\n\t\t//那么子类在没有重写此方法的情况下，默认调用的是父类中的同名同参数的方法。-->类优先原则\n\t\t//知识点4：如果实现类实现了多个接口，而这多个接口中定义了同名同参数的默认方法，\n\t\t//那么在实现类没有重写此方法的情况下，报错。-->接口冲突。\n\t\t//这就需要我们必须在实现类中重写此方法\n\t\ts.method3();\n\t\t\n\t}\n\t\n}\n\nclass SubClass extends SuperClass implements CompareA,CompareB{\n\t\n\tpublic void method2(){\n\t\tSystem.out.println(\"SubClass：上海\");\n\t}\n\t\n\tpublic void method3(){\n\t\tSystem.out.println(\"SubClass：深圳\");\n\t}\n\t\n\t//知识点5：如何在子类(或实现类)的方法中调用父类、接口中被重写的方法\n\tpublic void myMethod(){\n\t\tmethod3();//调用自己定义的重写的方法\n\t\tsuper.method3();//调用的是父类中声明的\n\t\t//调用接口中的默认方法\n\t\tCompareA.super.method3();\n\t\tCompareB.super.method3();\n\t}\n}\n```\n","slug":"2021-04-14-Java8新特性","published":1,"updated":"2024-04-14T14:33:03.956Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cly2c4k3b0000qsvd8a0xd2z1","content":"<h1 id=\"Java8新特性纵览\"><a href=\"#Java8新特性纵览\" class=\"headerlink\" title=\"Java8新特性纵览\"></a>Java8新特性纵览</h1><blockquote>\n<p>关于Java8新特性的学习与记录，资料来源于互联网。</p>\n</blockquote>\n<h1 id=\"Lambda表达式\"><a href=\"#Lambda表达式\" class=\"headerlink\" title=\"Lambda表达式\"></a>Lambda表达式</h1><h2 id=\"为什么使用Lambda表达式？\"><a href=\"#为什么使用Lambda表达式？\" class=\"headerlink\" title=\"为什么使用Lambda表达式？\"></a>为什么使用Lambda表达式？</h2><ul>\n<li>Lambda 是一个<strong>匿名函数</strong>，我们可以把 Lambda 表达式理解为是<strong>一段可以传递的代码</strong>（将代码像数据一样进行传递）。使用它可以写出更简洁、更灵活的代码。作为一种更紧凑的代码风格，使Java的语言表达能力得到了提升。</li>\n<li>在Java8之后的很多源码里用到了Lambda表达式，不学的话可能看不懂源码。</li>\n</ul>\n<h2 id=\"简单使用\"><a href=\"#简单使用\" class=\"headerlink\" title=\"简单使用\"></a>简单使用</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\">   <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test1</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">       <span class=\"comment\">//原始写法</span></span><br><span class=\"line\">       <span class=\"type\">Runnable</span> <span class=\"variable\">r1</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Runnable</span>() &#123;</span><br><span class=\"line\">           <span class=\"meta\">@Override</span></span><br><span class=\"line\">           <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">               System.out.println(<span class=\"string\">&quot;我爱北京天安门&quot;</span>);</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">       r1.run();</span><br><span class=\"line\"></span><br><span class=\"line\">       System.out.println(<span class=\"string\">&quot;***********************&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"comment\">//lambda表达式，可以表达一样的意思</span></span><br><span class=\"line\">       <span class=\"type\">Runnable</span> <span class=\"variable\">r2</span> <span class=\"operator\">=</span> () -&gt; System.out.println(<span class=\"string\">&quot;我爱北京故宫&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">       r2.run();</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"meta\">@Test</span></span><br><span class=\"line\">   <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test2</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">       Comparator&lt;Integer&gt; com1 = <span class=\"keyword\">new</span> <span class=\"title class_\">Comparator</span>&lt;Integer&gt;() &#123;</span><br><span class=\"line\">           <span class=\"meta\">@Override</span></span><br><span class=\"line\">           <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">compare</span><span class=\"params\">(Integer o1, Integer o2)</span> &#123;</span><br><span class=\"line\">               <span class=\"keyword\">return</span> Integer.compare(o1,o2);</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"type\">int</span> <span class=\"variable\">compare1</span> <span class=\"operator\">=</span> com1.compare(<span class=\"number\">12</span>,<span class=\"number\">21</span>);</span><br><span class=\"line\">       System.out.println(compare1);</span><br><span class=\"line\"></span><br><span class=\"line\">       System.out.println(<span class=\"string\">&quot;***********************&quot;</span>);</span><br><span class=\"line\">       </span><br><span class=\"line\">       <span class=\"comment\">//Lambda表达式的写法</span></span><br><span class=\"line\">       Comparator&lt;Integer&gt; com2 = (o1,o2) -&gt; Integer.compare(o1,o2);</span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"type\">int</span> <span class=\"variable\">compare2</span> <span class=\"operator\">=</span> com2.compare(<span class=\"number\">32</span>,<span class=\"number\">21</span>);</span><br><span class=\"line\">       System.out.println(compare2);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">       System.out.println(<span class=\"string\">&quot;***********************&quot;</span>);</span><br><span class=\"line\">       <span class=\"comment\">//方法引用</span></span><br><span class=\"line\">       Comparator&lt;Integer&gt; com3 = Integer :: compare;</span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"type\">int</span> <span class=\"variable\">compare3</span> <span class=\"operator\">=</span> com3.compare(<span class=\"number\">32</span>,<span class=\"number\">21</span>);</span><br><span class=\"line\">       System.out.println(compare3);</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"Lambda语法规则\"><a href=\"#Lambda语法规则\" class=\"headerlink\" title=\"Lambda语法规则\"></a>Lambda语法规则</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> org.junit.Test;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.ArrayList;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Comparator;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.function.Consumer;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Lambda表达式的使用</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;p&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> * 1.举例： (o1,o2) -&gt; Integer.compare(o1,o2);</span></span><br><span class=\"line\"><span class=\"comment\"> * 2.格式：</span></span><br><span class=\"line\"><span class=\"comment\"> * -&gt; :lambda操作符 或 箭头操作符</span></span><br><span class=\"line\"><span class=\"comment\"> * -&gt;左边：lambda形参列表 （其实就是接口中的抽象方法的形参列表）</span></span><br><span class=\"line\"><span class=\"comment\"> * -&gt;右边：lambda体 （其实就是重写的抽象方法的方法体）</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;p&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> * 3. Lambda表达式的使用：（分为6种情况介绍）</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;p&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> * 总结：</span></span><br><span class=\"line\"><span class=\"comment\"> * -&gt;左边：lambda形参列表的参数类型可以省略(类型推断)；如果lambda形参列表只有一个参数，其一对()也</span></span><br><span class=\"line\"><span class=\"comment\"> * 可以省略</span></span><br><span class=\"line\"><span class=\"comment\"> * -&gt;右边：lambda体应该使用一对&#123;&#125;包裹；如果lambda体只有一条执行语句（可能是return语句），省略这一</span></span><br><span class=\"line\"><span class=\"comment\"> 对&#123;&#125;和return关键字</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;p&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> * 4.Lambda表达式的本质：作为函数式接口的实例</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;p&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> * 5. 如果一个接口中，只声明了一个抽象方法，则此接口就称为函数式接口。我们可以在一个接口上</span></span><br><span class=\"line\"><span class=\"comment\"> 使用 <span class=\"doctag\">@FunctionalInterface</span> 注解，</span></span><br><span class=\"line\"><span class=\"comment\"> * 这样做可以检查它是否是一个函数式接口。</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;p&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> * 6. 所以以前用匿名实现类表示的现在都可以用Lambda表达式来写。</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">LambdaTest1</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//语法格式一：无参，无返回值</span></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test1</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Runnable</span> <span class=\"variable\">r1</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Runnable</span>() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;我爱北京天安门&quot;</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        r1.run();</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;***********************&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">Runnable</span> <span class=\"variable\">r2</span> <span class=\"operator\">=</span> () -&gt; &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;我爱北京故宫&quot;</span>);</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        r2.run();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//语法格式二：Lambda 需要一个参数，但是没有返回值。</span></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test2</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        Consumer&lt;String&gt; con = <span class=\"keyword\">new</span> <span class=\"title class_\">Consumer</span>&lt;String&gt;() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">accept</span><span class=\"params\">(String s)</span> &#123;</span><br><span class=\"line\">                System.out.println(s);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        con.accept(<span class=\"string\">&quot;谎言和誓言的区别是什么？&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;*******************&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        Consumer&lt;String&gt; con1 = (String s) -&gt; &#123;</span><br><span class=\"line\">            System.out.println(s);</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        con1.accept(<span class=\"string\">&quot;一个是听得人当真了，一个是说的人当真了&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//语法格式三：数据类型可以省略，因为可由编译器推断得出，称为“类型推断”</span></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test3</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        Consumer&lt;String&gt; con1 = (String s) -&gt; &#123;</span><br><span class=\"line\">            System.out.println(s);</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        con1.accept(<span class=\"string\">&quot;一个是听得人当真了，一个是说的人当真了&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;*******************&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        Consumer&lt;String&gt; con2 = (s) -&gt; &#123;</span><br><span class=\"line\">            System.out.println(s);</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        con2.accept(<span class=\"string\">&quot;一个是听得人当真了，一个是说的人当真了&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test4</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        ArrayList&lt;String&gt; list = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();<span class=\"comment\">//类型推断</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">int</span>[] arr = &#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>&#125;;<span class=\"comment\">//类型推断</span></span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//语法格式四：Lambda 若只需要一个参数时，参数的小括号可以省略</span></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test5</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        Consumer&lt;String&gt; con1 = (s) -&gt; &#123;</span><br><span class=\"line\">            System.out.println(s);</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        con1.accept(<span class=\"string\">&quot;一个是听得人当真了，一个是说的人当真了&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;*******************&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        Consumer&lt;String&gt; con2 = s -&gt; &#123;</span><br><span class=\"line\">            System.out.println(s);</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        con2.accept(<span class=\"string\">&quot;一个是听得人当真了，一个是说的人当真了&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//语法格式五：Lambda 需要两个或以上的参数，多条执行语句，并且可以有返回值</span></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test6</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        Comparator&lt;Integer&gt; com1 = <span class=\"keyword\">new</span> <span class=\"title class_\">Comparator</span>&lt;Integer&gt;() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">compare</span><span class=\"params\">(Integer o1, Integer o2)</span> &#123;</span><br><span class=\"line\">                System.out.println(o1);</span><br><span class=\"line\">                System.out.println(o2);</span><br><span class=\"line\">                <span class=\"keyword\">return</span> o1.compareTo(o2);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(com1.compare(<span class=\"number\">12</span>, <span class=\"number\">21</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;*****************************&quot;</span>);</span><br><span class=\"line\">        Comparator&lt;Integer&gt; com2 = (o1, o2) -&gt; &#123;</span><br><span class=\"line\">            System.out.println(o1);</span><br><span class=\"line\">            System.out.println(o2);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> o1.compareTo(o2);</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(com2.compare(<span class=\"number\">12</span>, <span class=\"number\">6</span>));</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//语法格式六：当 Lambda 体只有一条语句时，return 与大括号若有，都可以省略</span></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test7</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        Comparator&lt;Integer&gt; com1 = (o1, o2) -&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> o1.compareTo(o2);</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(com1.compare(<span class=\"number\">12</span>, <span class=\"number\">6</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;*****************************&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        Comparator&lt;Integer&gt; com2 = (o1, o2) -&gt; o1.compareTo(o2);</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(com2.compare(<span class=\"number\">12</span>, <span class=\"number\">21</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test8</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        Consumer&lt;String&gt; con1 = s -&gt; &#123;</span><br><span class=\"line\">            System.out.println(s);</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        con1.accept(<span class=\"string\">&quot;一个是听得人当真了，一个是说的人当真了&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;*****************************&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        Consumer&lt;String&gt; con2 = s -&gt; System.out.println(s);</span><br><span class=\"line\"></span><br><span class=\"line\">        con2.accept(<span class=\"string\">&quot;一个是听得人当真了，一个是说的人当真了&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"函数式接口\"><a href=\"#函数式接口\" class=\"headerlink\" title=\"函数式接口\"></a>函数式接口</h1><h2 id=\"什么是函数式-Functional-接口\"><a href=\"#什么是函数式-Functional-接口\" class=\"headerlink\" title=\"什么是函数式(Functional)接口\"></a>什么是函数式(Functional)接口</h2><ul>\n<li><p>只包含一个抽象方法的接口，称为<strong>函数式接口</strong>。 </p>\n</li>\n<li><p>你可以通过 Lambda 表达式来创建该接口的对象。（若 Lambda 表达式抛出一个受检异常(即：非运行时异常)，那么该异常需要在目标接口的抽象方法上进行声明）。</p>\n</li>\n<li><p>我们可以在一个接口上使用 <strong>@FunctionalInterface</strong> 注解，这样做可以检查它是否是一个函数式接口。同时 javadoc 也会包含一条声明，说明这个接口是一个函数式接口。</p>\n</li>\n<li><p>在java.util.function包下定义了Java 8 的丰富的函数式接口</p>\n</li>\n</ul>\n<h2 id=\"如何理解函数式接口\"><a href=\"#如何理解函数式接口\" class=\"headerlink\" title=\"如何理解函数式接口\"></a>如何理解函数式接口</h2><ul>\n<li>Java从诞生日起就是一直倡导“一切皆对象”，在Java里面面向对象(OOP)编程是一切。但是随着python、scala等语言的兴起和新技术的挑战，Java不得不做出调整以便支持更加广泛的技术要求，也即java不但可以支持OOP还可以支持OOF（面向函数编程） </li>\n<li>在函数式编程语言当中，函数被当做一等公民对待。在将函数作为一等公民的编程语言中，Lambda表达式的类型是函数。但是在Java8中，有所不同。在Java8中，Lambda表达式是对象，而不是函数，它们必须依附于一类特别的对象类型——函数式接口。 </li>\n<li>简单的说，在Java8中，Lambda表达式就是一个函数式接口的实例。这就是Lambda表达式和函数式接口的关系。也就是说，只要一个对象是函数式接口的实例，那么该对象就可以用Lambda表达式来表示。</li>\n<li>所以以前用匿名实现类表示的现在都可以用Lambda表达式来写。</li>\n</ul>\n<h2 id=\"Java内置函数式接口\"><a href=\"#Java内置函数式接口\" class=\"headerlink\" title=\"Java内置函数式接口\"></a>Java内置函数式接口</h2><p><strong>核心函数式接口</strong></p>\n<img src=\"https://npm.elemecdn.com/youthlql@1.0.8/Java_Basis/Java8_New_Features/0002.png\">\n\n\n\n<p><strong>其它函数式接口</strong></p>\n<img src=\"https://npm.elemecdn.com/youthlql@1.0.8/Java_Basis/Java8_New_Features/0003.png\">\n\n\n\n\n\n<p><strong>Consumer</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\">   <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test1</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">       happyTime(<span class=\"number\">500</span>, <span class=\"keyword\">new</span> <span class=\"title class_\">Consumer</span>&lt;Double&gt;() &#123;</span><br><span class=\"line\">           <span class=\"meta\">@Override</span></span><br><span class=\"line\">           <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">accept</span><span class=\"params\">(Double aDouble)</span> &#123;</span><br><span class=\"line\">               System.out.println(<span class=\"string\">&quot;学习太累了，去天上人间买了瓶矿泉水，价格为：&quot;</span> + aDouble);</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">       System.out.println(<span class=\"string\">&quot;********************&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">       happyTime(<span class=\"number\">400</span>,money -&gt; System.out.println(<span class=\"string\">&quot;学习太累了，去天上人间喝了口水，价格为：&quot;</span> + money));</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">happyTime</span><span class=\"params\">(<span class=\"type\">double</span> money, Consumer&lt;Double&gt; con)</span>&#123;</span><br><span class=\"line\">       con.accept(money);</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>结果：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">学习太累了，去天上人间买了瓶矿泉水，价格为：<span class=\"number\">500.0</span></span><br><span class=\"line\">********************</span><br><span class=\"line\">学习太累了，去天上人间喝了口水，价格为：<span class=\"number\">400.0</span></span><br><span class=\"line\"></span><br><span class=\"line\">Process finished with exit code <span class=\"number\">0</span></span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>Predicate</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test2</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        List&lt;String&gt; list = Arrays.asList(<span class=\"string\">&quot;北京&quot;</span>,<span class=\"string\">&quot;南京&quot;</span>,<span class=\"string\">&quot;天津&quot;</span>,<span class=\"string\">&quot;东京&quot;</span>,<span class=\"string\">&quot;西京&quot;</span>,<span class=\"string\">&quot;普京&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        List&lt;String&gt; filterStrs = filterString(list, <span class=\"keyword\">new</span> <span class=\"title class_\">Predicate</span>&lt;String&gt;() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">test</span><span class=\"params\">(String s)</span> &#123;<span class=\"comment\">//这里是定义一个校验规则</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span> s.contains(<span class=\"string\">&quot;京&quot;</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(filterStrs);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//用lambda表达式会很简单</span></span><br><span class=\"line\">        List&lt;String&gt; filterStrs1 = filterString(list,s -&gt; s.contains(<span class=\"string\">&quot;京&quot;</span>));</span><br><span class=\"line\">        System.out.println(filterStrs1);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//根据给定的规则，过滤集合中的字符串。此规则由Predicate的方法决定</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;String&gt; <span class=\"title function_\">filterString</span><span class=\"params\">(List&lt;String&gt; list, Predicate&lt;String&gt; pre)</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        ArrayList&lt;String&gt; filterList = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(String s : list)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(pre.test(s))&#123;</span><br><span class=\"line\">                filterList.add(s);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> filterList;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>结果：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[北京, 南京, 东京, 西京, 普京]</span><br><span class=\"line\">[北京, 南京, 东京, 西京, 普京]</span><br><span class=\"line\"></span><br><span class=\"line\">Process finished with exit code 0</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"自定义函数式接口\"><a href=\"#自定义函数式接口\" class=\"headerlink\" title=\"自定义函数式接口\"></a>自定义函数式接口</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 自定义函数式接口</span></span><br><span class=\"line\"><span class=\"comment\"> * 只是说加上<span class=\"doctag\">@FunctionalInterface</span>之后可以校验</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@FunctionalInterface</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">MyFunInterface</span>&lt;T&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> T <span class=\"title function_\">getValue</span><span class=\"params\">(T t)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Test</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//这个方法的第一个参数是lambda表达式，相当于是实例化了那个函数式接口</span></span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">s</span> <span class=\"operator\">=</span> toUpperString(str -&gt; str.toUpperCase(), <span class=\"string\">&quot;abcd&quot;</span>);</span><br><span class=\"line\">        System.out.println(s);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String <span class=\"title function_\">toUpperString</span><span class=\"params\">(MyFunInterface&lt;String&gt; mf,String str)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> mf.getValue(str);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"方法引用\"><a href=\"#方法引用\" class=\"headerlink\" title=\"方法引用\"></a>方法引用</h1><ul>\n<li><p>当要传递给Lambda体的操作，已经有实现的方法了，可以使用方法引用！</p>\n</li>\n<li><p>方法引用可以看做是Lambda表达式深层次的表达。换句话说，方法引用就是Lambda表达式，也就是函数式接口的一个实例，通过方法的名字来指向一个方法，可以认为是Lambda表达式的一个语法糖。</p>\n</li>\n<li><p>要求：实现接口的抽象方法的参数列表和返回值类型，必须与方法引用的方法的参数列表和返回值类型保持一致！</p>\n</li>\n<li><p>格式：使用操作符 “::” 将类(或对象) 与 方法名分隔开来。</p>\n</li>\n<li><p>如下三种主要使用情况： </p>\n<ul>\n<li><p>对象 :: 实例方法名</p>\n</li>\n<li><p>类 :: 静态方法名</p>\n</li>\n<li><p>类 :: 实例方法名</p>\n</li>\n</ul>\n</li>\n</ul>\n<p>我们直接拿例子来说明情况，先提前准备两个类：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Employee</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"type\">int</span> id;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"type\">int</span> age;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"type\">double</span> salary;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">getId</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> id;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setId</span><span class=\"params\">(<span class=\"type\">int</span> id)</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">this</span>.id = id;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> String <span class=\"title function_\">getName</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> name;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setName</span><span class=\"params\">(String name)</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">this</span>.name = name;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">getAge</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> age;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setAge</span><span class=\"params\">(<span class=\"type\">int</span> age)</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">this</span>.age = age;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"type\">double</span> <span class=\"title function_\">getSalary</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> salary;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setSalary</span><span class=\"params\">(<span class=\"type\">double</span> salary)</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">this</span>.salary = salary;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"title function_\">Employee</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;Employee().....&quot;</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"title function_\">Employee</span><span class=\"params\">(<span class=\"type\">int</span> id)</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">this</span>.id = id;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;Employee(int id).....&quot;</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"title function_\">Employee</span><span class=\"params\">(<span class=\"type\">int</span> id, String name)</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">this</span>.id = id;</span><br><span class=\"line\">\t\t<span class=\"built_in\">this</span>.name = name;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"title function_\">Employee</span><span class=\"params\">(<span class=\"type\">int</span> id, String name, <span class=\"type\">int</span> age, <span class=\"type\">double</span> salary)</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"built_in\">this</span>.id = id;</span><br><span class=\"line\">\t\t<span class=\"built_in\">this</span>.name = name;</span><br><span class=\"line\">\t\t<span class=\"built_in\">this</span>.age = age;</span><br><span class=\"line\">\t\t<span class=\"built_in\">this</span>.salary = salary;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> String <span class=\"title function_\">toString</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"string\">&quot;Employee&#123;&quot;</span> + <span class=\"string\">&quot;id=&quot;</span> + id + <span class=\"string\">&quot;, name=&#x27;&quot;</span> + name + <span class=\"string\">&#x27;\\&#x27;&#x27;</span> + <span class=\"string\">&quot;, age=&quot;</span> + age + <span class=\"string\">&quot;, salary=&quot;</span> + salary + <span class=\"string\">&#x27;&#125;&#x27;</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">equals</span><span class=\"params\">(Object o)</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (<span class=\"built_in\">this</span> == o)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (o == <span class=\"literal\">null</span> || getClass() != o.getClass())</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"type\">Employee</span> <span class=\"variable\">employee</span> <span class=\"operator\">=</span> (Employee) o;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (id != employee.id)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (age != employee.age)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (Double.compare(employee.salary, salary) != <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> name != <span class=\"literal\">null</span> ? name.equals(employee.name) : employee.name == <span class=\"literal\">null</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">hashCode</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> result;</span><br><span class=\"line\">\t\t<span class=\"type\">long</span> temp;</span><br><span class=\"line\">\t\tresult = id;</span><br><span class=\"line\">\t\tresult = <span class=\"number\">31</span> * result + (name != <span class=\"literal\">null</span> ? name.hashCode() : <span class=\"number\">0</span>);</span><br><span class=\"line\">\t\tresult = <span class=\"number\">31</span> * result + age;</span><br><span class=\"line\">\t\ttemp = Double.doubleToLongBits(salary);</span><br><span class=\"line\">\t\tresult = <span class=\"number\">31</span> * result + (<span class=\"type\">int</span>) (temp ^ (temp &gt;&gt;&gt; <span class=\"number\">32</span>));</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> result;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 提供用于测试的数据</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">EmployeeData</span> &#123;</span><br><span class=\"line\">   </span><br><span class=\"line\">   <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> List&lt;Employee&gt; <span class=\"title function_\">getEmployees</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">      List&lt;Employee&gt; list = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">      </span><br><span class=\"line\">      list.add(<span class=\"keyword\">new</span> <span class=\"title class_\">Employee</span>(<span class=\"number\">1001</span>, <span class=\"string\">&quot;马化腾&quot;</span>, <span class=\"number\">34</span>, <span class=\"number\">6000.38</span>));</span><br><span class=\"line\">      list.add(<span class=\"keyword\">new</span> <span class=\"title class_\">Employee</span>(<span class=\"number\">1002</span>, <span class=\"string\">&quot;马云&quot;</span>, <span class=\"number\">12</span>, <span class=\"number\">9876.12</span>));</span><br><span class=\"line\">      list.add(<span class=\"keyword\">new</span> <span class=\"title class_\">Employee</span>(<span class=\"number\">1003</span>, <span class=\"string\">&quot;刘强东&quot;</span>, <span class=\"number\">33</span>, <span class=\"number\">3000.82</span>));</span><br><span class=\"line\">      list.add(<span class=\"keyword\">new</span> <span class=\"title class_\">Employee</span>(<span class=\"number\">1004</span>, <span class=\"string\">&quot;雷军&quot;</span>, <span class=\"number\">26</span>, <span class=\"number\">7657.37</span>));</span><br><span class=\"line\">      list.add(<span class=\"keyword\">new</span> <span class=\"title class_\">Employee</span>(<span class=\"number\">1005</span>, <span class=\"string\">&quot;李彦宏&quot;</span>, <span class=\"number\">65</span>, <span class=\"number\">5555.32</span>));</span><br><span class=\"line\">      list.add(<span class=\"keyword\">new</span> <span class=\"title class_\">Employee</span>(<span class=\"number\">1006</span>, <span class=\"string\">&quot;比尔盖茨&quot;</span>, <span class=\"number\">42</span>, <span class=\"number\">9500.43</span>));</span><br><span class=\"line\">      list.add(<span class=\"keyword\">new</span> <span class=\"title class_\">Employee</span>(<span class=\"number\">1007</span>, <span class=\"string\">&quot;任正非&quot;</span>, <span class=\"number\">26</span>, <span class=\"number\">4333.32</span>));</span><br><span class=\"line\">      list.add(<span class=\"keyword\">new</span> <span class=\"title class_\">Employee</span>(<span class=\"number\">1008</span>, <span class=\"string\">&quot;扎克伯格&quot;</span>, <span class=\"number\">35</span>, <span class=\"number\">2500.32</span>));</span><br><span class=\"line\">      </span><br><span class=\"line\">      <span class=\"keyword\">return</span> list;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>下面来通过实际例子讲解方法引用：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 方法引用的使用</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * 1.使用情境：当要传递给Lambda体的操作，已经有实现的方法了，可以使用方法引用！</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * 2.方法引用，本质上就是Lambda表达式，而Lambda表达式作为函数式接口的实例。所以</span></span><br><span class=\"line\"><span class=\"comment\"> *   方法引用，也是函数式接口的实例。</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * 3. 使用格式：  类(或对象) :: 方法名</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * 4. 具体分为如下的三种情况：</span></span><br><span class=\"line\"><span class=\"comment\"> *    情况1     对象 :: 非静态方法</span></span><br><span class=\"line\"><span class=\"comment\"> *    情况2     类 :: 静态方法</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> *    情况3     类 :: 非静态方法</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * 5. 方法引用使用的要求：</span></span><br><span class=\"line\"><span class=\"comment\"> * \t接口中的抽象方法的形参列表和返回值类型</span></span><br><span class=\"line\"><span class=\"comment\"> * \t与</span></span><br><span class=\"line\"><span class=\"comment\"> * \t方法引用的方法的形参列表和返回值类型相同！（针对于情况1和情况2）</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">MethodRefTest</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 情况一：对象 :: 实例方法</span></span><br><span class=\"line\">\t<span class=\"comment\">//Consumer中的void accept(T t)</span></span><br><span class=\"line\">\t<span class=\"comment\">//PrintStream中的void println(T t)</span></span><br><span class=\"line\">\t<span class=\"meta\">@Test</span></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test1</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t\tConsumer&lt;String&gt; con1 = str -&gt; System.out.println(str);</span><br><span class=\"line\">\t\tcon1.accept(<span class=\"string\">&quot;北京&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;*******************&quot;</span>);</span><br><span class=\"line\">\t\t<span class=\"type\">PrintStream</span> <span class=\"variable\">ps</span> <span class=\"operator\">=</span> System.out;</span><br><span class=\"line\">\t\tConsumer&lt;String&gt; con2 = ps::println;</span><br><span class=\"line\">\t\tcon2.accept(<span class=\"string\">&quot;beijing&quot;</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">//Supplier中的T get()</span></span><br><span class=\"line\">\t<span class=\"comment\">//Employee中的String getName()</span></span><br><span class=\"line\">\t<span class=\"meta\">@Test</span></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test2</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"type\">Employee</span> <span class=\"variable\">emp</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Employee</span>(<span class=\"number\">1001</span>,<span class=\"string\">&quot;Tom&quot;</span>,<span class=\"number\">23</span>,<span class=\"number\">5600</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tSupplier&lt;String&gt; sup1 = () -&gt; emp.getName();</span><br><span class=\"line\">\t\tSystem.out.println(sup1.get());</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;*******************&quot;</span>);</span><br><span class=\"line\">\t\tSupplier&lt;String&gt; sup2 = emp::getName;</span><br><span class=\"line\">\t\tSystem.out.println(sup2.get());</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 情况二：类 :: 静态方法</span></span><br><span class=\"line\">\t<span class=\"comment\">//Comparator中的int compare(T t1,T t2)</span></span><br><span class=\"line\">\t<span class=\"comment\">//Integer中的int compare(T t1,T t2)</span></span><br><span class=\"line\">\t<span class=\"meta\">@Test</span></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test3</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t\tComparator&lt;Integer&gt; com1 = (t1,t2) -&gt; Integer.compare(t1,t2);</span><br><span class=\"line\">\t\tSystem.out.println(com1.compare(<span class=\"number\">12</span>,<span class=\"number\">21</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;*******************&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tComparator&lt;Integer&gt; com2 = Integer::compare;</span><br><span class=\"line\">\t\tSystem.out.println(com2.compare(<span class=\"number\">12</span>,<span class=\"number\">3</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">//Function中的R apply(T t)</span></span><br><span class=\"line\">\t<span class=\"comment\">//Math中的Long round(Double d)</span></span><br><span class=\"line\">\t<span class=\"meta\">@Test</span></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test4</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t\tFunction&lt;Double,Long&gt; func = <span class=\"keyword\">new</span> <span class=\"title class_\">Function</span>&lt;Double, Long&gt;() &#123;</span><br><span class=\"line\">\t\t\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">public</span> Long <span class=\"title function_\">apply</span><span class=\"params\">(Double d)</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> Math.round(d);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;*******************&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tFunction&lt;Double,Long&gt; func1 = d -&gt; Math.round(d);</span><br><span class=\"line\">\t\tSystem.out.println(func1.apply(<span class=\"number\">12.3</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;*******************&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tFunction&lt;Double,Long&gt; func2 = Math::round;</span><br><span class=\"line\">\t\tSystem.out.println(func2.apply(<span class=\"number\">12.6</span>));</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 情况三：类 :: 实例方法  (有难度)</span></span><br><span class=\"line\">\t<span class=\"comment\">// Comparator中的int comapre(T t1,T t2)  第一个参数T t1,也可以变成方法的调用者</span></span><br><span class=\"line\">\t<span class=\"comment\">// String中的int t1.compareTo(t2)        看上面说的，t1变成了调用者等价于第一个参数T t1</span></span><br><span class=\"line\">\t<span class=\"meta\">@Test</span></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test5</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t\tComparator&lt;String&gt; com1 = (s1,s2) -&gt; s1.compareTo(s2);</span><br><span class=\"line\">\t\tSystem.out.println(com1.compare(<span class=\"string\">&quot;abc&quot;</span>,<span class=\"string\">&quot;abd&quot;</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;*******************&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tComparator&lt;String&gt; com2 = String :: compareTo;</span><br><span class=\"line\">\t\tSystem.out.println(com2.compare(<span class=\"string\">&quot;abd&quot;</span>,<span class=\"string\">&quot;abm&quot;</span>));</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//BiPredicate中的boolean test(T t1, T t2);</span></span><br><span class=\"line\">\t<span class=\"comment\">//String中的boolean t1.equals(t2)</span></span><br><span class=\"line\">\t<span class=\"meta\">@Test</span></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test6</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t\tBiPredicate&lt;String,String&gt; pre1 = (s1,s2) -&gt; s1.equals(s2);</span><br><span class=\"line\">\t\tSystem.out.println(pre1.test(<span class=\"string\">&quot;abc&quot;</span>,<span class=\"string\">&quot;abc&quot;</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;*******************&quot;</span>);</span><br><span class=\"line\">\t\tBiPredicate&lt;String,String&gt; pre2 = String :: equals;</span><br><span class=\"line\">\t\tSystem.out.println(pre2.test(<span class=\"string\">&quot;abc&quot;</span>,<span class=\"string\">&quot;abd&quot;</span>));</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">// Function中的R apply(T t)</span></span><br><span class=\"line\">\t<span class=\"comment\">// Employee中的String getName();   第一个参数T t相当于方法调用者emp，返回值R和String对应</span></span><br><span class=\"line\">\t<span class=\"meta\">@Test</span></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test7</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"type\">Employee</span> <span class=\"variable\">employee</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Employee</span>(<span class=\"number\">1001</span>, <span class=\"string\">&quot;Jerry&quot;</span>, <span class=\"number\">23</span>, <span class=\"number\">6000</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">\t\tFunction&lt;Employee,String&gt; func1 = e -&gt; e.getName();</span><br><span class=\"line\">\t\tSystem.out.println(func1.apply(employee));</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;*******************&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">\t\tFunction&lt;Employee,String&gt; func2 = Employee::getName;</span><br><span class=\"line\">\t\tSystem.out.println(func2.apply(employee));</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h1 id=\"构造器引用\"><a href=\"#构造器引用\" class=\"headerlink\" title=\"构造器引用\"></a>构造器引用</h1><p>格式：ClassName :: new</p>\n<p>与函数式接口相结合，自动与函数式接口中方法兼容。可以把构造器引用赋值给定义的方法，要求构造器参数列表要与接口中抽象方法的参数列表一致！且方法的返回值即为构造器对应类的对象。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.junit.Test;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Arrays;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.function.BiFunction;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.function.Function;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.function.Supplier;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 一、构造器引用</span></span><br><span class=\"line\"><span class=\"comment\"> *      和方法引用类似，函数式接口的抽象方法的形参列表和构造器的形参列表一致。</span></span><br><span class=\"line\"><span class=\"comment\"> *      抽象方法的返回值类型即为构造器所属的类的类型</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * 二、数组引用</span></span><br><span class=\"line\"><span class=\"comment\"> *     大家可以把数组看做是一个特殊的类，则写法与构造器引用一致。</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ConstructorRefTest</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 构造器引用</span></span><br><span class=\"line\"><span class=\"comment\">     * Supplier中的T get()</span></span><br><span class=\"line\"><span class=\"comment\">     * Employee的空参构造器：Employee()</span></span><br><span class=\"line\"><span class=\"comment\">     * 1、和方法引用一样的理解方法，你的get()方法没有参数，我的Employee()也没有参数。</span></span><br><span class=\"line\"><span class=\"comment\">     * 2、你的get()方法有返回值T，我的Employee()方法返回值也是一个对象</span></span><br><span class=\"line\"><span class=\"comment\">     * 3、所以刚好可以用  </span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test1</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        Supplier&lt;Employee&gt; sup = <span class=\"keyword\">new</span> <span class=\"title class_\">Supplier</span>&lt;Employee&gt;() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"keyword\">public</span> Employee <span class=\"title function_\">get</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Employee</span>();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;*******************&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        Supplier&lt;Employee&gt;  sup1 = () -&gt; <span class=\"keyword\">new</span> <span class=\"title class_\">Employee</span>();</span><br><span class=\"line\">        System.out.println(sup1.get());</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;*******************&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        Supplier&lt;Employee&gt;  sup2 = Employee :: <span class=\"keyword\">new</span>;</span><br><span class=\"line\">        System.out.println(sup2.get());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//Function中的R apply(T t)</span></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test2</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        Function&lt;Integer,Employee&gt; func1 = id -&gt; <span class=\"keyword\">new</span> <span class=\"title class_\">Employee</span>(id);</span><br><span class=\"line\">        <span class=\"type\">Employee</span> <span class=\"variable\">employee</span> <span class=\"operator\">=</span> func1.apply(<span class=\"number\">1001</span>);</span><br><span class=\"line\">        System.out.println(employee);</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;*******************&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        Function&lt;Integer,Employee&gt; func2 = Employee :: <span class=\"keyword\">new</span>;</span><br><span class=\"line\">        <span class=\"type\">Employee</span> <span class=\"variable\">employee1</span> <span class=\"operator\">=</span> func2.apply(<span class=\"number\">1002</span>);</span><br><span class=\"line\">        System.out.println(employee1);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//BiFunction中的R apply(T t,U u)</span></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test3</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        BiFunction&lt;Integer,String,Employee&gt; func1 = (id,name) -&gt; <span class=\"keyword\">new</span> <span class=\"title class_\">Employee</span>(id,name);</span><br><span class=\"line\">        System.out.println(func1.apply(<span class=\"number\">1001</span>,<span class=\"string\">&quot;Tom&quot;</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;*******************&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        BiFunction&lt;Integer,String,Employee&gt; func2 = Employee :: <span class=\"keyword\">new</span>;</span><br><span class=\"line\">        System.out.println(func2.apply(<span class=\"number\">1002</span>,<span class=\"string\">&quot;Tom&quot;</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//数组引用</span></span><br><span class=\"line\">    <span class=\"comment\">//Function中的R apply(T t)</span></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test4</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        Function&lt;Integer,String[]&gt; func1 = length -&gt; <span class=\"keyword\">new</span> <span class=\"title class_\">String</span>[length];</span><br><span class=\"line\">        String[] arr1 = func1.apply(<span class=\"number\">5</span>);</span><br><span class=\"line\">        System.out.println(Arrays.toString(arr1));</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;*******************&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        Function&lt;Integer,String[]&gt; func2 = String[] :: <span class=\"keyword\">new</span>;</span><br><span class=\"line\">        String[] arr2 = func2.apply(<span class=\"number\">10</span>);</span><br><span class=\"line\">        System.out.println(Arrays.toString(arr2));</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"强大的Stream-API\"><a href=\"#强大的Stream-API\" class=\"headerlink\" title=\"强大的Stream API\"></a>强大的Stream API</h1><h2 id=\"Stream-API说明\"><a href=\"#Stream-API说明\" class=\"headerlink\" title=\"Stream API说明\"></a>Stream API说明</h2><ul>\n<li><p>Java8中有两大最为重要的改变。第一个是 <strong>Lambda</strong> <strong>表达式</strong>；另外一个则是 <strong>Stream API</strong>。 </p>\n</li>\n<li><p>Stream API ( java.util.stream) 把真正的函数式编程风格引入到Java中。这是目前为止对Java类库最好的补充，因为Stream API可以极大提供Java程序员的生产力，让程序员写出高效率、干净、简洁的代码。</p>\n</li>\n<li><p>Stream 是 Java8 中处理集合的关键抽象概念，它可以指定你希望对集合进行的操作，可以执行非常复杂的查找、过滤和映射数据等操作。 <strong>使用Stream API 对集合数据进行操作，就类似于使用 SQL 执行的数据库查询。</strong>也可以使用 Stream API 来并行执行操作。简言之，Stream API 提供了一种高效且易于使用的处理数据的方式</p>\n</li>\n</ul>\n<h2 id=\"为什么要使用Stream-API\"><a href=\"#为什么要使用Stream-API\" class=\"headerlink\" title=\"为什么要使用Stream API\"></a>为什么要使用Stream API</h2><ul>\n<li><p>实际开发中，项目中多数数据源都来自于Mysql，Oracle等，很多一些复杂的数据获取可以直接在sql层面去解决。但现在数据源可以更多了，有MongDB，Radis等，而这些NoSQL的数据本身不支持一些复杂的数据计算，这个时候就需要Java层面去处理。 </p>\n</li>\n<li><p>Stream 和 Collection 集合的区别：Collection 是一种静态的内存数据结构，而 Stream 是有关计算的。前者是主要面向内存，存储在内存中，后者主要是面向 CPU，通过 CPU 实现计算。</p>\n</li>\n</ul>\n<h2 id=\"什么是Stream\"><a href=\"#什么是Stream\" class=\"headerlink\" title=\"什么是Stream\"></a>什么是Stream</h2><p>Stream到底是什么呢？</p>\n<p>是数据渠道，用于操作数据源（集合、数组等）所生成的元素序列。</p>\n<p><strong>“集合讲的是数据，Stream讲的是计算！”</strong></p>\n<p><strong>注意：</strong></p>\n<p>①Stream 自己不会存储元素。</p>\n<p>②Stream 不会改变源对象。相反，他们会返回一个持有结果的新Stream。 </p>\n<p>③Stream 操作是延迟执行的。这意味着他们会等到需要结果的时候才执行</p>\n<p><strong>Stream</strong> <strong>的操作三个步骤</strong></p>\n<p>1、创建Stream</p>\n<p>一个数据源（如：集合、数组），获取一个流</p>\n<p>2、中间操作</p>\n<p>一个中间操作链，对数据源的数据进行处理</p>\n<p>3、终止操作(终端操作) </p>\n<p>一旦执行终止操作，就执行中间操作链，才产生结果【也就是所谓的延迟执行】。之后，不会再被使用</p>\n<img src=\"https://npm.elemecdn.com/youthlql@1.0.8/Java_Basis/Java8_New_Features/0004.png\">\n\n\n\n\n\n<h2 id=\"创建Stream\"><a href=\"#创建Stream\" class=\"headerlink\" title=\"创建Stream\"></a>创建Stream</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">StreamAPITest</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//创建 Stream方式一：通过集合</span></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test1</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        List&lt;Employee&gt; employees = EmployeeData.getEmployees();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//        default Stream&lt;E&gt; stream() : 返回一个顺序流，顺序流等会中间操作拿数据的时候按顺序拿</span></span><br><span class=\"line\">        Stream&lt;Employee&gt; stream = employees.stream();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//        default Stream&lt;E&gt; parallelStream() : 返回一个并行流</span></span><br><span class=\"line\">        Stream&lt;Employee&gt; parallelStream = employees.parallelStream();</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//创建 Stream方式二：通过数组</span></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test2</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span>[] arr = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[]&#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>&#125;;</span><br><span class=\"line\">        <span class=\"comment\">//调用Arrays类的static &lt;T&gt; Stream&lt;T&gt; stream(T[] array): 返回一个流</span></span><br><span class=\"line\">        <span class=\"type\">IntStream</span> <span class=\"variable\">stream</span> <span class=\"operator\">=</span> Arrays.stream(arr);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">Employee</span> <span class=\"variable\">e1</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Employee</span>(<span class=\"number\">1001</span>,<span class=\"string\">&quot;Tom&quot;</span>);</span><br><span class=\"line\">        <span class=\"type\">Employee</span> <span class=\"variable\">e2</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Employee</span>(<span class=\"number\">1002</span>,<span class=\"string\">&quot;Jerry&quot;</span>);</span><br><span class=\"line\">        Employee[] arr1 = <span class=\"keyword\">new</span> <span class=\"title class_\">Employee</span>[]&#123;e1,e2&#125;;</span><br><span class=\"line\">        Stream&lt;Employee&gt; stream1 = Arrays.stream(arr1);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//创建 Stream方式三：通过Stream的of()，通过显示值创建一个流。它可以接收任意数量的参数</span></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test3</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        Stream&lt;Integer&gt; stream = Stream.of(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//创建 Stream方式四：创建无限流【用的少，了解下就行】</span></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test4</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//      迭代</span></span><br><span class=\"line\"><span class=\"comment\">//      public static&lt;T&gt; Stream&lt;T&gt; iterate(final T seed, final UnaryOperator&lt;T&gt; f)</span></span><br><span class=\"line\">        <span class=\"comment\">//遍历前10个偶数</span></span><br><span class=\"line\">        Stream.iterate(<span class=\"number\">0</span>, t -&gt; t + <span class=\"number\">2</span>).limit(<span class=\"number\">10</span>).forEach(System.out::println);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//      生成</span></span><br><span class=\"line\"><span class=\"comment\">//      public static&lt;T&gt; Stream&lt;T&gt; generate(Supplier&lt;T&gt; s)</span></span><br><span class=\"line\">        Stream.generate(Math::random).limit(<span class=\"number\">10</span>).forEach(System.out::println);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h2 id=\"中间操作\"><a href=\"#中间操作\" class=\"headerlink\" title=\"中间操作\"></a>中间操作</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 测试Stream的中间操作</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">StreamAPITest1</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//1-筛选与切片</span></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test1</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        List&lt;Employee&gt; list = EmployeeData.getEmployees();</span><br><span class=\"line\"><span class=\"comment\">//        filter(Predicate p)——过滤   接收 Lambda ， 从流中排除某些元素。</span></span><br><span class=\"line\">        Stream&lt;Employee&gt; stream = list.stream();</span><br><span class=\"line\">        <span class=\"comment\">//练习：查询员工表中薪资大于7000的员工信息</span></span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">         * List&lt;String&gt; filterStrs1 = filterString(list,s -&gt; s.contains(&quot;京&quot;));</span></span><br><span class=\"line\"><span class=\"comment\">         * 跟之前的这个lambda表达式代码是一个意思</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        stream.filter(e -&gt; e.getSalary() &gt; <span class=\"number\">7000</span>).forEach(System.out::println);</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println();</span><br><span class=\"line\"><span class=\"comment\">//        limit(n)——截断流，使其元素不超过给定数量。</span></span><br><span class=\"line\">        list.stream().limit(<span class=\"number\">3</span>).forEach(System.out::println);</span><br><span class=\"line\">        System.out.println();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">        skip(n) —— 跳过元素，返回一个扔掉了前 n 个元素的流。若流中元素不足 n 个，</span></span><br><span class=\"line\"><span class=\"comment\">        则返回一个空流。与 limit(n) 互补</span></span><br><span class=\"line\"><span class=\"comment\">        */</span></span><br><span class=\"line\">        list.stream().skip(<span class=\"number\">3</span>).forEach(System.out::println);</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println();</span><br><span class=\"line\"><span class=\"comment\">//        distinct()——筛选，通过流所生成元素的 hashCode() 和 equals() 去除重复元素</span></span><br><span class=\"line\"></span><br><span class=\"line\">        list.add(<span class=\"keyword\">new</span> <span class=\"title class_\">Employee</span>(<span class=\"number\">1010</span>,<span class=\"string\">&quot;刘强东&quot;</span>,<span class=\"number\">40</span>,<span class=\"number\">8000</span>));</span><br><span class=\"line\">        list.add(<span class=\"keyword\">new</span> <span class=\"title class_\">Employee</span>(<span class=\"number\">1010</span>,<span class=\"string\">&quot;刘强东&quot;</span>,<span class=\"number\">41</span>,<span class=\"number\">8000</span>));</span><br><span class=\"line\">        list.add(<span class=\"keyword\">new</span> <span class=\"title class_\">Employee</span>(<span class=\"number\">1010</span>,<span class=\"string\">&quot;刘强东&quot;</span>,<span class=\"number\">40</span>,<span class=\"number\">8000</span>));</span><br><span class=\"line\">        list.add(<span class=\"keyword\">new</span> <span class=\"title class_\">Employee</span>(<span class=\"number\">1010</span>,<span class=\"string\">&quot;刘强东&quot;</span>,<span class=\"number\">40</span>,<span class=\"number\">8000</span>));</span><br><span class=\"line\">        list.add(<span class=\"keyword\">new</span> <span class=\"title class_\">Employee</span>(<span class=\"number\">1010</span>,<span class=\"string\">&quot;刘强东&quot;</span>,<span class=\"number\">40</span>,<span class=\"number\">8000</span>));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//        System.out.println(list);</span></span><br><span class=\"line\"></span><br><span class=\"line\">        list.stream().distinct().forEach(System.out::println);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//映射</span></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test2</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">        map(Function f)——接收一个函数作为参数，将元素转换成其他形式或提取信息，该函数会被应</span></span><br><span class=\"line\"><span class=\"comment\">        用到每个元素上，并将其映射成一个新的元素。</span></span><br><span class=\"line\"><span class=\"comment\">        */</span></span><br><span class=\"line\">        List&lt;String&gt; list = Arrays.asList(<span class=\"string\">&quot;aa&quot;</span>, <span class=\"string\">&quot;bb&quot;</span>, <span class=\"string\">&quot;cc&quot;</span>, <span class=\"string\">&quot;dd&quot;</span>);</span><br><span class=\"line\">        list.stream().map(str -&gt; str.toUpperCase()).forEach(System.out::println);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//        练习1：获取员工姓名长度大于3的员工的姓名。</span></span><br><span class=\"line\">        List&lt;Employee&gt; employees = EmployeeData.getEmployees();</span><br><span class=\"line\">        Stream&lt;String&gt; namesStream = employees.stream().map(Employee::getName);</span><br><span class=\"line\">        namesStream.filter(name -&gt; name.length() &gt; <span class=\"number\">3</span>).forEach(System.out::println);</span><br><span class=\"line\">        System.out.println();</span><br><span class=\"line\">        <span class=\"comment\">//练习2：</span></span><br><span class=\"line\">        Stream&lt;Stream&lt;Character&gt;&gt; streamStream = list.stream().map(StreamAPITest1::fromStringToStream);</span><br><span class=\"line\">        <span class=\"comment\">//这个还需要两层遍历</span></span><br><span class=\"line\">        streamStream.forEach(s -&gt;&#123;</span><br><span class=\"line\">            s.forEach(System.out::println);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        System.out.println();</span><br><span class=\"line\">        <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">        flatMap(Function f)——接收一个函数作为参数，将流中的每个值都换成另一个流，然后把所有流连</span></span><br><span class=\"line\"><span class=\"comment\">        接成一个流。flatMap一层遍历即可拿到想要的结果</span></span><br><span class=\"line\"><span class=\"comment\">        */</span></span><br><span class=\"line\">        Stream&lt;Character&gt; characterStream = list.stream().flatMap(StreamAPITest1::fromStringToStream);</span><br><span class=\"line\">        characterStream.forEach(System.out::println);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//将字符串中的多个字符构成的集合转换为对应的Stream的实例</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Stream&lt;Character&gt; <span class=\"title function_\">fromStringToStream</span><span class=\"params\">(String str)</span>&#123;<span class=\"comment\">//aa</span></span><br><span class=\"line\">        ArrayList&lt;Character&gt; list = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(Character c : str.toCharArray())&#123;</span><br><span class=\"line\">            list.add(c);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> list.stream();</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//3-排序</span></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test4</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\"><span class=\"comment\">//        sorted()——自然排序</span></span><br><span class=\"line\">        List&lt;Integer&gt; list = Arrays.asList(<span class=\"number\">12</span>, <span class=\"number\">43</span>, <span class=\"number\">65</span>, <span class=\"number\">34</span>, <span class=\"number\">87</span>, <span class=\"number\">0</span>, -<span class=\"number\">98</span>, <span class=\"number\">7</span>);</span><br><span class=\"line\">        list.stream().sorted().forEach(System.out::println);</span><br><span class=\"line\">        <span class=\"comment\">//抛异常，原因:Employee没有实现Comparable接口</span></span><br><span class=\"line\"><span class=\"comment\">//        List&lt;Employee&gt; employees = EmployeeData.getEmployees();</span></span><br><span class=\"line\"><span class=\"comment\">//        employees.stream().sorted().forEach(System.out::println);</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//        sorted(Comparator com)——定制排序</span></span><br><span class=\"line\"></span><br><span class=\"line\">        List&lt;Employee&gt; employees = EmployeeData.getEmployees();</span><br><span class=\"line\">        employees.stream().sorted( (e1,e2) -&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">           <span class=\"type\">int</span> <span class=\"variable\">ageValue</span> <span class=\"operator\">=</span> Integer.compare(e1.getAge(),e2.getAge());</span><br><span class=\"line\">           <span class=\"keyword\">if</span>(ageValue != <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">               <span class=\"keyword\">return</span> ageValue;</span><br><span class=\"line\">           &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">               <span class=\"keyword\">return</span> -Double.compare(e1.getSalary(),e2.getSalary());</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;).forEach(System.out::println);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"终止操作\"><a href=\"#终止操作\" class=\"headerlink\" title=\"终止操作\"></a>终止操作</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 测试Stream的终止操作</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">StreamAPITest2</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//1-匹配与查找</span></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test1</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        List&lt;Employee&gt; employees = EmployeeData.getEmployees();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//        allMatch(Predicate p)——检查是否匹配所有元素。</span></span><br><span class=\"line\"><span class=\"comment\">//          练习：是否所有的员工的年龄都大于18</span></span><br><span class=\"line\">        <span class=\"type\">boolean</span> <span class=\"variable\">allMatch</span> <span class=\"operator\">=</span> employees.stream().allMatch(e -&gt; e.getAge() &gt; <span class=\"number\">18</span>);</span><br><span class=\"line\">        System.out.println(allMatch);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//        anyMatch(Predicate p)——检查是否至少匹配一个元素。</span></span><br><span class=\"line\"><span class=\"comment\">//         练习：是否存在员工的工资大于 10000</span></span><br><span class=\"line\">        <span class=\"type\">boolean</span> <span class=\"variable\">anyMatch</span> <span class=\"operator\">=</span> employees.stream().anyMatch(e -&gt; e.getSalary() &gt; <span class=\"number\">10000</span>);</span><br><span class=\"line\">        System.out.println(anyMatch);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//        noneMatch(Predicate p)——检查是否没有匹配的元素。</span></span><br><span class=\"line\"><span class=\"comment\">//          练习：是否存在员工姓“雷”</span></span><br><span class=\"line\">        <span class=\"type\">boolean</span> <span class=\"variable\">noneMatch</span> <span class=\"operator\">=</span> employees.stream().noneMatch(e -&gt; e.getName().startsWith(<span class=\"string\">&quot;雷&quot;</span>));</span><br><span class=\"line\">        System.out.println(noneMatch);</span><br><span class=\"line\"><span class=\"comment\">//        findFirst——返回第一个元素</span></span><br><span class=\"line\">        Optional&lt;Employee&gt; employee = employees.stream().findFirst();</span><br><span class=\"line\">        System.out.println(employee);</span><br><span class=\"line\"><span class=\"comment\">//        findAny——返回当前流中的任意元素</span></span><br><span class=\"line\">        Optional&lt;Employee&gt; employee1 = employees.parallelStream().findAny();</span><br><span class=\"line\">        System.out.println(employee1);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test2</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        List&lt;Employee&gt; employees = EmployeeData.getEmployees();</span><br><span class=\"line\">        <span class=\"comment\">// count——返回流中元素的总个数</span></span><br><span class=\"line\">        <span class=\"type\">long</span> <span class=\"variable\">count</span> <span class=\"operator\">=</span> employees.stream().filter(e -&gt; e.getSalary() &gt; <span class=\"number\">5000</span>).count();</span><br><span class=\"line\">        System.out.println(count);</span><br><span class=\"line\"><span class=\"comment\">//        max(Comparator c)——返回流中最大值</span></span><br><span class=\"line\"><span class=\"comment\">//        练习：返回最高的工资：</span></span><br><span class=\"line\">        Stream&lt;Double&gt; salaryStream = employees.stream().map(e -&gt; e.getSalary());</span><br><span class=\"line\">        Optional&lt;Double&gt; maxSalary = salaryStream.max(Double::compare);</span><br><span class=\"line\">        System.out.println(maxSalary);</span><br><span class=\"line\"><span class=\"comment\">//        min(Comparator c)——返回流中最小值</span></span><br><span class=\"line\"><span class=\"comment\">//        练习：返回最低工资的员工</span></span><br><span class=\"line\">        Optional&lt;Employee&gt; employee = employees.stream().min((e1, e2) -&gt; Double.compare(e1.getSalary(), e2.getSalary()));</span><br><span class=\"line\">        System.out.println(employee);</span><br><span class=\"line\">        System.out.println();</span><br><span class=\"line\"><span class=\"comment\">//        forEach(Consumer c)——内部迭代</span></span><br><span class=\"line\">        employees.stream().forEach(System.out::println);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//使用集合的遍历操作</span></span><br><span class=\"line\">        employees.forEach(System.out::println);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//2-归约</span></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test3</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\"><span class=\"comment\">//        reduce(T identity, BinaryOperator)——可以将流中元素反复结合起来，得到一个值。返回 T</span></span><br><span class=\"line\"><span class=\"comment\">//        练习1：计算1-10的自然数的和</span></span><br><span class=\"line\">        List&lt;Integer&gt; list = Arrays.asList(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">7</span>,<span class=\"number\">8</span>,<span class=\"number\">9</span>,<span class=\"number\">10</span>);</span><br><span class=\"line\">        <span class=\"type\">Integer</span> <span class=\"variable\">sum</span> <span class=\"operator\">=</span> list.stream().reduce(<span class=\"number\">0</span>, Integer::sum);</span><br><span class=\"line\">        System.out.println(sum);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//        reduce(BinaryOperator) ——可以将流中元素反复结合起来，得到一个值。返回 Optional&lt;T&gt;</span></span><br><span class=\"line\"><span class=\"comment\">//        练习2：计算公司所有员工工资的总和</span></span><br><span class=\"line\">        List&lt;Employee&gt; employees = EmployeeData.getEmployees();</span><br><span class=\"line\">        Stream&lt;Double&gt; salaryStream = employees.stream().map(Employee::getSalary);</span><br><span class=\"line\"><span class=\"comment\">//        Optional&lt;Double&gt; sumMoney = salaryStream.reduce(Double::sum);</span></span><br><span class=\"line\">        Optional&lt;Double&gt; sumMoney = salaryStream.reduce((d1,d2) -&gt; d1 + d2);</span><br><span class=\"line\">        System.out.println(sumMoney.get());</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//3-收集</span></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test4</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\"><span class=\"comment\">// collect(Collector c)——将流转换为其他形式。接收一个 Collector接口的实现，用于给Stream中元素做汇总的方法</span></span><br><span class=\"line\"><span class=\"comment\">//        练习1：查找工资大于6000的员工，结果返回为一个List或Set</span></span><br><span class=\"line\"></span><br><span class=\"line\">        List&lt;Employee&gt; employees = EmployeeData.getEmployees();</span><br><span class=\"line\">        List&lt;Employee&gt; employeeList = employees.stream().filter(e -&gt; e.getSalary() &gt; <span class=\"number\">6000</span>).collect(Collectors.toList());</span><br><span class=\"line\"></span><br><span class=\"line\">        employeeList.forEach(System.out::println);</span><br><span class=\"line\">        System.out.println();</span><br><span class=\"line\">        Set&lt;Employee&gt; employeeSet = employees.stream().filter(e -&gt; e.getSalary() &gt; <span class=\"number\">6000</span>).collect(Collectors.toSet());</span><br><span class=\"line\"></span><br><span class=\"line\">        employeeSet.forEach(System.out::println);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"Optional类\"><a href=\"#Optional类\" class=\"headerlink\" title=\"Optional类\"></a>Optional类</h1><h2 id=\"什么是Optional？\"><a href=\"#什么是Optional？\" class=\"headerlink\" title=\"什么是Optional？\"></a>什么是Optional？</h2><ul>\n<li><p>到目前为止，臭名昭著的空指针异常是导致Java应用程序失败的最常见原因。以前，为了解决空指针异常，Google公司著名的Guava项目引入了Optional类，Guava通过使用检查空值的方式来防止代码污染，它鼓励程序员写更干净的代码。受到Google Guava的启发，Optional类已经成为Java 8类库的一部分。</p>\n</li>\n<li><p>Optional<T> 类(java.util.Optional) 是一个容器类，它可以保存类型T的值，代表这个值存在。或者仅仅保存null，表示这个值不存在。原来用 null 表示一个值不存在，现在 Optional 可以更好的表达这个概念。并且可以避免空指针异常。 </p>\n</li>\n<li><p>Optional类的Javadoc描述如下：这是一个可以为null的容器对象。如果值存在则isPresent()方法会返回true，调用get()方法会返回该对象。</p>\n</li>\n</ul>\n<h2 id=\"常用API\"><a href=\"#常用API\" class=\"headerlink\" title=\"常用API\"></a>常用API</h2><img src=\"https://npm.elemecdn.com/youthlql@1.0.8/Java_Basis/Java8_New_Features/0005.png\">\n\n\n\n\n\n<h2 id=\"举例\"><a href=\"#举例\" class=\"headerlink\" title=\"举例\"></a>举例</h2><p>首先准备两个类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Boy</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Girl girl;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">toString</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;Boy&#123;&quot;</span> +</span><br><span class=\"line\">                <span class=\"string\">&quot;girl=&quot;</span> + girl +</span><br><span class=\"line\">                <span class=\"string\">&#x27;&#125;&#x27;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Girl <span class=\"title function_\">getGirl</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> girl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setGirl</span><span class=\"params\">(Girl girl)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.girl = girl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">Boy</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">Boy</span><span class=\"params\">(Girl girl)</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">this</span>.girl = girl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Girl</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">toString</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;Girl&#123;&quot;</span> +</span><br><span class=\"line\">                <span class=\"string\">&quot;name=&#x27;&quot;</span> + name + <span class=\"string\">&#x27;\\&#x27;&#x27;</span> +</span><br><span class=\"line\">                <span class=\"string\">&#x27;&#125;&#x27;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">getName</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setName</span><span class=\"params\">(String name)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.name = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">Girl</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">Girl</span><span class=\"params\">(String name)</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">this</span>.name = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>这里只是简单的测试两个API</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Optional类：为了在程序中避免出现空指针异常而创建的。</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * 常用的方法：ofNullable(T t)</span></span><br><span class=\"line\"><span class=\"comment\"> *            orElse(T t)</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">OptionalTest</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">Optional.of(T t) : 创建一个 Optional 实例，t必须非空；</span></span><br><span class=\"line\"><span class=\"comment\">Optional.empty() : 创建一个空的 Optional 实例</span></span><br><span class=\"line\"><span class=\"comment\">Optional.ofNullable(T t)：t可以为null</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test1</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        <span class=\"type\">Girl</span> <span class=\"variable\">girl</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Girl</span>();</span><br><span class=\"line\"><span class=\"comment\">//        girl = null;</span></span><br><span class=\"line\">        <span class=\"comment\">//of(T t):保证t是非空的</span></span><br><span class=\"line\">        Optional&lt;Girl&gt; optionalGirl = Optional.of(girl);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test2</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        <span class=\"type\">Girl</span> <span class=\"variable\">girl</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Girl</span>();</span><br><span class=\"line\"><span class=\"comment\">//        girl = null;</span></span><br><span class=\"line\">        <span class=\"comment\">//ofNullable(T t)：t可以为null</span></span><br><span class=\"line\">        Optional&lt;Girl&gt; optionalGirl = Optional.ofNullable(girl);</span><br><span class=\"line\">        System.out.println(optionalGirl);</span><br><span class=\"line\">        <span class=\"comment\">//orElse(T t1):如果单前的Optional内部封装的t是非空的，则返回内部的t.</span></span><br><span class=\"line\">        <span class=\"comment\">//如果内部的t是空的，则返回orElse()方法中的参数t1.</span></span><br><span class=\"line\">        <span class=\"type\">Girl</span> <span class=\"variable\">girl1</span> <span class=\"operator\">=</span> optionalGirl.orElse(<span class=\"keyword\">new</span> <span class=\"title class_\">Girl</span>(<span class=\"string\">&quot;赵丽颖&quot;</span>));</span><br><span class=\"line\">        System.out.println(girl1);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>实际场景使用</strong></p>\n<p>可能出现空指针的例子：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> String <span class=\"title function_\">getGirlName</span><span class=\"params\">(Boy boy)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> boy.getGirl().getName();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test3</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        <span class=\"type\">Boy</span> <span class=\"variable\">boy</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Boy</span>();</span><br><span class=\"line\">        boy = <span class=\"literal\">null</span>;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">girlName</span> <span class=\"operator\">=</span> getGirlName(boy);</span><br><span class=\"line\">        System.out.println(girlName);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>结果：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">java.lang.NullPointerException</span><br><span class=\"line\">\tat com.atguigu.java4.OptionalTest.getGirlName(OptionalTest.java:47)</span><br><span class=\"line\">\tat com.atguigu.java4.OptionalTest.test3(OptionalTest.java:54)</span><br><span class=\"line\">...</span><br><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\">Process finished with exit code -1</span><br></pre></td></tr></table></figure>\n\n\n\n<p>没有Optional的解决办法，但是如果调用层数过多，就得一层一层判断是否为null，写起来很麻烦。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//优化以后的getGirlName():</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">getGirlName1</span><span class=\"params\">(Boy boy)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(boy != <span class=\"literal\">null</span>)&#123;</span><br><span class=\"line\">            <span class=\"type\">Girl</span> <span class=\"variable\">girl</span> <span class=\"operator\">=</span> boy.getGirl();</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(girl != <span class=\"literal\">null</span>)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> girl.getName();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test4</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        <span class=\"type\">Boy</span> <span class=\"variable\">boy</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Boy</span>();</span><br><span class=\"line\">        boy = <span class=\"literal\">null</span>;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">girlName</span> <span class=\"operator\">=</span> getGirlName1(boy);</span><br><span class=\"line\">        System.out.println(girlName);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>使用Optional解决问题：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//使用Optional类的getGirlName():</span></span><br><span class=\"line\">   <span class=\"keyword\">public</span> String <span class=\"title function_\">getGirlName2</span><span class=\"params\">(Boy boy)</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">       Optional&lt;Boy&gt; boyOptional = Optional.ofNullable(boy);</span><br><span class=\"line\">       <span class=\"comment\">//此时的boy1一定非空</span></span><br><span class=\"line\">       <span class=\"type\">Boy</span> <span class=\"variable\">boy1</span> <span class=\"operator\">=</span> boyOptional.orElse(<span class=\"keyword\">new</span> <span class=\"title class_\">Boy</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">Girl</span>(<span class=\"string\">&quot;迪丽热巴&quot;</span>)));</span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"type\">Girl</span> <span class=\"variable\">girl</span> <span class=\"operator\">=</span> boy1.getGirl();</span><br><span class=\"line\"></span><br><span class=\"line\">       Optional&lt;Girl&gt; girlOptional = Optional.ofNullable(girl);</span><br><span class=\"line\">       <span class=\"comment\">//girl1一定非空</span></span><br><span class=\"line\">       <span class=\"type\">Girl</span> <span class=\"variable\">girl1</span> <span class=\"operator\">=</span> girlOptional.orElse(<span class=\"keyword\">new</span> <span class=\"title class_\">Girl</span>(<span class=\"string\">&quot;古力娜扎&quot;</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"keyword\">return</span> girl1.getName();</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"meta\">@Test</span></span><br><span class=\"line\">   <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test5</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">       <span class=\"type\">Boy</span> <span class=\"variable\">boy</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">       boy = <span class=\"keyword\">new</span> <span class=\"title class_\">Boy</span>();</span><br><span class=\"line\">       boy = <span class=\"keyword\">new</span> <span class=\"title class_\">Boy</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">Girl</span>(<span class=\"string\">&quot;苍老师&quot;</span>));</span><br><span class=\"line\">       <span class=\"type\">String</span> <span class=\"variable\">girlName</span> <span class=\"operator\">=</span> getGirlName2(boy);</span><br><span class=\"line\">       System.out.println(girlName);</span><br><span class=\"line\"></span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n\n<p>这种是绝对不会出现空指针的。</p>\n<h1 id=\"接口的增强\"><a href=\"#接口的增强\" class=\"headerlink\" title=\"接口的增强\"></a>接口的增强</h1><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JDK7及以前：只能定义全局常量和抽象方法</span><br><span class=\"line\">  &gt;全局常量：public static final的.但是书写时，可以省略不写</span><br><span class=\"line\">  &gt;抽象方法：public abstract的</span><br><span class=\"line\">  \t\t\t</span><br><span class=\"line\">JDK8：除了定义全局常量和抽象方法之外，还可以定义静态方法、默认方法</span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * JDK8：除了定义全局常量和抽象方法之外，还可以定义静态方法、默认方法</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">CompareA</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//静态方法</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">method1</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;CompareA:北京&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//默认方法</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">default</span> <span class=\"keyword\">void</span> <span class=\"title function_\">method2</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;CompareA：上海&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//接口中的public 可以省略，自动就是public</span></span><br><span class=\"line\">    <span class=\"keyword\">default</span> <span class=\"keyword\">void</span> <span class=\"title function_\">method3</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;CompareA：上海&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">SuperClass</span> &#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">method3</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;SuperClass:北京&quot;</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">CompareB</span> &#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">default</span> <span class=\"keyword\">void</span> <span class=\"title function_\">method3</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;CompareB：上海&quot;</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">SubClassTest</span> &#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"type\">SubClass</span> <span class=\"variable\">s</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">SubClass</span>();</span><br><span class=\"line\">\t\t</span><br><span class=\"line\"><span class=\"comment\">//\t\ts.method1();</span></span><br><span class=\"line\"><span class=\"comment\">//\t\tSubClass.method1();</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//知识点1：接口中定义的静态方法，只能通过接口来调用。实现类用不了</span></span><br><span class=\"line\">\t\tCompareA.method1();</span><br><span class=\"line\">\t\t<span class=\"comment\">//知识点2：通过实现类的对象，可以调用接口中的默认方法。</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//如果实现类重写了接口中的默认方法，调用时，仍然调用的是重写以后的方法</span></span><br><span class=\"line\">\t\ts.method2();</span><br><span class=\"line\">\t\t<span class=\"comment\">//知识点3：如果子类(或实现类)继承的父类和实现的接口中声明了同名同参数的默认方法，</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//那么子类在没有重写此方法的情况下，默认调用的是父类中的同名同参数的方法。--&gt;类优先原则</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//知识点4：如果实现类实现了多个接口，而这多个接口中定义了同名同参数的默认方法，</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//那么在实现类没有重写此方法的情况下，报错。--&gt;接口冲突。</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//这就需要我们必须在实现类中重写此方法</span></span><br><span class=\"line\">\t\ts.method3();</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">SubClass</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">SuperClass</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">CompareA</span>,CompareB&#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">method2</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;SubClass：上海&quot;</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">method3</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;SubClass：深圳&quot;</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">//知识点5：如何在子类(或实现类)的方法中调用父类、接口中被重写的方法</span></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">myMethod</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">\t\tmethod3();<span class=\"comment\">//调用自己定义的重写的方法</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">super</span>.method3();<span class=\"comment\">//调用的是父类中声明的</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//调用接口中的默认方法</span></span><br><span class=\"line\">\t\tCompareA.<span class=\"built_in\">super</span>.method3();</span><br><span class=\"line\">\t\tCompareB.<span class=\"built_in\">super</span>.method3();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"cover_type":"img","excerpt":"","more":"<h1 id=\"Java8新特性纵览\"><a href=\"#Java8新特性纵览\" class=\"headerlink\" title=\"Java8新特性纵览\"></a>Java8新特性纵览</h1><blockquote>\n<p>关于Java8新特性的学习与记录，资料来源于互联网。</p>\n</blockquote>\n<h1 id=\"Lambda表达式\"><a href=\"#Lambda表达式\" class=\"headerlink\" title=\"Lambda表达式\"></a>Lambda表达式</h1><h2 id=\"为什么使用Lambda表达式？\"><a href=\"#为什么使用Lambda表达式？\" class=\"headerlink\" title=\"为什么使用Lambda表达式？\"></a>为什么使用Lambda表达式？</h2><ul>\n<li>Lambda 是一个<strong>匿名函数</strong>，我们可以把 Lambda 表达式理解为是<strong>一段可以传递的代码</strong>（将代码像数据一样进行传递）。使用它可以写出更简洁、更灵活的代码。作为一种更紧凑的代码风格，使Java的语言表达能力得到了提升。</li>\n<li>在Java8之后的很多源码里用到了Lambda表达式，不学的话可能看不懂源码。</li>\n</ul>\n<h2 id=\"简单使用\"><a href=\"#简单使用\" class=\"headerlink\" title=\"简单使用\"></a>简单使用</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\">   <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test1</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">       <span class=\"comment\">//原始写法</span></span><br><span class=\"line\">       <span class=\"type\">Runnable</span> <span class=\"variable\">r1</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Runnable</span>() &#123;</span><br><span class=\"line\">           <span class=\"meta\">@Override</span></span><br><span class=\"line\">           <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">               System.out.println(<span class=\"string\">&quot;我爱北京天安门&quot;</span>);</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">       r1.run();</span><br><span class=\"line\"></span><br><span class=\"line\">       System.out.println(<span class=\"string\">&quot;***********************&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"comment\">//lambda表达式，可以表达一样的意思</span></span><br><span class=\"line\">       <span class=\"type\">Runnable</span> <span class=\"variable\">r2</span> <span class=\"operator\">=</span> () -&gt; System.out.println(<span class=\"string\">&quot;我爱北京故宫&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">       r2.run();</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"meta\">@Test</span></span><br><span class=\"line\">   <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test2</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">       Comparator&lt;Integer&gt; com1 = <span class=\"keyword\">new</span> <span class=\"title class_\">Comparator</span>&lt;Integer&gt;() &#123;</span><br><span class=\"line\">           <span class=\"meta\">@Override</span></span><br><span class=\"line\">           <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">compare</span><span class=\"params\">(Integer o1, Integer o2)</span> &#123;</span><br><span class=\"line\">               <span class=\"keyword\">return</span> Integer.compare(o1,o2);</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"type\">int</span> <span class=\"variable\">compare1</span> <span class=\"operator\">=</span> com1.compare(<span class=\"number\">12</span>,<span class=\"number\">21</span>);</span><br><span class=\"line\">       System.out.println(compare1);</span><br><span class=\"line\"></span><br><span class=\"line\">       System.out.println(<span class=\"string\">&quot;***********************&quot;</span>);</span><br><span class=\"line\">       </span><br><span class=\"line\">       <span class=\"comment\">//Lambda表达式的写法</span></span><br><span class=\"line\">       Comparator&lt;Integer&gt; com2 = (o1,o2) -&gt; Integer.compare(o1,o2);</span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"type\">int</span> <span class=\"variable\">compare2</span> <span class=\"operator\">=</span> com2.compare(<span class=\"number\">32</span>,<span class=\"number\">21</span>);</span><br><span class=\"line\">       System.out.println(compare2);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">       System.out.println(<span class=\"string\">&quot;***********************&quot;</span>);</span><br><span class=\"line\">       <span class=\"comment\">//方法引用</span></span><br><span class=\"line\">       Comparator&lt;Integer&gt; com3 = Integer :: compare;</span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"type\">int</span> <span class=\"variable\">compare3</span> <span class=\"operator\">=</span> com3.compare(<span class=\"number\">32</span>,<span class=\"number\">21</span>);</span><br><span class=\"line\">       System.out.println(compare3);</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"Lambda语法规则\"><a href=\"#Lambda语法规则\" class=\"headerlink\" title=\"Lambda语法规则\"></a>Lambda语法规则</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> org.junit.Test;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.ArrayList;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Comparator;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.function.Consumer;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Lambda表达式的使用</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;p&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> * 1.举例： (o1,o2) -&gt; Integer.compare(o1,o2);</span></span><br><span class=\"line\"><span class=\"comment\"> * 2.格式：</span></span><br><span class=\"line\"><span class=\"comment\"> * -&gt; :lambda操作符 或 箭头操作符</span></span><br><span class=\"line\"><span class=\"comment\"> * -&gt;左边：lambda形参列表 （其实就是接口中的抽象方法的形参列表）</span></span><br><span class=\"line\"><span class=\"comment\"> * -&gt;右边：lambda体 （其实就是重写的抽象方法的方法体）</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;p&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> * 3. Lambda表达式的使用：（分为6种情况介绍）</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;p&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> * 总结：</span></span><br><span class=\"line\"><span class=\"comment\"> * -&gt;左边：lambda形参列表的参数类型可以省略(类型推断)；如果lambda形参列表只有一个参数，其一对()也</span></span><br><span class=\"line\"><span class=\"comment\"> * 可以省略</span></span><br><span class=\"line\"><span class=\"comment\"> * -&gt;右边：lambda体应该使用一对&#123;&#125;包裹；如果lambda体只有一条执行语句（可能是return语句），省略这一</span></span><br><span class=\"line\"><span class=\"comment\"> 对&#123;&#125;和return关键字</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;p&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> * 4.Lambda表达式的本质：作为函数式接口的实例</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;p&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> * 5. 如果一个接口中，只声明了一个抽象方法，则此接口就称为函数式接口。我们可以在一个接口上</span></span><br><span class=\"line\"><span class=\"comment\"> 使用 <span class=\"doctag\">@FunctionalInterface</span> 注解，</span></span><br><span class=\"line\"><span class=\"comment\"> * 这样做可以检查它是否是一个函数式接口。</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;p&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> * 6. 所以以前用匿名实现类表示的现在都可以用Lambda表达式来写。</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">LambdaTest1</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//语法格式一：无参，无返回值</span></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test1</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Runnable</span> <span class=\"variable\">r1</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Runnable</span>() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;我爱北京天安门&quot;</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        r1.run();</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;***********************&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">Runnable</span> <span class=\"variable\">r2</span> <span class=\"operator\">=</span> () -&gt; &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;我爱北京故宫&quot;</span>);</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        r2.run();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//语法格式二：Lambda 需要一个参数，但是没有返回值。</span></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test2</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        Consumer&lt;String&gt; con = <span class=\"keyword\">new</span> <span class=\"title class_\">Consumer</span>&lt;String&gt;() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">accept</span><span class=\"params\">(String s)</span> &#123;</span><br><span class=\"line\">                System.out.println(s);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        con.accept(<span class=\"string\">&quot;谎言和誓言的区别是什么？&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;*******************&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        Consumer&lt;String&gt; con1 = (String s) -&gt; &#123;</span><br><span class=\"line\">            System.out.println(s);</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        con1.accept(<span class=\"string\">&quot;一个是听得人当真了，一个是说的人当真了&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//语法格式三：数据类型可以省略，因为可由编译器推断得出，称为“类型推断”</span></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test3</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        Consumer&lt;String&gt; con1 = (String s) -&gt; &#123;</span><br><span class=\"line\">            System.out.println(s);</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        con1.accept(<span class=\"string\">&quot;一个是听得人当真了，一个是说的人当真了&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;*******************&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        Consumer&lt;String&gt; con2 = (s) -&gt; &#123;</span><br><span class=\"line\">            System.out.println(s);</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        con2.accept(<span class=\"string\">&quot;一个是听得人当真了，一个是说的人当真了&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test4</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        ArrayList&lt;String&gt; list = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();<span class=\"comment\">//类型推断</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">int</span>[] arr = &#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>&#125;;<span class=\"comment\">//类型推断</span></span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//语法格式四：Lambda 若只需要一个参数时，参数的小括号可以省略</span></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test5</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        Consumer&lt;String&gt; con1 = (s) -&gt; &#123;</span><br><span class=\"line\">            System.out.println(s);</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        con1.accept(<span class=\"string\">&quot;一个是听得人当真了，一个是说的人当真了&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;*******************&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        Consumer&lt;String&gt; con2 = s -&gt; &#123;</span><br><span class=\"line\">            System.out.println(s);</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        con2.accept(<span class=\"string\">&quot;一个是听得人当真了，一个是说的人当真了&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//语法格式五：Lambda 需要两个或以上的参数，多条执行语句，并且可以有返回值</span></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test6</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        Comparator&lt;Integer&gt; com1 = <span class=\"keyword\">new</span> <span class=\"title class_\">Comparator</span>&lt;Integer&gt;() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">compare</span><span class=\"params\">(Integer o1, Integer o2)</span> &#123;</span><br><span class=\"line\">                System.out.println(o1);</span><br><span class=\"line\">                System.out.println(o2);</span><br><span class=\"line\">                <span class=\"keyword\">return</span> o1.compareTo(o2);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(com1.compare(<span class=\"number\">12</span>, <span class=\"number\">21</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;*****************************&quot;</span>);</span><br><span class=\"line\">        Comparator&lt;Integer&gt; com2 = (o1, o2) -&gt; &#123;</span><br><span class=\"line\">            System.out.println(o1);</span><br><span class=\"line\">            System.out.println(o2);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> o1.compareTo(o2);</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(com2.compare(<span class=\"number\">12</span>, <span class=\"number\">6</span>));</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//语法格式六：当 Lambda 体只有一条语句时，return 与大括号若有，都可以省略</span></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test7</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        Comparator&lt;Integer&gt; com1 = (o1, o2) -&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> o1.compareTo(o2);</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(com1.compare(<span class=\"number\">12</span>, <span class=\"number\">6</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;*****************************&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        Comparator&lt;Integer&gt; com2 = (o1, o2) -&gt; o1.compareTo(o2);</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(com2.compare(<span class=\"number\">12</span>, <span class=\"number\">21</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test8</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        Consumer&lt;String&gt; con1 = s -&gt; &#123;</span><br><span class=\"line\">            System.out.println(s);</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        con1.accept(<span class=\"string\">&quot;一个是听得人当真了，一个是说的人当真了&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;*****************************&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        Consumer&lt;String&gt; con2 = s -&gt; System.out.println(s);</span><br><span class=\"line\"></span><br><span class=\"line\">        con2.accept(<span class=\"string\">&quot;一个是听得人当真了，一个是说的人当真了&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"函数式接口\"><a href=\"#函数式接口\" class=\"headerlink\" title=\"函数式接口\"></a>函数式接口</h1><h2 id=\"什么是函数式-Functional-接口\"><a href=\"#什么是函数式-Functional-接口\" class=\"headerlink\" title=\"什么是函数式(Functional)接口\"></a>什么是函数式(Functional)接口</h2><ul>\n<li><p>只包含一个抽象方法的接口，称为<strong>函数式接口</strong>。 </p>\n</li>\n<li><p>你可以通过 Lambda 表达式来创建该接口的对象。（若 Lambda 表达式抛出一个受检异常(即：非运行时异常)，那么该异常需要在目标接口的抽象方法上进行声明）。</p>\n</li>\n<li><p>我们可以在一个接口上使用 <strong>@FunctionalInterface</strong> 注解，这样做可以检查它是否是一个函数式接口。同时 javadoc 也会包含一条声明，说明这个接口是一个函数式接口。</p>\n</li>\n<li><p>在java.util.function包下定义了Java 8 的丰富的函数式接口</p>\n</li>\n</ul>\n<h2 id=\"如何理解函数式接口\"><a href=\"#如何理解函数式接口\" class=\"headerlink\" title=\"如何理解函数式接口\"></a>如何理解函数式接口</h2><ul>\n<li>Java从诞生日起就是一直倡导“一切皆对象”，在Java里面面向对象(OOP)编程是一切。但是随着python、scala等语言的兴起和新技术的挑战，Java不得不做出调整以便支持更加广泛的技术要求，也即java不但可以支持OOP还可以支持OOF（面向函数编程） </li>\n<li>在函数式编程语言当中，函数被当做一等公民对待。在将函数作为一等公民的编程语言中，Lambda表达式的类型是函数。但是在Java8中，有所不同。在Java8中，Lambda表达式是对象，而不是函数，它们必须依附于一类特别的对象类型——函数式接口。 </li>\n<li>简单的说，在Java8中，Lambda表达式就是一个函数式接口的实例。这就是Lambda表达式和函数式接口的关系。也就是说，只要一个对象是函数式接口的实例，那么该对象就可以用Lambda表达式来表示。</li>\n<li>所以以前用匿名实现类表示的现在都可以用Lambda表达式来写。</li>\n</ul>\n<h2 id=\"Java内置函数式接口\"><a href=\"#Java内置函数式接口\" class=\"headerlink\" title=\"Java内置函数式接口\"></a>Java内置函数式接口</h2><p><strong>核心函数式接口</strong></p>\n<img src=\"https://npm.elemecdn.com/youthlql@1.0.8/Java_Basis/Java8_New_Features/0002.png\">\n\n\n\n<p><strong>其它函数式接口</strong></p>\n<img src=\"https://npm.elemecdn.com/youthlql@1.0.8/Java_Basis/Java8_New_Features/0003.png\">\n\n\n\n\n\n<p><strong>Consumer</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\">   <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test1</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">       happyTime(<span class=\"number\">500</span>, <span class=\"keyword\">new</span> <span class=\"title class_\">Consumer</span>&lt;Double&gt;() &#123;</span><br><span class=\"line\">           <span class=\"meta\">@Override</span></span><br><span class=\"line\">           <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">accept</span><span class=\"params\">(Double aDouble)</span> &#123;</span><br><span class=\"line\">               System.out.println(<span class=\"string\">&quot;学习太累了，去天上人间买了瓶矿泉水，价格为：&quot;</span> + aDouble);</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">       System.out.println(<span class=\"string\">&quot;********************&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">       happyTime(<span class=\"number\">400</span>,money -&gt; System.out.println(<span class=\"string\">&quot;学习太累了，去天上人间喝了口水，价格为：&quot;</span> + money));</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">happyTime</span><span class=\"params\">(<span class=\"type\">double</span> money, Consumer&lt;Double&gt; con)</span>&#123;</span><br><span class=\"line\">       con.accept(money);</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>结果：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">学习太累了，去天上人间买了瓶矿泉水，价格为：<span class=\"number\">500.0</span></span><br><span class=\"line\">********************</span><br><span class=\"line\">学习太累了，去天上人间喝了口水，价格为：<span class=\"number\">400.0</span></span><br><span class=\"line\"></span><br><span class=\"line\">Process finished with exit code <span class=\"number\">0</span></span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>Predicate</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test2</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        List&lt;String&gt; list = Arrays.asList(<span class=\"string\">&quot;北京&quot;</span>,<span class=\"string\">&quot;南京&quot;</span>,<span class=\"string\">&quot;天津&quot;</span>,<span class=\"string\">&quot;东京&quot;</span>,<span class=\"string\">&quot;西京&quot;</span>,<span class=\"string\">&quot;普京&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        List&lt;String&gt; filterStrs = filterString(list, <span class=\"keyword\">new</span> <span class=\"title class_\">Predicate</span>&lt;String&gt;() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">test</span><span class=\"params\">(String s)</span> &#123;<span class=\"comment\">//这里是定义一个校验规则</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span> s.contains(<span class=\"string\">&quot;京&quot;</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(filterStrs);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//用lambda表达式会很简单</span></span><br><span class=\"line\">        List&lt;String&gt; filterStrs1 = filterString(list,s -&gt; s.contains(<span class=\"string\">&quot;京&quot;</span>));</span><br><span class=\"line\">        System.out.println(filterStrs1);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//根据给定的规则，过滤集合中的字符串。此规则由Predicate的方法决定</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;String&gt; <span class=\"title function_\">filterString</span><span class=\"params\">(List&lt;String&gt; list, Predicate&lt;String&gt; pre)</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        ArrayList&lt;String&gt; filterList = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(String s : list)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(pre.test(s))&#123;</span><br><span class=\"line\">                filterList.add(s);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> filterList;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>结果：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[北京, 南京, 东京, 西京, 普京]</span><br><span class=\"line\">[北京, 南京, 东京, 西京, 普京]</span><br><span class=\"line\"></span><br><span class=\"line\">Process finished with exit code 0</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"自定义函数式接口\"><a href=\"#自定义函数式接口\" class=\"headerlink\" title=\"自定义函数式接口\"></a>自定义函数式接口</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 自定义函数式接口</span></span><br><span class=\"line\"><span class=\"comment\"> * 只是说加上<span class=\"doctag\">@FunctionalInterface</span>之后可以校验</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@FunctionalInterface</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">MyFunInterface</span>&lt;T&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> T <span class=\"title function_\">getValue</span><span class=\"params\">(T t)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Test</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//这个方法的第一个参数是lambda表达式，相当于是实例化了那个函数式接口</span></span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">s</span> <span class=\"operator\">=</span> toUpperString(str -&gt; str.toUpperCase(), <span class=\"string\">&quot;abcd&quot;</span>);</span><br><span class=\"line\">        System.out.println(s);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String <span class=\"title function_\">toUpperString</span><span class=\"params\">(MyFunInterface&lt;String&gt; mf,String str)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> mf.getValue(str);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"方法引用\"><a href=\"#方法引用\" class=\"headerlink\" title=\"方法引用\"></a>方法引用</h1><ul>\n<li><p>当要传递给Lambda体的操作，已经有实现的方法了，可以使用方法引用！</p>\n</li>\n<li><p>方法引用可以看做是Lambda表达式深层次的表达。换句话说，方法引用就是Lambda表达式，也就是函数式接口的一个实例，通过方法的名字来指向一个方法，可以认为是Lambda表达式的一个语法糖。</p>\n</li>\n<li><p>要求：实现接口的抽象方法的参数列表和返回值类型，必须与方法引用的方法的参数列表和返回值类型保持一致！</p>\n</li>\n<li><p>格式：使用操作符 “::” 将类(或对象) 与 方法名分隔开来。</p>\n</li>\n<li><p>如下三种主要使用情况： </p>\n<ul>\n<li><p>对象 :: 实例方法名</p>\n</li>\n<li><p>类 :: 静态方法名</p>\n</li>\n<li><p>类 :: 实例方法名</p>\n</li>\n</ul>\n</li>\n</ul>\n<p>我们直接拿例子来说明情况，先提前准备两个类：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Employee</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"type\">int</span> id;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"type\">int</span> age;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"type\">double</span> salary;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">getId</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> id;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setId</span><span class=\"params\">(<span class=\"type\">int</span> id)</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">this</span>.id = id;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> String <span class=\"title function_\">getName</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> name;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setName</span><span class=\"params\">(String name)</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">this</span>.name = name;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">getAge</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> age;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setAge</span><span class=\"params\">(<span class=\"type\">int</span> age)</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">this</span>.age = age;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"type\">double</span> <span class=\"title function_\">getSalary</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> salary;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setSalary</span><span class=\"params\">(<span class=\"type\">double</span> salary)</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">this</span>.salary = salary;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"title function_\">Employee</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;Employee().....&quot;</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"title function_\">Employee</span><span class=\"params\">(<span class=\"type\">int</span> id)</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">this</span>.id = id;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;Employee(int id).....&quot;</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"title function_\">Employee</span><span class=\"params\">(<span class=\"type\">int</span> id, String name)</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">this</span>.id = id;</span><br><span class=\"line\">\t\t<span class=\"built_in\">this</span>.name = name;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"title function_\">Employee</span><span class=\"params\">(<span class=\"type\">int</span> id, String name, <span class=\"type\">int</span> age, <span class=\"type\">double</span> salary)</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"built_in\">this</span>.id = id;</span><br><span class=\"line\">\t\t<span class=\"built_in\">this</span>.name = name;</span><br><span class=\"line\">\t\t<span class=\"built_in\">this</span>.age = age;</span><br><span class=\"line\">\t\t<span class=\"built_in\">this</span>.salary = salary;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> String <span class=\"title function_\">toString</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"string\">&quot;Employee&#123;&quot;</span> + <span class=\"string\">&quot;id=&quot;</span> + id + <span class=\"string\">&quot;, name=&#x27;&quot;</span> + name + <span class=\"string\">&#x27;\\&#x27;&#x27;</span> + <span class=\"string\">&quot;, age=&quot;</span> + age + <span class=\"string\">&quot;, salary=&quot;</span> + salary + <span class=\"string\">&#x27;&#125;&#x27;</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">equals</span><span class=\"params\">(Object o)</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (<span class=\"built_in\">this</span> == o)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (o == <span class=\"literal\">null</span> || getClass() != o.getClass())</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"type\">Employee</span> <span class=\"variable\">employee</span> <span class=\"operator\">=</span> (Employee) o;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (id != employee.id)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (age != employee.age)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (Double.compare(employee.salary, salary) != <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> name != <span class=\"literal\">null</span> ? name.equals(employee.name) : employee.name == <span class=\"literal\">null</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">hashCode</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> result;</span><br><span class=\"line\">\t\t<span class=\"type\">long</span> temp;</span><br><span class=\"line\">\t\tresult = id;</span><br><span class=\"line\">\t\tresult = <span class=\"number\">31</span> * result + (name != <span class=\"literal\">null</span> ? name.hashCode() : <span class=\"number\">0</span>);</span><br><span class=\"line\">\t\tresult = <span class=\"number\">31</span> * result + age;</span><br><span class=\"line\">\t\ttemp = Double.doubleToLongBits(salary);</span><br><span class=\"line\">\t\tresult = <span class=\"number\">31</span> * result + (<span class=\"type\">int</span>) (temp ^ (temp &gt;&gt;&gt; <span class=\"number\">32</span>));</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> result;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 提供用于测试的数据</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">EmployeeData</span> &#123;</span><br><span class=\"line\">   </span><br><span class=\"line\">   <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> List&lt;Employee&gt; <span class=\"title function_\">getEmployees</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">      List&lt;Employee&gt; list = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">      </span><br><span class=\"line\">      list.add(<span class=\"keyword\">new</span> <span class=\"title class_\">Employee</span>(<span class=\"number\">1001</span>, <span class=\"string\">&quot;马化腾&quot;</span>, <span class=\"number\">34</span>, <span class=\"number\">6000.38</span>));</span><br><span class=\"line\">      list.add(<span class=\"keyword\">new</span> <span class=\"title class_\">Employee</span>(<span class=\"number\">1002</span>, <span class=\"string\">&quot;马云&quot;</span>, <span class=\"number\">12</span>, <span class=\"number\">9876.12</span>));</span><br><span class=\"line\">      list.add(<span class=\"keyword\">new</span> <span class=\"title class_\">Employee</span>(<span class=\"number\">1003</span>, <span class=\"string\">&quot;刘强东&quot;</span>, <span class=\"number\">33</span>, <span class=\"number\">3000.82</span>));</span><br><span class=\"line\">      list.add(<span class=\"keyword\">new</span> <span class=\"title class_\">Employee</span>(<span class=\"number\">1004</span>, <span class=\"string\">&quot;雷军&quot;</span>, <span class=\"number\">26</span>, <span class=\"number\">7657.37</span>));</span><br><span class=\"line\">      list.add(<span class=\"keyword\">new</span> <span class=\"title class_\">Employee</span>(<span class=\"number\">1005</span>, <span class=\"string\">&quot;李彦宏&quot;</span>, <span class=\"number\">65</span>, <span class=\"number\">5555.32</span>));</span><br><span class=\"line\">      list.add(<span class=\"keyword\">new</span> <span class=\"title class_\">Employee</span>(<span class=\"number\">1006</span>, <span class=\"string\">&quot;比尔盖茨&quot;</span>, <span class=\"number\">42</span>, <span class=\"number\">9500.43</span>));</span><br><span class=\"line\">      list.add(<span class=\"keyword\">new</span> <span class=\"title class_\">Employee</span>(<span class=\"number\">1007</span>, <span class=\"string\">&quot;任正非&quot;</span>, <span class=\"number\">26</span>, <span class=\"number\">4333.32</span>));</span><br><span class=\"line\">      list.add(<span class=\"keyword\">new</span> <span class=\"title class_\">Employee</span>(<span class=\"number\">1008</span>, <span class=\"string\">&quot;扎克伯格&quot;</span>, <span class=\"number\">35</span>, <span class=\"number\">2500.32</span>));</span><br><span class=\"line\">      </span><br><span class=\"line\">      <span class=\"keyword\">return</span> list;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>下面来通过实际例子讲解方法引用：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 方法引用的使用</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * 1.使用情境：当要传递给Lambda体的操作，已经有实现的方法了，可以使用方法引用！</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * 2.方法引用，本质上就是Lambda表达式，而Lambda表达式作为函数式接口的实例。所以</span></span><br><span class=\"line\"><span class=\"comment\"> *   方法引用，也是函数式接口的实例。</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * 3. 使用格式：  类(或对象) :: 方法名</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * 4. 具体分为如下的三种情况：</span></span><br><span class=\"line\"><span class=\"comment\"> *    情况1     对象 :: 非静态方法</span></span><br><span class=\"line\"><span class=\"comment\"> *    情况2     类 :: 静态方法</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> *    情况3     类 :: 非静态方法</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * 5. 方法引用使用的要求：</span></span><br><span class=\"line\"><span class=\"comment\"> * \t接口中的抽象方法的形参列表和返回值类型</span></span><br><span class=\"line\"><span class=\"comment\"> * \t与</span></span><br><span class=\"line\"><span class=\"comment\"> * \t方法引用的方法的形参列表和返回值类型相同！（针对于情况1和情况2）</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">MethodRefTest</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 情况一：对象 :: 实例方法</span></span><br><span class=\"line\">\t<span class=\"comment\">//Consumer中的void accept(T t)</span></span><br><span class=\"line\">\t<span class=\"comment\">//PrintStream中的void println(T t)</span></span><br><span class=\"line\">\t<span class=\"meta\">@Test</span></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test1</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t\tConsumer&lt;String&gt; con1 = str -&gt; System.out.println(str);</span><br><span class=\"line\">\t\tcon1.accept(<span class=\"string\">&quot;北京&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;*******************&quot;</span>);</span><br><span class=\"line\">\t\t<span class=\"type\">PrintStream</span> <span class=\"variable\">ps</span> <span class=\"operator\">=</span> System.out;</span><br><span class=\"line\">\t\tConsumer&lt;String&gt; con2 = ps::println;</span><br><span class=\"line\">\t\tcon2.accept(<span class=\"string\">&quot;beijing&quot;</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">//Supplier中的T get()</span></span><br><span class=\"line\">\t<span class=\"comment\">//Employee中的String getName()</span></span><br><span class=\"line\">\t<span class=\"meta\">@Test</span></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test2</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"type\">Employee</span> <span class=\"variable\">emp</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Employee</span>(<span class=\"number\">1001</span>,<span class=\"string\">&quot;Tom&quot;</span>,<span class=\"number\">23</span>,<span class=\"number\">5600</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tSupplier&lt;String&gt; sup1 = () -&gt; emp.getName();</span><br><span class=\"line\">\t\tSystem.out.println(sup1.get());</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;*******************&quot;</span>);</span><br><span class=\"line\">\t\tSupplier&lt;String&gt; sup2 = emp::getName;</span><br><span class=\"line\">\t\tSystem.out.println(sup2.get());</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 情况二：类 :: 静态方法</span></span><br><span class=\"line\">\t<span class=\"comment\">//Comparator中的int compare(T t1,T t2)</span></span><br><span class=\"line\">\t<span class=\"comment\">//Integer中的int compare(T t1,T t2)</span></span><br><span class=\"line\">\t<span class=\"meta\">@Test</span></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test3</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t\tComparator&lt;Integer&gt; com1 = (t1,t2) -&gt; Integer.compare(t1,t2);</span><br><span class=\"line\">\t\tSystem.out.println(com1.compare(<span class=\"number\">12</span>,<span class=\"number\">21</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;*******************&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tComparator&lt;Integer&gt; com2 = Integer::compare;</span><br><span class=\"line\">\t\tSystem.out.println(com2.compare(<span class=\"number\">12</span>,<span class=\"number\">3</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">//Function中的R apply(T t)</span></span><br><span class=\"line\">\t<span class=\"comment\">//Math中的Long round(Double d)</span></span><br><span class=\"line\">\t<span class=\"meta\">@Test</span></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test4</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t\tFunction&lt;Double,Long&gt; func = <span class=\"keyword\">new</span> <span class=\"title class_\">Function</span>&lt;Double, Long&gt;() &#123;</span><br><span class=\"line\">\t\t\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">public</span> Long <span class=\"title function_\">apply</span><span class=\"params\">(Double d)</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> Math.round(d);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;*******************&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tFunction&lt;Double,Long&gt; func1 = d -&gt; Math.round(d);</span><br><span class=\"line\">\t\tSystem.out.println(func1.apply(<span class=\"number\">12.3</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;*******************&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tFunction&lt;Double,Long&gt; func2 = Math::round;</span><br><span class=\"line\">\t\tSystem.out.println(func2.apply(<span class=\"number\">12.6</span>));</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 情况三：类 :: 实例方法  (有难度)</span></span><br><span class=\"line\">\t<span class=\"comment\">// Comparator中的int comapre(T t1,T t2)  第一个参数T t1,也可以变成方法的调用者</span></span><br><span class=\"line\">\t<span class=\"comment\">// String中的int t1.compareTo(t2)        看上面说的，t1变成了调用者等价于第一个参数T t1</span></span><br><span class=\"line\">\t<span class=\"meta\">@Test</span></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test5</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t\tComparator&lt;String&gt; com1 = (s1,s2) -&gt; s1.compareTo(s2);</span><br><span class=\"line\">\t\tSystem.out.println(com1.compare(<span class=\"string\">&quot;abc&quot;</span>,<span class=\"string\">&quot;abd&quot;</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;*******************&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tComparator&lt;String&gt; com2 = String :: compareTo;</span><br><span class=\"line\">\t\tSystem.out.println(com2.compare(<span class=\"string\">&quot;abd&quot;</span>,<span class=\"string\">&quot;abm&quot;</span>));</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//BiPredicate中的boolean test(T t1, T t2);</span></span><br><span class=\"line\">\t<span class=\"comment\">//String中的boolean t1.equals(t2)</span></span><br><span class=\"line\">\t<span class=\"meta\">@Test</span></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test6</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t\tBiPredicate&lt;String,String&gt; pre1 = (s1,s2) -&gt; s1.equals(s2);</span><br><span class=\"line\">\t\tSystem.out.println(pre1.test(<span class=\"string\">&quot;abc&quot;</span>,<span class=\"string\">&quot;abc&quot;</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;*******************&quot;</span>);</span><br><span class=\"line\">\t\tBiPredicate&lt;String,String&gt; pre2 = String :: equals;</span><br><span class=\"line\">\t\tSystem.out.println(pre2.test(<span class=\"string\">&quot;abc&quot;</span>,<span class=\"string\">&quot;abd&quot;</span>));</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">// Function中的R apply(T t)</span></span><br><span class=\"line\">\t<span class=\"comment\">// Employee中的String getName();   第一个参数T t相当于方法调用者emp，返回值R和String对应</span></span><br><span class=\"line\">\t<span class=\"meta\">@Test</span></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test7</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"type\">Employee</span> <span class=\"variable\">employee</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Employee</span>(<span class=\"number\">1001</span>, <span class=\"string\">&quot;Jerry&quot;</span>, <span class=\"number\">23</span>, <span class=\"number\">6000</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">\t\tFunction&lt;Employee,String&gt; func1 = e -&gt; e.getName();</span><br><span class=\"line\">\t\tSystem.out.println(func1.apply(employee));</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;*******************&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">\t\tFunction&lt;Employee,String&gt; func2 = Employee::getName;</span><br><span class=\"line\">\t\tSystem.out.println(func2.apply(employee));</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h1 id=\"构造器引用\"><a href=\"#构造器引用\" class=\"headerlink\" title=\"构造器引用\"></a>构造器引用</h1><p>格式：ClassName :: new</p>\n<p>与函数式接口相结合，自动与函数式接口中方法兼容。可以把构造器引用赋值给定义的方法，要求构造器参数列表要与接口中抽象方法的参数列表一致！且方法的返回值即为构造器对应类的对象。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.junit.Test;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Arrays;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.function.BiFunction;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.function.Function;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.function.Supplier;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 一、构造器引用</span></span><br><span class=\"line\"><span class=\"comment\"> *      和方法引用类似，函数式接口的抽象方法的形参列表和构造器的形参列表一致。</span></span><br><span class=\"line\"><span class=\"comment\"> *      抽象方法的返回值类型即为构造器所属的类的类型</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * 二、数组引用</span></span><br><span class=\"line\"><span class=\"comment\"> *     大家可以把数组看做是一个特殊的类，则写法与构造器引用一致。</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ConstructorRefTest</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 构造器引用</span></span><br><span class=\"line\"><span class=\"comment\">     * Supplier中的T get()</span></span><br><span class=\"line\"><span class=\"comment\">     * Employee的空参构造器：Employee()</span></span><br><span class=\"line\"><span class=\"comment\">     * 1、和方法引用一样的理解方法，你的get()方法没有参数，我的Employee()也没有参数。</span></span><br><span class=\"line\"><span class=\"comment\">     * 2、你的get()方法有返回值T，我的Employee()方法返回值也是一个对象</span></span><br><span class=\"line\"><span class=\"comment\">     * 3、所以刚好可以用  </span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test1</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        Supplier&lt;Employee&gt; sup = <span class=\"keyword\">new</span> <span class=\"title class_\">Supplier</span>&lt;Employee&gt;() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"keyword\">public</span> Employee <span class=\"title function_\">get</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Employee</span>();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;*******************&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        Supplier&lt;Employee&gt;  sup1 = () -&gt; <span class=\"keyword\">new</span> <span class=\"title class_\">Employee</span>();</span><br><span class=\"line\">        System.out.println(sup1.get());</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;*******************&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        Supplier&lt;Employee&gt;  sup2 = Employee :: <span class=\"keyword\">new</span>;</span><br><span class=\"line\">        System.out.println(sup2.get());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//Function中的R apply(T t)</span></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test2</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        Function&lt;Integer,Employee&gt; func1 = id -&gt; <span class=\"keyword\">new</span> <span class=\"title class_\">Employee</span>(id);</span><br><span class=\"line\">        <span class=\"type\">Employee</span> <span class=\"variable\">employee</span> <span class=\"operator\">=</span> func1.apply(<span class=\"number\">1001</span>);</span><br><span class=\"line\">        System.out.println(employee);</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;*******************&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        Function&lt;Integer,Employee&gt; func2 = Employee :: <span class=\"keyword\">new</span>;</span><br><span class=\"line\">        <span class=\"type\">Employee</span> <span class=\"variable\">employee1</span> <span class=\"operator\">=</span> func2.apply(<span class=\"number\">1002</span>);</span><br><span class=\"line\">        System.out.println(employee1);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//BiFunction中的R apply(T t,U u)</span></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test3</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        BiFunction&lt;Integer,String,Employee&gt; func1 = (id,name) -&gt; <span class=\"keyword\">new</span> <span class=\"title class_\">Employee</span>(id,name);</span><br><span class=\"line\">        System.out.println(func1.apply(<span class=\"number\">1001</span>,<span class=\"string\">&quot;Tom&quot;</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;*******************&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        BiFunction&lt;Integer,String,Employee&gt; func2 = Employee :: <span class=\"keyword\">new</span>;</span><br><span class=\"line\">        System.out.println(func2.apply(<span class=\"number\">1002</span>,<span class=\"string\">&quot;Tom&quot;</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//数组引用</span></span><br><span class=\"line\">    <span class=\"comment\">//Function中的R apply(T t)</span></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test4</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        Function&lt;Integer,String[]&gt; func1 = length -&gt; <span class=\"keyword\">new</span> <span class=\"title class_\">String</span>[length];</span><br><span class=\"line\">        String[] arr1 = func1.apply(<span class=\"number\">5</span>);</span><br><span class=\"line\">        System.out.println(Arrays.toString(arr1));</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;*******************&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        Function&lt;Integer,String[]&gt; func2 = String[] :: <span class=\"keyword\">new</span>;</span><br><span class=\"line\">        String[] arr2 = func2.apply(<span class=\"number\">10</span>);</span><br><span class=\"line\">        System.out.println(Arrays.toString(arr2));</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"强大的Stream-API\"><a href=\"#强大的Stream-API\" class=\"headerlink\" title=\"强大的Stream API\"></a>强大的Stream API</h1><h2 id=\"Stream-API说明\"><a href=\"#Stream-API说明\" class=\"headerlink\" title=\"Stream API说明\"></a>Stream API说明</h2><ul>\n<li><p>Java8中有两大最为重要的改变。第一个是 <strong>Lambda</strong> <strong>表达式</strong>；另外一个则是 <strong>Stream API</strong>。 </p>\n</li>\n<li><p>Stream API ( java.util.stream) 把真正的函数式编程风格引入到Java中。这是目前为止对Java类库最好的补充，因为Stream API可以极大提供Java程序员的生产力，让程序员写出高效率、干净、简洁的代码。</p>\n</li>\n<li><p>Stream 是 Java8 中处理集合的关键抽象概念，它可以指定你希望对集合进行的操作，可以执行非常复杂的查找、过滤和映射数据等操作。 <strong>使用Stream API 对集合数据进行操作，就类似于使用 SQL 执行的数据库查询。</strong>也可以使用 Stream API 来并行执行操作。简言之，Stream API 提供了一种高效且易于使用的处理数据的方式</p>\n</li>\n</ul>\n<h2 id=\"为什么要使用Stream-API\"><a href=\"#为什么要使用Stream-API\" class=\"headerlink\" title=\"为什么要使用Stream API\"></a>为什么要使用Stream API</h2><ul>\n<li><p>实际开发中，项目中多数数据源都来自于Mysql，Oracle等，很多一些复杂的数据获取可以直接在sql层面去解决。但现在数据源可以更多了，有MongDB，Radis等，而这些NoSQL的数据本身不支持一些复杂的数据计算，这个时候就需要Java层面去处理。 </p>\n</li>\n<li><p>Stream 和 Collection 集合的区别：Collection 是一种静态的内存数据结构，而 Stream 是有关计算的。前者是主要面向内存，存储在内存中，后者主要是面向 CPU，通过 CPU 实现计算。</p>\n</li>\n</ul>\n<h2 id=\"什么是Stream\"><a href=\"#什么是Stream\" class=\"headerlink\" title=\"什么是Stream\"></a>什么是Stream</h2><p>Stream到底是什么呢？</p>\n<p>是数据渠道，用于操作数据源（集合、数组等）所生成的元素序列。</p>\n<p><strong>“集合讲的是数据，Stream讲的是计算！”</strong></p>\n<p><strong>注意：</strong></p>\n<p>①Stream 自己不会存储元素。</p>\n<p>②Stream 不会改变源对象。相反，他们会返回一个持有结果的新Stream。 </p>\n<p>③Stream 操作是延迟执行的。这意味着他们会等到需要结果的时候才执行</p>\n<p><strong>Stream</strong> <strong>的操作三个步骤</strong></p>\n<p>1、创建Stream</p>\n<p>一个数据源（如：集合、数组），获取一个流</p>\n<p>2、中间操作</p>\n<p>一个中间操作链，对数据源的数据进行处理</p>\n<p>3、终止操作(终端操作) </p>\n<p>一旦执行终止操作，就执行中间操作链，才产生结果【也就是所谓的延迟执行】。之后，不会再被使用</p>\n<img src=\"https://npm.elemecdn.com/youthlql@1.0.8/Java_Basis/Java8_New_Features/0004.png\">\n\n\n\n\n\n<h2 id=\"创建Stream\"><a href=\"#创建Stream\" class=\"headerlink\" title=\"创建Stream\"></a>创建Stream</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">StreamAPITest</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//创建 Stream方式一：通过集合</span></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test1</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        List&lt;Employee&gt; employees = EmployeeData.getEmployees();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//        default Stream&lt;E&gt; stream() : 返回一个顺序流，顺序流等会中间操作拿数据的时候按顺序拿</span></span><br><span class=\"line\">        Stream&lt;Employee&gt; stream = employees.stream();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//        default Stream&lt;E&gt; parallelStream() : 返回一个并行流</span></span><br><span class=\"line\">        Stream&lt;Employee&gt; parallelStream = employees.parallelStream();</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//创建 Stream方式二：通过数组</span></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test2</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span>[] arr = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[]&#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>&#125;;</span><br><span class=\"line\">        <span class=\"comment\">//调用Arrays类的static &lt;T&gt; Stream&lt;T&gt; stream(T[] array): 返回一个流</span></span><br><span class=\"line\">        <span class=\"type\">IntStream</span> <span class=\"variable\">stream</span> <span class=\"operator\">=</span> Arrays.stream(arr);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">Employee</span> <span class=\"variable\">e1</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Employee</span>(<span class=\"number\">1001</span>,<span class=\"string\">&quot;Tom&quot;</span>);</span><br><span class=\"line\">        <span class=\"type\">Employee</span> <span class=\"variable\">e2</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Employee</span>(<span class=\"number\">1002</span>,<span class=\"string\">&quot;Jerry&quot;</span>);</span><br><span class=\"line\">        Employee[] arr1 = <span class=\"keyword\">new</span> <span class=\"title class_\">Employee</span>[]&#123;e1,e2&#125;;</span><br><span class=\"line\">        Stream&lt;Employee&gt; stream1 = Arrays.stream(arr1);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//创建 Stream方式三：通过Stream的of()，通过显示值创建一个流。它可以接收任意数量的参数</span></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test3</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        Stream&lt;Integer&gt; stream = Stream.of(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//创建 Stream方式四：创建无限流【用的少，了解下就行】</span></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test4</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//      迭代</span></span><br><span class=\"line\"><span class=\"comment\">//      public static&lt;T&gt; Stream&lt;T&gt; iterate(final T seed, final UnaryOperator&lt;T&gt; f)</span></span><br><span class=\"line\">        <span class=\"comment\">//遍历前10个偶数</span></span><br><span class=\"line\">        Stream.iterate(<span class=\"number\">0</span>, t -&gt; t + <span class=\"number\">2</span>).limit(<span class=\"number\">10</span>).forEach(System.out::println);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//      生成</span></span><br><span class=\"line\"><span class=\"comment\">//      public static&lt;T&gt; Stream&lt;T&gt; generate(Supplier&lt;T&gt; s)</span></span><br><span class=\"line\">        Stream.generate(Math::random).limit(<span class=\"number\">10</span>).forEach(System.out::println);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h2 id=\"中间操作\"><a href=\"#中间操作\" class=\"headerlink\" title=\"中间操作\"></a>中间操作</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 测试Stream的中间操作</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">StreamAPITest1</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//1-筛选与切片</span></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test1</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        List&lt;Employee&gt; list = EmployeeData.getEmployees();</span><br><span class=\"line\"><span class=\"comment\">//        filter(Predicate p)——过滤   接收 Lambda ， 从流中排除某些元素。</span></span><br><span class=\"line\">        Stream&lt;Employee&gt; stream = list.stream();</span><br><span class=\"line\">        <span class=\"comment\">//练习：查询员工表中薪资大于7000的员工信息</span></span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">         * List&lt;String&gt; filterStrs1 = filterString(list,s -&gt; s.contains(&quot;京&quot;));</span></span><br><span class=\"line\"><span class=\"comment\">         * 跟之前的这个lambda表达式代码是一个意思</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        stream.filter(e -&gt; e.getSalary() &gt; <span class=\"number\">7000</span>).forEach(System.out::println);</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println();</span><br><span class=\"line\"><span class=\"comment\">//        limit(n)——截断流，使其元素不超过给定数量。</span></span><br><span class=\"line\">        list.stream().limit(<span class=\"number\">3</span>).forEach(System.out::println);</span><br><span class=\"line\">        System.out.println();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">        skip(n) —— 跳过元素，返回一个扔掉了前 n 个元素的流。若流中元素不足 n 个，</span></span><br><span class=\"line\"><span class=\"comment\">        则返回一个空流。与 limit(n) 互补</span></span><br><span class=\"line\"><span class=\"comment\">        */</span></span><br><span class=\"line\">        list.stream().skip(<span class=\"number\">3</span>).forEach(System.out::println);</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println();</span><br><span class=\"line\"><span class=\"comment\">//        distinct()——筛选，通过流所生成元素的 hashCode() 和 equals() 去除重复元素</span></span><br><span class=\"line\"></span><br><span class=\"line\">        list.add(<span class=\"keyword\">new</span> <span class=\"title class_\">Employee</span>(<span class=\"number\">1010</span>,<span class=\"string\">&quot;刘强东&quot;</span>,<span class=\"number\">40</span>,<span class=\"number\">8000</span>));</span><br><span class=\"line\">        list.add(<span class=\"keyword\">new</span> <span class=\"title class_\">Employee</span>(<span class=\"number\">1010</span>,<span class=\"string\">&quot;刘强东&quot;</span>,<span class=\"number\">41</span>,<span class=\"number\">8000</span>));</span><br><span class=\"line\">        list.add(<span class=\"keyword\">new</span> <span class=\"title class_\">Employee</span>(<span class=\"number\">1010</span>,<span class=\"string\">&quot;刘强东&quot;</span>,<span class=\"number\">40</span>,<span class=\"number\">8000</span>));</span><br><span class=\"line\">        list.add(<span class=\"keyword\">new</span> <span class=\"title class_\">Employee</span>(<span class=\"number\">1010</span>,<span class=\"string\">&quot;刘强东&quot;</span>,<span class=\"number\">40</span>,<span class=\"number\">8000</span>));</span><br><span class=\"line\">        list.add(<span class=\"keyword\">new</span> <span class=\"title class_\">Employee</span>(<span class=\"number\">1010</span>,<span class=\"string\">&quot;刘强东&quot;</span>,<span class=\"number\">40</span>,<span class=\"number\">8000</span>));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//        System.out.println(list);</span></span><br><span class=\"line\"></span><br><span class=\"line\">        list.stream().distinct().forEach(System.out::println);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//映射</span></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test2</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">        map(Function f)——接收一个函数作为参数，将元素转换成其他形式或提取信息，该函数会被应</span></span><br><span class=\"line\"><span class=\"comment\">        用到每个元素上，并将其映射成一个新的元素。</span></span><br><span class=\"line\"><span class=\"comment\">        */</span></span><br><span class=\"line\">        List&lt;String&gt; list = Arrays.asList(<span class=\"string\">&quot;aa&quot;</span>, <span class=\"string\">&quot;bb&quot;</span>, <span class=\"string\">&quot;cc&quot;</span>, <span class=\"string\">&quot;dd&quot;</span>);</span><br><span class=\"line\">        list.stream().map(str -&gt; str.toUpperCase()).forEach(System.out::println);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//        练习1：获取员工姓名长度大于3的员工的姓名。</span></span><br><span class=\"line\">        List&lt;Employee&gt; employees = EmployeeData.getEmployees();</span><br><span class=\"line\">        Stream&lt;String&gt; namesStream = employees.stream().map(Employee::getName);</span><br><span class=\"line\">        namesStream.filter(name -&gt; name.length() &gt; <span class=\"number\">3</span>).forEach(System.out::println);</span><br><span class=\"line\">        System.out.println();</span><br><span class=\"line\">        <span class=\"comment\">//练习2：</span></span><br><span class=\"line\">        Stream&lt;Stream&lt;Character&gt;&gt; streamStream = list.stream().map(StreamAPITest1::fromStringToStream);</span><br><span class=\"line\">        <span class=\"comment\">//这个还需要两层遍历</span></span><br><span class=\"line\">        streamStream.forEach(s -&gt;&#123;</span><br><span class=\"line\">            s.forEach(System.out::println);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        System.out.println();</span><br><span class=\"line\">        <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">        flatMap(Function f)——接收一个函数作为参数，将流中的每个值都换成另一个流，然后把所有流连</span></span><br><span class=\"line\"><span class=\"comment\">        接成一个流。flatMap一层遍历即可拿到想要的结果</span></span><br><span class=\"line\"><span class=\"comment\">        */</span></span><br><span class=\"line\">        Stream&lt;Character&gt; characterStream = list.stream().flatMap(StreamAPITest1::fromStringToStream);</span><br><span class=\"line\">        characterStream.forEach(System.out::println);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//将字符串中的多个字符构成的集合转换为对应的Stream的实例</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Stream&lt;Character&gt; <span class=\"title function_\">fromStringToStream</span><span class=\"params\">(String str)</span>&#123;<span class=\"comment\">//aa</span></span><br><span class=\"line\">        ArrayList&lt;Character&gt; list = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(Character c : str.toCharArray())&#123;</span><br><span class=\"line\">            list.add(c);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> list.stream();</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//3-排序</span></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test4</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\"><span class=\"comment\">//        sorted()——自然排序</span></span><br><span class=\"line\">        List&lt;Integer&gt; list = Arrays.asList(<span class=\"number\">12</span>, <span class=\"number\">43</span>, <span class=\"number\">65</span>, <span class=\"number\">34</span>, <span class=\"number\">87</span>, <span class=\"number\">0</span>, -<span class=\"number\">98</span>, <span class=\"number\">7</span>);</span><br><span class=\"line\">        list.stream().sorted().forEach(System.out::println);</span><br><span class=\"line\">        <span class=\"comment\">//抛异常，原因:Employee没有实现Comparable接口</span></span><br><span class=\"line\"><span class=\"comment\">//        List&lt;Employee&gt; employees = EmployeeData.getEmployees();</span></span><br><span class=\"line\"><span class=\"comment\">//        employees.stream().sorted().forEach(System.out::println);</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//        sorted(Comparator com)——定制排序</span></span><br><span class=\"line\"></span><br><span class=\"line\">        List&lt;Employee&gt; employees = EmployeeData.getEmployees();</span><br><span class=\"line\">        employees.stream().sorted( (e1,e2) -&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">           <span class=\"type\">int</span> <span class=\"variable\">ageValue</span> <span class=\"operator\">=</span> Integer.compare(e1.getAge(),e2.getAge());</span><br><span class=\"line\">           <span class=\"keyword\">if</span>(ageValue != <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">               <span class=\"keyword\">return</span> ageValue;</span><br><span class=\"line\">           &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">               <span class=\"keyword\">return</span> -Double.compare(e1.getSalary(),e2.getSalary());</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;).forEach(System.out::println);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"终止操作\"><a href=\"#终止操作\" class=\"headerlink\" title=\"终止操作\"></a>终止操作</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 测试Stream的终止操作</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">StreamAPITest2</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//1-匹配与查找</span></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test1</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        List&lt;Employee&gt; employees = EmployeeData.getEmployees();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//        allMatch(Predicate p)——检查是否匹配所有元素。</span></span><br><span class=\"line\"><span class=\"comment\">//          练习：是否所有的员工的年龄都大于18</span></span><br><span class=\"line\">        <span class=\"type\">boolean</span> <span class=\"variable\">allMatch</span> <span class=\"operator\">=</span> employees.stream().allMatch(e -&gt; e.getAge() &gt; <span class=\"number\">18</span>);</span><br><span class=\"line\">        System.out.println(allMatch);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//        anyMatch(Predicate p)——检查是否至少匹配一个元素。</span></span><br><span class=\"line\"><span class=\"comment\">//         练习：是否存在员工的工资大于 10000</span></span><br><span class=\"line\">        <span class=\"type\">boolean</span> <span class=\"variable\">anyMatch</span> <span class=\"operator\">=</span> employees.stream().anyMatch(e -&gt; e.getSalary() &gt; <span class=\"number\">10000</span>);</span><br><span class=\"line\">        System.out.println(anyMatch);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//        noneMatch(Predicate p)——检查是否没有匹配的元素。</span></span><br><span class=\"line\"><span class=\"comment\">//          练习：是否存在员工姓“雷”</span></span><br><span class=\"line\">        <span class=\"type\">boolean</span> <span class=\"variable\">noneMatch</span> <span class=\"operator\">=</span> employees.stream().noneMatch(e -&gt; e.getName().startsWith(<span class=\"string\">&quot;雷&quot;</span>));</span><br><span class=\"line\">        System.out.println(noneMatch);</span><br><span class=\"line\"><span class=\"comment\">//        findFirst——返回第一个元素</span></span><br><span class=\"line\">        Optional&lt;Employee&gt; employee = employees.stream().findFirst();</span><br><span class=\"line\">        System.out.println(employee);</span><br><span class=\"line\"><span class=\"comment\">//        findAny——返回当前流中的任意元素</span></span><br><span class=\"line\">        Optional&lt;Employee&gt; employee1 = employees.parallelStream().findAny();</span><br><span class=\"line\">        System.out.println(employee1);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test2</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        List&lt;Employee&gt; employees = EmployeeData.getEmployees();</span><br><span class=\"line\">        <span class=\"comment\">// count——返回流中元素的总个数</span></span><br><span class=\"line\">        <span class=\"type\">long</span> <span class=\"variable\">count</span> <span class=\"operator\">=</span> employees.stream().filter(e -&gt; e.getSalary() &gt; <span class=\"number\">5000</span>).count();</span><br><span class=\"line\">        System.out.println(count);</span><br><span class=\"line\"><span class=\"comment\">//        max(Comparator c)——返回流中最大值</span></span><br><span class=\"line\"><span class=\"comment\">//        练习：返回最高的工资：</span></span><br><span class=\"line\">        Stream&lt;Double&gt; salaryStream = employees.stream().map(e -&gt; e.getSalary());</span><br><span class=\"line\">        Optional&lt;Double&gt; maxSalary = salaryStream.max(Double::compare);</span><br><span class=\"line\">        System.out.println(maxSalary);</span><br><span class=\"line\"><span class=\"comment\">//        min(Comparator c)——返回流中最小值</span></span><br><span class=\"line\"><span class=\"comment\">//        练习：返回最低工资的员工</span></span><br><span class=\"line\">        Optional&lt;Employee&gt; employee = employees.stream().min((e1, e2) -&gt; Double.compare(e1.getSalary(), e2.getSalary()));</span><br><span class=\"line\">        System.out.println(employee);</span><br><span class=\"line\">        System.out.println();</span><br><span class=\"line\"><span class=\"comment\">//        forEach(Consumer c)——内部迭代</span></span><br><span class=\"line\">        employees.stream().forEach(System.out::println);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//使用集合的遍历操作</span></span><br><span class=\"line\">        employees.forEach(System.out::println);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//2-归约</span></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test3</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\"><span class=\"comment\">//        reduce(T identity, BinaryOperator)——可以将流中元素反复结合起来，得到一个值。返回 T</span></span><br><span class=\"line\"><span class=\"comment\">//        练习1：计算1-10的自然数的和</span></span><br><span class=\"line\">        List&lt;Integer&gt; list = Arrays.asList(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">7</span>,<span class=\"number\">8</span>,<span class=\"number\">9</span>,<span class=\"number\">10</span>);</span><br><span class=\"line\">        <span class=\"type\">Integer</span> <span class=\"variable\">sum</span> <span class=\"operator\">=</span> list.stream().reduce(<span class=\"number\">0</span>, Integer::sum);</span><br><span class=\"line\">        System.out.println(sum);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//        reduce(BinaryOperator) ——可以将流中元素反复结合起来，得到一个值。返回 Optional&lt;T&gt;</span></span><br><span class=\"line\"><span class=\"comment\">//        练习2：计算公司所有员工工资的总和</span></span><br><span class=\"line\">        List&lt;Employee&gt; employees = EmployeeData.getEmployees();</span><br><span class=\"line\">        Stream&lt;Double&gt; salaryStream = employees.stream().map(Employee::getSalary);</span><br><span class=\"line\"><span class=\"comment\">//        Optional&lt;Double&gt; sumMoney = salaryStream.reduce(Double::sum);</span></span><br><span class=\"line\">        Optional&lt;Double&gt; sumMoney = salaryStream.reduce((d1,d2) -&gt; d1 + d2);</span><br><span class=\"line\">        System.out.println(sumMoney.get());</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//3-收集</span></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test4</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\"><span class=\"comment\">// collect(Collector c)——将流转换为其他形式。接收一个 Collector接口的实现，用于给Stream中元素做汇总的方法</span></span><br><span class=\"line\"><span class=\"comment\">//        练习1：查找工资大于6000的员工，结果返回为一个List或Set</span></span><br><span class=\"line\"></span><br><span class=\"line\">        List&lt;Employee&gt; employees = EmployeeData.getEmployees();</span><br><span class=\"line\">        List&lt;Employee&gt; employeeList = employees.stream().filter(e -&gt; e.getSalary() &gt; <span class=\"number\">6000</span>).collect(Collectors.toList());</span><br><span class=\"line\"></span><br><span class=\"line\">        employeeList.forEach(System.out::println);</span><br><span class=\"line\">        System.out.println();</span><br><span class=\"line\">        Set&lt;Employee&gt; employeeSet = employees.stream().filter(e -&gt; e.getSalary() &gt; <span class=\"number\">6000</span>).collect(Collectors.toSet());</span><br><span class=\"line\"></span><br><span class=\"line\">        employeeSet.forEach(System.out::println);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"Optional类\"><a href=\"#Optional类\" class=\"headerlink\" title=\"Optional类\"></a>Optional类</h1><h2 id=\"什么是Optional？\"><a href=\"#什么是Optional？\" class=\"headerlink\" title=\"什么是Optional？\"></a>什么是Optional？</h2><ul>\n<li><p>到目前为止，臭名昭著的空指针异常是导致Java应用程序失败的最常见原因。以前，为了解决空指针异常，Google公司著名的Guava项目引入了Optional类，Guava通过使用检查空值的方式来防止代码污染，它鼓励程序员写更干净的代码。受到Google Guava的启发，Optional类已经成为Java 8类库的一部分。</p>\n</li>\n<li><p>Optional<T> 类(java.util.Optional) 是一个容器类，它可以保存类型T的值，代表这个值存在。或者仅仅保存null，表示这个值不存在。原来用 null 表示一个值不存在，现在 Optional 可以更好的表达这个概念。并且可以避免空指针异常。 </p>\n</li>\n<li><p>Optional类的Javadoc描述如下：这是一个可以为null的容器对象。如果值存在则isPresent()方法会返回true，调用get()方法会返回该对象。</p>\n</li>\n</ul>\n<h2 id=\"常用API\"><a href=\"#常用API\" class=\"headerlink\" title=\"常用API\"></a>常用API</h2><img src=\"https://npm.elemecdn.com/youthlql@1.0.8/Java_Basis/Java8_New_Features/0005.png\">\n\n\n\n\n\n<h2 id=\"举例\"><a href=\"#举例\" class=\"headerlink\" title=\"举例\"></a>举例</h2><p>首先准备两个类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Boy</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Girl girl;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">toString</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;Boy&#123;&quot;</span> +</span><br><span class=\"line\">                <span class=\"string\">&quot;girl=&quot;</span> + girl +</span><br><span class=\"line\">                <span class=\"string\">&#x27;&#125;&#x27;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Girl <span class=\"title function_\">getGirl</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> girl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setGirl</span><span class=\"params\">(Girl girl)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.girl = girl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">Boy</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">Boy</span><span class=\"params\">(Girl girl)</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">this</span>.girl = girl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Girl</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">toString</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;Girl&#123;&quot;</span> +</span><br><span class=\"line\">                <span class=\"string\">&quot;name=&#x27;&quot;</span> + name + <span class=\"string\">&#x27;\\&#x27;&#x27;</span> +</span><br><span class=\"line\">                <span class=\"string\">&#x27;&#125;&#x27;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">getName</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setName</span><span class=\"params\">(String name)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.name = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">Girl</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">Girl</span><span class=\"params\">(String name)</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">this</span>.name = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>这里只是简单的测试两个API</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Optional类：为了在程序中避免出现空指针异常而创建的。</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * 常用的方法：ofNullable(T t)</span></span><br><span class=\"line\"><span class=\"comment\"> *            orElse(T t)</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">OptionalTest</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">Optional.of(T t) : 创建一个 Optional 实例，t必须非空；</span></span><br><span class=\"line\"><span class=\"comment\">Optional.empty() : 创建一个空的 Optional 实例</span></span><br><span class=\"line\"><span class=\"comment\">Optional.ofNullable(T t)：t可以为null</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test1</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        <span class=\"type\">Girl</span> <span class=\"variable\">girl</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Girl</span>();</span><br><span class=\"line\"><span class=\"comment\">//        girl = null;</span></span><br><span class=\"line\">        <span class=\"comment\">//of(T t):保证t是非空的</span></span><br><span class=\"line\">        Optional&lt;Girl&gt; optionalGirl = Optional.of(girl);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test2</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        <span class=\"type\">Girl</span> <span class=\"variable\">girl</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Girl</span>();</span><br><span class=\"line\"><span class=\"comment\">//        girl = null;</span></span><br><span class=\"line\">        <span class=\"comment\">//ofNullable(T t)：t可以为null</span></span><br><span class=\"line\">        Optional&lt;Girl&gt; optionalGirl = Optional.ofNullable(girl);</span><br><span class=\"line\">        System.out.println(optionalGirl);</span><br><span class=\"line\">        <span class=\"comment\">//orElse(T t1):如果单前的Optional内部封装的t是非空的，则返回内部的t.</span></span><br><span class=\"line\">        <span class=\"comment\">//如果内部的t是空的，则返回orElse()方法中的参数t1.</span></span><br><span class=\"line\">        <span class=\"type\">Girl</span> <span class=\"variable\">girl1</span> <span class=\"operator\">=</span> optionalGirl.orElse(<span class=\"keyword\">new</span> <span class=\"title class_\">Girl</span>(<span class=\"string\">&quot;赵丽颖&quot;</span>));</span><br><span class=\"line\">        System.out.println(girl1);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>实际场景使用</strong></p>\n<p>可能出现空指针的例子：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> String <span class=\"title function_\">getGirlName</span><span class=\"params\">(Boy boy)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> boy.getGirl().getName();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test3</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        <span class=\"type\">Boy</span> <span class=\"variable\">boy</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Boy</span>();</span><br><span class=\"line\">        boy = <span class=\"literal\">null</span>;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">girlName</span> <span class=\"operator\">=</span> getGirlName(boy);</span><br><span class=\"line\">        System.out.println(girlName);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>结果：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">java.lang.NullPointerException</span><br><span class=\"line\">\tat com.atguigu.java4.OptionalTest.getGirlName(OptionalTest.java:47)</span><br><span class=\"line\">\tat com.atguigu.java4.OptionalTest.test3(OptionalTest.java:54)</span><br><span class=\"line\">...</span><br><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\">Process finished with exit code -1</span><br></pre></td></tr></table></figure>\n\n\n\n<p>没有Optional的解决办法，但是如果调用层数过多，就得一层一层判断是否为null，写起来很麻烦。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//优化以后的getGirlName():</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">getGirlName1</span><span class=\"params\">(Boy boy)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(boy != <span class=\"literal\">null</span>)&#123;</span><br><span class=\"line\">            <span class=\"type\">Girl</span> <span class=\"variable\">girl</span> <span class=\"operator\">=</span> boy.getGirl();</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(girl != <span class=\"literal\">null</span>)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> girl.getName();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test4</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        <span class=\"type\">Boy</span> <span class=\"variable\">boy</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Boy</span>();</span><br><span class=\"line\">        boy = <span class=\"literal\">null</span>;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">girlName</span> <span class=\"operator\">=</span> getGirlName1(boy);</span><br><span class=\"line\">        System.out.println(girlName);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>使用Optional解决问题：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//使用Optional类的getGirlName():</span></span><br><span class=\"line\">   <span class=\"keyword\">public</span> String <span class=\"title function_\">getGirlName2</span><span class=\"params\">(Boy boy)</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">       Optional&lt;Boy&gt; boyOptional = Optional.ofNullable(boy);</span><br><span class=\"line\">       <span class=\"comment\">//此时的boy1一定非空</span></span><br><span class=\"line\">       <span class=\"type\">Boy</span> <span class=\"variable\">boy1</span> <span class=\"operator\">=</span> boyOptional.orElse(<span class=\"keyword\">new</span> <span class=\"title class_\">Boy</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">Girl</span>(<span class=\"string\">&quot;迪丽热巴&quot;</span>)));</span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"type\">Girl</span> <span class=\"variable\">girl</span> <span class=\"operator\">=</span> boy1.getGirl();</span><br><span class=\"line\"></span><br><span class=\"line\">       Optional&lt;Girl&gt; girlOptional = Optional.ofNullable(girl);</span><br><span class=\"line\">       <span class=\"comment\">//girl1一定非空</span></span><br><span class=\"line\">       <span class=\"type\">Girl</span> <span class=\"variable\">girl1</span> <span class=\"operator\">=</span> girlOptional.orElse(<span class=\"keyword\">new</span> <span class=\"title class_\">Girl</span>(<span class=\"string\">&quot;古力娜扎&quot;</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"keyword\">return</span> girl1.getName();</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"meta\">@Test</span></span><br><span class=\"line\">   <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test5</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">       <span class=\"type\">Boy</span> <span class=\"variable\">boy</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">       boy = <span class=\"keyword\">new</span> <span class=\"title class_\">Boy</span>();</span><br><span class=\"line\">       boy = <span class=\"keyword\">new</span> <span class=\"title class_\">Boy</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">Girl</span>(<span class=\"string\">&quot;苍老师&quot;</span>));</span><br><span class=\"line\">       <span class=\"type\">String</span> <span class=\"variable\">girlName</span> <span class=\"operator\">=</span> getGirlName2(boy);</span><br><span class=\"line\">       System.out.println(girlName);</span><br><span class=\"line\"></span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n\n<p>这种是绝对不会出现空指针的。</p>\n<h1 id=\"接口的增强\"><a href=\"#接口的增强\" class=\"headerlink\" title=\"接口的增强\"></a>接口的增强</h1><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JDK7及以前：只能定义全局常量和抽象方法</span><br><span class=\"line\">  &gt;全局常量：public static final的.但是书写时，可以省略不写</span><br><span class=\"line\">  &gt;抽象方法：public abstract的</span><br><span class=\"line\">  \t\t\t</span><br><span class=\"line\">JDK8：除了定义全局常量和抽象方法之外，还可以定义静态方法、默认方法</span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * JDK8：除了定义全局常量和抽象方法之外，还可以定义静态方法、默认方法</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">CompareA</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//静态方法</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">method1</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;CompareA:北京&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//默认方法</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">default</span> <span class=\"keyword\">void</span> <span class=\"title function_\">method2</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;CompareA：上海&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//接口中的public 可以省略，自动就是public</span></span><br><span class=\"line\">    <span class=\"keyword\">default</span> <span class=\"keyword\">void</span> <span class=\"title function_\">method3</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;CompareA：上海&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">SuperClass</span> &#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">method3</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;SuperClass:北京&quot;</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">CompareB</span> &#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">default</span> <span class=\"keyword\">void</span> <span class=\"title function_\">method3</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;CompareB：上海&quot;</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">SubClassTest</span> &#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"type\">SubClass</span> <span class=\"variable\">s</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">SubClass</span>();</span><br><span class=\"line\">\t\t</span><br><span class=\"line\"><span class=\"comment\">//\t\ts.method1();</span></span><br><span class=\"line\"><span class=\"comment\">//\t\tSubClass.method1();</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//知识点1：接口中定义的静态方法，只能通过接口来调用。实现类用不了</span></span><br><span class=\"line\">\t\tCompareA.method1();</span><br><span class=\"line\">\t\t<span class=\"comment\">//知识点2：通过实现类的对象，可以调用接口中的默认方法。</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//如果实现类重写了接口中的默认方法，调用时，仍然调用的是重写以后的方法</span></span><br><span class=\"line\">\t\ts.method2();</span><br><span class=\"line\">\t\t<span class=\"comment\">//知识点3：如果子类(或实现类)继承的父类和实现的接口中声明了同名同参数的默认方法，</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//那么子类在没有重写此方法的情况下，默认调用的是父类中的同名同参数的方法。--&gt;类优先原则</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//知识点4：如果实现类实现了多个接口，而这多个接口中定义了同名同参数的默认方法，</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//那么在实现类没有重写此方法的情况下，报错。--&gt;接口冲突。</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//这就需要我们必须在实现类中重写此方法</span></span><br><span class=\"line\">\t\ts.method3();</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">SubClass</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">SuperClass</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">CompareA</span>,CompareB&#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">method2</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;SubClass：上海&quot;</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">method3</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;SubClass：深圳&quot;</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">//知识点5：如何在子类(或实现类)的方法中调用父类、接口中被重写的方法</span></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">myMethod</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">\t\tmethod3();<span class=\"comment\">//调用自己定义的重写的方法</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">super</span>.method3();<span class=\"comment\">//调用的是父类中声明的</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//调用接口中的默认方法</span></span><br><span class=\"line\">\t\tCompareA.<span class=\"built_in\">super</span>.method3();</span><br><span class=\"line\">\t\tCompareB.<span class=\"built_in\">super</span>.method3();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"CompletableFuture的使用","date":"2023-08-10T04:17:39.000Z","cover":"../img/Java/Thread/Thread.svg","_content":"\n> CompletableFuture类提供了非常强大的Future的扩展功能，可以帮助我们简化异步编程的复杂性，提供了函数式编程的能力，可以通过回调的方式处理计算结果，并且提供了转换和组合CompletableFuture的方法。\n\n# 总结\n\n<table>\n    <tr>\n        <th>分类</th>\n        <th>方法名</th>\n        <th>描述</th>\n    </tr>\n    <tr>\n        <th rowspan=\"2\">创建异步任务</th>\n        <td><code>runAsync</code></td>\n        <td>不支持返回值</td>\n    </tr>\n    <tr>\n        <td><code>supplyAsync</code></td>\n        <td>支持返回值</td>\n    </tr>\n    <tr>\n        <th rowspan=\"6\">创建异步任务</th>\n        <td><code>thenRun</code>、<code>thenRunAsync</code></td>\n        <td>不接参数、无返回值</td>\n    </tr>\n    <tr>\n        <td><code>thenAccept</code>、<code>thenAcceptAsync</code></td>\n        <td>接返回值、无返回值</td>\n    </tr>\n    <tr>\n        <td><code>thenApply</code>、<code>thenApplyAsync</code></td>\n        <td>接返回值、有返回值</td>\n    </tr>\n    <tr>\n        <td><code>exceptionally</code>、<code>exceptionallyAsync</code></td>\n        <td>接异常、有返回值</td>\n    </tr>\n    <tr>\n        <td><code>whenComplete</code>、<code>whenCompleteAsync</code></td>\n        <td>接返回值和异常、无返回值</td>\n    </tr>\n    <tr>\n        <td><code>handle</code>、<code>handleAsync</code></td>\n        <td>接返回值和异常、有返回值</td>\n    </tr>\n    <tr>\n        <th rowspan=\"7\">两个任务组合</th>\n        <td><code>thenCompose</code>、<code>thenComposeAsync</code></td>\n        <td>任务转化</td>\n    </tr>\n    <tr>\n        <td><code>thenCombine</code>、<code>thenCombineAsync</code></td>\n        <td>“且”组合、接返回值、有返回值</td>\n    </tr>\n    <tr>\n        <td><code>thenAcceptBoth</code>、<code>thenAcceptBothAsync</code></td>\n        <td>“且”组合、接返回值、无返回值</td>\n    </tr>\n    <tr>\n        <td><code>runAfterBoth</code>、<code>runAfterBothAsync</code></td>\n        <td>“且”组合、不接参数、无返回值</td>\n    </tr>\n    <tr>\n        <td><code>applyToEither</code>、<code>applyToEitherAsync</code></td>\n        <td>“或”组合、接返回值、有返回值</td>\n    </tr>\n    <tr>\n        <td><code>acceptEither</code>、<code>acceptEitherAsync</code></td>\n        <td>“或”组合、接返回值、无返回值</td>\n    </tr>\n    <tr>\n        <td><code>runAfterEither</code>、<code>runAfterEitherAsync</code></td>\n        <td>“或”组合、不接参数、无返回值</td>\n    </tr>\n    <tr>\n        <th rowspan=\"2\">多个任务组合</th>\n        <td><code>anyOf</code></td>\n        <td>“任意一个”组合</td>\n    </tr>\n    <tr>\n        <td><code>allOf</code></td>\n        <td>“所有”组合</td>\n    </tr>\n</table>\n\n> 在CompletableFuture中如果使用没有指定线程池的方法，则会使用`ForkJoinPool.commonPool()`作为它的线程池执行异步代码。\n\n# 创建异步任务\n\n### 不支持返回值\n\n- 方法签名\n  ```java\n  // 使用默认线程池中的线程\n  public static CompletableFuture<Void> runAsync(Runnable runnable);\n  // 使用自定义线程池中的线程\n  public static CompletableFuture<Void> runAsync(Runnable runnable, Executor executor); \n  ```\n- 示例代码\n  ```java\n  CompletableFuture.runAsync(() -> {\n      // TODO 执行任务\n  });\n  ```\n\n### 支持返回值\n\n- 方法签名\n  ```java\n  // 使用默认线程池中的线程\n  public static <U> CompletableFuture<U> supplyAsync(Supplier<U> supplier);\n  // 使用自定义线程池中的线程\n  public static <U> CompletableFuture<U> supplyAsync(Supplier<U> supplier, Executor executor); \n  ```\n\n- 示例代码\n  ```java\n  CompletableFuture.supplyAsync(() -> {\n      // TODO 执行任务\n      return null;\n  });\n    ```\n\n# 任务完成时回调方法\n\n当CompletableFuture任务执行完成或者抛出异常的时候，可以执行特定的回调方法。\n\n### 不接参数、无返回值\n\n> 前一个任务执行完成后执行；任务之间**无参数传递**，回调方法**无返回值**\n\n- 方法签名\n  ```java\n  // 使用调用它的线程上运行（一般是主线程）\n  public CompletableFuture<Void> thenRun(Runnable action);\n  // 使用默认线程池中的线程\n  public CompletableFuture<Void> thenRunAsync(Runnable action);\n  // 使用自定义线程池中的线程\n  public CompletableFuture<Void> thenRunAsync(Runnable action, Executor executor);\n  ```\n- 示例代码\n  ```java\n  CompletableFuture.runAsync(() -> {\n  }).thenRun(() -> {\n      // TODO 执行任务\n  });\n  ```\n\n### 接返回值、无返回值\n\n> 前一个任务执行完成后执行；前一个任务会将执行结果**作为参数**，传递到回调方法中，回调方法**无返回值**\n\n- 方法签名\n  ```java\n  // 使用调用它的线程上运行（一般是主线程）\n  public CompletableFuture<Void> thenAccept(Consumer<? super T> action);\n  // 使用默认线程池中的线程\n  public CompletableFuture<Void> thenAcceptAsync(Consumer<? super T> action);\n  // 使用自定义线程池中的线程\n  public CompletableFuture<Void> thenAcceptAsync(Consumer<? super T> action, Executor executor);\n  ```\n- 示例代码\n  ```java\n  CompletableFuture.supplyAsync(() -> {\n      return \"Result\";\n  }).thenAccept((result) -> {\n      // TODO 执行任务\n  });\n  ```\n\n### 接返回值、有返回值\n\n> 前一个任务执行完成后执行；前一个任务会将执行结果**作为参数**，传递到回调方法中，并且会调方法**有返回值**\n\n- 方法签名\n  ```java\n  // 使用调用它的线程上运行（一般是主线程）\n  public <U> CompletableFuture<U> thenApply(Function<? super T,? extends U> fn);\n  // 使用默认线程池中的线程\n  public <U> CompletableFuture<U> thenApplyAsync(Function<? super T,? extends U> fn);\n  // 使用自定义线程池中的线程\n  public <U> CompletableFuture<U> thenApplyAsync(Function<? super T,? extends U> fn, Executor executor);\n  ```\n- 示例代码\n  ```java\n  CompletableFuture.supplyAsync(() -> {\n      return \"Result_1\";\n  }).thenApply(() -> {\n      // TODO 执行任务\n      return \"Result_2\";\n  });\n  ```\n\n### 接异常、有返回值\n\n> 某个任务执行异常时执行；异常任务抛出的异常**作为参数**，传递到回调方法中，并且会调方法**有返回值**\n\n- 方法签名\n  ```java\n  // 使用调用它的线程上运行（一般是主线程）\n  public CompletableFuture<T> exceptionally(Function<Throwable, ? extends T> fn);\n  // 使用默认线程池中的线程\n  public CompletableFuture<T> exceptionallyAsync(Function<Throwable, ? extends T> fn);\n  // 使用自定义线程池中的线程\n  public CompletableFuture<T> exceptionallyAsync(Function<Throwable, ? extends T> fn, Executor executor);\n  ```\n- 示例代码\n  ```java\n  CompletableFuture.runAsync(() -> {\n      throw new RuntimeException();\n  }).exceptionally((exception) -> {\n      // TODO 处理异常\n      return \"ERROR!\";\n  });\n  ```\n\n### 接返回值和异常、无返回值\n\n> 前一个任务执行完成或出现异常时执行；前一个任务会将结果或抛出的异常**作为参数**，传递到回调方法中，回调方法**无返回值**\n\n- 方法签名\n  ```java\n  // 使用调用它的线程上运行（一般是主线程）\n  public CompletableFuture<T> whenComplete(BiConsumer<? super T, ? super Throwable> action);\n  // 使用默认线程池中的线程\n  public CompletableFuture<T> whenCompleteAsync(BiConsumer<? super T, ? super Throwable> action);\n  // 使用自定义线程池中的线程\n  public CompletableFuture<T> whenCompleteAsync(BiConsumer<? super T, ? super Throwable> action, Executor executor);\n  ```\n- 示例代码\n  ```java\n  CompletableFuture.supplyAsync(() -> {\n      throw new RuntimeException();\n  }).whenCompleteAsync((result, exception) -> {\n      if (exception != null) {\n          // TODO 处理异常\n      } else {\n          // TODO 执行任务\n      }\n  });\n  ```\n\n### 接返回值和异常、有返回值\n\n> 前一个任务执行完成后执行；前一个任务会将结果或抛出的异常**作为参数**，传递到回调方法中，回调方法**有返回值**\n\n- 方法签名\n  ```java\n  // 使用调用它的线程上运行（一般是主线程）\n  public <U> CompletableFuture<U> handle(BiFunction<? super T, Throwable, ? extends U> fn);\n  // 使用默认线程池中的线程\n  public <U> CompletableFuture<U> handleAsync(BiFunction<? super T, Throwable, ? extends U> fn);\n  // 使用自定义线程池中的线程\n  public <U> CompletableFuture<U> handleAsync(BiFunction<? super T, Throwable, ? extends U> fn, Executor executor);\n  ```\n- 示例代码\n  ```java\n  CompletableFuture.supplyAsync(() -> {\n      throw new RuntimeException();\n  }).handleAsync((result, exception) -> {\n      if (exception != null) {\n          // TODO 处理异常\n          return \"ERROR!\";\n      } else {\n          // 执行任务\n          return \"SUCCESS!\";\n      }\n  });\n  ```\n\n# 两个任务组合\n\n### 任务转化\n\n> 将前一个任务的执行结果**作为参数**进行处理，处理后**返回一个新的任务**\n\n- 方法签名\n  ```java\n  // 使用调用它的线程上运行（一般是主线程）\n  public <U> CompletableFuture<U> thenCompose(Function<? super T, ? extends CompletionStage<U>> fn);\n  // 使用默认线程池中的线程\n  public <U> CompletableFuture<U> thenComposeAsync(Function<? super T, ? extends CompletionStage<U>> fn);\n  // 使用自定义线程池中的线程\n  public <U> CompletableFuture<U> thenComposeAsync(Function<? super T, ? extends CompletionStage<U>> fn, Executor executor);\n  ```\n- 示例代码\n  ```java\n  CompletableFuture<String> task = CompletableFuture.supplyAsync(() -> {\n      return \"任务一的结果\";\n  });\n  \n  CompletableFuture<String> stringCompletableFuture = CompletableFuture.supplyAsync(() -> {\n      return \"任务二的结果\";\n  }).thenComposeAsync((result) -> {\n      // TODO 执行任务\n      return task;\n  });\n  ```\n\n### “且”组合、接返回值、有返回值\n\n> 将两个任务组合，当两个任务都正常执行完了，将两个任务的结果作为参数，传递到回调方法中，回调方法有返回值\n\n- 方法签名\n  ```java\n  // 使用调用它的线程上运行（一般是主线程）\n  public <U,V> CompletableFuture<V> thenCombine(CompletionStage<? extends U> other, BiFunction<? super T,? super U,? extends V> fn);\n  // 使用默认线程池中的线程\n  public <U,V> CompletableFuture<V> thenCombineAsync(CompletionStage<? extends U> other, BiFunction<? super T,? super U,? extends V> fn);\n  // 使用自定义线程池中的线程\n  public <U,V> CompletableFuture<V> thenCombineAsync(CompletionStage<? extends U> other, BiFunction<? super T,? super U,? extends V> fn, Executor executor);\n  ```\n- 示例代码\n  ```java\n  CompletableFuture.supplyAsync(() -> {\n      // TODO 任务一\n      return \"任务一的结果\";\n  }).thenCombineAsync(CompletableFuture.supplyAsync(() -> {\n      // TODO 任务二\n      return \"任务二的结果\";\n  }), (result1, result2) -> {\n      // 任务一和任务二都完成时执行的回调方法\n      return null;\n  });\n  ```\n\n### “且”组合、接返回值、无返回值\n\n> 将两个任务组合，当两个任务都正常执行完了，将两个任务的结果作为参数，传递到回调方法中，回调方法无返回值\n\n- 方法签名\n  ```java\n  // 使用调用它的线程上运行（一般是主线程）\n  public <U> CompletableFuture<Void> thenAcceptBoth(CompletionStage<? extends U> other, BiConsumer<? super T, ? super U> action);\n  // 使用默认线程池中的线程\n  public <U> CompletableFuture<Void> thenAcceptBothAsync(CompletionStage<? extends U> other, BiConsumer<? super T, ? super U> action);\n  // 使用自定义线程池中的线程\n  public <U> CompletableFuture<Void> thenAcceptBothAsync(CompletionStage<? extends U> other, BiConsumer<? super T, ? super U> action, Executor executor);\n  ```\n- 示例代码\n  ```java\n  CompletableFuture.supplyAsync(() -> {\n      // TODO 任务一\n      return \"任务一的结果\";\n  }).thenAcceptBothAsync(CompletableFuture.supplyAsync(() -> {\n      // TODO 任务二\n      return \"任务二的结果\";\n  }), (result1, result2) -> {\n      // TODO 任务一和任务二都完成时执行的回调方法\n  });\n  ```\n\n### “且”组合、不接参数、无返回值\n\n> 将两个任务组合，当两个任务都正常执行完了，执行回调方法，回调方法无返回值\n\n- 方法签名\n  ```java\n  // 使用调用它的线程上运行（一般是主线程）\n  public CompletableFuture<Void> runAfterBoth(CompletionStage<?> other, Runnable action);\n  // 使用默认线程池中的线程\n  public CompletableFuture<Void> runAfterBothAsync(CompletionStage<?> other, Runnable action);\n  // 使用自定义线程池中的线程\n  public CompletableFuture<Void> runAfterBothAsync(CompletionStage<?> other, Runnable action, Executor executor);\n  ```\n- 示例代码\n  ```java\n  CompletableFuture.supplyAsync(() -> {\n      // TODO 任务一\n      return \"任务一的结果\";\n  }).runAfterBothAsync(CompletableFuture.supplyAsync(() -> {\n      // TODO 任务二\n      return \"任务二的结果\";\n  }), () -> {\n      // TODO 任务一和任务二都完成时执行的回调方法\n  });\n  ```\n\n### “或”组合、接返回值、有返回值\n\n> 将两个任务组合，其中任意一个任务执行完成，将该任务的结果作为参数，传递到回调方法中，回调方法有返回值\n\n- 方法签名\n  ```java\n  // 使用调用它的线程上运行（一般是主线程）\n  public <U> CompletableFuture<U> applyToEither(CompletionStage<? extends T> other, Function<? super T, U> fn);\n  // 使用默认线程池中的线程\n  public <U> CompletableFuture<U> applyToEitherAsync(CompletionStage<? extends T> other, Function<? super T, U> fn);\n  // 使用自定义线程池中的线程\n  public <U> CompletableFuture<U> applyToEitherAsync(CompletionStage<? extends T> other, Function<? super T, U> fn, Executor executor);\n  ```\n- 示例代码\n  ```java\n  CompletableFuture.supplyAsync(() -> {\n      // TODO 任务一\n      return \"任务一的结果\";\n  }).applyToEitherAsync(CompletableFuture.supplyAsync(() -> {\n      // TODO 任务二\n      return \"任务二的结果\";\n  }), (result) -> {\n      // TODO 任务一和任务二任意一个执行完成时执行的回调方法\n      return \"SUCCESS\";\n  });\n  ```\n\n### “或”组合、接返回值、无返回值\n\n> 将两个任务组合，其中任意一个任务执行完成，将该任务的结果作为参数，传递到回调方法中，回调方法无返回值\n\n- 方法签名\n  ```java\n  // 使用调用它的线程上运行（一般是主线程）\n  public CompletableFuture<Void> acceptEither(CompletionStage<? extends T> other, Consumer<? super T> action);\n  // 使用默认线程池中的线程\n  public CompletableFuture<Void> acceptEitherAsync(CompletionStage<? extends T> other, Consumer<? super T> action);\n  // 使用自定义线程池中的线程\n  public CompletableFuture<Void> acceptEitherAsync(CompletionStage<? extends T> other, Consumer<? super T> action, Executor executor);\n  ```\n- 示例代码\n  ```java\n  CompletableFuture.supplyAsync(() -> {\n      // TODO 任务一\n      try {\n          Thread.sleep(10);\n      } catch (InterruptedException e) {\n          throw new RuntimeException(e);\n      }\n      return \"任务一的结果\";\n  }).acceptEitherAsync(CompletableFuture.supplyAsync(() -> {\n      // TODO 任务二\n      return \"任务二的结果\";\n  }), (result) -> {\n      // TODO 任务一和任务二任意一个执行完成时执行的回调方法\n  });\n  ```\n\n### “或”组合、不接参数、无返回值\n\n> 将两个任务组合，其中任意一个任务执行完成，执行回调方法，回调方法无返回值\n\n- 方法签名\n  ```java\n  // 使用调用它的线程上运行（一般是主线程）\n  public CompletableFuture<Void> runAfterEither(CompletionStage<?> other, Runnable action);\n  // 使用默认线程池中的线程\n  public CompletableFuture<Void> runAfterEitherAsync(CompletionStage<?> other, Runnable action);\n  // 使用自定义线程池中的线程\n  public CompletableFuture<Void> runAfterEitherAsync(CompletionStage<?> other, Runnable action, Executor executor);\n  ```\n- 示例代码\n  ```java\n  CompletableFuture.supplyAsync(() -> {\n      // TODO 任务一\n      try {\n          Thread.sleep(10);\n      } catch (InterruptedException e) {\n          throw new RuntimeException(e);\n      }\n      return \"任务一的结果\";\n  }).runAfterEitherAsync(CompletableFuture.supplyAsync(() -> {\n      // TODO 任务二\n      return \"任务二的结果\";\n  }), () -> {\n      // TODO 任务一和任务二任意一个执行完成时执行的回调方法\n  });\n  ```\n\n# 多个任务组合\n\n### “任意一个”组合\n\n> 将多个任务组合，其中任意一个任务执行完成即可拿到该任务的执行结果（执行结果为Object类型），或执行接下来的任务\n\n- 方法签名\n  ```java\n  public static CompletableFuture<Object> anyOf(CompletableFuture<?>... cfs);\n  ```\n- 示例代码\n  ```java\n  CompletableFuture<String> task1 = CompletableFuture.supplyAsync(() -> {\n      return \"任务一的结果\";\n  });\n  \n  CompletableFuture<String> task2 = CompletableFuture.supplyAsync(() -> {\n      return \"任务二的结果\";\n  });\n  \n  Object result = CompletableFuture.anyOf(task1, task2).join();\n  ```\n\n### “所有”组合\n\n> 将多个任务组合，当所有任务都执行完成后执行接下来的任务\n\n- 方法签名\n  ```java\n  public static CompletableFuture<Void> allOf(CompletableFuture<?>... cfs);\n  ```\n- 示例代码\n  ```java\n  CompletableFuture<String> task1 = CompletableFuture.supplyAsync(() -> {\n      return \"任务一的结果\";\n  });\n  \n  CompletableFuture<String> task2 = CompletableFuture.supplyAsync(() -> {\n      return \"任务二的结果\";\n  });\n  \n  Object join = CompletableFuture.allOf(task1, task2).join();\n  ```\n","source":"_posts/2023-08-10-CompletableFuture的使用.md","raw":"---\ntitle: CompletableFuture的使用\ndate: 2023-08-10 12:17:39\ncover: ../img/Java/Thread/Thread.svg\ntags: [ Java,并发,CompletableFuture ]\ncategories:\n  - Java\n---\n\n> CompletableFuture类提供了非常强大的Future的扩展功能，可以帮助我们简化异步编程的复杂性，提供了函数式编程的能力，可以通过回调的方式处理计算结果，并且提供了转换和组合CompletableFuture的方法。\n\n# 总结\n\n<table>\n    <tr>\n        <th>分类</th>\n        <th>方法名</th>\n        <th>描述</th>\n    </tr>\n    <tr>\n        <th rowspan=\"2\">创建异步任务</th>\n        <td><code>runAsync</code></td>\n        <td>不支持返回值</td>\n    </tr>\n    <tr>\n        <td><code>supplyAsync</code></td>\n        <td>支持返回值</td>\n    </tr>\n    <tr>\n        <th rowspan=\"6\">创建异步任务</th>\n        <td><code>thenRun</code>、<code>thenRunAsync</code></td>\n        <td>不接参数、无返回值</td>\n    </tr>\n    <tr>\n        <td><code>thenAccept</code>、<code>thenAcceptAsync</code></td>\n        <td>接返回值、无返回值</td>\n    </tr>\n    <tr>\n        <td><code>thenApply</code>、<code>thenApplyAsync</code></td>\n        <td>接返回值、有返回值</td>\n    </tr>\n    <tr>\n        <td><code>exceptionally</code>、<code>exceptionallyAsync</code></td>\n        <td>接异常、有返回值</td>\n    </tr>\n    <tr>\n        <td><code>whenComplete</code>、<code>whenCompleteAsync</code></td>\n        <td>接返回值和异常、无返回值</td>\n    </tr>\n    <tr>\n        <td><code>handle</code>、<code>handleAsync</code></td>\n        <td>接返回值和异常、有返回值</td>\n    </tr>\n    <tr>\n        <th rowspan=\"7\">两个任务组合</th>\n        <td><code>thenCompose</code>、<code>thenComposeAsync</code></td>\n        <td>任务转化</td>\n    </tr>\n    <tr>\n        <td><code>thenCombine</code>、<code>thenCombineAsync</code></td>\n        <td>“且”组合、接返回值、有返回值</td>\n    </tr>\n    <tr>\n        <td><code>thenAcceptBoth</code>、<code>thenAcceptBothAsync</code></td>\n        <td>“且”组合、接返回值、无返回值</td>\n    </tr>\n    <tr>\n        <td><code>runAfterBoth</code>、<code>runAfterBothAsync</code></td>\n        <td>“且”组合、不接参数、无返回值</td>\n    </tr>\n    <tr>\n        <td><code>applyToEither</code>、<code>applyToEitherAsync</code></td>\n        <td>“或”组合、接返回值、有返回值</td>\n    </tr>\n    <tr>\n        <td><code>acceptEither</code>、<code>acceptEitherAsync</code></td>\n        <td>“或”组合、接返回值、无返回值</td>\n    </tr>\n    <tr>\n        <td><code>runAfterEither</code>、<code>runAfterEitherAsync</code></td>\n        <td>“或”组合、不接参数、无返回值</td>\n    </tr>\n    <tr>\n        <th rowspan=\"2\">多个任务组合</th>\n        <td><code>anyOf</code></td>\n        <td>“任意一个”组合</td>\n    </tr>\n    <tr>\n        <td><code>allOf</code></td>\n        <td>“所有”组合</td>\n    </tr>\n</table>\n\n> 在CompletableFuture中如果使用没有指定线程池的方法，则会使用`ForkJoinPool.commonPool()`作为它的线程池执行异步代码。\n\n# 创建异步任务\n\n### 不支持返回值\n\n- 方法签名\n  ```java\n  // 使用默认线程池中的线程\n  public static CompletableFuture<Void> runAsync(Runnable runnable);\n  // 使用自定义线程池中的线程\n  public static CompletableFuture<Void> runAsync(Runnable runnable, Executor executor); \n  ```\n- 示例代码\n  ```java\n  CompletableFuture.runAsync(() -> {\n      // TODO 执行任务\n  });\n  ```\n\n### 支持返回值\n\n- 方法签名\n  ```java\n  // 使用默认线程池中的线程\n  public static <U> CompletableFuture<U> supplyAsync(Supplier<U> supplier);\n  // 使用自定义线程池中的线程\n  public static <U> CompletableFuture<U> supplyAsync(Supplier<U> supplier, Executor executor); \n  ```\n\n- 示例代码\n  ```java\n  CompletableFuture.supplyAsync(() -> {\n      // TODO 执行任务\n      return null;\n  });\n    ```\n\n# 任务完成时回调方法\n\n当CompletableFuture任务执行完成或者抛出异常的时候，可以执行特定的回调方法。\n\n### 不接参数、无返回值\n\n> 前一个任务执行完成后执行；任务之间**无参数传递**，回调方法**无返回值**\n\n- 方法签名\n  ```java\n  // 使用调用它的线程上运行（一般是主线程）\n  public CompletableFuture<Void> thenRun(Runnable action);\n  // 使用默认线程池中的线程\n  public CompletableFuture<Void> thenRunAsync(Runnable action);\n  // 使用自定义线程池中的线程\n  public CompletableFuture<Void> thenRunAsync(Runnable action, Executor executor);\n  ```\n- 示例代码\n  ```java\n  CompletableFuture.runAsync(() -> {\n  }).thenRun(() -> {\n      // TODO 执行任务\n  });\n  ```\n\n### 接返回值、无返回值\n\n> 前一个任务执行完成后执行；前一个任务会将执行结果**作为参数**，传递到回调方法中，回调方法**无返回值**\n\n- 方法签名\n  ```java\n  // 使用调用它的线程上运行（一般是主线程）\n  public CompletableFuture<Void> thenAccept(Consumer<? super T> action);\n  // 使用默认线程池中的线程\n  public CompletableFuture<Void> thenAcceptAsync(Consumer<? super T> action);\n  // 使用自定义线程池中的线程\n  public CompletableFuture<Void> thenAcceptAsync(Consumer<? super T> action, Executor executor);\n  ```\n- 示例代码\n  ```java\n  CompletableFuture.supplyAsync(() -> {\n      return \"Result\";\n  }).thenAccept((result) -> {\n      // TODO 执行任务\n  });\n  ```\n\n### 接返回值、有返回值\n\n> 前一个任务执行完成后执行；前一个任务会将执行结果**作为参数**，传递到回调方法中，并且会调方法**有返回值**\n\n- 方法签名\n  ```java\n  // 使用调用它的线程上运行（一般是主线程）\n  public <U> CompletableFuture<U> thenApply(Function<? super T,? extends U> fn);\n  // 使用默认线程池中的线程\n  public <U> CompletableFuture<U> thenApplyAsync(Function<? super T,? extends U> fn);\n  // 使用自定义线程池中的线程\n  public <U> CompletableFuture<U> thenApplyAsync(Function<? super T,? extends U> fn, Executor executor);\n  ```\n- 示例代码\n  ```java\n  CompletableFuture.supplyAsync(() -> {\n      return \"Result_1\";\n  }).thenApply(() -> {\n      // TODO 执行任务\n      return \"Result_2\";\n  });\n  ```\n\n### 接异常、有返回值\n\n> 某个任务执行异常时执行；异常任务抛出的异常**作为参数**，传递到回调方法中，并且会调方法**有返回值**\n\n- 方法签名\n  ```java\n  // 使用调用它的线程上运行（一般是主线程）\n  public CompletableFuture<T> exceptionally(Function<Throwable, ? extends T> fn);\n  // 使用默认线程池中的线程\n  public CompletableFuture<T> exceptionallyAsync(Function<Throwable, ? extends T> fn);\n  // 使用自定义线程池中的线程\n  public CompletableFuture<T> exceptionallyAsync(Function<Throwable, ? extends T> fn, Executor executor);\n  ```\n- 示例代码\n  ```java\n  CompletableFuture.runAsync(() -> {\n      throw new RuntimeException();\n  }).exceptionally((exception) -> {\n      // TODO 处理异常\n      return \"ERROR!\";\n  });\n  ```\n\n### 接返回值和异常、无返回值\n\n> 前一个任务执行完成或出现异常时执行；前一个任务会将结果或抛出的异常**作为参数**，传递到回调方法中，回调方法**无返回值**\n\n- 方法签名\n  ```java\n  // 使用调用它的线程上运行（一般是主线程）\n  public CompletableFuture<T> whenComplete(BiConsumer<? super T, ? super Throwable> action);\n  // 使用默认线程池中的线程\n  public CompletableFuture<T> whenCompleteAsync(BiConsumer<? super T, ? super Throwable> action);\n  // 使用自定义线程池中的线程\n  public CompletableFuture<T> whenCompleteAsync(BiConsumer<? super T, ? super Throwable> action, Executor executor);\n  ```\n- 示例代码\n  ```java\n  CompletableFuture.supplyAsync(() -> {\n      throw new RuntimeException();\n  }).whenCompleteAsync((result, exception) -> {\n      if (exception != null) {\n          // TODO 处理异常\n      } else {\n          // TODO 执行任务\n      }\n  });\n  ```\n\n### 接返回值和异常、有返回值\n\n> 前一个任务执行完成后执行；前一个任务会将结果或抛出的异常**作为参数**，传递到回调方法中，回调方法**有返回值**\n\n- 方法签名\n  ```java\n  // 使用调用它的线程上运行（一般是主线程）\n  public <U> CompletableFuture<U> handle(BiFunction<? super T, Throwable, ? extends U> fn);\n  // 使用默认线程池中的线程\n  public <U> CompletableFuture<U> handleAsync(BiFunction<? super T, Throwable, ? extends U> fn);\n  // 使用自定义线程池中的线程\n  public <U> CompletableFuture<U> handleAsync(BiFunction<? super T, Throwable, ? extends U> fn, Executor executor);\n  ```\n- 示例代码\n  ```java\n  CompletableFuture.supplyAsync(() -> {\n      throw new RuntimeException();\n  }).handleAsync((result, exception) -> {\n      if (exception != null) {\n          // TODO 处理异常\n          return \"ERROR!\";\n      } else {\n          // 执行任务\n          return \"SUCCESS!\";\n      }\n  });\n  ```\n\n# 两个任务组合\n\n### 任务转化\n\n> 将前一个任务的执行结果**作为参数**进行处理，处理后**返回一个新的任务**\n\n- 方法签名\n  ```java\n  // 使用调用它的线程上运行（一般是主线程）\n  public <U> CompletableFuture<U> thenCompose(Function<? super T, ? extends CompletionStage<U>> fn);\n  // 使用默认线程池中的线程\n  public <U> CompletableFuture<U> thenComposeAsync(Function<? super T, ? extends CompletionStage<U>> fn);\n  // 使用自定义线程池中的线程\n  public <U> CompletableFuture<U> thenComposeAsync(Function<? super T, ? extends CompletionStage<U>> fn, Executor executor);\n  ```\n- 示例代码\n  ```java\n  CompletableFuture<String> task = CompletableFuture.supplyAsync(() -> {\n      return \"任务一的结果\";\n  });\n  \n  CompletableFuture<String> stringCompletableFuture = CompletableFuture.supplyAsync(() -> {\n      return \"任务二的结果\";\n  }).thenComposeAsync((result) -> {\n      // TODO 执行任务\n      return task;\n  });\n  ```\n\n### “且”组合、接返回值、有返回值\n\n> 将两个任务组合，当两个任务都正常执行完了，将两个任务的结果作为参数，传递到回调方法中，回调方法有返回值\n\n- 方法签名\n  ```java\n  // 使用调用它的线程上运行（一般是主线程）\n  public <U,V> CompletableFuture<V> thenCombine(CompletionStage<? extends U> other, BiFunction<? super T,? super U,? extends V> fn);\n  // 使用默认线程池中的线程\n  public <U,V> CompletableFuture<V> thenCombineAsync(CompletionStage<? extends U> other, BiFunction<? super T,? super U,? extends V> fn);\n  // 使用自定义线程池中的线程\n  public <U,V> CompletableFuture<V> thenCombineAsync(CompletionStage<? extends U> other, BiFunction<? super T,? super U,? extends V> fn, Executor executor);\n  ```\n- 示例代码\n  ```java\n  CompletableFuture.supplyAsync(() -> {\n      // TODO 任务一\n      return \"任务一的结果\";\n  }).thenCombineAsync(CompletableFuture.supplyAsync(() -> {\n      // TODO 任务二\n      return \"任务二的结果\";\n  }), (result1, result2) -> {\n      // 任务一和任务二都完成时执行的回调方法\n      return null;\n  });\n  ```\n\n### “且”组合、接返回值、无返回值\n\n> 将两个任务组合，当两个任务都正常执行完了，将两个任务的结果作为参数，传递到回调方法中，回调方法无返回值\n\n- 方法签名\n  ```java\n  // 使用调用它的线程上运行（一般是主线程）\n  public <U> CompletableFuture<Void> thenAcceptBoth(CompletionStage<? extends U> other, BiConsumer<? super T, ? super U> action);\n  // 使用默认线程池中的线程\n  public <U> CompletableFuture<Void> thenAcceptBothAsync(CompletionStage<? extends U> other, BiConsumer<? super T, ? super U> action);\n  // 使用自定义线程池中的线程\n  public <U> CompletableFuture<Void> thenAcceptBothAsync(CompletionStage<? extends U> other, BiConsumer<? super T, ? super U> action, Executor executor);\n  ```\n- 示例代码\n  ```java\n  CompletableFuture.supplyAsync(() -> {\n      // TODO 任务一\n      return \"任务一的结果\";\n  }).thenAcceptBothAsync(CompletableFuture.supplyAsync(() -> {\n      // TODO 任务二\n      return \"任务二的结果\";\n  }), (result1, result2) -> {\n      // TODO 任务一和任务二都完成时执行的回调方法\n  });\n  ```\n\n### “且”组合、不接参数、无返回值\n\n> 将两个任务组合，当两个任务都正常执行完了，执行回调方法，回调方法无返回值\n\n- 方法签名\n  ```java\n  // 使用调用它的线程上运行（一般是主线程）\n  public CompletableFuture<Void> runAfterBoth(CompletionStage<?> other, Runnable action);\n  // 使用默认线程池中的线程\n  public CompletableFuture<Void> runAfterBothAsync(CompletionStage<?> other, Runnable action);\n  // 使用自定义线程池中的线程\n  public CompletableFuture<Void> runAfterBothAsync(CompletionStage<?> other, Runnable action, Executor executor);\n  ```\n- 示例代码\n  ```java\n  CompletableFuture.supplyAsync(() -> {\n      // TODO 任务一\n      return \"任务一的结果\";\n  }).runAfterBothAsync(CompletableFuture.supplyAsync(() -> {\n      // TODO 任务二\n      return \"任务二的结果\";\n  }), () -> {\n      // TODO 任务一和任务二都完成时执行的回调方法\n  });\n  ```\n\n### “或”组合、接返回值、有返回值\n\n> 将两个任务组合，其中任意一个任务执行完成，将该任务的结果作为参数，传递到回调方法中，回调方法有返回值\n\n- 方法签名\n  ```java\n  // 使用调用它的线程上运行（一般是主线程）\n  public <U> CompletableFuture<U> applyToEither(CompletionStage<? extends T> other, Function<? super T, U> fn);\n  // 使用默认线程池中的线程\n  public <U> CompletableFuture<U> applyToEitherAsync(CompletionStage<? extends T> other, Function<? super T, U> fn);\n  // 使用自定义线程池中的线程\n  public <U> CompletableFuture<U> applyToEitherAsync(CompletionStage<? extends T> other, Function<? super T, U> fn, Executor executor);\n  ```\n- 示例代码\n  ```java\n  CompletableFuture.supplyAsync(() -> {\n      // TODO 任务一\n      return \"任务一的结果\";\n  }).applyToEitherAsync(CompletableFuture.supplyAsync(() -> {\n      // TODO 任务二\n      return \"任务二的结果\";\n  }), (result) -> {\n      // TODO 任务一和任务二任意一个执行完成时执行的回调方法\n      return \"SUCCESS\";\n  });\n  ```\n\n### “或”组合、接返回值、无返回值\n\n> 将两个任务组合，其中任意一个任务执行完成，将该任务的结果作为参数，传递到回调方法中，回调方法无返回值\n\n- 方法签名\n  ```java\n  // 使用调用它的线程上运行（一般是主线程）\n  public CompletableFuture<Void> acceptEither(CompletionStage<? extends T> other, Consumer<? super T> action);\n  // 使用默认线程池中的线程\n  public CompletableFuture<Void> acceptEitherAsync(CompletionStage<? extends T> other, Consumer<? super T> action);\n  // 使用自定义线程池中的线程\n  public CompletableFuture<Void> acceptEitherAsync(CompletionStage<? extends T> other, Consumer<? super T> action, Executor executor);\n  ```\n- 示例代码\n  ```java\n  CompletableFuture.supplyAsync(() -> {\n      // TODO 任务一\n      try {\n          Thread.sleep(10);\n      } catch (InterruptedException e) {\n          throw new RuntimeException(e);\n      }\n      return \"任务一的结果\";\n  }).acceptEitherAsync(CompletableFuture.supplyAsync(() -> {\n      // TODO 任务二\n      return \"任务二的结果\";\n  }), (result) -> {\n      // TODO 任务一和任务二任意一个执行完成时执行的回调方法\n  });\n  ```\n\n### “或”组合、不接参数、无返回值\n\n> 将两个任务组合，其中任意一个任务执行完成，执行回调方法，回调方法无返回值\n\n- 方法签名\n  ```java\n  // 使用调用它的线程上运行（一般是主线程）\n  public CompletableFuture<Void> runAfterEither(CompletionStage<?> other, Runnable action);\n  // 使用默认线程池中的线程\n  public CompletableFuture<Void> runAfterEitherAsync(CompletionStage<?> other, Runnable action);\n  // 使用自定义线程池中的线程\n  public CompletableFuture<Void> runAfterEitherAsync(CompletionStage<?> other, Runnable action, Executor executor);\n  ```\n- 示例代码\n  ```java\n  CompletableFuture.supplyAsync(() -> {\n      // TODO 任务一\n      try {\n          Thread.sleep(10);\n      } catch (InterruptedException e) {\n          throw new RuntimeException(e);\n      }\n      return \"任务一的结果\";\n  }).runAfterEitherAsync(CompletableFuture.supplyAsync(() -> {\n      // TODO 任务二\n      return \"任务二的结果\";\n  }), () -> {\n      // TODO 任务一和任务二任意一个执行完成时执行的回调方法\n  });\n  ```\n\n# 多个任务组合\n\n### “任意一个”组合\n\n> 将多个任务组合，其中任意一个任务执行完成即可拿到该任务的执行结果（执行结果为Object类型），或执行接下来的任务\n\n- 方法签名\n  ```java\n  public static CompletableFuture<Object> anyOf(CompletableFuture<?>... cfs);\n  ```\n- 示例代码\n  ```java\n  CompletableFuture<String> task1 = CompletableFuture.supplyAsync(() -> {\n      return \"任务一的结果\";\n  });\n  \n  CompletableFuture<String> task2 = CompletableFuture.supplyAsync(() -> {\n      return \"任务二的结果\";\n  });\n  \n  Object result = CompletableFuture.anyOf(task1, task2).join();\n  ```\n\n### “所有”组合\n\n> 将多个任务组合，当所有任务都执行完成后执行接下来的任务\n\n- 方法签名\n  ```java\n  public static CompletableFuture<Void> allOf(CompletableFuture<?>... cfs);\n  ```\n- 示例代码\n  ```java\n  CompletableFuture<String> task1 = CompletableFuture.supplyAsync(() -> {\n      return \"任务一的结果\";\n  });\n  \n  CompletableFuture<String> task2 = CompletableFuture.supplyAsync(() -> {\n      return \"任务二的结果\";\n  });\n  \n  Object join = CompletableFuture.allOf(task1, task2).join();\n  ```\n","slug":"2023-08-10-CompletableFuture的使用","published":1,"updated":"2024-04-13T14:25:52.438Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cly2c4k3g0001qsvd5x9u92qd","content":"<blockquote>\n<p>CompletableFuture类提供了非常强大的Future的扩展功能，可以帮助我们简化异步编程的复杂性，提供了函数式编程的能力，可以通过回调的方式处理计算结果，并且提供了转换和组合CompletableFuture的方法。</p>\n</blockquote>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><table>\n    <tr>\n        <th>分类</th>\n        <th>方法名</th>\n        <th>描述</th>\n    </tr>\n    <tr>\n        <th rowspan=\"2\">创建异步任务</th>\n        <td><code>runAsync</code></td>\n        <td>不支持返回值</td>\n    </tr>\n    <tr>\n        <td><code>supplyAsync</code></td>\n        <td>支持返回值</td>\n    </tr>\n    <tr>\n        <th rowspan=\"6\">创建异步任务</th>\n        <td><code>thenRun</code>、<code>thenRunAsync</code></td>\n        <td>不接参数、无返回值</td>\n    </tr>\n    <tr>\n        <td><code>thenAccept</code>、<code>thenAcceptAsync</code></td>\n        <td>接返回值、无返回值</td>\n    </tr>\n    <tr>\n        <td><code>thenApply</code>、<code>thenApplyAsync</code></td>\n        <td>接返回值、有返回值</td>\n    </tr>\n    <tr>\n        <td><code>exceptionally</code>、<code>exceptionallyAsync</code></td>\n        <td>接异常、有返回值</td>\n    </tr>\n    <tr>\n        <td><code>whenComplete</code>、<code>whenCompleteAsync</code></td>\n        <td>接返回值和异常、无返回值</td>\n    </tr>\n    <tr>\n        <td><code>handle</code>、<code>handleAsync</code></td>\n        <td>接返回值和异常、有返回值</td>\n    </tr>\n    <tr>\n        <th rowspan=\"7\">两个任务组合</th>\n        <td><code>thenCompose</code>、<code>thenComposeAsync</code></td>\n        <td>任务转化</td>\n    </tr>\n    <tr>\n        <td><code>thenCombine</code>、<code>thenCombineAsync</code></td>\n        <td>“且”组合、接返回值、有返回值</td>\n    </tr>\n    <tr>\n        <td><code>thenAcceptBoth</code>、<code>thenAcceptBothAsync</code></td>\n        <td>“且”组合、接返回值、无返回值</td>\n    </tr>\n    <tr>\n        <td><code>runAfterBoth</code>、<code>runAfterBothAsync</code></td>\n        <td>“且”组合、不接参数、无返回值</td>\n    </tr>\n    <tr>\n        <td><code>applyToEither</code>、<code>applyToEitherAsync</code></td>\n        <td>“或”组合、接返回值、有返回值</td>\n    </tr>\n    <tr>\n        <td><code>acceptEither</code>、<code>acceptEitherAsync</code></td>\n        <td>“或”组合、接返回值、无返回值</td>\n    </tr>\n    <tr>\n        <td><code>runAfterEither</code>、<code>runAfterEitherAsync</code></td>\n        <td>“或”组合、不接参数、无返回值</td>\n    </tr>\n    <tr>\n        <th rowspan=\"2\">多个任务组合</th>\n        <td><code>anyOf</code></td>\n        <td>“任意一个”组合</td>\n    </tr>\n    <tr>\n        <td><code>allOf</code></td>\n        <td>“所有”组合</td>\n    </tr>\n</table>\n\n<blockquote>\n<p>在CompletableFuture中如果使用没有指定线程池的方法，则会使用<code>ForkJoinPool.commonPool()</code>作为它的线程池执行异步代码。</p>\n</blockquote>\n<h1 id=\"创建异步任务\"><a href=\"#创建异步任务\" class=\"headerlink\" title=\"创建异步任务\"></a>创建异步任务</h1><h3 id=\"不支持返回值\"><a href=\"#不支持返回值\" class=\"headerlink\" title=\"不支持返回值\"></a>不支持返回值</h3><ul>\n<li>方法签名<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用默认线程池中的线程</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> CompletableFuture&lt;Void&gt; <span class=\"title function_\">runAsync</span><span class=\"params\">(Runnable runnable)</span>;</span><br><span class=\"line\"><span class=\"comment\">// 使用自定义线程池中的线程</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> CompletableFuture&lt;Void&gt; <span class=\"title function_\">runAsync</span><span class=\"params\">(Runnable runnable, Executor executor)</span>; </span><br></pre></td></tr></table></figure></li>\n<li>示例代码<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">// TODO 执行任务</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"支持返回值\"><a href=\"#支持返回值\" class=\"headerlink\" title=\"支持返回值\"></a>支持返回值</h3><ul>\n<li><p>方法签名</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用默认线程池中的线程</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class=\"title function_\">supplyAsync</span><span class=\"params\">(Supplier&lt;U&gt; supplier)</span>;</span><br><span class=\"line\"><span class=\"comment\">// 使用自定义线程池中的线程</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class=\"title function_\">supplyAsync</span><span class=\"params\">(Supplier&lt;U&gt; supplier, Executor executor)</span>; </span><br></pre></td></tr></table></figure>\n</li>\n<li><p>示例代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">// TODO 执行任务</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h1 id=\"任务完成时回调方法\"><a href=\"#任务完成时回调方法\" class=\"headerlink\" title=\"任务完成时回调方法\"></a>任务完成时回调方法</h1><p>当CompletableFuture任务执行完成或者抛出异常的时候，可以执行特定的回调方法。</p>\n<h3 id=\"不接参数、无返回值\"><a href=\"#不接参数、无返回值\" class=\"headerlink\" title=\"不接参数、无返回值\"></a>不接参数、无返回值</h3><blockquote>\n<p>前一个任务执行完成后执行；任务之间<strong>无参数传递</strong>，回调方法<strong>无返回值</strong></p>\n</blockquote>\n<ul>\n<li>方法签名<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用调用它的线程上运行（一般是主线程）</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> CompletableFuture&lt;Void&gt; <span class=\"title function_\">thenRun</span><span class=\"params\">(Runnable action)</span>;</span><br><span class=\"line\"><span class=\"comment\">// 使用默认线程池中的线程</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> CompletableFuture&lt;Void&gt; <span class=\"title function_\">thenRunAsync</span><span class=\"params\">(Runnable action)</span>;</span><br><span class=\"line\"><span class=\"comment\">// 使用自定义线程池中的线程</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> CompletableFuture&lt;Void&gt; <span class=\"title function_\">thenRunAsync</span><span class=\"params\">(Runnable action, Executor executor)</span>;</span><br></pre></td></tr></table></figure></li>\n<li>示例代码<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class=\"line\">&#125;).thenRun(() -&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">// TODO 执行任务</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"接返回值、无返回值\"><a href=\"#接返回值、无返回值\" class=\"headerlink\" title=\"接返回值、无返回值\"></a>接返回值、无返回值</h3><blockquote>\n<p>前一个任务执行完成后执行；前一个任务会将执行结果<strong>作为参数</strong>，传递到回调方法中，回调方法<strong>无返回值</strong></p>\n</blockquote>\n<ul>\n<li>方法签名<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用调用它的线程上运行（一般是主线程）</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> CompletableFuture&lt;Void&gt; <span class=\"title function_\">thenAccept</span><span class=\"params\">(Consumer&lt;? <span class=\"built_in\">super</span> T&gt; action)</span>;</span><br><span class=\"line\"><span class=\"comment\">// 使用默认线程池中的线程</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> CompletableFuture&lt;Void&gt; <span class=\"title function_\">thenAcceptAsync</span><span class=\"params\">(Consumer&lt;? <span class=\"built_in\">super</span> T&gt; action)</span>;</span><br><span class=\"line\"><span class=\"comment\">// 使用自定义线程池中的线程</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> CompletableFuture&lt;Void&gt; <span class=\"title function_\">thenAcceptAsync</span><span class=\"params\">(Consumer&lt;? <span class=\"built_in\">super</span> T&gt; action, Executor executor)</span>;</span><br></pre></td></tr></table></figure></li>\n<li>示例代码<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;Result&quot;</span>;</span><br><span class=\"line\">&#125;).thenAccept((result) -&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">// TODO 执行任务</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"接返回值、有返回值\"><a href=\"#接返回值、有返回值\" class=\"headerlink\" title=\"接返回值、有返回值\"></a>接返回值、有返回值</h3><blockquote>\n<p>前一个任务执行完成后执行；前一个任务会将执行结果<strong>作为参数</strong>，传递到回调方法中，并且会调方法<strong>有返回值</strong></p>\n</blockquote>\n<ul>\n<li>方法签名<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用调用它的线程上运行（一般是主线程）</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class=\"title function_\">thenApply</span><span class=\"params\">(Function&lt;? <span class=\"built_in\">super</span> T,? extends U&gt; fn)</span>;</span><br><span class=\"line\"><span class=\"comment\">// 使用默认线程池中的线程</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class=\"title function_\">thenApplyAsync</span><span class=\"params\">(Function&lt;? <span class=\"built_in\">super</span> T,? extends U&gt; fn)</span>;</span><br><span class=\"line\"><span class=\"comment\">// 使用自定义线程池中的线程</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class=\"title function_\">thenApplyAsync</span><span class=\"params\">(Function&lt;? <span class=\"built_in\">super</span> T,? extends U&gt; fn, Executor executor)</span>;</span><br></pre></td></tr></table></figure></li>\n<li>示例代码<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;Result_1&quot;</span>;</span><br><span class=\"line\">&#125;).thenApply(() -&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">// TODO 执行任务</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;Result_2&quot;</span>;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"接异常、有返回值\"><a href=\"#接异常、有返回值\" class=\"headerlink\" title=\"接异常、有返回值\"></a>接异常、有返回值</h3><blockquote>\n<p>某个任务执行异常时执行；异常任务抛出的异常<strong>作为参数</strong>，传递到回调方法中，并且会调方法<strong>有返回值</strong></p>\n</blockquote>\n<ul>\n<li>方法签名<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用调用它的线程上运行（一般是主线程）</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> CompletableFuture&lt;T&gt; <span class=\"title function_\">exceptionally</span><span class=\"params\">(Function&lt;Throwable, ? extends T&gt; fn)</span>;</span><br><span class=\"line\"><span class=\"comment\">// 使用默认线程池中的线程</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> CompletableFuture&lt;T&gt; <span class=\"title function_\">exceptionallyAsync</span><span class=\"params\">(Function&lt;Throwable, ? extends T&gt; fn)</span>;</span><br><span class=\"line\"><span class=\"comment\">// 使用自定义线程池中的线程</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> CompletableFuture&lt;T&gt; <span class=\"title function_\">exceptionallyAsync</span><span class=\"params\">(Function&lt;Throwable, ? extends T&gt; fn, Executor executor)</span>;</span><br></pre></td></tr></table></figure></li>\n<li>示例代码<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RuntimeException</span>();</span><br><span class=\"line\">&#125;).exceptionally((exception) -&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">// TODO 处理异常</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;ERROR!&quot;</span>;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"接返回值和异常、无返回值\"><a href=\"#接返回值和异常、无返回值\" class=\"headerlink\" title=\"接返回值和异常、无返回值\"></a>接返回值和异常、无返回值</h3><blockquote>\n<p>前一个任务执行完成或出现异常时执行；前一个任务会将结果或抛出的异常<strong>作为参数</strong>，传递到回调方法中，回调方法<strong>无返回值</strong></p>\n</blockquote>\n<ul>\n<li>方法签名<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用调用它的线程上运行（一般是主线程）</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> CompletableFuture&lt;T&gt; <span class=\"title function_\">whenComplete</span><span class=\"params\">(BiConsumer&lt;? <span class=\"built_in\">super</span> T, ? <span class=\"built_in\">super</span> Throwable&gt; action)</span>;</span><br><span class=\"line\"><span class=\"comment\">// 使用默认线程池中的线程</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> CompletableFuture&lt;T&gt; <span class=\"title function_\">whenCompleteAsync</span><span class=\"params\">(BiConsumer&lt;? <span class=\"built_in\">super</span> T, ? <span class=\"built_in\">super</span> Throwable&gt; action)</span>;</span><br><span class=\"line\"><span class=\"comment\">// 使用自定义线程池中的线程</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> CompletableFuture&lt;T&gt; <span class=\"title function_\">whenCompleteAsync</span><span class=\"params\">(BiConsumer&lt;? <span class=\"built_in\">super</span> T, ? <span class=\"built_in\">super</span> Throwable&gt; action, Executor executor)</span>;</span><br></pre></td></tr></table></figure></li>\n<li>示例代码<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RuntimeException</span>();</span><br><span class=\"line\">&#125;).whenCompleteAsync((result, exception) -&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (exception != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// TODO 处理异常</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// TODO 执行任务</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"接返回值和异常、有返回值\"><a href=\"#接返回值和异常、有返回值\" class=\"headerlink\" title=\"接返回值和异常、有返回值\"></a>接返回值和异常、有返回值</h3><blockquote>\n<p>前一个任务执行完成后执行；前一个任务会将结果或抛出的异常<strong>作为参数</strong>，传递到回调方法中，回调方法<strong>有返回值</strong></p>\n</blockquote>\n<ul>\n<li>方法签名<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用调用它的线程上运行（一般是主线程）</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class=\"title function_\">handle</span><span class=\"params\">(BiFunction&lt;? <span class=\"built_in\">super</span> T, Throwable, ? extends U&gt; fn)</span>;</span><br><span class=\"line\"><span class=\"comment\">// 使用默认线程池中的线程</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class=\"title function_\">handleAsync</span><span class=\"params\">(BiFunction&lt;? <span class=\"built_in\">super</span> T, Throwable, ? extends U&gt; fn)</span>;</span><br><span class=\"line\"><span class=\"comment\">// 使用自定义线程池中的线程</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class=\"title function_\">handleAsync</span><span class=\"params\">(BiFunction&lt;? <span class=\"built_in\">super</span> T, Throwable, ? extends U&gt; fn, Executor executor)</span>;</span><br></pre></td></tr></table></figure></li>\n<li>示例代码<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RuntimeException</span>();</span><br><span class=\"line\">&#125;).handleAsync((result, exception) -&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (exception != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// TODO 处理异常</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;ERROR!&quot;</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 执行任务</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;SUCCESS!&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h1 id=\"两个任务组合\"><a href=\"#两个任务组合\" class=\"headerlink\" title=\"两个任务组合\"></a>两个任务组合</h1><h3 id=\"任务转化\"><a href=\"#任务转化\" class=\"headerlink\" title=\"任务转化\"></a>任务转化</h3><blockquote>\n<p>将前一个任务的执行结果<strong>作为参数</strong>进行处理，处理后<strong>返回一个新的任务</strong></p>\n</blockquote>\n<ul>\n<li>方法签名<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用调用它的线程上运行（一般是主线程）</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class=\"title function_\">thenCompose</span><span class=\"params\">(Function&lt;? <span class=\"built_in\">super</span> T, ? extends CompletionStage&lt;U&gt;&gt; fn)</span>;</span><br><span class=\"line\"><span class=\"comment\">// 使用默认线程池中的线程</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class=\"title function_\">thenComposeAsync</span><span class=\"params\">(Function&lt;? <span class=\"built_in\">super</span> T, ? extends CompletionStage&lt;U&gt;&gt; fn)</span>;</span><br><span class=\"line\"><span class=\"comment\">// 使用自定义线程池中的线程</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class=\"title function_\">thenComposeAsync</span><span class=\"params\">(Function&lt;? <span class=\"built_in\">super</span> T, ? extends CompletionStage&lt;U&gt;&gt; fn, Executor executor)</span>;</span><br></pre></td></tr></table></figure></li>\n<li>示例代码<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CompletableFuture&lt;String&gt; task = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;任务一的结果&quot;</span>;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">CompletableFuture&lt;String&gt; stringCompletableFuture = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;任务二的结果&quot;</span>;</span><br><span class=\"line\">&#125;).thenComposeAsync((result) -&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">// TODO 执行任务</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> task;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"“且”组合、接返回值、有返回值\"><a href=\"#“且”组合、接返回值、有返回值\" class=\"headerlink\" title=\"“且”组合、接返回值、有返回值\"></a>“且”组合、接返回值、有返回值</h3><blockquote>\n<p>将两个任务组合，当两个任务都正常执行完了，将两个任务的结果作为参数，传递到回调方法中，回调方法有返回值</p>\n</blockquote>\n<ul>\n<li>方法签名<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用调用它的线程上运行（一般是主线程）</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> &lt;U,V&gt; CompletableFuture&lt;V&gt; <span class=\"title function_\">thenCombine</span><span class=\"params\">(CompletionStage&lt;? extends U&gt; other, BiFunction&lt;? <span class=\"built_in\">super</span> T,? <span class=\"built_in\">super</span> U,? extends V&gt; fn)</span>;</span><br><span class=\"line\"><span class=\"comment\">// 使用默认线程池中的线程</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> &lt;U,V&gt; CompletableFuture&lt;V&gt; <span class=\"title function_\">thenCombineAsync</span><span class=\"params\">(CompletionStage&lt;? extends U&gt; other, BiFunction&lt;? <span class=\"built_in\">super</span> T,? <span class=\"built_in\">super</span> U,? extends V&gt; fn)</span>;</span><br><span class=\"line\"><span class=\"comment\">// 使用自定义线程池中的线程</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> &lt;U,V&gt; CompletableFuture&lt;V&gt; <span class=\"title function_\">thenCombineAsync</span><span class=\"params\">(CompletionStage&lt;? extends U&gt; other, BiFunction&lt;? <span class=\"built_in\">super</span> T,? <span class=\"built_in\">super</span> U,? extends V&gt; fn, Executor executor)</span>;</span><br></pre></td></tr></table></figure></li>\n<li>示例代码<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">// TODO 任务一</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;任务一的结果&quot;</span>;</span><br><span class=\"line\">&#125;).thenCombineAsync(CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">// TODO 任务二</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;任务二的结果&quot;</span>;</span><br><span class=\"line\">&#125;), (result1, result2) -&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 任务一和任务二都完成时执行的回调方法</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"“且”组合、接返回值、无返回值\"><a href=\"#“且”组合、接返回值、无返回值\" class=\"headerlink\" title=\"“且”组合、接返回值、无返回值\"></a>“且”组合、接返回值、无返回值</h3><blockquote>\n<p>将两个任务组合，当两个任务都正常执行完了，将两个任务的结果作为参数，传递到回调方法中，回调方法无返回值</p>\n</blockquote>\n<ul>\n<li>方法签名<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用调用它的线程上运行（一般是主线程）</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> &lt;U&gt; CompletableFuture&lt;Void&gt; <span class=\"title function_\">thenAcceptBoth</span><span class=\"params\">(CompletionStage&lt;? extends U&gt; other, BiConsumer&lt;? <span class=\"built_in\">super</span> T, ? <span class=\"built_in\">super</span> U&gt; action)</span>;</span><br><span class=\"line\"><span class=\"comment\">// 使用默认线程池中的线程</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> &lt;U&gt; CompletableFuture&lt;Void&gt; <span class=\"title function_\">thenAcceptBothAsync</span><span class=\"params\">(CompletionStage&lt;? extends U&gt; other, BiConsumer&lt;? <span class=\"built_in\">super</span> T, ? <span class=\"built_in\">super</span> U&gt; action)</span>;</span><br><span class=\"line\"><span class=\"comment\">// 使用自定义线程池中的线程</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> &lt;U&gt; CompletableFuture&lt;Void&gt; <span class=\"title function_\">thenAcceptBothAsync</span><span class=\"params\">(CompletionStage&lt;? extends U&gt; other, BiConsumer&lt;? <span class=\"built_in\">super</span> T, ? <span class=\"built_in\">super</span> U&gt; action, Executor executor)</span>;</span><br></pre></td></tr></table></figure></li>\n<li>示例代码<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">// TODO 任务一</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;任务一的结果&quot;</span>;</span><br><span class=\"line\">&#125;).thenAcceptBothAsync(CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">// TODO 任务二</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;任务二的结果&quot;</span>;</span><br><span class=\"line\">&#125;), (result1, result2) -&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">// TODO 任务一和任务二都完成时执行的回调方法</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"“且”组合、不接参数、无返回值\"><a href=\"#“且”组合、不接参数、无返回值\" class=\"headerlink\" title=\"“且”组合、不接参数、无返回值\"></a>“且”组合、不接参数、无返回值</h3><blockquote>\n<p>将两个任务组合，当两个任务都正常执行完了，执行回调方法，回调方法无返回值</p>\n</blockquote>\n<ul>\n<li>方法签名<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用调用它的线程上运行（一般是主线程）</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> CompletableFuture&lt;Void&gt; <span class=\"title function_\">runAfterBoth</span><span class=\"params\">(CompletionStage&lt;?&gt; other, Runnable action)</span>;</span><br><span class=\"line\"><span class=\"comment\">// 使用默认线程池中的线程</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> CompletableFuture&lt;Void&gt; <span class=\"title function_\">runAfterBothAsync</span><span class=\"params\">(CompletionStage&lt;?&gt; other, Runnable action)</span>;</span><br><span class=\"line\"><span class=\"comment\">// 使用自定义线程池中的线程</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> CompletableFuture&lt;Void&gt; <span class=\"title function_\">runAfterBothAsync</span><span class=\"params\">(CompletionStage&lt;?&gt; other, Runnable action, Executor executor)</span>;</span><br></pre></td></tr></table></figure></li>\n<li>示例代码<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">// TODO 任务一</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;任务一的结果&quot;</span>;</span><br><span class=\"line\">&#125;).runAfterBothAsync(CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">// TODO 任务二</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;任务二的结果&quot;</span>;</span><br><span class=\"line\">&#125;), () -&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">// TODO 任务一和任务二都完成时执行的回调方法</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"“或”组合、接返回值、有返回值\"><a href=\"#“或”组合、接返回值、有返回值\" class=\"headerlink\" title=\"“或”组合、接返回值、有返回值\"></a>“或”组合、接返回值、有返回值</h3><blockquote>\n<p>将两个任务组合，其中任意一个任务执行完成，将该任务的结果作为参数，传递到回调方法中，回调方法有返回值</p>\n</blockquote>\n<ul>\n<li>方法签名<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用调用它的线程上运行（一般是主线程）</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class=\"title function_\">applyToEither</span><span class=\"params\">(CompletionStage&lt;? extends T&gt; other, Function&lt;? <span class=\"built_in\">super</span> T, U&gt; fn)</span>;</span><br><span class=\"line\"><span class=\"comment\">// 使用默认线程池中的线程</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class=\"title function_\">applyToEitherAsync</span><span class=\"params\">(CompletionStage&lt;? extends T&gt; other, Function&lt;? <span class=\"built_in\">super</span> T, U&gt; fn)</span>;</span><br><span class=\"line\"><span class=\"comment\">// 使用自定义线程池中的线程</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class=\"title function_\">applyToEitherAsync</span><span class=\"params\">(CompletionStage&lt;? extends T&gt; other, Function&lt;? <span class=\"built_in\">super</span> T, U&gt; fn, Executor executor)</span>;</span><br></pre></td></tr></table></figure></li>\n<li>示例代码<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">// TODO 任务一</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;任务一的结果&quot;</span>;</span><br><span class=\"line\">&#125;).applyToEitherAsync(CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">// TODO 任务二</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;任务二的结果&quot;</span>;</span><br><span class=\"line\">&#125;), (result) -&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">// TODO 任务一和任务二任意一个执行完成时执行的回调方法</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;SUCCESS&quot;</span>;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"“或”组合、接返回值、无返回值\"><a href=\"#“或”组合、接返回值、无返回值\" class=\"headerlink\" title=\"“或”组合、接返回值、无返回值\"></a>“或”组合、接返回值、无返回值</h3><blockquote>\n<p>将两个任务组合，其中任意一个任务执行完成，将该任务的结果作为参数，传递到回调方法中，回调方法无返回值</p>\n</blockquote>\n<ul>\n<li>方法签名<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用调用它的线程上运行（一般是主线程）</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> CompletableFuture&lt;Void&gt; <span class=\"title function_\">acceptEither</span><span class=\"params\">(CompletionStage&lt;? extends T&gt; other, Consumer&lt;? <span class=\"built_in\">super</span> T&gt; action)</span>;</span><br><span class=\"line\"><span class=\"comment\">// 使用默认线程池中的线程</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> CompletableFuture&lt;Void&gt; <span class=\"title function_\">acceptEitherAsync</span><span class=\"params\">(CompletionStage&lt;? extends T&gt; other, Consumer&lt;? <span class=\"built_in\">super</span> T&gt; action)</span>;</span><br><span class=\"line\"><span class=\"comment\">// 使用自定义线程池中的线程</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> CompletableFuture&lt;Void&gt; <span class=\"title function_\">acceptEitherAsync</span><span class=\"params\">(CompletionStage&lt;? extends T&gt; other, Consumer&lt;? <span class=\"built_in\">super</span> T&gt; action, Executor executor)</span>;</span><br></pre></td></tr></table></figure></li>\n<li>示例代码<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">// TODO 任务一</span></span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        Thread.sleep(<span class=\"number\">10</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RuntimeException</span>(e);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;任务一的结果&quot;</span>;</span><br><span class=\"line\">&#125;).acceptEitherAsync(CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">// TODO 任务二</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;任务二的结果&quot;</span>;</span><br><span class=\"line\">&#125;), (result) -&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">// TODO 任务一和任务二任意一个执行完成时执行的回调方法</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"“或”组合、不接参数、无返回值\"><a href=\"#“或”组合、不接参数、无返回值\" class=\"headerlink\" title=\"“或”组合、不接参数、无返回值\"></a>“或”组合、不接参数、无返回值</h3><blockquote>\n<p>将两个任务组合，其中任意一个任务执行完成，执行回调方法，回调方法无返回值</p>\n</blockquote>\n<ul>\n<li>方法签名<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用调用它的线程上运行（一般是主线程）</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> CompletableFuture&lt;Void&gt; <span class=\"title function_\">runAfterEither</span><span class=\"params\">(CompletionStage&lt;?&gt; other, Runnable action)</span>;</span><br><span class=\"line\"><span class=\"comment\">// 使用默认线程池中的线程</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> CompletableFuture&lt;Void&gt; <span class=\"title function_\">runAfterEitherAsync</span><span class=\"params\">(CompletionStage&lt;?&gt; other, Runnable action)</span>;</span><br><span class=\"line\"><span class=\"comment\">// 使用自定义线程池中的线程</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> CompletableFuture&lt;Void&gt; <span class=\"title function_\">runAfterEitherAsync</span><span class=\"params\">(CompletionStage&lt;?&gt; other, Runnable action, Executor executor)</span>;</span><br></pre></td></tr></table></figure></li>\n<li>示例代码<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">// TODO 任务一</span></span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        Thread.sleep(<span class=\"number\">10</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RuntimeException</span>(e);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;任务一的结果&quot;</span>;</span><br><span class=\"line\">&#125;).runAfterEitherAsync(CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">// TODO 任务二</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;任务二的结果&quot;</span>;</span><br><span class=\"line\">&#125;), () -&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">// TODO 任务一和任务二任意一个执行完成时执行的回调方法</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h1 id=\"多个任务组合\"><a href=\"#多个任务组合\" class=\"headerlink\" title=\"多个任务组合\"></a>多个任务组合</h1><h3 id=\"“任意一个”组合\"><a href=\"#“任意一个”组合\" class=\"headerlink\" title=\"“任意一个”组合\"></a>“任意一个”组合</h3><blockquote>\n<p>将多个任务组合，其中任意一个任务执行完成即可拿到该任务的执行结果（执行结果为Object类型），或执行接下来的任务</p>\n</blockquote>\n<ul>\n<li>方法签名<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> CompletableFuture&lt;Object&gt; <span class=\"title function_\">anyOf</span><span class=\"params\">(CompletableFuture&lt;?&gt;... cfs)</span>;</span><br></pre></td></tr></table></figure></li>\n<li>示例代码<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CompletableFuture&lt;String&gt; task1 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;任务一的结果&quot;</span>;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">CompletableFuture&lt;String&gt; task2 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;任务二的结果&quot;</span>;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">Object</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> CompletableFuture.anyOf(task1, task2).join();</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"“所有”组合\"><a href=\"#“所有”组合\" class=\"headerlink\" title=\"“所有”组合\"></a>“所有”组合</h3><blockquote>\n<p>将多个任务组合，当所有任务都执行完成后执行接下来的任务</p>\n</blockquote>\n<ul>\n<li>方法签名<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> CompletableFuture&lt;Void&gt; <span class=\"title function_\">allOf</span><span class=\"params\">(CompletableFuture&lt;?&gt;... cfs)</span>;</span><br></pre></td></tr></table></figure></li>\n<li>示例代码<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CompletableFuture&lt;String&gt; task1 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;任务一的结果&quot;</span>;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">CompletableFuture&lt;String&gt; task2 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;任务二的结果&quot;</span>;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">Object</span> <span class=\"variable\">join</span> <span class=\"operator\">=</span> CompletableFuture.allOf(task1, task2).join();</span><br></pre></td></tr></table></figure></li>\n</ul>\n","site":{"data":{}},"cover_type":"img","excerpt":"","more":"<blockquote>\n<p>CompletableFuture类提供了非常强大的Future的扩展功能，可以帮助我们简化异步编程的复杂性，提供了函数式编程的能力，可以通过回调的方式处理计算结果，并且提供了转换和组合CompletableFuture的方法。</p>\n</blockquote>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><table>\n    <tr>\n        <th>分类</th>\n        <th>方法名</th>\n        <th>描述</th>\n    </tr>\n    <tr>\n        <th rowspan=\"2\">创建异步任务</th>\n        <td><code>runAsync</code></td>\n        <td>不支持返回值</td>\n    </tr>\n    <tr>\n        <td><code>supplyAsync</code></td>\n        <td>支持返回值</td>\n    </tr>\n    <tr>\n        <th rowspan=\"6\">创建异步任务</th>\n        <td><code>thenRun</code>、<code>thenRunAsync</code></td>\n        <td>不接参数、无返回值</td>\n    </tr>\n    <tr>\n        <td><code>thenAccept</code>、<code>thenAcceptAsync</code></td>\n        <td>接返回值、无返回值</td>\n    </tr>\n    <tr>\n        <td><code>thenApply</code>、<code>thenApplyAsync</code></td>\n        <td>接返回值、有返回值</td>\n    </tr>\n    <tr>\n        <td><code>exceptionally</code>、<code>exceptionallyAsync</code></td>\n        <td>接异常、有返回值</td>\n    </tr>\n    <tr>\n        <td><code>whenComplete</code>、<code>whenCompleteAsync</code></td>\n        <td>接返回值和异常、无返回值</td>\n    </tr>\n    <tr>\n        <td><code>handle</code>、<code>handleAsync</code></td>\n        <td>接返回值和异常、有返回值</td>\n    </tr>\n    <tr>\n        <th rowspan=\"7\">两个任务组合</th>\n        <td><code>thenCompose</code>、<code>thenComposeAsync</code></td>\n        <td>任务转化</td>\n    </tr>\n    <tr>\n        <td><code>thenCombine</code>、<code>thenCombineAsync</code></td>\n        <td>“且”组合、接返回值、有返回值</td>\n    </tr>\n    <tr>\n        <td><code>thenAcceptBoth</code>、<code>thenAcceptBothAsync</code></td>\n        <td>“且”组合、接返回值、无返回值</td>\n    </tr>\n    <tr>\n        <td><code>runAfterBoth</code>、<code>runAfterBothAsync</code></td>\n        <td>“且”组合、不接参数、无返回值</td>\n    </tr>\n    <tr>\n        <td><code>applyToEither</code>、<code>applyToEitherAsync</code></td>\n        <td>“或”组合、接返回值、有返回值</td>\n    </tr>\n    <tr>\n        <td><code>acceptEither</code>、<code>acceptEitherAsync</code></td>\n        <td>“或”组合、接返回值、无返回值</td>\n    </tr>\n    <tr>\n        <td><code>runAfterEither</code>、<code>runAfterEitherAsync</code></td>\n        <td>“或”组合、不接参数、无返回值</td>\n    </tr>\n    <tr>\n        <th rowspan=\"2\">多个任务组合</th>\n        <td><code>anyOf</code></td>\n        <td>“任意一个”组合</td>\n    </tr>\n    <tr>\n        <td><code>allOf</code></td>\n        <td>“所有”组合</td>\n    </tr>\n</table>\n\n<blockquote>\n<p>在CompletableFuture中如果使用没有指定线程池的方法，则会使用<code>ForkJoinPool.commonPool()</code>作为它的线程池执行异步代码。</p>\n</blockquote>\n<h1 id=\"创建异步任务\"><a href=\"#创建异步任务\" class=\"headerlink\" title=\"创建异步任务\"></a>创建异步任务</h1><h3 id=\"不支持返回值\"><a href=\"#不支持返回值\" class=\"headerlink\" title=\"不支持返回值\"></a>不支持返回值</h3><ul>\n<li>方法签名<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用默认线程池中的线程</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> CompletableFuture&lt;Void&gt; <span class=\"title function_\">runAsync</span><span class=\"params\">(Runnable runnable)</span>;</span><br><span class=\"line\"><span class=\"comment\">// 使用自定义线程池中的线程</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> CompletableFuture&lt;Void&gt; <span class=\"title function_\">runAsync</span><span class=\"params\">(Runnable runnable, Executor executor)</span>; </span><br></pre></td></tr></table></figure></li>\n<li>示例代码<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">// TODO 执行任务</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"支持返回值\"><a href=\"#支持返回值\" class=\"headerlink\" title=\"支持返回值\"></a>支持返回值</h3><ul>\n<li><p>方法签名</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用默认线程池中的线程</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class=\"title function_\">supplyAsync</span><span class=\"params\">(Supplier&lt;U&gt; supplier)</span>;</span><br><span class=\"line\"><span class=\"comment\">// 使用自定义线程池中的线程</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class=\"title function_\">supplyAsync</span><span class=\"params\">(Supplier&lt;U&gt; supplier, Executor executor)</span>; </span><br></pre></td></tr></table></figure>\n</li>\n<li><p>示例代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">// TODO 执行任务</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h1 id=\"任务完成时回调方法\"><a href=\"#任务完成时回调方法\" class=\"headerlink\" title=\"任务完成时回调方法\"></a>任务完成时回调方法</h1><p>当CompletableFuture任务执行完成或者抛出异常的时候，可以执行特定的回调方法。</p>\n<h3 id=\"不接参数、无返回值\"><a href=\"#不接参数、无返回值\" class=\"headerlink\" title=\"不接参数、无返回值\"></a>不接参数、无返回值</h3><blockquote>\n<p>前一个任务执行完成后执行；任务之间<strong>无参数传递</strong>，回调方法<strong>无返回值</strong></p>\n</blockquote>\n<ul>\n<li>方法签名<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用调用它的线程上运行（一般是主线程）</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> CompletableFuture&lt;Void&gt; <span class=\"title function_\">thenRun</span><span class=\"params\">(Runnable action)</span>;</span><br><span class=\"line\"><span class=\"comment\">// 使用默认线程池中的线程</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> CompletableFuture&lt;Void&gt; <span class=\"title function_\">thenRunAsync</span><span class=\"params\">(Runnable action)</span>;</span><br><span class=\"line\"><span class=\"comment\">// 使用自定义线程池中的线程</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> CompletableFuture&lt;Void&gt; <span class=\"title function_\">thenRunAsync</span><span class=\"params\">(Runnable action, Executor executor)</span>;</span><br></pre></td></tr></table></figure></li>\n<li>示例代码<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class=\"line\">&#125;).thenRun(() -&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">// TODO 执行任务</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"接返回值、无返回值\"><a href=\"#接返回值、无返回值\" class=\"headerlink\" title=\"接返回值、无返回值\"></a>接返回值、无返回值</h3><blockquote>\n<p>前一个任务执行完成后执行；前一个任务会将执行结果<strong>作为参数</strong>，传递到回调方法中，回调方法<strong>无返回值</strong></p>\n</blockquote>\n<ul>\n<li>方法签名<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用调用它的线程上运行（一般是主线程）</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> CompletableFuture&lt;Void&gt; <span class=\"title function_\">thenAccept</span><span class=\"params\">(Consumer&lt;? <span class=\"built_in\">super</span> T&gt; action)</span>;</span><br><span class=\"line\"><span class=\"comment\">// 使用默认线程池中的线程</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> CompletableFuture&lt;Void&gt; <span class=\"title function_\">thenAcceptAsync</span><span class=\"params\">(Consumer&lt;? <span class=\"built_in\">super</span> T&gt; action)</span>;</span><br><span class=\"line\"><span class=\"comment\">// 使用自定义线程池中的线程</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> CompletableFuture&lt;Void&gt; <span class=\"title function_\">thenAcceptAsync</span><span class=\"params\">(Consumer&lt;? <span class=\"built_in\">super</span> T&gt; action, Executor executor)</span>;</span><br></pre></td></tr></table></figure></li>\n<li>示例代码<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;Result&quot;</span>;</span><br><span class=\"line\">&#125;).thenAccept((result) -&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">// TODO 执行任务</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"接返回值、有返回值\"><a href=\"#接返回值、有返回值\" class=\"headerlink\" title=\"接返回值、有返回值\"></a>接返回值、有返回值</h3><blockquote>\n<p>前一个任务执行完成后执行；前一个任务会将执行结果<strong>作为参数</strong>，传递到回调方法中，并且会调方法<strong>有返回值</strong></p>\n</blockquote>\n<ul>\n<li>方法签名<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用调用它的线程上运行（一般是主线程）</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class=\"title function_\">thenApply</span><span class=\"params\">(Function&lt;? <span class=\"built_in\">super</span> T,? extends U&gt; fn)</span>;</span><br><span class=\"line\"><span class=\"comment\">// 使用默认线程池中的线程</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class=\"title function_\">thenApplyAsync</span><span class=\"params\">(Function&lt;? <span class=\"built_in\">super</span> T,? extends U&gt; fn)</span>;</span><br><span class=\"line\"><span class=\"comment\">// 使用自定义线程池中的线程</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class=\"title function_\">thenApplyAsync</span><span class=\"params\">(Function&lt;? <span class=\"built_in\">super</span> T,? extends U&gt; fn, Executor executor)</span>;</span><br></pre></td></tr></table></figure></li>\n<li>示例代码<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;Result_1&quot;</span>;</span><br><span class=\"line\">&#125;).thenApply(() -&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">// TODO 执行任务</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;Result_2&quot;</span>;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"接异常、有返回值\"><a href=\"#接异常、有返回值\" class=\"headerlink\" title=\"接异常、有返回值\"></a>接异常、有返回值</h3><blockquote>\n<p>某个任务执行异常时执行；异常任务抛出的异常<strong>作为参数</strong>，传递到回调方法中，并且会调方法<strong>有返回值</strong></p>\n</blockquote>\n<ul>\n<li>方法签名<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用调用它的线程上运行（一般是主线程）</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> CompletableFuture&lt;T&gt; <span class=\"title function_\">exceptionally</span><span class=\"params\">(Function&lt;Throwable, ? extends T&gt; fn)</span>;</span><br><span class=\"line\"><span class=\"comment\">// 使用默认线程池中的线程</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> CompletableFuture&lt;T&gt; <span class=\"title function_\">exceptionallyAsync</span><span class=\"params\">(Function&lt;Throwable, ? extends T&gt; fn)</span>;</span><br><span class=\"line\"><span class=\"comment\">// 使用自定义线程池中的线程</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> CompletableFuture&lt;T&gt; <span class=\"title function_\">exceptionallyAsync</span><span class=\"params\">(Function&lt;Throwable, ? extends T&gt; fn, Executor executor)</span>;</span><br></pre></td></tr></table></figure></li>\n<li>示例代码<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RuntimeException</span>();</span><br><span class=\"line\">&#125;).exceptionally((exception) -&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">// TODO 处理异常</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;ERROR!&quot;</span>;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"接返回值和异常、无返回值\"><a href=\"#接返回值和异常、无返回值\" class=\"headerlink\" title=\"接返回值和异常、无返回值\"></a>接返回值和异常、无返回值</h3><blockquote>\n<p>前一个任务执行完成或出现异常时执行；前一个任务会将结果或抛出的异常<strong>作为参数</strong>，传递到回调方法中，回调方法<strong>无返回值</strong></p>\n</blockquote>\n<ul>\n<li>方法签名<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用调用它的线程上运行（一般是主线程）</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> CompletableFuture&lt;T&gt; <span class=\"title function_\">whenComplete</span><span class=\"params\">(BiConsumer&lt;? <span class=\"built_in\">super</span> T, ? <span class=\"built_in\">super</span> Throwable&gt; action)</span>;</span><br><span class=\"line\"><span class=\"comment\">// 使用默认线程池中的线程</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> CompletableFuture&lt;T&gt; <span class=\"title function_\">whenCompleteAsync</span><span class=\"params\">(BiConsumer&lt;? <span class=\"built_in\">super</span> T, ? <span class=\"built_in\">super</span> Throwable&gt; action)</span>;</span><br><span class=\"line\"><span class=\"comment\">// 使用自定义线程池中的线程</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> CompletableFuture&lt;T&gt; <span class=\"title function_\">whenCompleteAsync</span><span class=\"params\">(BiConsumer&lt;? <span class=\"built_in\">super</span> T, ? <span class=\"built_in\">super</span> Throwable&gt; action, Executor executor)</span>;</span><br></pre></td></tr></table></figure></li>\n<li>示例代码<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RuntimeException</span>();</span><br><span class=\"line\">&#125;).whenCompleteAsync((result, exception) -&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (exception != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// TODO 处理异常</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// TODO 执行任务</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"接返回值和异常、有返回值\"><a href=\"#接返回值和异常、有返回值\" class=\"headerlink\" title=\"接返回值和异常、有返回值\"></a>接返回值和异常、有返回值</h3><blockquote>\n<p>前一个任务执行完成后执行；前一个任务会将结果或抛出的异常<strong>作为参数</strong>，传递到回调方法中，回调方法<strong>有返回值</strong></p>\n</blockquote>\n<ul>\n<li>方法签名<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用调用它的线程上运行（一般是主线程）</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class=\"title function_\">handle</span><span class=\"params\">(BiFunction&lt;? <span class=\"built_in\">super</span> T, Throwable, ? extends U&gt; fn)</span>;</span><br><span class=\"line\"><span class=\"comment\">// 使用默认线程池中的线程</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class=\"title function_\">handleAsync</span><span class=\"params\">(BiFunction&lt;? <span class=\"built_in\">super</span> T, Throwable, ? extends U&gt; fn)</span>;</span><br><span class=\"line\"><span class=\"comment\">// 使用自定义线程池中的线程</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class=\"title function_\">handleAsync</span><span class=\"params\">(BiFunction&lt;? <span class=\"built_in\">super</span> T, Throwable, ? extends U&gt; fn, Executor executor)</span>;</span><br></pre></td></tr></table></figure></li>\n<li>示例代码<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RuntimeException</span>();</span><br><span class=\"line\">&#125;).handleAsync((result, exception) -&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (exception != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// TODO 处理异常</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;ERROR!&quot;</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 执行任务</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;SUCCESS!&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h1 id=\"两个任务组合\"><a href=\"#两个任务组合\" class=\"headerlink\" title=\"两个任务组合\"></a>两个任务组合</h1><h3 id=\"任务转化\"><a href=\"#任务转化\" class=\"headerlink\" title=\"任务转化\"></a>任务转化</h3><blockquote>\n<p>将前一个任务的执行结果<strong>作为参数</strong>进行处理，处理后<strong>返回一个新的任务</strong></p>\n</blockquote>\n<ul>\n<li>方法签名<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用调用它的线程上运行（一般是主线程）</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class=\"title function_\">thenCompose</span><span class=\"params\">(Function&lt;? <span class=\"built_in\">super</span> T, ? extends CompletionStage&lt;U&gt;&gt; fn)</span>;</span><br><span class=\"line\"><span class=\"comment\">// 使用默认线程池中的线程</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class=\"title function_\">thenComposeAsync</span><span class=\"params\">(Function&lt;? <span class=\"built_in\">super</span> T, ? extends CompletionStage&lt;U&gt;&gt; fn)</span>;</span><br><span class=\"line\"><span class=\"comment\">// 使用自定义线程池中的线程</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class=\"title function_\">thenComposeAsync</span><span class=\"params\">(Function&lt;? <span class=\"built_in\">super</span> T, ? extends CompletionStage&lt;U&gt;&gt; fn, Executor executor)</span>;</span><br></pre></td></tr></table></figure></li>\n<li>示例代码<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CompletableFuture&lt;String&gt; task = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;任务一的结果&quot;</span>;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">CompletableFuture&lt;String&gt; stringCompletableFuture = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;任务二的结果&quot;</span>;</span><br><span class=\"line\">&#125;).thenComposeAsync((result) -&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">// TODO 执行任务</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> task;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"“且”组合、接返回值、有返回值\"><a href=\"#“且”组合、接返回值、有返回值\" class=\"headerlink\" title=\"“且”组合、接返回值、有返回值\"></a>“且”组合、接返回值、有返回值</h3><blockquote>\n<p>将两个任务组合，当两个任务都正常执行完了，将两个任务的结果作为参数，传递到回调方法中，回调方法有返回值</p>\n</blockquote>\n<ul>\n<li>方法签名<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用调用它的线程上运行（一般是主线程）</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> &lt;U,V&gt; CompletableFuture&lt;V&gt; <span class=\"title function_\">thenCombine</span><span class=\"params\">(CompletionStage&lt;? extends U&gt; other, BiFunction&lt;? <span class=\"built_in\">super</span> T,? <span class=\"built_in\">super</span> U,? extends V&gt; fn)</span>;</span><br><span class=\"line\"><span class=\"comment\">// 使用默认线程池中的线程</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> &lt;U,V&gt; CompletableFuture&lt;V&gt; <span class=\"title function_\">thenCombineAsync</span><span class=\"params\">(CompletionStage&lt;? extends U&gt; other, BiFunction&lt;? <span class=\"built_in\">super</span> T,? <span class=\"built_in\">super</span> U,? extends V&gt; fn)</span>;</span><br><span class=\"line\"><span class=\"comment\">// 使用自定义线程池中的线程</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> &lt;U,V&gt; CompletableFuture&lt;V&gt; <span class=\"title function_\">thenCombineAsync</span><span class=\"params\">(CompletionStage&lt;? extends U&gt; other, BiFunction&lt;? <span class=\"built_in\">super</span> T,? <span class=\"built_in\">super</span> U,? extends V&gt; fn, Executor executor)</span>;</span><br></pre></td></tr></table></figure></li>\n<li>示例代码<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">// TODO 任务一</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;任务一的结果&quot;</span>;</span><br><span class=\"line\">&#125;).thenCombineAsync(CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">// TODO 任务二</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;任务二的结果&quot;</span>;</span><br><span class=\"line\">&#125;), (result1, result2) -&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 任务一和任务二都完成时执行的回调方法</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"“且”组合、接返回值、无返回值\"><a href=\"#“且”组合、接返回值、无返回值\" class=\"headerlink\" title=\"“且”组合、接返回值、无返回值\"></a>“且”组合、接返回值、无返回值</h3><blockquote>\n<p>将两个任务组合，当两个任务都正常执行完了，将两个任务的结果作为参数，传递到回调方法中，回调方法无返回值</p>\n</blockquote>\n<ul>\n<li>方法签名<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用调用它的线程上运行（一般是主线程）</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> &lt;U&gt; CompletableFuture&lt;Void&gt; <span class=\"title function_\">thenAcceptBoth</span><span class=\"params\">(CompletionStage&lt;? extends U&gt; other, BiConsumer&lt;? <span class=\"built_in\">super</span> T, ? <span class=\"built_in\">super</span> U&gt; action)</span>;</span><br><span class=\"line\"><span class=\"comment\">// 使用默认线程池中的线程</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> &lt;U&gt; CompletableFuture&lt;Void&gt; <span class=\"title function_\">thenAcceptBothAsync</span><span class=\"params\">(CompletionStage&lt;? extends U&gt; other, BiConsumer&lt;? <span class=\"built_in\">super</span> T, ? <span class=\"built_in\">super</span> U&gt; action)</span>;</span><br><span class=\"line\"><span class=\"comment\">// 使用自定义线程池中的线程</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> &lt;U&gt; CompletableFuture&lt;Void&gt; <span class=\"title function_\">thenAcceptBothAsync</span><span class=\"params\">(CompletionStage&lt;? extends U&gt; other, BiConsumer&lt;? <span class=\"built_in\">super</span> T, ? <span class=\"built_in\">super</span> U&gt; action, Executor executor)</span>;</span><br></pre></td></tr></table></figure></li>\n<li>示例代码<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">// TODO 任务一</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;任务一的结果&quot;</span>;</span><br><span class=\"line\">&#125;).thenAcceptBothAsync(CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">// TODO 任务二</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;任务二的结果&quot;</span>;</span><br><span class=\"line\">&#125;), (result1, result2) -&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">// TODO 任务一和任务二都完成时执行的回调方法</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"“且”组合、不接参数、无返回值\"><a href=\"#“且”组合、不接参数、无返回值\" class=\"headerlink\" title=\"“且”组合、不接参数、无返回值\"></a>“且”组合、不接参数、无返回值</h3><blockquote>\n<p>将两个任务组合，当两个任务都正常执行完了，执行回调方法，回调方法无返回值</p>\n</blockquote>\n<ul>\n<li>方法签名<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用调用它的线程上运行（一般是主线程）</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> CompletableFuture&lt;Void&gt; <span class=\"title function_\">runAfterBoth</span><span class=\"params\">(CompletionStage&lt;?&gt; other, Runnable action)</span>;</span><br><span class=\"line\"><span class=\"comment\">// 使用默认线程池中的线程</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> CompletableFuture&lt;Void&gt; <span class=\"title function_\">runAfterBothAsync</span><span class=\"params\">(CompletionStage&lt;?&gt; other, Runnable action)</span>;</span><br><span class=\"line\"><span class=\"comment\">// 使用自定义线程池中的线程</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> CompletableFuture&lt;Void&gt; <span class=\"title function_\">runAfterBothAsync</span><span class=\"params\">(CompletionStage&lt;?&gt; other, Runnable action, Executor executor)</span>;</span><br></pre></td></tr></table></figure></li>\n<li>示例代码<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">// TODO 任务一</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;任务一的结果&quot;</span>;</span><br><span class=\"line\">&#125;).runAfterBothAsync(CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">// TODO 任务二</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;任务二的结果&quot;</span>;</span><br><span class=\"line\">&#125;), () -&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">// TODO 任务一和任务二都完成时执行的回调方法</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"“或”组合、接返回值、有返回值\"><a href=\"#“或”组合、接返回值、有返回值\" class=\"headerlink\" title=\"“或”组合、接返回值、有返回值\"></a>“或”组合、接返回值、有返回值</h3><blockquote>\n<p>将两个任务组合，其中任意一个任务执行完成，将该任务的结果作为参数，传递到回调方法中，回调方法有返回值</p>\n</blockquote>\n<ul>\n<li>方法签名<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用调用它的线程上运行（一般是主线程）</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class=\"title function_\">applyToEither</span><span class=\"params\">(CompletionStage&lt;? extends T&gt; other, Function&lt;? <span class=\"built_in\">super</span> T, U&gt; fn)</span>;</span><br><span class=\"line\"><span class=\"comment\">// 使用默认线程池中的线程</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class=\"title function_\">applyToEitherAsync</span><span class=\"params\">(CompletionStage&lt;? extends T&gt; other, Function&lt;? <span class=\"built_in\">super</span> T, U&gt; fn)</span>;</span><br><span class=\"line\"><span class=\"comment\">// 使用自定义线程池中的线程</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class=\"title function_\">applyToEitherAsync</span><span class=\"params\">(CompletionStage&lt;? extends T&gt; other, Function&lt;? <span class=\"built_in\">super</span> T, U&gt; fn, Executor executor)</span>;</span><br></pre></td></tr></table></figure></li>\n<li>示例代码<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">// TODO 任务一</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;任务一的结果&quot;</span>;</span><br><span class=\"line\">&#125;).applyToEitherAsync(CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">// TODO 任务二</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;任务二的结果&quot;</span>;</span><br><span class=\"line\">&#125;), (result) -&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">// TODO 任务一和任务二任意一个执行完成时执行的回调方法</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;SUCCESS&quot;</span>;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"“或”组合、接返回值、无返回值\"><a href=\"#“或”组合、接返回值、无返回值\" class=\"headerlink\" title=\"“或”组合、接返回值、无返回值\"></a>“或”组合、接返回值、无返回值</h3><blockquote>\n<p>将两个任务组合，其中任意一个任务执行完成，将该任务的结果作为参数，传递到回调方法中，回调方法无返回值</p>\n</blockquote>\n<ul>\n<li>方法签名<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用调用它的线程上运行（一般是主线程）</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> CompletableFuture&lt;Void&gt; <span class=\"title function_\">acceptEither</span><span class=\"params\">(CompletionStage&lt;? extends T&gt; other, Consumer&lt;? <span class=\"built_in\">super</span> T&gt; action)</span>;</span><br><span class=\"line\"><span class=\"comment\">// 使用默认线程池中的线程</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> CompletableFuture&lt;Void&gt; <span class=\"title function_\">acceptEitherAsync</span><span class=\"params\">(CompletionStage&lt;? extends T&gt; other, Consumer&lt;? <span class=\"built_in\">super</span> T&gt; action)</span>;</span><br><span class=\"line\"><span class=\"comment\">// 使用自定义线程池中的线程</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> CompletableFuture&lt;Void&gt; <span class=\"title function_\">acceptEitherAsync</span><span class=\"params\">(CompletionStage&lt;? extends T&gt; other, Consumer&lt;? <span class=\"built_in\">super</span> T&gt; action, Executor executor)</span>;</span><br></pre></td></tr></table></figure></li>\n<li>示例代码<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">// TODO 任务一</span></span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        Thread.sleep(<span class=\"number\">10</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RuntimeException</span>(e);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;任务一的结果&quot;</span>;</span><br><span class=\"line\">&#125;).acceptEitherAsync(CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">// TODO 任务二</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;任务二的结果&quot;</span>;</span><br><span class=\"line\">&#125;), (result) -&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">// TODO 任务一和任务二任意一个执行完成时执行的回调方法</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"“或”组合、不接参数、无返回值\"><a href=\"#“或”组合、不接参数、无返回值\" class=\"headerlink\" title=\"“或”组合、不接参数、无返回值\"></a>“或”组合、不接参数、无返回值</h3><blockquote>\n<p>将两个任务组合，其中任意一个任务执行完成，执行回调方法，回调方法无返回值</p>\n</blockquote>\n<ul>\n<li>方法签名<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用调用它的线程上运行（一般是主线程）</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> CompletableFuture&lt;Void&gt; <span class=\"title function_\">runAfterEither</span><span class=\"params\">(CompletionStage&lt;?&gt; other, Runnable action)</span>;</span><br><span class=\"line\"><span class=\"comment\">// 使用默认线程池中的线程</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> CompletableFuture&lt;Void&gt; <span class=\"title function_\">runAfterEitherAsync</span><span class=\"params\">(CompletionStage&lt;?&gt; other, Runnable action)</span>;</span><br><span class=\"line\"><span class=\"comment\">// 使用自定义线程池中的线程</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> CompletableFuture&lt;Void&gt; <span class=\"title function_\">runAfterEitherAsync</span><span class=\"params\">(CompletionStage&lt;?&gt; other, Runnable action, Executor executor)</span>;</span><br></pre></td></tr></table></figure></li>\n<li>示例代码<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">// TODO 任务一</span></span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        Thread.sleep(<span class=\"number\">10</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RuntimeException</span>(e);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;任务一的结果&quot;</span>;</span><br><span class=\"line\">&#125;).runAfterEitherAsync(CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">// TODO 任务二</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;任务二的结果&quot;</span>;</span><br><span class=\"line\">&#125;), () -&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">// TODO 任务一和任务二任意一个执行完成时执行的回调方法</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h1 id=\"多个任务组合\"><a href=\"#多个任务组合\" class=\"headerlink\" title=\"多个任务组合\"></a>多个任务组合</h1><h3 id=\"“任意一个”组合\"><a href=\"#“任意一个”组合\" class=\"headerlink\" title=\"“任意一个”组合\"></a>“任意一个”组合</h3><blockquote>\n<p>将多个任务组合，其中任意一个任务执行完成即可拿到该任务的执行结果（执行结果为Object类型），或执行接下来的任务</p>\n</blockquote>\n<ul>\n<li>方法签名<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> CompletableFuture&lt;Object&gt; <span class=\"title function_\">anyOf</span><span class=\"params\">(CompletableFuture&lt;?&gt;... cfs)</span>;</span><br></pre></td></tr></table></figure></li>\n<li>示例代码<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CompletableFuture&lt;String&gt; task1 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;任务一的结果&quot;</span>;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">CompletableFuture&lt;String&gt; task2 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;任务二的结果&quot;</span>;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">Object</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> CompletableFuture.anyOf(task1, task2).join();</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"“所有”组合\"><a href=\"#“所有”组合\" class=\"headerlink\" title=\"“所有”组合\"></a>“所有”组合</h3><blockquote>\n<p>将多个任务组合，当所有任务都执行完成后执行接下来的任务</p>\n</blockquote>\n<ul>\n<li>方法签名<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> CompletableFuture&lt;Void&gt; <span class=\"title function_\">allOf</span><span class=\"params\">(CompletableFuture&lt;?&gt;... cfs)</span>;</span><br></pre></td></tr></table></figure></li>\n<li>示例代码<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CompletableFuture&lt;String&gt; task1 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;任务一的结果&quot;</span>;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">CompletableFuture&lt;String&gt; task2 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;任务二的结果&quot;</span>;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">Object</span> <span class=\"variable\">join</span> <span class=\"operator\">=</span> CompletableFuture.allOf(task1, task2).join();</span><br></pre></td></tr></table></figure></li>\n</ul>\n"},{"title":"单节点单硬盘部署MinIO","date":"2024-04-13T13:56:39.000Z","cover":"../img/minio/minio.svg","_content":"# 一、新建目录\n``` Shell\ncd /use/local\nmkdir minio\n```\n# 二、新建日志文件\n``` Shell\ncd ./minio\ntouch minio.log\n```\n# 三、下载minio文件\n``` Java\nwget https://dl.minio.io/server/minio/release/linux-amd64/minio\n```\n# 四、给minio文件赋予777权限，可写可读都执行\n``` Shell\nchmod 777 minio\n```\n# 五、设置环境变量\n``` Shell\nvim /etc/profile\n\n# 在文件末尾添加一下内容\n# minio环境变量\nexport MINIO_ROOT_USER=myminioadmin\nexport MINIO_ROOT_PASSWORD=minio-secret-key-change-me\n```\n# 六、生效环境变量\n``` Shell\nsource /etc/profile\n```\n# 七、编写minio启动Shell脚本\n``` Shell\nvim startup.sh\n\n# 添加一下内容\nnohup /usr/local/minio/minio server  /usr/local/minio/data --console-address \":35555\" > /usr/local/minio/minio.log 2>&1 &\n```\n# 八、编写minio停止sh脚本\n``` Shell\nvim stop.sh\n\n# 添加以下内容\n#!/bin/bash\n\n# 查找 MinIO 进程的 PID\nminio_pid=$(ps aux | grep '/usr/local/minio/minio server' | grep -v 'grep' | awk '{print $2}')\n\n# 如果找到了 MinIO 进程的 PID，则终止该进程\nif [ -n \"$minio_pid\" ]; then\n    echo \"Stopping MinIO server...\"\n    kill $minio_pid\nelse\n    echo \"MinIO server is not running.\"\nfi\n```\n# 九、开发端口\n``` Shell\nfirewall-cmd --zone=public --add-port=9000/tcp --permanent\nfirewall-cmd --zone=public --add-port=35555/tcp --permanent\nfirewall-cmd –reload\n```\n# 十、启动或者停止脚本\n``` Shell\n# 启动脚本\nsh startup.sh\n\n# 停止脚本\nsh stop.sh\n\n``` \n# 十一、访问minio console\n``` java\n控制台：http://ip:35555\nAPI：http://ip:9000\n```\n# 十二、注意事项\n无法访问可查看minio.log文件或者重启服务器\n``` Shell\nshutdown -r now\n```","source":"_posts/2024-04-13-单节点单硬盘部署MinIO.md","raw":"---\ntitle: 单节点单硬盘部署MinIO\ndate: 2024-04-13 21:56:39\ncover: ../img/minio/minio.svg\ntags: [ Java,对象储存,Minio ]\ncategories:\n  - Minio\n---\n# 一、新建目录\n``` Shell\ncd /use/local\nmkdir minio\n```\n# 二、新建日志文件\n``` Shell\ncd ./minio\ntouch minio.log\n```\n# 三、下载minio文件\n``` Java\nwget https://dl.minio.io/server/minio/release/linux-amd64/minio\n```\n# 四、给minio文件赋予777权限，可写可读都执行\n``` Shell\nchmod 777 minio\n```\n# 五、设置环境变量\n``` Shell\nvim /etc/profile\n\n# 在文件末尾添加一下内容\n# minio环境变量\nexport MINIO_ROOT_USER=myminioadmin\nexport MINIO_ROOT_PASSWORD=minio-secret-key-change-me\n```\n# 六、生效环境变量\n``` Shell\nsource /etc/profile\n```\n# 七、编写minio启动Shell脚本\n``` Shell\nvim startup.sh\n\n# 添加一下内容\nnohup /usr/local/minio/minio server  /usr/local/minio/data --console-address \":35555\" > /usr/local/minio/minio.log 2>&1 &\n```\n# 八、编写minio停止sh脚本\n``` Shell\nvim stop.sh\n\n# 添加以下内容\n#!/bin/bash\n\n# 查找 MinIO 进程的 PID\nminio_pid=$(ps aux | grep '/usr/local/minio/minio server' | grep -v 'grep' | awk '{print $2}')\n\n# 如果找到了 MinIO 进程的 PID，则终止该进程\nif [ -n \"$minio_pid\" ]; then\n    echo \"Stopping MinIO server...\"\n    kill $minio_pid\nelse\n    echo \"MinIO server is not running.\"\nfi\n```\n# 九、开发端口\n``` Shell\nfirewall-cmd --zone=public --add-port=9000/tcp --permanent\nfirewall-cmd --zone=public --add-port=35555/tcp --permanent\nfirewall-cmd –reload\n```\n# 十、启动或者停止脚本\n``` Shell\n# 启动脚本\nsh startup.sh\n\n# 停止脚本\nsh stop.sh\n\n``` \n# 十一、访问minio console\n``` java\n控制台：http://ip:35555\nAPI：http://ip:9000\n```\n# 十二、注意事项\n无法访问可查看minio.log文件或者重启服务器\n``` Shell\nshutdown -r now\n```","slug":"2024-04-13-单节点单硬盘部署MinIO","published":1,"updated":"2024-04-13T14:27:28.772Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cly2c4k3k0004qsvd0r0bgq6a","content":"<h1 id=\"一、新建目录\"><a href=\"#一、新建目录\" class=\"headerlink\" title=\"一、新建目录\"></a>一、新建目录</h1><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd /use/local</span><br><span class=\"line\">mkdir minio</span><br></pre></td></tr></table></figure>\n<h1 id=\"二、新建日志文件\"><a href=\"#二、新建日志文件\" class=\"headerlink\" title=\"二、新建日志文件\"></a>二、新建日志文件</h1><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd ./minio</span><br><span class=\"line\">touch minio.log</span><br></pre></td></tr></table></figure>\n<h1 id=\"三、下载minio文件\"><a href=\"#三、下载minio文件\" class=\"headerlink\" title=\"三、下载minio文件\"></a>三、下载minio文件</h1><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget https:<span class=\"comment\">//dl.minio.io/server/minio/release/linux-amd64/minio</span></span><br></pre></td></tr></table></figure>\n<h1 id=\"四、给minio文件赋予777权限，可写可读都执行\"><a href=\"#四、给minio文件赋予777权限，可写可读都执行\" class=\"headerlink\" title=\"四、给minio文件赋予777权限，可写可读都执行\"></a>四、给minio文件赋予777权限，可写可读都执行</h1><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">chmod 777 minio</span><br></pre></td></tr></table></figure>\n<h1 id=\"五、设置环境变量\"><a href=\"#五、设置环境变量\" class=\"headerlink\" title=\"五、设置环境变量\"></a>五、设置环境变量</h1><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vim /etc/profile</span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">在文件末尾添加一下内容</span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">minio环境变量</span></span><br><span class=\"line\">export MINIO_ROOT_USER=myminioadmin</span><br><span class=\"line\">export MINIO_ROOT_PASSWORD=minio-secret-key-change-me</span><br></pre></td></tr></table></figure>\n<h1 id=\"六、生效环境变量\"><a href=\"#六、生效环境变量\" class=\"headerlink\" title=\"六、生效环境变量\"></a>六、生效环境变量</h1><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">source /etc/profile</span><br></pre></td></tr></table></figure>\n<h1 id=\"七、编写minio启动Shell脚本\"><a href=\"#七、编写minio启动Shell脚本\" class=\"headerlink\" title=\"七、编写minio启动Shell脚本\"></a>七、编写minio启动Shell脚本</h1><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vim startup.sh</span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">添加一下内容</span></span><br><span class=\"line\">nohup /usr/local/minio/minio server  /usr/local/minio/data --console-address &quot;:35555&quot; &gt; /usr/local/minio/minio.log 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure>\n<h1 id=\"八、编写minio停止sh脚本\"><a href=\"#八、编写minio停止sh脚本\" class=\"headerlink\" title=\"八、编写minio停止sh脚本\"></a>八、编写minio停止sh脚本</h1><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vim stop.sh</span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">添加以下内容</span></span><br><span class=\"line\"><span class=\"meta prompt_\">#</span><span class=\"language-bash\">!/bin/bash</span></span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">查找 MinIO 进程的 PID</span></span><br><span class=\"line\">minio_pid=$(ps aux | grep &#x27;/usr/local/minio/minio server&#x27; | grep -v &#x27;grep&#x27; | awk &#x27;&#123;print $2&#125;&#x27;)</span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">如果找到了 MinIO 进程的 PID，则终止该进程</span></span><br><span class=\"line\">if [ -n &quot;$minio_pid&quot; ]; then</span><br><span class=\"line\">    echo &quot;Stopping MinIO server...&quot;</span><br><span class=\"line\">    kill $minio_pid</span><br><span class=\"line\">else</span><br><span class=\"line\">    echo &quot;MinIO server is not running.&quot;</span><br><span class=\"line\">fi</span><br></pre></td></tr></table></figure>\n<h1 id=\"九、开发端口\"><a href=\"#九、开发端口\" class=\"headerlink\" title=\"九、开发端口\"></a>九、开发端口</h1><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">firewall-cmd --zone=public --add-port=9000/tcp --permanent</span><br><span class=\"line\">firewall-cmd --zone=public --add-port=35555/tcp --permanent</span><br><span class=\"line\">firewall-cmd –reload</span><br></pre></td></tr></table></figure>\n<h1 id=\"十、启动或者停止脚本\"><a href=\"#十、启动或者停止脚本\" class=\"headerlink\" title=\"十、启动或者停止脚本\"></a>十、启动或者停止脚本</h1><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">启动脚本</span></span><br><span class=\"line\">sh startup.sh</span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">停止脚本</span></span><br><span class=\"line\">sh stop.sh</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h1 id=\"十一、访问minio-console\"><a href=\"#十一、访问minio-console\" class=\"headerlink\" title=\"十一、访问minio console\"></a>十一、访问minio console</h1><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">控制台：http:<span class=\"comment\">//ip:35555</span></span><br><span class=\"line\">API：http:<span class=\"comment\">//ip:9000</span></span><br></pre></td></tr></table></figure>\n<h1 id=\"十二、注意事项\"><a href=\"#十二、注意事项\" class=\"headerlink\" title=\"十二、注意事项\"></a>十二、注意事项</h1><p>无法访问可查看minio.log文件或者重启服务器</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">shutdown -r now</span><br></pre></td></tr></table></figure>","site":{"data":{}},"cover_type":"img","excerpt":"","more":"<h1 id=\"一、新建目录\"><a href=\"#一、新建目录\" class=\"headerlink\" title=\"一、新建目录\"></a>一、新建目录</h1><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd /use/local</span><br><span class=\"line\">mkdir minio</span><br></pre></td></tr></table></figure>\n<h1 id=\"二、新建日志文件\"><a href=\"#二、新建日志文件\" class=\"headerlink\" title=\"二、新建日志文件\"></a>二、新建日志文件</h1><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd ./minio</span><br><span class=\"line\">touch minio.log</span><br></pre></td></tr></table></figure>\n<h1 id=\"三、下载minio文件\"><a href=\"#三、下载minio文件\" class=\"headerlink\" title=\"三、下载minio文件\"></a>三、下载minio文件</h1><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget https:<span class=\"comment\">//dl.minio.io/server/minio/release/linux-amd64/minio</span></span><br></pre></td></tr></table></figure>\n<h1 id=\"四、给minio文件赋予777权限，可写可读都执行\"><a href=\"#四、给minio文件赋予777权限，可写可读都执行\" class=\"headerlink\" title=\"四、给minio文件赋予777权限，可写可读都执行\"></a>四、给minio文件赋予777权限，可写可读都执行</h1><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">chmod 777 minio</span><br></pre></td></tr></table></figure>\n<h1 id=\"五、设置环境变量\"><a href=\"#五、设置环境变量\" class=\"headerlink\" title=\"五、设置环境变量\"></a>五、设置环境变量</h1><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vim /etc/profile</span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">在文件末尾添加一下内容</span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">minio环境变量</span></span><br><span class=\"line\">export MINIO_ROOT_USER=myminioadmin</span><br><span class=\"line\">export MINIO_ROOT_PASSWORD=minio-secret-key-change-me</span><br></pre></td></tr></table></figure>\n<h1 id=\"六、生效环境变量\"><a href=\"#六、生效环境变量\" class=\"headerlink\" title=\"六、生效环境变量\"></a>六、生效环境变量</h1><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">source /etc/profile</span><br></pre></td></tr></table></figure>\n<h1 id=\"七、编写minio启动Shell脚本\"><a href=\"#七、编写minio启动Shell脚本\" class=\"headerlink\" title=\"七、编写minio启动Shell脚本\"></a>七、编写minio启动Shell脚本</h1><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vim startup.sh</span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">添加一下内容</span></span><br><span class=\"line\">nohup /usr/local/minio/minio server  /usr/local/minio/data --console-address &quot;:35555&quot; &gt; /usr/local/minio/minio.log 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure>\n<h1 id=\"八、编写minio停止sh脚本\"><a href=\"#八、编写minio停止sh脚本\" class=\"headerlink\" title=\"八、编写minio停止sh脚本\"></a>八、编写minio停止sh脚本</h1><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vim stop.sh</span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">添加以下内容</span></span><br><span class=\"line\"><span class=\"meta prompt_\">#</span><span class=\"language-bash\">!/bin/bash</span></span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">查找 MinIO 进程的 PID</span></span><br><span class=\"line\">minio_pid=$(ps aux | grep &#x27;/usr/local/minio/minio server&#x27; | grep -v &#x27;grep&#x27; | awk &#x27;&#123;print $2&#125;&#x27;)</span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">如果找到了 MinIO 进程的 PID，则终止该进程</span></span><br><span class=\"line\">if [ -n &quot;$minio_pid&quot; ]; then</span><br><span class=\"line\">    echo &quot;Stopping MinIO server...&quot;</span><br><span class=\"line\">    kill $minio_pid</span><br><span class=\"line\">else</span><br><span class=\"line\">    echo &quot;MinIO server is not running.&quot;</span><br><span class=\"line\">fi</span><br></pre></td></tr></table></figure>\n<h1 id=\"九、开发端口\"><a href=\"#九、开发端口\" class=\"headerlink\" title=\"九、开发端口\"></a>九、开发端口</h1><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">firewall-cmd --zone=public --add-port=9000/tcp --permanent</span><br><span class=\"line\">firewall-cmd --zone=public --add-port=35555/tcp --permanent</span><br><span class=\"line\">firewall-cmd –reload</span><br></pre></td></tr></table></figure>\n<h1 id=\"十、启动或者停止脚本\"><a href=\"#十、启动或者停止脚本\" class=\"headerlink\" title=\"十、启动或者停止脚本\"></a>十、启动或者停止脚本</h1><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">启动脚本</span></span><br><span class=\"line\">sh startup.sh</span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">停止脚本</span></span><br><span class=\"line\">sh stop.sh</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h1 id=\"十一、访问minio-console\"><a href=\"#十一、访问minio-console\" class=\"headerlink\" title=\"十一、访问minio console\"></a>十一、访问minio console</h1><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">控制台：http:<span class=\"comment\">//ip:35555</span></span><br><span class=\"line\">API：http:<span class=\"comment\">//ip:9000</span></span><br></pre></td></tr></table></figure>\n<h1 id=\"十二、注意事项\"><a href=\"#十二、注意事项\" class=\"headerlink\" title=\"十二、注意事项\"></a>十二、注意事项</h1><p>无法访问可查看minio.log文件或者重启服务器</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">shutdown -r now</span><br></pre></td></tr></table></figure>"},{"title":"设计模式-01.设计思想","keywords":"设计模式，设计思想","description":"设计模式第一部分-常用设计思想。","cover":"https://npm.elemecdn.com/lql_static@latest/logo/design_patterns.jpg","abbrlink":"c3dcce5d","date":"2024-04-21T15:22:58.000Z","_content":"\n# 声明\n\n> 1. 此系列文章非本人原创，是学习笔记。\n> 2. 设计模式系列以后会持续更新，包括已经发布的设计模式文章，因为后续还要再多看一下书，教程和开源项目等，继续润色文章。\n\n下面讲一些常见的设计思想\n\n## 基于接口而非实现编程\n\n这个原则非常重要，是一种非常有效的提高代码质量的手段，在平时的开发中特别经常被用到。\n\n### 如何解读原则中的“接口”二字？\n\n1. “基于接口而非实现编程”这条原则的英文描述是：“Program to an interface, not an implementation”。我们理解这条原则的时候，千万不要一开始就与具体的编程语言挂钩，局限在编程语言的“接口”语法中（比如 Java 中的 interface 接口语法）。这条原则最早出现于 1994 年 GoF 的《设计模式》这本书，它先于很多编程语言而诞生（比如 Java 语言），是一条比较抽象、泛化的设计思想。\n2. 实际上，理解这条原则的关键，就是理解其中的“接口”两个字。还记得我们上一节课讲的“接口”的定义吗？从本质上来看，“接口”就是一组“协议”或者“约定”，是功能提供者提供给使用者的一个“功能列表”。“接口”在不同的应用场景下会有不同的解读，比如服务端与客户端之间的“接口”，类库提供的“接口”，甚至是一组通信的协议都可以叫作“接口”。刚刚对“接口”的理解，都比较偏上层、偏抽象，与实际的写代码离得有点远。如果落实到具体的编码，“基于接口而非实现编程”这条原则中的“接口”，可以理解为编程语言中的接口或者抽象类。\n3. 前面我们提到，这条原则能非常有效地提高代码质量，之所以这么说，那是因为，应用这条原则，可以将接口和实现相分离，封装不稳定的实现，暴露稳定的接口。上游系统面向接口而非实现编程，不依赖不稳定的实现细节，这样当实现发生变化的时候，上游系统的代码基本上不需要做改动，以此来降低耦合性，提高扩展性。\n4. 实际上，“基于接口而非实现编程”这条原则的另一个表述方式，是“基于抽象而非实现编程”。后者的表述方式其实更能体现这条原则的设计初衷。在软件开发中，最大的挑战之一就是需求的不断变化，这也是考验代码设计好坏的一个标准。**越抽象、越顶层、越脱离具体某一实现的设计，越能提高代码的灵活性，越能应对未来的需求变化。好的代码设计，不仅能应对当下的需求，而且在将来需求发生变化的时候，仍然能够在不破坏原有代码设计的情况下灵活应对**。而抽象就是提高代码扩展性、灵活性、可维护性最有效的手段之一。\n\n\n\n### 如何将这条原则应用到实战中？\n\n假设我们的系统中有很多涉及图片处理和存储的业务逻辑。图片经过处理之后被上传到阿里云上。为了代码复用，我们封装了图片存储相关的代码逻辑，提供了一个统一的 AliyunImageStore 类，供整个系统来使用。具体的代码实现如下所示：\n\n```java\npublic class AliyunImageStore {\n  //...省略属性、构造函数等...\n  \n  public void createBucketIfNotExisting(String bucketName) {\n    // ...创建bucket代码逻辑...\n    // ...失败会抛出异常..\n  }\n  \n  public String generateAccessToken() {\n    // ...根据accesskey/secrectkey等生成access token\n  }\n  \n  public String uploadToAliyun(Image image, String bucketName, String accessToken) {\n    //...上传图片到阿里云...\n    //...返回图片存储在阿里云上的地址(url）...\n  }\n  \n  public Image downloadFromAliyun(String url, String accessToken) {\n    //...从阿里云下载图片...\n  }\n}\n\n// AliyunImageStore类的使用举例\npublic class ImageProcessingJob {\n  private static final String BUCKET_NAME = \"ai_images_bucket\";\n  //...省略其他无关代码...\n  \n  public void process() {\n    Image image = ...; //处理图片，并封装为Image对象\n    AliyunImageStore imageStore = new AliyunImageStore(/*省略参数*/);\n    imageStore.createBucketIfNotExisting(BUCKET_NAME);\n    String accessToken = imageStore.generateAccessToken();\n    imagestore.uploadToAliyun(image, BUCKET_NAME, accessToken);\n  }\n  \n}\n```\n\n\n\n1. 整个上传流程包含三个步骤：创建 bucket（你可以简单理解为存储目录）、生成 access token 访问凭证、携带 access token 上传图片到指定的 bucket 中。代码实现非常简单，类中的几个方法定义得都很干净，用起来也很清晰，乍看起来没有太大问题，完全能满足我们将图片存储在阿里云的业务需求。\n2. 不过，软件开发中唯一不变的就是变化。过了一段时间后，我们自建了私有云，不再将图片存储到阿里云了，而是将图片存储到自建私有云上。为了满足这样一个需求的变化，我们该如何修改代码呢？\n3. 我们需要重新设计实现一个存储图片到私有云的 PrivateImageStore 类，并用它替换掉项目中所有的 AliyunImageStore 类对象。这样的修改听起来并不复杂，只是简单替换而已，对整个代码的改动并不大。不过，我们经常说，“细节是魔鬼”。这句话在软件开发中特别适用。实际上，刚刚的设计实现方式，就隐藏了很多容易出问题的“魔鬼细节”，我们一块来看看都有哪些。\n4. 新的 PrivateImageStore 类需要设计实现哪些方法，才能在尽量最小化代码修改的情况下，替换掉 AliyunImageStore 类呢？这就要求我们必须将 AliyunImageStore 类中所定义的所有 public 方法，在 PrivateImageStore 类中都逐一定义并重新实现一遍。而这样做就会存在一些问题，我总结了下面两点。\n   - 首先，AliyunImageStore 类中有些函数命名暴露了实现细节，比如，uploadToAliyun() 和 downloadFromAliyun()。如果开发这个功能的同事没有接口意识、抽象思维，那这种暴露实现细节的命名方式就不足为奇了，毕竟最初我们只考虑将图片存储在阿里云上。而我们把这种包含“aliyun”字眼的方法，照抄到 PrivateImageStore 类中，显然是不合适的。如果我们在新类中重新命名 uploadToAliyun()、downloadFromAliyun() 这些方法，那就意味着，我们要修改项目中所有使用到这两个方法的代码，代码修改量可能就会很大。\n   - 其次，将图片存储到阿里云的流程，跟存储到私有云的流程，可能并不是完全一致的。比如，阿里云的图片上传和下载的过程中，需要生产 access token，而私有云不需要 access token。一方面，AliyunImageStore 中定义的 generateAccessToken() 方法不能照抄到 PrivateImageStore 中；另一方面，我们在使用 AliyunImageStore 上传、下载图片的时候，代码中用到了 generateAccessToken() 方法，如果要改为私有云的上传下载流程，这些代码都需要做调整。\n5. 那这两个问题该如何解决呢？解决这个问题的根本方法就是，在编写代码的时候，要遵从“基于接口而非实现编程”的原则，具体来讲，我们需要做到下面这 3 点。\n   1. 函数的命名不能暴露任何实现细节。比如，前面提到的 uploadToAliyun() 就不符合要求，应该改为去掉 aliyun 这样的字眼，改为更加抽象的命名方式，比如：upload()。\n   2. 封装具体的实现细节。比如，跟阿里云相关的特殊上传（或下载）流程不应该暴露给调用者。我们对上传（或下载）流程进行封装，对外提供一个包裹所有上传（或下载）细节的方法，给调用者使用。\n   3. 为实现类定义抽象的接口。具体的实现类都依赖统一的接口定义，遵从一致的上传功能协议。使用者依赖接口，而不是具体的实现类来编程。\n6. 我们按照这个思路，把代码重构一下。重构后的代码如下所示：\n\n```java\npublic interface ImageStore {\n  String upload(Image image, String bucketName);\n  Image download(String url);\n}\n\npublic class AliyunImageStore implements ImageStore {\n  //...省略属性、构造函数等...\n\n  public String upload(Image image, String bucketName) {\n    createBucketIfNotExisting(bucketName);\n    String accessToken = generateAccessToken();\n    //...上传图片到阿里云...\n    //...返回图片在阿里云上的地址(url)...\n  }\n\n  public Image download(String url) {\n    String accessToken = generateAccessToken();\n    //...从阿里云下载图片...\n  }\n\n  private void createBucketIfNotExisting(String bucketName) {\n    // ...创建bucket...\n    // ...失败会抛出异常..\n  }\n\n  private String generateAccessToken() {\n    // ...根据accesskey/secrectkey等生成access token\n  }\n}\n\n// 上传下载流程改变：私有云不需要支持access token\npublic class PrivateImageStore implements ImageStore  {\n  public String upload(Image image, String bucketName) {\n    createBucketIfNotExisting(bucketName);\n    //...上传图片到私有云...\n    //...返回图片的url...\n  }\n\n  public Image download(String url) {\n    //...从私有云下载图片...\n  }\n\n  private void createBucketIfNotExisting(String bucketName) {\n    // ...创建bucket...\n    // ...失败会抛出异常..\n  }\n}\n\n// ImageStore的使用举例\npublic class ImageProcessingJob {\n  private static final String BUCKET_NAME = \"ai_images_bucket\";\n  //...省略其他无关代码...\n  \n  public void process() {\n    Image image = ...;//处理图片，并封装为Image对象\n    ImageStore imageStore = new PrivateImageStore(...);\n    imagestore.upload(image, BUCKET_NAME);\n  }\n}\n```\n\n1. 除此之外，很多人在定义接口的时候，希望通过实现类来反推接口的定义。先把实现类写好，然后看实现类中有哪些方法，照抄到接口定义中。如果按照这种思考方式，就有可能导致接口定义不够抽象，依赖具体的实现。这样的接口设计就没有意义了。不过，如果你觉得这种思考方式更加顺畅，那也没问题，只是将实现类的方法搬移到接口定义中的时候，要有选择性的搬移，不要将跟具体实现相关的方法搬移到接口中，比如 AliyunImageStore 中的 generateAccessToken() 方法。\n2. 总结一下，我们在做软件开发的时候，一定要有抽象意识、封装意识、接口意识。在定义接口的时候，不要暴露任何实现细节。接口的定义只表明做什么，而不是怎么做。而且，在设计接口的时候，我们要多思考一下，这样的接口设计是否足够通用，是否能够做到在替换具体的接口实现的时候，不需要任何接口定义的改动。\n\n\n\n### 是否需要为每个类定义接口？\n\n1. 看了刚刚的讲解，你可能会有这样的疑问：为了满足这条原则，我是不是需要给每个实现类都定义对应的接口呢？在开发的时候，是不是任何代码都要只依赖接口，完全不依赖实现编程呢？\n2. 做任何事情都要讲求一个“度”，过度使用这条原则，非得给每个类都定义接口，接口满天飞，也会导致不必要的开发负担。至于什么时候，该为某个类定义接口，实现基于接口的编程，什么时候不需要定义接口，直接使用实现类编程，我们做权衡的根本依据，还是要回归到设计原则诞生的初衷上来。只要搞清楚了这条原则是为了解决什么样的问题而产生的，你就会发现，很多之前模棱两可的问题，都会变得豁然开朗。\n3. 前面我们也提到，这条原则的设计初衷是，将接口和实现相分离，封装不稳定的实现，暴露稳定的接口。上游系统面向接口而非实现编程，不依赖不稳定的实现细节，这样当实现发生变化的时候，上游系统的代码基本上不需要做改动，以此来降低代码间的耦合性，提高代码的扩展性。\n4. 从这个设计初衷上来看，如果在我们的业务场景中，某个功能只有一种实现方式，未来也不可能被其他实现方式替换，那我们就没有必要为其设计接口，也没有必要基于接口编程，直接使用实现类就可以了。\n5. 除此之外，越是不稳定的系统，我们越是要在代码的扩展性、维护性上下功夫。相反，如果某个系统特别稳定，在开发完之后，基本上不需要做维护，那我们就没有必要为其扩展性，投入不必要的开发时间。\n\n\n\n## 多用组合少用继承\n\n在面向对象编程中，有一条非常经典的设计原则，那就是：组合优于继承，多用组合少用继承。为什么不推荐使用继承？组合相比继承有哪些优势？如何判断该用组合还是继承？今天，我们就围绕着这三个问题，来详细讲解一下这条设计原则。\n\n\n\n\n\n### 为什么不推荐使用继承？\n\n1. 继承是面向对象的四大特性之一，用来表示类之间的 is-a 关系，可以解决代码复用的问题。虽然继承有诸多作用，但继承层次过深、过复杂，也会影响到代码的可维护性。所以，对于是否应该在项目中使用继承，网上有很多争议。很多人觉得继承是一种反模式，应该尽量少用，甚至不用。为什么会有这样的争议？我们通过一个例子来解释一下。\n2. 假设我们要设计一个关于鸟的类。我们将“鸟类”这样一个抽象的事物概念，定义为一个抽象类 AbstractBird。所有更细分的鸟，比如麻雀、鸽子、乌鸦等，都继承这个抽象类。\n3. 我们知道，大部分鸟都会飞，那我们可不可以在 AbstractBird 抽象类中，定义一个 fly() 方法呢？答案是否定的。尽管大部分鸟都会飞，但也有特例，比如鸵鸟就不会飞。鸵鸟继承具有 fly() 方法的父类，那鸵鸟就具有“飞”这样的行为，这显然不符合我们对现实世界中事物的认识。当然，你可能会说，我在鸵鸟这个子类中重写（override）fly() 方法，让它抛出 UnSupportedMethodException 异常不就可以了吗？具体的代码实现如下所示：\n\n```java\npublic class AbstractBird {\n  //...省略其他属性和方法...\n  public void fly() { //... }\n}\n\npublic class Ostrich extends AbstractBird { //鸵鸟\n  //...省略其他属性和方法...\n  public void fly() {\n    throw new UnSupportedMethodException(\"I can't fly.'\");\n  }\n}\n```\n\n1. 这种设计思路虽然可以解决问题，但不够优美。因为除了鸵鸟之外，不会飞的鸟还有很多，比如企鹅。对于这些不会飞的鸟来说，我们都需要重写 fly() 方法，抛出异常。这样的设计，一方面，徒增了编码的工作量；另一方面，也违背了我们之后要讲的最小知识原则（Least Knowledge Principle，也叫最少知识原则或者迪米特法则），暴露不该暴露的接口给外部，增加了类使用过程中被误用的概率。\n2. 你可能又会说，那我们再通过 AbstractBird 类派生出两个更加细分的抽象类：会飞的鸟类 AbstractFlyableBird 和不会飞的鸟类 AbstractUnFlyableBird，让麻雀、乌鸦这些会飞的鸟都继承 AbstractFlyableBird，让鸵鸟、企鹅这些不会飞的鸟，都继承 AbstractUnFlyableBird 类，不就可以了吗？具体的继承关系如下图所示：\n\n<img src=\"https://npm.elemecdn.com/youthlql@1.0.0/design_patterns/design_ideas/0001.png\"/>\n\n\n\n1. 从图中我们可以看出，继承关系变成了三层。不过，整体上来讲，目前的继承关系还比较简单，层次比较浅，也算是一种可以接受的设计思路。我们再继续加点难度。在刚刚这个场景中，我们只关注“鸟会不会飞”，但如果我们还关注“鸟会不会叫”，那这个时候，我们又该如何设计类之间的继承关系呢？\n\n2. 是否会飞？是否会叫？两个行为搭配起来会产生四种情况：会飞会叫、不会飞会叫、会飞不会叫、不会飞不会叫。如果我们继续沿用刚才的设计思路，那就需要再定义四个抽象类（AbstractFlyableTweetableBird、AbstractFlyableUnTweetableBird、AbstractUnFlyableTweetableBird、AbstractUnFlyableUnTweetableBird）。\n\n<img src=\"https://npm.elemecdn.com/youthlql@1.0.0/design_patterns/design_ideas/0002.png\"/>\n\n\n\n1. 如果我们还需要考虑“是否会下蛋”这样一个行为，那估计就要组合爆炸了。类的继承层次会越来越深、继承关系会越来越复杂。而这种层次很深、很复杂的继承关系，一方面，会导致代码的可读性变差。因为我们要搞清楚某个类具有哪些方法、属性，必须阅读父类的代码、父类的父类的代码……一直追溯到最顶层父类的代码。另一方面，这也破坏了类的封装特性，将父类的实现细节暴露给了子类。子类的实现依赖父类的实现，两者高度耦合，一旦父类代码修改，就会影响所有子类的逻辑。\n2. 总之，继承最大的问题就在于：继承层次过深、继承关系过于复杂会影响到代码的可读性和可维护性。这也是为什么我们不推荐使用继承。那刚刚例子中继承存在的问题，我们又该如何来解决呢？你可以先自己思考一下，再听我下面的讲解。\n\n\n\n### 组合相比继承有哪些优势？\n\n1. 实际上，我们可以利用组合（composition）、接口、委托（delegation）三个技术手段，一块儿来解决刚刚继承存在的问题。\n2. 接口表示具有某种行为特性。针对“会飞”这样一个行为特性，我们可以定义一个 Flyable 接口，只让会飞的鸟去实现这个接口。对于会叫、会下蛋这些行为特性，我们可以类似地定义 Tweetable 接口、EggLayable 接口。我们将这个设计思路翻译成 Java 代码的话，就是下面这个样子：\n\n```java\npublic interface Flyable {\n  void fly();\n}\npublic interface Tweetable {\n  void tweet();\n}\npublic interface EggLayable {\n  void layEgg();\n}\npublic class Ostrich implements Tweetable, EggLayable {//鸵鸟\n  //... 省略其他属性和方法...\n  @Override\n  public void tweet() { //... }\n  @Override\n  public void layEgg() { //... }\n}\npublic class Sparrow impelents Flyable, Tweetable, EggLayable {//麻雀\n  //... 省略其他属性和方法...\n  @Override\n  public void fly() { //... }\n  @Override\n  public void tweet() { //... }\n  @Override\n  public void layEgg() { //... }\n}\n```\n\n1. 不过，我们知道，接口只声明方法，不定义实现。也就是说，每个会下蛋的鸟都要实现一遍 layEgg() 方法，并且实现逻辑是一样的，这就会导致代码重复的问题。那这个问题又该如何解决呢？\n2. 我们可以针对三个接口再定义三个实现类，它们分别是：实现了 fly() 方法的 FlyAbility 类、实现了 tweet() 方法的 TweetAbility 类、实现了 layEgg() 方法的 EggLayAbility 类。然后，通过组合和委托技术来消除代码重复。具体的代码实现如下所示：\n\n```java\npublic interface Flyable {\n  void fly()；\n}\npublic class FlyAbility implements Flyable {\n  @Override\n  public void fly() { //... }\n}\n//省略Tweetable/TweetAbility/EggLayable/EggLayAbility\n\npublic class Ostrich implements Tweetable, EggLayable {//鸵鸟\n  private TweetAbility tweetAbility = new TweetAbility(); //组合\n  private EggLayAbility eggLayAbility = new EggLayAbility(); //组合\n  //... 省略其他属性和方法...\n  @Override\n  public void tweet() {\n    tweetAbility.tweet(); // 委托\n  }\n  @Override\n  public void layEgg() {\n    eggLayAbility.layEgg(); // 委托\n  }\n}\n```\n\n\n\n我们知道继承主要有三个作用：表示 is-a 关系，支持多态特性，代码复用。而这三个作用都可以通过其他技术手段来达成。比如 is-a 关系，我们可以通过组合和接口的 has-a 关系来替代；多态特性我们可以利用接口来实现；代码复用我们可以通过组合和委托来实现。所以，从理论上讲，通过组合、接口、委托三个技术手段，我们完全可以替换掉继承，在项目中不用或者少用继承关系，特别是一些复杂的继承关系。\n\n\n\n### 如何判断该用组合还是继承？\n\n1. 尽管我们鼓励多用组合少用继承，但组合也并不是完美的，继承也并非一无是处。从上面的例子来看，继承改写成组合意味着要做更细粒度的类的拆分。这也就意味着，我们要定义更多的类和接口。类和接口的增多也就或多或少地增加代码的复杂程度和维护成本。所以，在实际的项目开发中，我们还是要根据具体的情况，来具体选择该用继承还是组合。\n2. 如果类之间的继承结构稳定（不会轻易改变），继承层次比较浅（比如，最多有两层继承关系），继承关系不复杂，我们就可以大胆地使用继承。反之，系统越不稳定，继承层次很深，继承关系复杂，我们就尽量使用组合来替代继承。\n3. 除此之外，还有一些设计模式会固定使用继承或者组合。比如，装饰者模式（decorator pattern）、策略模式（strategy pattern）、组合模式（composite pattern）等都使用了组合关系，而模板模式（template pattern）使用了继承关系。\n4. 前面我们讲到继承可以实现代码复用。利用继承特性，我们把相同的属性和方法，抽取出来，定义到父类中。子类复用父类中的属性和方法，达到代码复用的目的。但是，有的时候，从业务含义上，A 类和 B 类并不一定具有继承关系。比如，Crawler 类和 PageAnalyzer 类，它们都用到了 URL 拼接和分割的功能，但并不具有继承关系（既不是父子关系，也不是兄弟关系）。仅仅为了代码复用，生硬地抽象出一个父类出来，会影响到代码的可读性。如果不熟悉背后设计思路的同事，发现 Crawler 类和 PageAnalyzer 类继承同一个父类，而父类中定义的却只是 URL 相关的操作，会觉得这个代码写得莫名其妙，理解不了。这个时候，使用组合就更加合理、更加灵活。具体的代码实现如下所示：\n\n```java\npublic class Url {\n  //...省略属性和方法\n}\n\npublic class Crawler {\n  private Url url; // 组合\n  public Crawler() {\n    this.url = new Url();\n  }\n  //...\n}\n\npublic class PageAnalyzer {\n  private Url url; // 组合\n  public PageAnalyzer() {\n    this.url = new Url();\n  }\n  //..\n}\n```\n\n\n\n还有一些特殊的场景要求我们必须使用继承。如果你不能改变一个函数的入参类型，而入参又非接口，为了支持多态，只能采用继承来实现。比如下面这样一段代码，其中 FeignClient 是一个外部类，我们没有权限去修改这部分代码，但是我们希望能重写这个类在运行时执行的 encode() 函数。这个时候，我们只能采用继承来实现了。\n\n\n\n```java\npublic class FeignClient { // Feign Client框架代码\n  //...省略其他代码...\n  public void encode(String url) { //... }\n}\n\npublic void demofunction(FeignClient feignClient) {\n  //...\n  feignClient.encode(url);\n  //...\n}\n\npublic class CustomizedFeignClient extends FeignClient {\n  @Override\n  public void encode(String url) { //...重写encode的实现...}\n}\n\n// 调用\nFeignClient client = new CustomizedFeignClient();\ndemofunction(client);\n```\n\n尽管有些人说，要杜绝继承，100% 用组合代替继承，但是我的观点没那么极端！之所以“多用组合少用继承”这个口号喊得这么响，只是因为，长期以来，我们过度使用继承。还是那句话，组合并不完美，继承也不是一无是处。只要我们控制好它们的副作用、发挥它们各自的优势，在不同的场合下，恰当地选择使用继承还是组合，这才是我们所追求的境界。\n\n\n\n\n\n## 如何通过封装、抽象、模块化、中间层等解耦代码？\n\n### “解耦”为何如此重要？\n\n1. 软件设计与开发最重要的工作之一就是应对复杂性。人处理复杂性的能力是有限的。过于复杂的代码往往在可读性、可维护性上都不友好。那如何来控制代码的复杂性呢？手段有很多，我个人认为，最关键的就是解耦，保证代码松耦合、高内聚。如果说重构是保证代码质量不至于腐化到无可救药地步的有效手段，那么利用解耦的方法对代码重构，就是保证代码不至于复杂到无法控制的有效手段。\n2. 后文迪米特法则有介绍，什么是“高内聚、松耦合”。。实际上，“高内聚、松耦合”是一个比较通用的设计思想，不仅可以指导细粒度的类和类之间关系的设计，还能指导粗粒度的系统、架构、模块的设计。相对于编码规范，它能够在更高层次上提高代码的可读性和可维护性。\n3. 不管是阅读代码还是修改代码，“高内聚、松耦合”的特性可以让我们聚焦在某一模块或类中，不需要了解太多其他模块或类的代码，让我们的焦点不至于过于发散，降低了阅读和修改代码的难度。而且，因为依赖关系简单，耦合小，修改代码不至于牵一发而动全身，代码改动比较集中，引入 bug 的风险也就减少了很多。同时，“高内聚、松耦合”的代码可测试性也更加好，容易 mock 或者很少需要 mock 外部依赖的模块或者类。\n4. 除此之外，代码“高内聚、松耦合”，也就意味着，代码结构清晰、分层和模块化合理、依赖关系简单、模块或类之间的耦合小，那代码整体的质量就不会差。即便某个具体的类或者模块设计得不怎么合理，代码质量不怎么高，影响的范围是非常有限的。我们可以聚焦于这个模块或者类，做相应的小型重构。而相对于代码结构的调整，这种改动范围比较集中的小型重构的难度就容易多了。\n\n\n\n### 代码是否需要“解耦”？\n\n1. 那现在问题来了，我们该怎么判断代码的耦合程度呢？或者说，怎么判断代码是否符合“高内聚、松耦合”呢？再或者说，如何判断系统是否需要解耦重构呢？\n2. 间接的衡量标准有很多，前面我们讲到了一些，比如，看修改代码会不会牵一发而动全身。除此之外，还有一个直接的衡量标准，也是我在阅读源码的时候经常会用到的，那就是把模块与模块之间、类与类之间的依赖关系画出来，根据依赖关系图的复杂性来判断是否需要解耦重构。\n3. 如果依赖关系复杂、混乱，那从代码结构上来讲，可读性和可维护性肯定不是太好，那我们就需要考虑是否可以通过解耦的方法，让依赖关系变得清晰、简单。当然，这种判断还是有比较强的主观色彩，但是可以作为一种参考和梳理依赖的手段，配合间接的衡量标准一块来使用。\n\n### 如何给代码“解耦”？\n\n>  封装与抽象\n\n封装和抽象作为两个非常通用的设计思想，可以应用在很多设计场景中，比如系统、模块、lib、组件、接口、类等等的设计。封装和抽象可以有效地隐藏实现的复杂性，隔离实现的易变性，给依赖的模块提供稳定且易用的抽象接口\n\n\n\n> 中间层\n\n引入中间层能简化模块或类之间的依赖关系。下面这张图是引入中间层前后的依赖关系对比图。在引入数据存储中间层之前，A、B、C 三个模块都要依赖内存一级缓存、Redis 二级缓存、DB 持久化存储三个模块。在引入中间层之后，三个模块只需要依赖数据存储一个模块即可。从图上可以看出，中间层的引入明显地简化了依赖关系，让代码结构更加清晰\n\n\n\n<img src=\"https://npm.elemecdn.com/youthlql@1.0.0/design_patterns/design_ideas/0003.png\"/>\n\n\n\n除此之外，我们在进行重构的时候，引入中间层可以起到过渡的作用，能够让开发和重构同步进行，不互相干扰。比如，某个接口设计得有问题，我们需要修改它的定义，同时，所有调用这个接口的代码都要做相应的改动。如果新开发的代码也用到这个接口，那开发就跟重构冲突了。为了让重构能小步快跑，我们可以分下面四个阶段来完成接口的修改。\n\n\n\n- 第一阶段：引入一个中间层，包裹老的接口，提供新的接口定义。\n- 第二阶段：新开发的代码依赖中间层提供的新接口。\n- 第三阶段：将依赖老接口的代码改为调用新接口。\n- 第四阶段：确保所有的代码都调用新接口之后，删除掉老的接口。\n\n这样，每个阶段的开发工作量都不会很大，都可以在很短的时间内完成。重构跟开发冲突的概率也变小了。\n\n\n\n\n\n> 模块化\n\n模块化是构建复杂系统常用的手段。不仅在软件行业，在建筑、机械制造等行业，这个手段也非常有用。对于一个大型复杂系统来说，没有人能掌控所有的细节。之所以我们能搭建出如此复杂的系统，并且能维护得了，最主要的原因就是将系统划分成各个独立的模块，让不同的人负责不同的模块，这样即便在不了解全部细节的情况下，管理者也能协调各个模块，让整个系统有效运转。\n\n\n\n\n\n>  其他设计思想和原则\n\n“高内聚、松耦合”是一个非常重要的设计思想，能够有效提高代码的可读性和可维护性，缩小功能改动导致的代码改动范围。实际上，在前面的章节中，我们已经多次提到过这个设计思想。很多设计原则都以实现代码的“高内聚、松耦合”为目的。我们来一块总结回顾一下都有哪些原则。\n\n(这里没有讲的，在后面文章里)\n\n- 单一职责原则\n\n我们前面提到，内聚性和耦合性并非独立的。高内聚会让代码更加松耦合，而实现高内聚的重要指导原则就是单一职责原则。模块或者类的职责设计得单一，而不是大而全，那依赖它的类和它依赖的类就会比较少，代码耦合也就相应的降低了。\n\n\n\n- 基于接口而非实现编程\n\n基于接口而非实现编程能通过接口这样一个中间层，隔离变化和具体的实现。这样做的好处是，在有依赖关系的两个模块或类之间，一个模块或者类的改动，不会影响到另一个模块或类。实际上，这就相当于将一种强依赖关系（强耦合）解耦为了弱依赖关系（弱耦合）。依赖注入\n\n\n\n- 依赖注入\n\n跟基于接口而非实现编程思想类似，依赖注入也是将代码之间的强耦合变为弱耦合。尽管依赖注入无法将本应该有依赖关系的两个类，解耦为没有依赖关系，但可以让耦合关系没那么紧密，容易做到插拔替换\n\n\n\n- 多用组合少用继承\n\n我们知道，继承是一种强依赖关系，父类与子类高度耦合，且这种耦合关系非常脆弱，牵一发而动全身，父类的每一次改动都会影响所有的子类。相反，组合关系是一种弱依赖关系，这种关系更加灵活，所以，对于继承结构比较复杂的代码，利用组合来替换继承，也是一种解耦的有效手段。\n\n\n\n- 迪米特法则\n\n迪米特法则讲的是，不该有直接依赖关系的类之间，不要有依赖；有依赖关系的类之间，尽量只依赖必要的接口。从定义上，我们明显可以看出，这条原则的目的就是为了实现代码的松耦合。至于如何应用这条原则来解耦代码，你可以回过头去阅读一下第 22 讲，这里我就不赘述了。除了上面讲到的这些设计思想和原则之外，还有一些设计模式也是为了解耦依赖，比如观察者模式，有关这一部分的内容，我们留在设计模式模块中慢慢讲解。\n\n\n\n","source":"_posts/2024-04-21-设计模式-01.设计思想.md","raw":"---\ntitle: 设计模式-01.设计思想\ntags:\n  - 设计模式\n  - 设计思想\ncategories:\n  - 设计模式\n  - 01.设计思想\nkeywords: 设计模式，设计思想\ndescription: 设计模式第一部分-常用设计思想。\ncover: 'https://npm.elemecdn.com/lql_static@latest/logo/design_patterns.jpg'\nabbrlink: c3dcce5d\ndate: 2024-04-21 23:22:58\n---\n\n# 声明\n\n> 1. 此系列文章非本人原创，是学习笔记。\n> 2. 设计模式系列以后会持续更新，包括已经发布的设计模式文章，因为后续还要再多看一下书，教程和开源项目等，继续润色文章。\n\n下面讲一些常见的设计思想\n\n## 基于接口而非实现编程\n\n这个原则非常重要，是一种非常有效的提高代码质量的手段，在平时的开发中特别经常被用到。\n\n### 如何解读原则中的“接口”二字？\n\n1. “基于接口而非实现编程”这条原则的英文描述是：“Program to an interface, not an implementation”。我们理解这条原则的时候，千万不要一开始就与具体的编程语言挂钩，局限在编程语言的“接口”语法中（比如 Java 中的 interface 接口语法）。这条原则最早出现于 1994 年 GoF 的《设计模式》这本书，它先于很多编程语言而诞生（比如 Java 语言），是一条比较抽象、泛化的设计思想。\n2. 实际上，理解这条原则的关键，就是理解其中的“接口”两个字。还记得我们上一节课讲的“接口”的定义吗？从本质上来看，“接口”就是一组“协议”或者“约定”，是功能提供者提供给使用者的一个“功能列表”。“接口”在不同的应用场景下会有不同的解读，比如服务端与客户端之间的“接口”，类库提供的“接口”，甚至是一组通信的协议都可以叫作“接口”。刚刚对“接口”的理解，都比较偏上层、偏抽象，与实际的写代码离得有点远。如果落实到具体的编码，“基于接口而非实现编程”这条原则中的“接口”，可以理解为编程语言中的接口或者抽象类。\n3. 前面我们提到，这条原则能非常有效地提高代码质量，之所以这么说，那是因为，应用这条原则，可以将接口和实现相分离，封装不稳定的实现，暴露稳定的接口。上游系统面向接口而非实现编程，不依赖不稳定的实现细节，这样当实现发生变化的时候，上游系统的代码基本上不需要做改动，以此来降低耦合性，提高扩展性。\n4. 实际上，“基于接口而非实现编程”这条原则的另一个表述方式，是“基于抽象而非实现编程”。后者的表述方式其实更能体现这条原则的设计初衷。在软件开发中，最大的挑战之一就是需求的不断变化，这也是考验代码设计好坏的一个标准。**越抽象、越顶层、越脱离具体某一实现的设计，越能提高代码的灵活性，越能应对未来的需求变化。好的代码设计，不仅能应对当下的需求，而且在将来需求发生变化的时候，仍然能够在不破坏原有代码设计的情况下灵活应对**。而抽象就是提高代码扩展性、灵活性、可维护性最有效的手段之一。\n\n\n\n### 如何将这条原则应用到实战中？\n\n假设我们的系统中有很多涉及图片处理和存储的业务逻辑。图片经过处理之后被上传到阿里云上。为了代码复用，我们封装了图片存储相关的代码逻辑，提供了一个统一的 AliyunImageStore 类，供整个系统来使用。具体的代码实现如下所示：\n\n```java\npublic class AliyunImageStore {\n  //...省略属性、构造函数等...\n  \n  public void createBucketIfNotExisting(String bucketName) {\n    // ...创建bucket代码逻辑...\n    // ...失败会抛出异常..\n  }\n  \n  public String generateAccessToken() {\n    // ...根据accesskey/secrectkey等生成access token\n  }\n  \n  public String uploadToAliyun(Image image, String bucketName, String accessToken) {\n    //...上传图片到阿里云...\n    //...返回图片存储在阿里云上的地址(url）...\n  }\n  \n  public Image downloadFromAliyun(String url, String accessToken) {\n    //...从阿里云下载图片...\n  }\n}\n\n// AliyunImageStore类的使用举例\npublic class ImageProcessingJob {\n  private static final String BUCKET_NAME = \"ai_images_bucket\";\n  //...省略其他无关代码...\n  \n  public void process() {\n    Image image = ...; //处理图片，并封装为Image对象\n    AliyunImageStore imageStore = new AliyunImageStore(/*省略参数*/);\n    imageStore.createBucketIfNotExisting(BUCKET_NAME);\n    String accessToken = imageStore.generateAccessToken();\n    imagestore.uploadToAliyun(image, BUCKET_NAME, accessToken);\n  }\n  \n}\n```\n\n\n\n1. 整个上传流程包含三个步骤：创建 bucket（你可以简单理解为存储目录）、生成 access token 访问凭证、携带 access token 上传图片到指定的 bucket 中。代码实现非常简单，类中的几个方法定义得都很干净，用起来也很清晰，乍看起来没有太大问题，完全能满足我们将图片存储在阿里云的业务需求。\n2. 不过，软件开发中唯一不变的就是变化。过了一段时间后，我们自建了私有云，不再将图片存储到阿里云了，而是将图片存储到自建私有云上。为了满足这样一个需求的变化，我们该如何修改代码呢？\n3. 我们需要重新设计实现一个存储图片到私有云的 PrivateImageStore 类，并用它替换掉项目中所有的 AliyunImageStore 类对象。这样的修改听起来并不复杂，只是简单替换而已，对整个代码的改动并不大。不过，我们经常说，“细节是魔鬼”。这句话在软件开发中特别适用。实际上，刚刚的设计实现方式，就隐藏了很多容易出问题的“魔鬼细节”，我们一块来看看都有哪些。\n4. 新的 PrivateImageStore 类需要设计实现哪些方法，才能在尽量最小化代码修改的情况下，替换掉 AliyunImageStore 类呢？这就要求我们必须将 AliyunImageStore 类中所定义的所有 public 方法，在 PrivateImageStore 类中都逐一定义并重新实现一遍。而这样做就会存在一些问题，我总结了下面两点。\n   - 首先，AliyunImageStore 类中有些函数命名暴露了实现细节，比如，uploadToAliyun() 和 downloadFromAliyun()。如果开发这个功能的同事没有接口意识、抽象思维，那这种暴露实现细节的命名方式就不足为奇了，毕竟最初我们只考虑将图片存储在阿里云上。而我们把这种包含“aliyun”字眼的方法，照抄到 PrivateImageStore 类中，显然是不合适的。如果我们在新类中重新命名 uploadToAliyun()、downloadFromAliyun() 这些方法，那就意味着，我们要修改项目中所有使用到这两个方法的代码，代码修改量可能就会很大。\n   - 其次，将图片存储到阿里云的流程，跟存储到私有云的流程，可能并不是完全一致的。比如，阿里云的图片上传和下载的过程中，需要生产 access token，而私有云不需要 access token。一方面，AliyunImageStore 中定义的 generateAccessToken() 方法不能照抄到 PrivateImageStore 中；另一方面，我们在使用 AliyunImageStore 上传、下载图片的时候，代码中用到了 generateAccessToken() 方法，如果要改为私有云的上传下载流程，这些代码都需要做调整。\n5. 那这两个问题该如何解决呢？解决这个问题的根本方法就是，在编写代码的时候，要遵从“基于接口而非实现编程”的原则，具体来讲，我们需要做到下面这 3 点。\n   1. 函数的命名不能暴露任何实现细节。比如，前面提到的 uploadToAliyun() 就不符合要求，应该改为去掉 aliyun 这样的字眼，改为更加抽象的命名方式，比如：upload()。\n   2. 封装具体的实现细节。比如，跟阿里云相关的特殊上传（或下载）流程不应该暴露给调用者。我们对上传（或下载）流程进行封装，对外提供一个包裹所有上传（或下载）细节的方法，给调用者使用。\n   3. 为实现类定义抽象的接口。具体的实现类都依赖统一的接口定义，遵从一致的上传功能协议。使用者依赖接口，而不是具体的实现类来编程。\n6. 我们按照这个思路，把代码重构一下。重构后的代码如下所示：\n\n```java\npublic interface ImageStore {\n  String upload(Image image, String bucketName);\n  Image download(String url);\n}\n\npublic class AliyunImageStore implements ImageStore {\n  //...省略属性、构造函数等...\n\n  public String upload(Image image, String bucketName) {\n    createBucketIfNotExisting(bucketName);\n    String accessToken = generateAccessToken();\n    //...上传图片到阿里云...\n    //...返回图片在阿里云上的地址(url)...\n  }\n\n  public Image download(String url) {\n    String accessToken = generateAccessToken();\n    //...从阿里云下载图片...\n  }\n\n  private void createBucketIfNotExisting(String bucketName) {\n    // ...创建bucket...\n    // ...失败会抛出异常..\n  }\n\n  private String generateAccessToken() {\n    // ...根据accesskey/secrectkey等生成access token\n  }\n}\n\n// 上传下载流程改变：私有云不需要支持access token\npublic class PrivateImageStore implements ImageStore  {\n  public String upload(Image image, String bucketName) {\n    createBucketIfNotExisting(bucketName);\n    //...上传图片到私有云...\n    //...返回图片的url...\n  }\n\n  public Image download(String url) {\n    //...从私有云下载图片...\n  }\n\n  private void createBucketIfNotExisting(String bucketName) {\n    // ...创建bucket...\n    // ...失败会抛出异常..\n  }\n}\n\n// ImageStore的使用举例\npublic class ImageProcessingJob {\n  private static final String BUCKET_NAME = \"ai_images_bucket\";\n  //...省略其他无关代码...\n  \n  public void process() {\n    Image image = ...;//处理图片，并封装为Image对象\n    ImageStore imageStore = new PrivateImageStore(...);\n    imagestore.upload(image, BUCKET_NAME);\n  }\n}\n```\n\n1. 除此之外，很多人在定义接口的时候，希望通过实现类来反推接口的定义。先把实现类写好，然后看实现类中有哪些方法，照抄到接口定义中。如果按照这种思考方式，就有可能导致接口定义不够抽象，依赖具体的实现。这样的接口设计就没有意义了。不过，如果你觉得这种思考方式更加顺畅，那也没问题，只是将实现类的方法搬移到接口定义中的时候，要有选择性的搬移，不要将跟具体实现相关的方法搬移到接口中，比如 AliyunImageStore 中的 generateAccessToken() 方法。\n2. 总结一下，我们在做软件开发的时候，一定要有抽象意识、封装意识、接口意识。在定义接口的时候，不要暴露任何实现细节。接口的定义只表明做什么，而不是怎么做。而且，在设计接口的时候，我们要多思考一下，这样的接口设计是否足够通用，是否能够做到在替换具体的接口实现的时候，不需要任何接口定义的改动。\n\n\n\n### 是否需要为每个类定义接口？\n\n1. 看了刚刚的讲解，你可能会有这样的疑问：为了满足这条原则，我是不是需要给每个实现类都定义对应的接口呢？在开发的时候，是不是任何代码都要只依赖接口，完全不依赖实现编程呢？\n2. 做任何事情都要讲求一个“度”，过度使用这条原则，非得给每个类都定义接口，接口满天飞，也会导致不必要的开发负担。至于什么时候，该为某个类定义接口，实现基于接口的编程，什么时候不需要定义接口，直接使用实现类编程，我们做权衡的根本依据，还是要回归到设计原则诞生的初衷上来。只要搞清楚了这条原则是为了解决什么样的问题而产生的，你就会发现，很多之前模棱两可的问题，都会变得豁然开朗。\n3. 前面我们也提到，这条原则的设计初衷是，将接口和实现相分离，封装不稳定的实现，暴露稳定的接口。上游系统面向接口而非实现编程，不依赖不稳定的实现细节，这样当实现发生变化的时候，上游系统的代码基本上不需要做改动，以此来降低代码间的耦合性，提高代码的扩展性。\n4. 从这个设计初衷上来看，如果在我们的业务场景中，某个功能只有一种实现方式，未来也不可能被其他实现方式替换，那我们就没有必要为其设计接口，也没有必要基于接口编程，直接使用实现类就可以了。\n5. 除此之外，越是不稳定的系统，我们越是要在代码的扩展性、维护性上下功夫。相反，如果某个系统特别稳定，在开发完之后，基本上不需要做维护，那我们就没有必要为其扩展性，投入不必要的开发时间。\n\n\n\n## 多用组合少用继承\n\n在面向对象编程中，有一条非常经典的设计原则，那就是：组合优于继承，多用组合少用继承。为什么不推荐使用继承？组合相比继承有哪些优势？如何判断该用组合还是继承？今天，我们就围绕着这三个问题，来详细讲解一下这条设计原则。\n\n\n\n\n\n### 为什么不推荐使用继承？\n\n1. 继承是面向对象的四大特性之一，用来表示类之间的 is-a 关系，可以解决代码复用的问题。虽然继承有诸多作用，但继承层次过深、过复杂，也会影响到代码的可维护性。所以，对于是否应该在项目中使用继承，网上有很多争议。很多人觉得继承是一种反模式，应该尽量少用，甚至不用。为什么会有这样的争议？我们通过一个例子来解释一下。\n2. 假设我们要设计一个关于鸟的类。我们将“鸟类”这样一个抽象的事物概念，定义为一个抽象类 AbstractBird。所有更细分的鸟，比如麻雀、鸽子、乌鸦等，都继承这个抽象类。\n3. 我们知道，大部分鸟都会飞，那我们可不可以在 AbstractBird 抽象类中，定义一个 fly() 方法呢？答案是否定的。尽管大部分鸟都会飞，但也有特例，比如鸵鸟就不会飞。鸵鸟继承具有 fly() 方法的父类，那鸵鸟就具有“飞”这样的行为，这显然不符合我们对现实世界中事物的认识。当然，你可能会说，我在鸵鸟这个子类中重写（override）fly() 方法，让它抛出 UnSupportedMethodException 异常不就可以了吗？具体的代码实现如下所示：\n\n```java\npublic class AbstractBird {\n  //...省略其他属性和方法...\n  public void fly() { //... }\n}\n\npublic class Ostrich extends AbstractBird { //鸵鸟\n  //...省略其他属性和方法...\n  public void fly() {\n    throw new UnSupportedMethodException(\"I can't fly.'\");\n  }\n}\n```\n\n1. 这种设计思路虽然可以解决问题，但不够优美。因为除了鸵鸟之外，不会飞的鸟还有很多，比如企鹅。对于这些不会飞的鸟来说，我们都需要重写 fly() 方法，抛出异常。这样的设计，一方面，徒增了编码的工作量；另一方面，也违背了我们之后要讲的最小知识原则（Least Knowledge Principle，也叫最少知识原则或者迪米特法则），暴露不该暴露的接口给外部，增加了类使用过程中被误用的概率。\n2. 你可能又会说，那我们再通过 AbstractBird 类派生出两个更加细分的抽象类：会飞的鸟类 AbstractFlyableBird 和不会飞的鸟类 AbstractUnFlyableBird，让麻雀、乌鸦这些会飞的鸟都继承 AbstractFlyableBird，让鸵鸟、企鹅这些不会飞的鸟，都继承 AbstractUnFlyableBird 类，不就可以了吗？具体的继承关系如下图所示：\n\n<img src=\"https://npm.elemecdn.com/youthlql@1.0.0/design_patterns/design_ideas/0001.png\"/>\n\n\n\n1. 从图中我们可以看出，继承关系变成了三层。不过，整体上来讲，目前的继承关系还比较简单，层次比较浅，也算是一种可以接受的设计思路。我们再继续加点难度。在刚刚这个场景中，我们只关注“鸟会不会飞”，但如果我们还关注“鸟会不会叫”，那这个时候，我们又该如何设计类之间的继承关系呢？\n\n2. 是否会飞？是否会叫？两个行为搭配起来会产生四种情况：会飞会叫、不会飞会叫、会飞不会叫、不会飞不会叫。如果我们继续沿用刚才的设计思路，那就需要再定义四个抽象类（AbstractFlyableTweetableBird、AbstractFlyableUnTweetableBird、AbstractUnFlyableTweetableBird、AbstractUnFlyableUnTweetableBird）。\n\n<img src=\"https://npm.elemecdn.com/youthlql@1.0.0/design_patterns/design_ideas/0002.png\"/>\n\n\n\n1. 如果我们还需要考虑“是否会下蛋”这样一个行为，那估计就要组合爆炸了。类的继承层次会越来越深、继承关系会越来越复杂。而这种层次很深、很复杂的继承关系，一方面，会导致代码的可读性变差。因为我们要搞清楚某个类具有哪些方法、属性，必须阅读父类的代码、父类的父类的代码……一直追溯到最顶层父类的代码。另一方面，这也破坏了类的封装特性，将父类的实现细节暴露给了子类。子类的实现依赖父类的实现，两者高度耦合，一旦父类代码修改，就会影响所有子类的逻辑。\n2. 总之，继承最大的问题就在于：继承层次过深、继承关系过于复杂会影响到代码的可读性和可维护性。这也是为什么我们不推荐使用继承。那刚刚例子中继承存在的问题，我们又该如何来解决呢？你可以先自己思考一下，再听我下面的讲解。\n\n\n\n### 组合相比继承有哪些优势？\n\n1. 实际上，我们可以利用组合（composition）、接口、委托（delegation）三个技术手段，一块儿来解决刚刚继承存在的问题。\n2. 接口表示具有某种行为特性。针对“会飞”这样一个行为特性，我们可以定义一个 Flyable 接口，只让会飞的鸟去实现这个接口。对于会叫、会下蛋这些行为特性，我们可以类似地定义 Tweetable 接口、EggLayable 接口。我们将这个设计思路翻译成 Java 代码的话，就是下面这个样子：\n\n```java\npublic interface Flyable {\n  void fly();\n}\npublic interface Tweetable {\n  void tweet();\n}\npublic interface EggLayable {\n  void layEgg();\n}\npublic class Ostrich implements Tweetable, EggLayable {//鸵鸟\n  //... 省略其他属性和方法...\n  @Override\n  public void tweet() { //... }\n  @Override\n  public void layEgg() { //... }\n}\npublic class Sparrow impelents Flyable, Tweetable, EggLayable {//麻雀\n  //... 省略其他属性和方法...\n  @Override\n  public void fly() { //... }\n  @Override\n  public void tweet() { //... }\n  @Override\n  public void layEgg() { //... }\n}\n```\n\n1. 不过，我们知道，接口只声明方法，不定义实现。也就是说，每个会下蛋的鸟都要实现一遍 layEgg() 方法，并且实现逻辑是一样的，这就会导致代码重复的问题。那这个问题又该如何解决呢？\n2. 我们可以针对三个接口再定义三个实现类，它们分别是：实现了 fly() 方法的 FlyAbility 类、实现了 tweet() 方法的 TweetAbility 类、实现了 layEgg() 方法的 EggLayAbility 类。然后，通过组合和委托技术来消除代码重复。具体的代码实现如下所示：\n\n```java\npublic interface Flyable {\n  void fly()；\n}\npublic class FlyAbility implements Flyable {\n  @Override\n  public void fly() { //... }\n}\n//省略Tweetable/TweetAbility/EggLayable/EggLayAbility\n\npublic class Ostrich implements Tweetable, EggLayable {//鸵鸟\n  private TweetAbility tweetAbility = new TweetAbility(); //组合\n  private EggLayAbility eggLayAbility = new EggLayAbility(); //组合\n  //... 省略其他属性和方法...\n  @Override\n  public void tweet() {\n    tweetAbility.tweet(); // 委托\n  }\n  @Override\n  public void layEgg() {\n    eggLayAbility.layEgg(); // 委托\n  }\n}\n```\n\n\n\n我们知道继承主要有三个作用：表示 is-a 关系，支持多态特性，代码复用。而这三个作用都可以通过其他技术手段来达成。比如 is-a 关系，我们可以通过组合和接口的 has-a 关系来替代；多态特性我们可以利用接口来实现；代码复用我们可以通过组合和委托来实现。所以，从理论上讲，通过组合、接口、委托三个技术手段，我们完全可以替换掉继承，在项目中不用或者少用继承关系，特别是一些复杂的继承关系。\n\n\n\n### 如何判断该用组合还是继承？\n\n1. 尽管我们鼓励多用组合少用继承，但组合也并不是完美的，继承也并非一无是处。从上面的例子来看，继承改写成组合意味着要做更细粒度的类的拆分。这也就意味着，我们要定义更多的类和接口。类和接口的增多也就或多或少地增加代码的复杂程度和维护成本。所以，在实际的项目开发中，我们还是要根据具体的情况，来具体选择该用继承还是组合。\n2. 如果类之间的继承结构稳定（不会轻易改变），继承层次比较浅（比如，最多有两层继承关系），继承关系不复杂，我们就可以大胆地使用继承。反之，系统越不稳定，继承层次很深，继承关系复杂，我们就尽量使用组合来替代继承。\n3. 除此之外，还有一些设计模式会固定使用继承或者组合。比如，装饰者模式（decorator pattern）、策略模式（strategy pattern）、组合模式（composite pattern）等都使用了组合关系，而模板模式（template pattern）使用了继承关系。\n4. 前面我们讲到继承可以实现代码复用。利用继承特性，我们把相同的属性和方法，抽取出来，定义到父类中。子类复用父类中的属性和方法，达到代码复用的目的。但是，有的时候，从业务含义上，A 类和 B 类并不一定具有继承关系。比如，Crawler 类和 PageAnalyzer 类，它们都用到了 URL 拼接和分割的功能，但并不具有继承关系（既不是父子关系，也不是兄弟关系）。仅仅为了代码复用，生硬地抽象出一个父类出来，会影响到代码的可读性。如果不熟悉背后设计思路的同事，发现 Crawler 类和 PageAnalyzer 类继承同一个父类，而父类中定义的却只是 URL 相关的操作，会觉得这个代码写得莫名其妙，理解不了。这个时候，使用组合就更加合理、更加灵活。具体的代码实现如下所示：\n\n```java\npublic class Url {\n  //...省略属性和方法\n}\n\npublic class Crawler {\n  private Url url; // 组合\n  public Crawler() {\n    this.url = new Url();\n  }\n  //...\n}\n\npublic class PageAnalyzer {\n  private Url url; // 组合\n  public PageAnalyzer() {\n    this.url = new Url();\n  }\n  //..\n}\n```\n\n\n\n还有一些特殊的场景要求我们必须使用继承。如果你不能改变一个函数的入参类型，而入参又非接口，为了支持多态，只能采用继承来实现。比如下面这样一段代码，其中 FeignClient 是一个外部类，我们没有权限去修改这部分代码，但是我们希望能重写这个类在运行时执行的 encode() 函数。这个时候，我们只能采用继承来实现了。\n\n\n\n```java\npublic class FeignClient { // Feign Client框架代码\n  //...省略其他代码...\n  public void encode(String url) { //... }\n}\n\npublic void demofunction(FeignClient feignClient) {\n  //...\n  feignClient.encode(url);\n  //...\n}\n\npublic class CustomizedFeignClient extends FeignClient {\n  @Override\n  public void encode(String url) { //...重写encode的实现...}\n}\n\n// 调用\nFeignClient client = new CustomizedFeignClient();\ndemofunction(client);\n```\n\n尽管有些人说，要杜绝继承，100% 用组合代替继承，但是我的观点没那么极端！之所以“多用组合少用继承”这个口号喊得这么响，只是因为，长期以来，我们过度使用继承。还是那句话，组合并不完美，继承也不是一无是处。只要我们控制好它们的副作用、发挥它们各自的优势，在不同的场合下，恰当地选择使用继承还是组合，这才是我们所追求的境界。\n\n\n\n\n\n## 如何通过封装、抽象、模块化、中间层等解耦代码？\n\n### “解耦”为何如此重要？\n\n1. 软件设计与开发最重要的工作之一就是应对复杂性。人处理复杂性的能力是有限的。过于复杂的代码往往在可读性、可维护性上都不友好。那如何来控制代码的复杂性呢？手段有很多，我个人认为，最关键的就是解耦，保证代码松耦合、高内聚。如果说重构是保证代码质量不至于腐化到无可救药地步的有效手段，那么利用解耦的方法对代码重构，就是保证代码不至于复杂到无法控制的有效手段。\n2. 后文迪米特法则有介绍，什么是“高内聚、松耦合”。。实际上，“高内聚、松耦合”是一个比较通用的设计思想，不仅可以指导细粒度的类和类之间关系的设计，还能指导粗粒度的系统、架构、模块的设计。相对于编码规范，它能够在更高层次上提高代码的可读性和可维护性。\n3. 不管是阅读代码还是修改代码，“高内聚、松耦合”的特性可以让我们聚焦在某一模块或类中，不需要了解太多其他模块或类的代码，让我们的焦点不至于过于发散，降低了阅读和修改代码的难度。而且，因为依赖关系简单，耦合小，修改代码不至于牵一发而动全身，代码改动比较集中，引入 bug 的风险也就减少了很多。同时，“高内聚、松耦合”的代码可测试性也更加好，容易 mock 或者很少需要 mock 外部依赖的模块或者类。\n4. 除此之外，代码“高内聚、松耦合”，也就意味着，代码结构清晰、分层和模块化合理、依赖关系简单、模块或类之间的耦合小，那代码整体的质量就不会差。即便某个具体的类或者模块设计得不怎么合理，代码质量不怎么高，影响的范围是非常有限的。我们可以聚焦于这个模块或者类，做相应的小型重构。而相对于代码结构的调整，这种改动范围比较集中的小型重构的难度就容易多了。\n\n\n\n### 代码是否需要“解耦”？\n\n1. 那现在问题来了，我们该怎么判断代码的耦合程度呢？或者说，怎么判断代码是否符合“高内聚、松耦合”呢？再或者说，如何判断系统是否需要解耦重构呢？\n2. 间接的衡量标准有很多，前面我们讲到了一些，比如，看修改代码会不会牵一发而动全身。除此之外，还有一个直接的衡量标准，也是我在阅读源码的时候经常会用到的，那就是把模块与模块之间、类与类之间的依赖关系画出来，根据依赖关系图的复杂性来判断是否需要解耦重构。\n3. 如果依赖关系复杂、混乱，那从代码结构上来讲，可读性和可维护性肯定不是太好，那我们就需要考虑是否可以通过解耦的方法，让依赖关系变得清晰、简单。当然，这种判断还是有比较强的主观色彩，但是可以作为一种参考和梳理依赖的手段，配合间接的衡量标准一块来使用。\n\n### 如何给代码“解耦”？\n\n>  封装与抽象\n\n封装和抽象作为两个非常通用的设计思想，可以应用在很多设计场景中，比如系统、模块、lib、组件、接口、类等等的设计。封装和抽象可以有效地隐藏实现的复杂性，隔离实现的易变性，给依赖的模块提供稳定且易用的抽象接口\n\n\n\n> 中间层\n\n引入中间层能简化模块或类之间的依赖关系。下面这张图是引入中间层前后的依赖关系对比图。在引入数据存储中间层之前，A、B、C 三个模块都要依赖内存一级缓存、Redis 二级缓存、DB 持久化存储三个模块。在引入中间层之后，三个模块只需要依赖数据存储一个模块即可。从图上可以看出，中间层的引入明显地简化了依赖关系，让代码结构更加清晰\n\n\n\n<img src=\"https://npm.elemecdn.com/youthlql@1.0.0/design_patterns/design_ideas/0003.png\"/>\n\n\n\n除此之外，我们在进行重构的时候，引入中间层可以起到过渡的作用，能够让开发和重构同步进行，不互相干扰。比如，某个接口设计得有问题，我们需要修改它的定义，同时，所有调用这个接口的代码都要做相应的改动。如果新开发的代码也用到这个接口，那开发就跟重构冲突了。为了让重构能小步快跑，我们可以分下面四个阶段来完成接口的修改。\n\n\n\n- 第一阶段：引入一个中间层，包裹老的接口，提供新的接口定义。\n- 第二阶段：新开发的代码依赖中间层提供的新接口。\n- 第三阶段：将依赖老接口的代码改为调用新接口。\n- 第四阶段：确保所有的代码都调用新接口之后，删除掉老的接口。\n\n这样，每个阶段的开发工作量都不会很大，都可以在很短的时间内完成。重构跟开发冲突的概率也变小了。\n\n\n\n\n\n> 模块化\n\n模块化是构建复杂系统常用的手段。不仅在软件行业，在建筑、机械制造等行业，这个手段也非常有用。对于一个大型复杂系统来说，没有人能掌控所有的细节。之所以我们能搭建出如此复杂的系统，并且能维护得了，最主要的原因就是将系统划分成各个独立的模块，让不同的人负责不同的模块，这样即便在不了解全部细节的情况下，管理者也能协调各个模块，让整个系统有效运转。\n\n\n\n\n\n>  其他设计思想和原则\n\n“高内聚、松耦合”是一个非常重要的设计思想，能够有效提高代码的可读性和可维护性，缩小功能改动导致的代码改动范围。实际上，在前面的章节中，我们已经多次提到过这个设计思想。很多设计原则都以实现代码的“高内聚、松耦合”为目的。我们来一块总结回顾一下都有哪些原则。\n\n(这里没有讲的，在后面文章里)\n\n- 单一职责原则\n\n我们前面提到，内聚性和耦合性并非独立的。高内聚会让代码更加松耦合，而实现高内聚的重要指导原则就是单一职责原则。模块或者类的职责设计得单一，而不是大而全，那依赖它的类和它依赖的类就会比较少，代码耦合也就相应的降低了。\n\n\n\n- 基于接口而非实现编程\n\n基于接口而非实现编程能通过接口这样一个中间层，隔离变化和具体的实现。这样做的好处是，在有依赖关系的两个模块或类之间，一个模块或者类的改动，不会影响到另一个模块或类。实际上，这就相当于将一种强依赖关系（强耦合）解耦为了弱依赖关系（弱耦合）。依赖注入\n\n\n\n- 依赖注入\n\n跟基于接口而非实现编程思想类似，依赖注入也是将代码之间的强耦合变为弱耦合。尽管依赖注入无法将本应该有依赖关系的两个类，解耦为没有依赖关系，但可以让耦合关系没那么紧密，容易做到插拔替换\n\n\n\n- 多用组合少用继承\n\n我们知道，继承是一种强依赖关系，父类与子类高度耦合，且这种耦合关系非常脆弱，牵一发而动全身，父类的每一次改动都会影响所有的子类。相反，组合关系是一种弱依赖关系，这种关系更加灵活，所以，对于继承结构比较复杂的代码，利用组合来替换继承，也是一种解耦的有效手段。\n\n\n\n- 迪米特法则\n\n迪米特法则讲的是，不该有直接依赖关系的类之间，不要有依赖；有依赖关系的类之间，尽量只依赖必要的接口。从定义上，我们明显可以看出，这条原则的目的就是为了实现代码的松耦合。至于如何应用这条原则来解耦代码，你可以回过头去阅读一下第 22 讲，这里我就不赘述了。除了上面讲到的这些设计思想和原则之外，还有一些设计模式也是为了解耦依赖，比如观察者模式，有关这一部分的内容，我们留在设计模式模块中慢慢讲解。\n\n\n\n","slug":"2024-04-21-设计模式-01.设计思想","published":1,"updated":"2024-05-01T05:29:39.556Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cly2c4k3s000tqsvd8obm795n","content":"<h1 id=\"声明\"><a href=\"#声明\" class=\"headerlink\" title=\"声明\"></a>声明</h1><blockquote>\n<ol>\n<li>此系列文章非本人原创，是学习笔记。</li>\n<li>设计模式系列以后会持续更新，包括已经发布的设计模式文章，因为后续还要再多看一下书，教程和开源项目等，继续润色文章。</li>\n</ol>\n</blockquote>\n<p>下面讲一些常见的设计思想</p>\n<h2 id=\"基于接口而非实现编程\"><a href=\"#基于接口而非实现编程\" class=\"headerlink\" title=\"基于接口而非实现编程\"></a>基于接口而非实现编程</h2><p>这个原则非常重要，是一种非常有效的提高代码质量的手段，在平时的开发中特别经常被用到。</p>\n<h3 id=\"如何解读原则中的“接口”二字？\"><a href=\"#如何解读原则中的“接口”二字？\" class=\"headerlink\" title=\"如何解读原则中的“接口”二字？\"></a>如何解读原则中的“接口”二字？</h3><ol>\n<li>“基于接口而非实现编程”这条原则的英文描述是：“Program to an interface, not an implementation”。我们理解这条原则的时候，千万不要一开始就与具体的编程语言挂钩，局限在编程语言的“接口”语法中（比如 Java 中的 interface 接口语法）。这条原则最早出现于 1994 年 GoF 的《设计模式》这本书，它先于很多编程语言而诞生（比如 Java 语言），是一条比较抽象、泛化的设计思想。</li>\n<li>实际上，理解这条原则的关键，就是理解其中的“接口”两个字。还记得我们上一节课讲的“接口”的定义吗？从本质上来看，“接口”就是一组“协议”或者“约定”，是功能提供者提供给使用者的一个“功能列表”。“接口”在不同的应用场景下会有不同的解读，比如服务端与客户端之间的“接口”，类库提供的“接口”，甚至是一组通信的协议都可以叫作“接口”。刚刚对“接口”的理解，都比较偏上层、偏抽象，与实际的写代码离得有点远。如果落实到具体的编码，“基于接口而非实现编程”这条原则中的“接口”，可以理解为编程语言中的接口或者抽象类。</li>\n<li>前面我们提到，这条原则能非常有效地提高代码质量，之所以这么说，那是因为，应用这条原则，可以将接口和实现相分离，封装不稳定的实现，暴露稳定的接口。上游系统面向接口而非实现编程，不依赖不稳定的实现细节，这样当实现发生变化的时候，上游系统的代码基本上不需要做改动，以此来降低耦合性，提高扩展性。</li>\n<li>实际上，“基于接口而非实现编程”这条原则的另一个表述方式，是“基于抽象而非实现编程”。后者的表述方式其实更能体现这条原则的设计初衷。在软件开发中，最大的挑战之一就是需求的不断变化，这也是考验代码设计好坏的一个标准。<strong>越抽象、越顶层、越脱离具体某一实现的设计，越能提高代码的灵活性，越能应对未来的需求变化。好的代码设计，不仅能应对当下的需求，而且在将来需求发生变化的时候，仍然能够在不破坏原有代码设计的情况下灵活应对</strong>。而抽象就是提高代码扩展性、灵活性、可维护性最有效的手段之一。</li>\n</ol>\n<h3 id=\"如何将这条原则应用到实战中？\"><a href=\"#如何将这条原则应用到实战中？\" class=\"headerlink\" title=\"如何将这条原则应用到实战中？\"></a>如何将这条原则应用到实战中？</h3><p>假设我们的系统中有很多涉及图片处理和存储的业务逻辑。图片经过处理之后被上传到阿里云上。为了代码复用，我们封装了图片存储相关的代码逻辑，提供了一个统一的 AliyunImageStore 类，供整个系统来使用。具体的代码实现如下所示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AliyunImageStore</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">//...省略属性、构造函数等...</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">createBucketIfNotExisting</span><span class=\"params\">(String bucketName)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...创建bucket代码逻辑...</span></span><br><span class=\"line\">    <span class=\"comment\">// ...失败会抛出异常..</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">public</span> String <span class=\"title function_\">generateAccessToken</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...根据accesskey/secrectkey等生成access token</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">public</span> String <span class=\"title function_\">uploadToAliyun</span><span class=\"params\">(Image image, String bucketName, String accessToken)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//...上传图片到阿里云...</span></span><br><span class=\"line\">    <span class=\"comment\">//...返回图片存储在阿里云上的地址(url）...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">public</span> Image <span class=\"title function_\">downloadFromAliyun</span><span class=\"params\">(String url, String accessToken)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//...从阿里云下载图片...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// AliyunImageStore类的使用举例</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ImageProcessingJob</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">String</span> <span class=\"variable\">BUCKET_NAME</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;ai_images_bucket&quot;</span>;</span><br><span class=\"line\">  <span class=\"comment\">//...省略其他无关代码...</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">process</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">Image</span> <span class=\"variable\">image</span> <span class=\"operator\">=</span> ...; <span class=\"comment\">//处理图片，并封装为Image对象</span></span><br><span class=\"line\">    <span class=\"type\">AliyunImageStore</span> <span class=\"variable\">imageStore</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">AliyunImageStore</span>(<span class=\"comment\">/*省略参数*/</span>);</span><br><span class=\"line\">    imageStore.createBucketIfNotExisting(BUCKET_NAME);</span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">accessToken</span> <span class=\"operator\">=</span> imageStore.generateAccessToken();</span><br><span class=\"line\">    imagestore.uploadToAliyun(image, BUCKET_NAME, accessToken);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<ol>\n<li>整个上传流程包含三个步骤：创建 bucket（你可以简单理解为存储目录）、生成 access token 访问凭证、携带 access token 上传图片到指定的 bucket 中。代码实现非常简单，类中的几个方法定义得都很干净，用起来也很清晰，乍看起来没有太大问题，完全能满足我们将图片存储在阿里云的业务需求。</li>\n<li>不过，软件开发中唯一不变的就是变化。过了一段时间后，我们自建了私有云，不再将图片存储到阿里云了，而是将图片存储到自建私有云上。为了满足这样一个需求的变化，我们该如何修改代码呢？</li>\n<li>我们需要重新设计实现一个存储图片到私有云的 PrivateImageStore 类，并用它替换掉项目中所有的 AliyunImageStore 类对象。这样的修改听起来并不复杂，只是简单替换而已，对整个代码的改动并不大。不过，我们经常说，“细节是魔鬼”。这句话在软件开发中特别适用。实际上，刚刚的设计实现方式，就隐藏了很多容易出问题的“魔鬼细节”，我们一块来看看都有哪些。</li>\n<li>新的 PrivateImageStore 类需要设计实现哪些方法，才能在尽量最小化代码修改的情况下，替换掉 AliyunImageStore 类呢？这就要求我们必须将 AliyunImageStore 类中所定义的所有 public 方法，在 PrivateImageStore 类中都逐一定义并重新实现一遍。而这样做就会存在一些问题，我总结了下面两点。<ul>\n<li>首先，AliyunImageStore 类中有些函数命名暴露了实现细节，比如，uploadToAliyun() 和 downloadFromAliyun()。如果开发这个功能的同事没有接口意识、抽象思维，那这种暴露实现细节的命名方式就不足为奇了，毕竟最初我们只考虑将图片存储在阿里云上。而我们把这种包含“aliyun”字眼的方法，照抄到 PrivateImageStore 类中，显然是不合适的。如果我们在新类中重新命名 uploadToAliyun()、downloadFromAliyun() 这些方法，那就意味着，我们要修改项目中所有使用到这两个方法的代码，代码修改量可能就会很大。</li>\n<li>其次，将图片存储到阿里云的流程，跟存储到私有云的流程，可能并不是完全一致的。比如，阿里云的图片上传和下载的过程中，需要生产 access token，而私有云不需要 access token。一方面，AliyunImageStore 中定义的 generateAccessToken() 方法不能照抄到 PrivateImageStore 中；另一方面，我们在使用 AliyunImageStore 上传、下载图片的时候，代码中用到了 generateAccessToken() 方法，如果要改为私有云的上传下载流程，这些代码都需要做调整。</li>\n</ul>\n</li>\n<li>那这两个问题该如何解决呢？解决这个问题的根本方法就是，在编写代码的时候，要遵从“基于接口而非实现编程”的原则，具体来讲，我们需要做到下面这 3 点。<ol>\n<li>函数的命名不能暴露任何实现细节。比如，前面提到的 uploadToAliyun() 就不符合要求，应该改为去掉 aliyun 这样的字眼，改为更加抽象的命名方式，比如：upload()。</li>\n<li>封装具体的实现细节。比如，跟阿里云相关的特殊上传（或下载）流程不应该暴露给调用者。我们对上传（或下载）流程进行封装，对外提供一个包裹所有上传（或下载）细节的方法，给调用者使用。</li>\n<li>为实现类定义抽象的接口。具体的实现类都依赖统一的接口定义，遵从一致的上传功能协议。使用者依赖接口，而不是具体的实现类来编程。</li>\n</ol>\n</li>\n<li>我们按照这个思路，把代码重构一下。重构后的代码如下所示：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">ImageStore</span> &#123;</span><br><span class=\"line\">  String <span class=\"title function_\">upload</span><span class=\"params\">(Image image, String bucketName)</span>;</span><br><span class=\"line\">  Image <span class=\"title function_\">download</span><span class=\"params\">(String url)</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AliyunImageStore</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">ImageStore</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">//...省略属性、构造函数等...</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> String <span class=\"title function_\">upload</span><span class=\"params\">(Image image, String bucketName)</span> &#123;</span><br><span class=\"line\">    createBucketIfNotExisting(bucketName);</span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">accessToken</span> <span class=\"operator\">=</span> generateAccessToken();</span><br><span class=\"line\">    <span class=\"comment\">//...上传图片到阿里云...</span></span><br><span class=\"line\">    <span class=\"comment\">//...返回图片在阿里云上的地址(url)...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> Image <span class=\"title function_\">download</span><span class=\"params\">(String url)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">accessToken</span> <span class=\"operator\">=</span> generateAccessToken();</span><br><span class=\"line\">    <span class=\"comment\">//...从阿里云下载图片...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">createBucketIfNotExisting</span><span class=\"params\">(String bucketName)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...创建bucket...</span></span><br><span class=\"line\">    <span class=\"comment\">// ...失败会抛出异常..</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> String <span class=\"title function_\">generateAccessToken</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...根据accesskey/secrectkey等生成access token</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 上传下载流程改变：私有云不需要支持access token</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">PrivateImageStore</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">ImageStore</span>  &#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> String <span class=\"title function_\">upload</span><span class=\"params\">(Image image, String bucketName)</span> &#123;</span><br><span class=\"line\">    createBucketIfNotExisting(bucketName);</span><br><span class=\"line\">    <span class=\"comment\">//...上传图片到私有云...</span></span><br><span class=\"line\">    <span class=\"comment\">//...返回图片的url...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> Image <span class=\"title function_\">download</span><span class=\"params\">(String url)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//...从私有云下载图片...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">createBucketIfNotExisting</span><span class=\"params\">(String bucketName)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...创建bucket...</span></span><br><span class=\"line\">    <span class=\"comment\">// ...失败会抛出异常..</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ImageStore的使用举例</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ImageProcessingJob</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">String</span> <span class=\"variable\">BUCKET_NAME</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;ai_images_bucket&quot;</span>;</span><br><span class=\"line\">  <span class=\"comment\">//...省略其他无关代码...</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">process</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">Image</span> <span class=\"variable\">image</span> <span class=\"operator\">=</span> ...;<span class=\"comment\">//处理图片，并封装为Image对象</span></span><br><span class=\"line\">    <span class=\"type\">ImageStore</span> <span class=\"variable\">imageStore</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">PrivateImageStore</span>(...);</span><br><span class=\"line\">    imagestore.upload(image, BUCKET_NAME);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>除此之外，很多人在定义接口的时候，希望通过实现类来反推接口的定义。先把实现类写好，然后看实现类中有哪些方法，照抄到接口定义中。如果按照这种思考方式，就有可能导致接口定义不够抽象，依赖具体的实现。这样的接口设计就没有意义了。不过，如果你觉得这种思考方式更加顺畅，那也没问题，只是将实现类的方法搬移到接口定义中的时候，要有选择性的搬移，不要将跟具体实现相关的方法搬移到接口中，比如 AliyunImageStore 中的 generateAccessToken() 方法。</li>\n<li>总结一下，我们在做软件开发的时候，一定要有抽象意识、封装意识、接口意识。在定义接口的时候，不要暴露任何实现细节。接口的定义只表明做什么，而不是怎么做。而且，在设计接口的时候，我们要多思考一下，这样的接口设计是否足够通用，是否能够做到在替换具体的接口实现的时候，不需要任何接口定义的改动。</li>\n</ol>\n<h3 id=\"是否需要为每个类定义接口？\"><a href=\"#是否需要为每个类定义接口？\" class=\"headerlink\" title=\"是否需要为每个类定义接口？\"></a>是否需要为每个类定义接口？</h3><ol>\n<li>看了刚刚的讲解，你可能会有这样的疑问：为了满足这条原则，我是不是需要给每个实现类都定义对应的接口呢？在开发的时候，是不是任何代码都要只依赖接口，完全不依赖实现编程呢？</li>\n<li>做任何事情都要讲求一个“度”，过度使用这条原则，非得给每个类都定义接口，接口满天飞，也会导致不必要的开发负担。至于什么时候，该为某个类定义接口，实现基于接口的编程，什么时候不需要定义接口，直接使用实现类编程，我们做权衡的根本依据，还是要回归到设计原则诞生的初衷上来。只要搞清楚了这条原则是为了解决什么样的问题而产生的，你就会发现，很多之前模棱两可的问题，都会变得豁然开朗。</li>\n<li>前面我们也提到，这条原则的设计初衷是，将接口和实现相分离，封装不稳定的实现，暴露稳定的接口。上游系统面向接口而非实现编程，不依赖不稳定的实现细节，这样当实现发生变化的时候，上游系统的代码基本上不需要做改动，以此来降低代码间的耦合性，提高代码的扩展性。</li>\n<li>从这个设计初衷上来看，如果在我们的业务场景中，某个功能只有一种实现方式，未来也不可能被其他实现方式替换，那我们就没有必要为其设计接口，也没有必要基于接口编程，直接使用实现类就可以了。</li>\n<li>除此之外，越是不稳定的系统，我们越是要在代码的扩展性、维护性上下功夫。相反，如果某个系统特别稳定，在开发完之后，基本上不需要做维护，那我们就没有必要为其扩展性，投入不必要的开发时间。</li>\n</ol>\n<h2 id=\"多用组合少用继承\"><a href=\"#多用组合少用继承\" class=\"headerlink\" title=\"多用组合少用继承\"></a>多用组合少用继承</h2><p>在面向对象编程中，有一条非常经典的设计原则，那就是：组合优于继承，多用组合少用继承。为什么不推荐使用继承？组合相比继承有哪些优势？如何判断该用组合还是继承？今天，我们就围绕着这三个问题，来详细讲解一下这条设计原则。</p>\n<h3 id=\"为什么不推荐使用继承？\"><a href=\"#为什么不推荐使用继承？\" class=\"headerlink\" title=\"为什么不推荐使用继承？\"></a>为什么不推荐使用继承？</h3><ol>\n<li>继承是面向对象的四大特性之一，用来表示类之间的 is-a 关系，可以解决代码复用的问题。虽然继承有诸多作用，但继承层次过深、过复杂，也会影响到代码的可维护性。所以，对于是否应该在项目中使用继承，网上有很多争议。很多人觉得继承是一种反模式，应该尽量少用，甚至不用。为什么会有这样的争议？我们通过一个例子来解释一下。</li>\n<li>假设我们要设计一个关于鸟的类。我们将“鸟类”这样一个抽象的事物概念，定义为一个抽象类 AbstractBird。所有更细分的鸟，比如麻雀、鸽子、乌鸦等，都继承这个抽象类。</li>\n<li>我们知道，大部分鸟都会飞，那我们可不可以在 AbstractBird 抽象类中，定义一个 fly() 方法呢？答案是否定的。尽管大部分鸟都会飞，但也有特例，比如鸵鸟就不会飞。鸵鸟继承具有 fly() 方法的父类，那鸵鸟就具有“飞”这样的行为，这显然不符合我们对现实世界中事物的认识。当然，你可能会说，我在鸵鸟这个子类中重写（override）fly() 方法，让它抛出 UnSupportedMethodException 异常不就可以了吗？具体的代码实现如下所示：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AbstractBird</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">//...省略其他属性和方法...</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">fly</span><span class=\"params\">()</span> &#123; <span class=\"comment\">//... &#125;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Ostrich</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">AbstractBird</span> &#123; <span class=\"comment\">//鸵鸟</span></span><br><span class=\"line\">  <span class=\"comment\">//...省略其他属性和方法...</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">fly</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">UnSupportedMethodException</span>(<span class=\"string\">&quot;I can&#x27;t fly.&#x27;&quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>这种设计思路虽然可以解决问题，但不够优美。因为除了鸵鸟之外，不会飞的鸟还有很多，比如企鹅。对于这些不会飞的鸟来说，我们都需要重写 fly() 方法，抛出异常。这样的设计，一方面，徒增了编码的工作量；另一方面，也违背了我们之后要讲的最小知识原则（Least Knowledge Principle，也叫最少知识原则或者迪米特法则），暴露不该暴露的接口给外部，增加了类使用过程中被误用的概率。</li>\n<li>你可能又会说，那我们再通过 AbstractBird 类派生出两个更加细分的抽象类：会飞的鸟类 AbstractFlyableBird 和不会飞的鸟类 AbstractUnFlyableBird，让麻雀、乌鸦这些会飞的鸟都继承 AbstractFlyableBird，让鸵鸟、企鹅这些不会飞的鸟，都继承 AbstractUnFlyableBird 类，不就可以了吗？具体的继承关系如下图所示：</li>\n</ol>\n<img src=\"https://npm.elemecdn.com/youthlql@1.0.0/design_patterns/design_ideas/0001.png\"/>\n\n\n\n<ol>\n<li><p>从图中我们可以看出，继承关系变成了三层。不过，整体上来讲，目前的继承关系还比较简单，层次比较浅，也算是一种可以接受的设计思路。我们再继续加点难度。在刚刚这个场景中，我们只关注“鸟会不会飞”，但如果我们还关注“鸟会不会叫”，那这个时候，我们又该如何设计类之间的继承关系呢？</p>\n</li>\n<li><p>是否会飞？是否会叫？两个行为搭配起来会产生四种情况：会飞会叫、不会飞会叫、会飞不会叫、不会飞不会叫。如果我们继续沿用刚才的设计思路，那就需要再定义四个抽象类（AbstractFlyableTweetableBird、AbstractFlyableUnTweetableBird、AbstractUnFlyableTweetableBird、AbstractUnFlyableUnTweetableBird）。</p>\n</li>\n</ol>\n<img src=\"https://npm.elemecdn.com/youthlql@1.0.0/design_patterns/design_ideas/0002.png\"/>\n\n\n\n<ol>\n<li>如果我们还需要考虑“是否会下蛋”这样一个行为，那估计就要组合爆炸了。类的继承层次会越来越深、继承关系会越来越复杂。而这种层次很深、很复杂的继承关系，一方面，会导致代码的可读性变差。因为我们要搞清楚某个类具有哪些方法、属性，必须阅读父类的代码、父类的父类的代码……一直追溯到最顶层父类的代码。另一方面，这也破坏了类的封装特性，将父类的实现细节暴露给了子类。子类的实现依赖父类的实现，两者高度耦合，一旦父类代码修改，就会影响所有子类的逻辑。</li>\n<li>总之，继承最大的问题就在于：继承层次过深、继承关系过于复杂会影响到代码的可读性和可维护性。这也是为什么我们不推荐使用继承。那刚刚例子中继承存在的问题，我们又该如何来解决呢？你可以先自己思考一下，再听我下面的讲解。</li>\n</ol>\n<h3 id=\"组合相比继承有哪些优势？\"><a href=\"#组合相比继承有哪些优势？\" class=\"headerlink\" title=\"组合相比继承有哪些优势？\"></a>组合相比继承有哪些优势？</h3><ol>\n<li>实际上，我们可以利用组合（composition）、接口、委托（delegation）三个技术手段，一块儿来解决刚刚继承存在的问题。</li>\n<li>接口表示具有某种行为特性。针对“会飞”这样一个行为特性，我们可以定义一个 Flyable 接口，只让会飞的鸟去实现这个接口。对于会叫、会下蛋这些行为特性，我们可以类似地定义 Tweetable 接口、EggLayable 接口。我们将这个设计思路翻译成 Java 代码的话，就是下面这个样子：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">Flyable</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">void</span> <span class=\"title function_\">fly</span><span class=\"params\">()</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">Tweetable</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">void</span> <span class=\"title function_\">tweet</span><span class=\"params\">()</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">EggLayable</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">void</span> <span class=\"title function_\">layEgg</span><span class=\"params\">()</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Ostrich</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Tweetable</span>, EggLayable &#123;<span class=\"comment\">//鸵鸟</span></span><br><span class=\"line\">  <span class=\"comment\">//... 省略其他属性和方法...</span></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">tweet</span><span class=\"params\">()</span> &#123; <span class=\"comment\">//... &#125;</span></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">layEgg</span><span class=\"params\">()</span> &#123; <span class=\"comment\">//... &#125;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Sparrow</span> impelents Flyable, Tweetable, EggLayable &#123;<span class=\"comment\">//麻雀</span></span><br><span class=\"line\">  <span class=\"comment\">//... 省略其他属性和方法...</span></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">fly</span><span class=\"params\">()</span> &#123; <span class=\"comment\">//... &#125;</span></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">tweet</span><span class=\"params\">()</span> &#123; <span class=\"comment\">//... &#125;</span></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">layEgg</span><span class=\"params\">()</span> &#123; <span class=\"comment\">//... &#125;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>不过，我们知道，接口只声明方法，不定义实现。也就是说，每个会下蛋的鸟都要实现一遍 layEgg() 方法，并且实现逻辑是一样的，这就会导致代码重复的问题。那这个问题又该如何解决呢？</li>\n<li>我们可以针对三个接口再定义三个实现类，它们分别是：实现了 fly() 方法的 FlyAbility 类、实现了 tweet() 方法的 TweetAbility 类、实现了 layEgg() 方法的 EggLayAbility 类。然后，通过组合和委托技术来消除代码重复。具体的代码实现如下所示：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">Flyable</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">void</span> <span class=\"title function_\">fly</span><span class=\"params\">()</span>；</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">FlyAbility</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Flyable</span> &#123;</span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">fly</span><span class=\"params\">()</span> &#123; <span class=\"comment\">//... &#125;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//省略Tweetable/TweetAbility/EggLayable/EggLayAbility</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Ostrich</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Tweetable</span>, EggLayable &#123;<span class=\"comment\">//鸵鸟</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"type\">TweetAbility</span> <span class=\"variable\">tweetAbility</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">TweetAbility</span>(); <span class=\"comment\">//组合</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"type\">EggLayAbility</span> <span class=\"variable\">eggLayAbility</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">EggLayAbility</span>(); <span class=\"comment\">//组合</span></span><br><span class=\"line\">  <span class=\"comment\">//... 省略其他属性和方法...</span></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">tweet</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    tweetAbility.tweet(); <span class=\"comment\">// 委托</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">layEgg</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    eggLayAbility.layEgg(); <span class=\"comment\">// 委托</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>我们知道继承主要有三个作用：表示 is-a 关系，支持多态特性，代码复用。而这三个作用都可以通过其他技术手段来达成。比如 is-a 关系，我们可以通过组合和接口的 has-a 关系来替代；多态特性我们可以利用接口来实现；代码复用我们可以通过组合和委托来实现。所以，从理论上讲，通过组合、接口、委托三个技术手段，我们完全可以替换掉继承，在项目中不用或者少用继承关系，特别是一些复杂的继承关系。</p>\n<h3 id=\"如何判断该用组合还是继承？\"><a href=\"#如何判断该用组合还是继承？\" class=\"headerlink\" title=\"如何判断该用组合还是继承？\"></a>如何判断该用组合还是继承？</h3><ol>\n<li>尽管我们鼓励多用组合少用继承，但组合也并不是完美的，继承也并非一无是处。从上面的例子来看，继承改写成组合意味着要做更细粒度的类的拆分。这也就意味着，我们要定义更多的类和接口。类和接口的增多也就或多或少地增加代码的复杂程度和维护成本。所以，在实际的项目开发中，我们还是要根据具体的情况，来具体选择该用继承还是组合。</li>\n<li>如果类之间的继承结构稳定（不会轻易改变），继承层次比较浅（比如，最多有两层继承关系），继承关系不复杂，我们就可以大胆地使用继承。反之，系统越不稳定，继承层次很深，继承关系复杂，我们就尽量使用组合来替代继承。</li>\n<li>除此之外，还有一些设计模式会固定使用继承或者组合。比如，装饰者模式（decorator pattern）、策略模式（strategy pattern）、组合模式（composite pattern）等都使用了组合关系，而模板模式（template pattern）使用了继承关系。</li>\n<li>前面我们讲到继承可以实现代码复用。利用继承特性，我们把相同的属性和方法，抽取出来，定义到父类中。子类复用父类中的属性和方法，达到代码复用的目的。但是，有的时候，从业务含义上，A 类和 B 类并不一定具有继承关系。比如，Crawler 类和 PageAnalyzer 类，它们都用到了 URL 拼接和分割的功能，但并不具有继承关系（既不是父子关系，也不是兄弟关系）。仅仅为了代码复用，生硬地抽象出一个父类出来，会影响到代码的可读性。如果不熟悉背后设计思路的同事，发现 Crawler 类和 PageAnalyzer 类继承同一个父类，而父类中定义的却只是 URL 相关的操作，会觉得这个代码写得莫名其妙，理解不了。这个时候，使用组合就更加合理、更加灵活。具体的代码实现如下所示：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Url</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">//...省略属性和方法</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Crawler</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> Url url; <span class=\"comment\">// 组合</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"title function_\">Crawler</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.url = <span class=\"keyword\">new</span> <span class=\"title class_\">Url</span>();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">PageAnalyzer</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> Url url; <span class=\"comment\">// 组合</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"title function_\">PageAnalyzer</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.url = <span class=\"keyword\">new</span> <span class=\"title class_\">Url</span>();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//..</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>还有一些特殊的场景要求我们必须使用继承。如果你不能改变一个函数的入参类型，而入参又非接口，为了支持多态，只能采用继承来实现。比如下面这样一段代码，其中 FeignClient 是一个外部类，我们没有权限去修改这部分代码，但是我们希望能重写这个类在运行时执行的 encode() 函数。这个时候，我们只能采用继承来实现了。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">FeignClient</span> &#123; <span class=\"comment\">// Feign Client框架代码</span></span><br><span class=\"line\">  <span class=\"comment\">//...省略其他代码...</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">encode</span><span class=\"params\">(String url)</span> &#123; <span class=\"comment\">//... &#125;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">demofunction</span><span class=\"params\">(FeignClient feignClient)</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">//...</span></span><br><span class=\"line\">  feignClient.encode(url);</span><br><span class=\"line\">  <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">CustomizedFeignClient</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">FeignClient</span> &#123;</span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">encode</span><span class=\"params\">(String url)</span> &#123; <span class=\"comment\">//...重写encode的实现...&#125;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 调用</span></span><br><span class=\"line\"><span class=\"type\">FeignClient</span> <span class=\"variable\">client</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">CustomizedFeignClient</span>();</span><br><span class=\"line\">demofunction(client);</span><br></pre></td></tr></table></figure>\n\n<p>尽管有些人说，要杜绝继承，100% 用组合代替继承，但是我的观点没那么极端！之所以“多用组合少用继承”这个口号喊得这么响，只是因为，长期以来，我们过度使用继承。还是那句话，组合并不完美，继承也不是一无是处。只要我们控制好它们的副作用、发挥它们各自的优势，在不同的场合下，恰当地选择使用继承还是组合，这才是我们所追求的境界。</p>\n<h2 id=\"如何通过封装、抽象、模块化、中间层等解耦代码？\"><a href=\"#如何通过封装、抽象、模块化、中间层等解耦代码？\" class=\"headerlink\" title=\"如何通过封装、抽象、模块化、中间层等解耦代码？\"></a>如何通过封装、抽象、模块化、中间层等解耦代码？</h2><h3 id=\"“解耦”为何如此重要？\"><a href=\"#“解耦”为何如此重要？\" class=\"headerlink\" title=\"“解耦”为何如此重要？\"></a>“解耦”为何如此重要？</h3><ol>\n<li>软件设计与开发最重要的工作之一就是应对复杂性。人处理复杂性的能力是有限的。过于复杂的代码往往在可读性、可维护性上都不友好。那如何来控制代码的复杂性呢？手段有很多，我个人认为，最关键的就是解耦，保证代码松耦合、高内聚。如果说重构是保证代码质量不至于腐化到无可救药地步的有效手段，那么利用解耦的方法对代码重构，就是保证代码不至于复杂到无法控制的有效手段。</li>\n<li>后文迪米特法则有介绍，什么是“高内聚、松耦合”。。实际上，“高内聚、松耦合”是一个比较通用的设计思想，不仅可以指导细粒度的类和类之间关系的设计，还能指导粗粒度的系统、架构、模块的设计。相对于编码规范，它能够在更高层次上提高代码的可读性和可维护性。</li>\n<li>不管是阅读代码还是修改代码，“高内聚、松耦合”的特性可以让我们聚焦在某一模块或类中，不需要了解太多其他模块或类的代码，让我们的焦点不至于过于发散，降低了阅读和修改代码的难度。而且，因为依赖关系简单，耦合小，修改代码不至于牵一发而动全身，代码改动比较集中，引入 bug 的风险也就减少了很多。同时，“高内聚、松耦合”的代码可测试性也更加好，容易 mock 或者很少需要 mock 外部依赖的模块或者类。</li>\n<li>除此之外，代码“高内聚、松耦合”，也就意味着，代码结构清晰、分层和模块化合理、依赖关系简单、模块或类之间的耦合小，那代码整体的质量就不会差。即便某个具体的类或者模块设计得不怎么合理，代码质量不怎么高，影响的范围是非常有限的。我们可以聚焦于这个模块或者类，做相应的小型重构。而相对于代码结构的调整，这种改动范围比较集中的小型重构的难度就容易多了。</li>\n</ol>\n<h3 id=\"代码是否需要“解耦”？\"><a href=\"#代码是否需要“解耦”？\" class=\"headerlink\" title=\"代码是否需要“解耦”？\"></a>代码是否需要“解耦”？</h3><ol>\n<li>那现在问题来了，我们该怎么判断代码的耦合程度呢？或者说，怎么判断代码是否符合“高内聚、松耦合”呢？再或者说，如何判断系统是否需要解耦重构呢？</li>\n<li>间接的衡量标准有很多，前面我们讲到了一些，比如，看修改代码会不会牵一发而动全身。除此之外，还有一个直接的衡量标准，也是我在阅读源码的时候经常会用到的，那就是把模块与模块之间、类与类之间的依赖关系画出来，根据依赖关系图的复杂性来判断是否需要解耦重构。</li>\n<li>如果依赖关系复杂、混乱，那从代码结构上来讲，可读性和可维护性肯定不是太好，那我们就需要考虑是否可以通过解耦的方法，让依赖关系变得清晰、简单。当然，这种判断还是有比较强的主观色彩，但是可以作为一种参考和梳理依赖的手段，配合间接的衡量标准一块来使用。</li>\n</ol>\n<h3 id=\"如何给代码“解耦”？\"><a href=\"#如何给代码“解耦”？\" class=\"headerlink\" title=\"如何给代码“解耦”？\"></a>如何给代码“解耦”？</h3><blockquote>\n<p> 封装与抽象</p>\n</blockquote>\n<p>封装和抽象作为两个非常通用的设计思想，可以应用在很多设计场景中，比如系统、模块、lib、组件、接口、类等等的设计。封装和抽象可以有效地隐藏实现的复杂性，隔离实现的易变性，给依赖的模块提供稳定且易用的抽象接口</p>\n<blockquote>\n<p>中间层</p>\n</blockquote>\n<p>引入中间层能简化模块或类之间的依赖关系。下面这张图是引入中间层前后的依赖关系对比图。在引入数据存储中间层之前，A、B、C 三个模块都要依赖内存一级缓存、Redis 二级缓存、DB 持久化存储三个模块。在引入中间层之后，三个模块只需要依赖数据存储一个模块即可。从图上可以看出，中间层的引入明显地简化了依赖关系，让代码结构更加清晰</p>\n<img src=\"https://npm.elemecdn.com/youthlql@1.0.0/design_patterns/design_ideas/0003.png\"/>\n\n\n\n<p>除此之外，我们在进行重构的时候，引入中间层可以起到过渡的作用，能够让开发和重构同步进行，不互相干扰。比如，某个接口设计得有问题，我们需要修改它的定义，同时，所有调用这个接口的代码都要做相应的改动。如果新开发的代码也用到这个接口，那开发就跟重构冲突了。为了让重构能小步快跑，我们可以分下面四个阶段来完成接口的修改。</p>\n<ul>\n<li>第一阶段：引入一个中间层，包裹老的接口，提供新的接口定义。</li>\n<li>第二阶段：新开发的代码依赖中间层提供的新接口。</li>\n<li>第三阶段：将依赖老接口的代码改为调用新接口。</li>\n<li>第四阶段：确保所有的代码都调用新接口之后，删除掉老的接口。</li>\n</ul>\n<p>这样，每个阶段的开发工作量都不会很大，都可以在很短的时间内完成。重构跟开发冲突的概率也变小了。</p>\n<blockquote>\n<p>模块化</p>\n</blockquote>\n<p>模块化是构建复杂系统常用的手段。不仅在软件行业，在建筑、机械制造等行业，这个手段也非常有用。对于一个大型复杂系统来说，没有人能掌控所有的细节。之所以我们能搭建出如此复杂的系统，并且能维护得了，最主要的原因就是将系统划分成各个独立的模块，让不同的人负责不同的模块，这样即便在不了解全部细节的情况下，管理者也能协调各个模块，让整个系统有效运转。</p>\n<blockquote>\n<p> 其他设计思想和原则</p>\n</blockquote>\n<p>“高内聚、松耦合”是一个非常重要的设计思想，能够有效提高代码的可读性和可维护性，缩小功能改动导致的代码改动范围。实际上，在前面的章节中，我们已经多次提到过这个设计思想。很多设计原则都以实现代码的“高内聚、松耦合”为目的。我们来一块总结回顾一下都有哪些原则。</p>\n<p>(这里没有讲的，在后面文章里)</p>\n<ul>\n<li>单一职责原则</li>\n</ul>\n<p>我们前面提到，内聚性和耦合性并非独立的。高内聚会让代码更加松耦合，而实现高内聚的重要指导原则就是单一职责原则。模块或者类的职责设计得单一，而不是大而全，那依赖它的类和它依赖的类就会比较少，代码耦合也就相应的降低了。</p>\n<ul>\n<li>基于接口而非实现编程</li>\n</ul>\n<p>基于接口而非实现编程能通过接口这样一个中间层，隔离变化和具体的实现。这样做的好处是，在有依赖关系的两个模块或类之间，一个模块或者类的改动，不会影响到另一个模块或类。实际上，这就相当于将一种强依赖关系（强耦合）解耦为了弱依赖关系（弱耦合）。依赖注入</p>\n<ul>\n<li>依赖注入</li>\n</ul>\n<p>跟基于接口而非实现编程思想类似，依赖注入也是将代码之间的强耦合变为弱耦合。尽管依赖注入无法将本应该有依赖关系的两个类，解耦为没有依赖关系，但可以让耦合关系没那么紧密，容易做到插拔替换</p>\n<ul>\n<li>多用组合少用继承</li>\n</ul>\n<p>我们知道，继承是一种强依赖关系，父类与子类高度耦合，且这种耦合关系非常脆弱，牵一发而动全身，父类的每一次改动都会影响所有的子类。相反，组合关系是一种弱依赖关系，这种关系更加灵活，所以，对于继承结构比较复杂的代码，利用组合来替换继承，也是一种解耦的有效手段。</p>\n<ul>\n<li>迪米特法则</li>\n</ul>\n<p>迪米特法则讲的是，不该有直接依赖关系的类之间，不要有依赖；有依赖关系的类之间，尽量只依赖必要的接口。从定义上，我们明显可以看出，这条原则的目的就是为了实现代码的松耦合。至于如何应用这条原则来解耦代码，你可以回过头去阅读一下第 22 讲，这里我就不赘述了。除了上面讲到的这些设计思想和原则之外，还有一些设计模式也是为了解耦依赖，比如观察者模式，有关这一部分的内容，我们留在设计模式模块中慢慢讲解。</p>\n","site":{"data":{}},"cover_type":"img","excerpt":"","more":"<h1 id=\"声明\"><a href=\"#声明\" class=\"headerlink\" title=\"声明\"></a>声明</h1><blockquote>\n<ol>\n<li>此系列文章非本人原创，是学习笔记。</li>\n<li>设计模式系列以后会持续更新，包括已经发布的设计模式文章，因为后续还要再多看一下书，教程和开源项目等，继续润色文章。</li>\n</ol>\n</blockquote>\n<p>下面讲一些常见的设计思想</p>\n<h2 id=\"基于接口而非实现编程\"><a href=\"#基于接口而非实现编程\" class=\"headerlink\" title=\"基于接口而非实现编程\"></a>基于接口而非实现编程</h2><p>这个原则非常重要，是一种非常有效的提高代码质量的手段，在平时的开发中特别经常被用到。</p>\n<h3 id=\"如何解读原则中的“接口”二字？\"><a href=\"#如何解读原则中的“接口”二字？\" class=\"headerlink\" title=\"如何解读原则中的“接口”二字？\"></a>如何解读原则中的“接口”二字？</h3><ol>\n<li>“基于接口而非实现编程”这条原则的英文描述是：“Program to an interface, not an implementation”。我们理解这条原则的时候，千万不要一开始就与具体的编程语言挂钩，局限在编程语言的“接口”语法中（比如 Java 中的 interface 接口语法）。这条原则最早出现于 1994 年 GoF 的《设计模式》这本书，它先于很多编程语言而诞生（比如 Java 语言），是一条比较抽象、泛化的设计思想。</li>\n<li>实际上，理解这条原则的关键，就是理解其中的“接口”两个字。还记得我们上一节课讲的“接口”的定义吗？从本质上来看，“接口”就是一组“协议”或者“约定”，是功能提供者提供给使用者的一个“功能列表”。“接口”在不同的应用场景下会有不同的解读，比如服务端与客户端之间的“接口”，类库提供的“接口”，甚至是一组通信的协议都可以叫作“接口”。刚刚对“接口”的理解，都比较偏上层、偏抽象，与实际的写代码离得有点远。如果落实到具体的编码，“基于接口而非实现编程”这条原则中的“接口”，可以理解为编程语言中的接口或者抽象类。</li>\n<li>前面我们提到，这条原则能非常有效地提高代码质量，之所以这么说，那是因为，应用这条原则，可以将接口和实现相分离，封装不稳定的实现，暴露稳定的接口。上游系统面向接口而非实现编程，不依赖不稳定的实现细节，这样当实现发生变化的时候，上游系统的代码基本上不需要做改动，以此来降低耦合性，提高扩展性。</li>\n<li>实际上，“基于接口而非实现编程”这条原则的另一个表述方式，是“基于抽象而非实现编程”。后者的表述方式其实更能体现这条原则的设计初衷。在软件开发中，最大的挑战之一就是需求的不断变化，这也是考验代码设计好坏的一个标准。<strong>越抽象、越顶层、越脱离具体某一实现的设计，越能提高代码的灵活性，越能应对未来的需求变化。好的代码设计，不仅能应对当下的需求，而且在将来需求发生变化的时候，仍然能够在不破坏原有代码设计的情况下灵活应对</strong>。而抽象就是提高代码扩展性、灵活性、可维护性最有效的手段之一。</li>\n</ol>\n<h3 id=\"如何将这条原则应用到实战中？\"><a href=\"#如何将这条原则应用到实战中？\" class=\"headerlink\" title=\"如何将这条原则应用到实战中？\"></a>如何将这条原则应用到实战中？</h3><p>假设我们的系统中有很多涉及图片处理和存储的业务逻辑。图片经过处理之后被上传到阿里云上。为了代码复用，我们封装了图片存储相关的代码逻辑，提供了一个统一的 AliyunImageStore 类，供整个系统来使用。具体的代码实现如下所示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AliyunImageStore</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">//...省略属性、构造函数等...</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">createBucketIfNotExisting</span><span class=\"params\">(String bucketName)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...创建bucket代码逻辑...</span></span><br><span class=\"line\">    <span class=\"comment\">// ...失败会抛出异常..</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">public</span> String <span class=\"title function_\">generateAccessToken</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...根据accesskey/secrectkey等生成access token</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">public</span> String <span class=\"title function_\">uploadToAliyun</span><span class=\"params\">(Image image, String bucketName, String accessToken)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//...上传图片到阿里云...</span></span><br><span class=\"line\">    <span class=\"comment\">//...返回图片存储在阿里云上的地址(url）...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">public</span> Image <span class=\"title function_\">downloadFromAliyun</span><span class=\"params\">(String url, String accessToken)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//...从阿里云下载图片...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// AliyunImageStore类的使用举例</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ImageProcessingJob</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">String</span> <span class=\"variable\">BUCKET_NAME</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;ai_images_bucket&quot;</span>;</span><br><span class=\"line\">  <span class=\"comment\">//...省略其他无关代码...</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">process</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">Image</span> <span class=\"variable\">image</span> <span class=\"operator\">=</span> ...; <span class=\"comment\">//处理图片，并封装为Image对象</span></span><br><span class=\"line\">    <span class=\"type\">AliyunImageStore</span> <span class=\"variable\">imageStore</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">AliyunImageStore</span>(<span class=\"comment\">/*省略参数*/</span>);</span><br><span class=\"line\">    imageStore.createBucketIfNotExisting(BUCKET_NAME);</span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">accessToken</span> <span class=\"operator\">=</span> imageStore.generateAccessToken();</span><br><span class=\"line\">    imagestore.uploadToAliyun(image, BUCKET_NAME, accessToken);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<ol>\n<li>整个上传流程包含三个步骤：创建 bucket（你可以简单理解为存储目录）、生成 access token 访问凭证、携带 access token 上传图片到指定的 bucket 中。代码实现非常简单，类中的几个方法定义得都很干净，用起来也很清晰，乍看起来没有太大问题，完全能满足我们将图片存储在阿里云的业务需求。</li>\n<li>不过，软件开发中唯一不变的就是变化。过了一段时间后，我们自建了私有云，不再将图片存储到阿里云了，而是将图片存储到自建私有云上。为了满足这样一个需求的变化，我们该如何修改代码呢？</li>\n<li>我们需要重新设计实现一个存储图片到私有云的 PrivateImageStore 类，并用它替换掉项目中所有的 AliyunImageStore 类对象。这样的修改听起来并不复杂，只是简单替换而已，对整个代码的改动并不大。不过，我们经常说，“细节是魔鬼”。这句话在软件开发中特别适用。实际上，刚刚的设计实现方式，就隐藏了很多容易出问题的“魔鬼细节”，我们一块来看看都有哪些。</li>\n<li>新的 PrivateImageStore 类需要设计实现哪些方法，才能在尽量最小化代码修改的情况下，替换掉 AliyunImageStore 类呢？这就要求我们必须将 AliyunImageStore 类中所定义的所有 public 方法，在 PrivateImageStore 类中都逐一定义并重新实现一遍。而这样做就会存在一些问题，我总结了下面两点。<ul>\n<li>首先，AliyunImageStore 类中有些函数命名暴露了实现细节，比如，uploadToAliyun() 和 downloadFromAliyun()。如果开发这个功能的同事没有接口意识、抽象思维，那这种暴露实现细节的命名方式就不足为奇了，毕竟最初我们只考虑将图片存储在阿里云上。而我们把这种包含“aliyun”字眼的方法，照抄到 PrivateImageStore 类中，显然是不合适的。如果我们在新类中重新命名 uploadToAliyun()、downloadFromAliyun() 这些方法，那就意味着，我们要修改项目中所有使用到这两个方法的代码，代码修改量可能就会很大。</li>\n<li>其次，将图片存储到阿里云的流程，跟存储到私有云的流程，可能并不是完全一致的。比如，阿里云的图片上传和下载的过程中，需要生产 access token，而私有云不需要 access token。一方面，AliyunImageStore 中定义的 generateAccessToken() 方法不能照抄到 PrivateImageStore 中；另一方面，我们在使用 AliyunImageStore 上传、下载图片的时候，代码中用到了 generateAccessToken() 方法，如果要改为私有云的上传下载流程，这些代码都需要做调整。</li>\n</ul>\n</li>\n<li>那这两个问题该如何解决呢？解决这个问题的根本方法就是，在编写代码的时候，要遵从“基于接口而非实现编程”的原则，具体来讲，我们需要做到下面这 3 点。<ol>\n<li>函数的命名不能暴露任何实现细节。比如，前面提到的 uploadToAliyun() 就不符合要求，应该改为去掉 aliyun 这样的字眼，改为更加抽象的命名方式，比如：upload()。</li>\n<li>封装具体的实现细节。比如，跟阿里云相关的特殊上传（或下载）流程不应该暴露给调用者。我们对上传（或下载）流程进行封装，对外提供一个包裹所有上传（或下载）细节的方法，给调用者使用。</li>\n<li>为实现类定义抽象的接口。具体的实现类都依赖统一的接口定义，遵从一致的上传功能协议。使用者依赖接口，而不是具体的实现类来编程。</li>\n</ol>\n</li>\n<li>我们按照这个思路，把代码重构一下。重构后的代码如下所示：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">ImageStore</span> &#123;</span><br><span class=\"line\">  String <span class=\"title function_\">upload</span><span class=\"params\">(Image image, String bucketName)</span>;</span><br><span class=\"line\">  Image <span class=\"title function_\">download</span><span class=\"params\">(String url)</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AliyunImageStore</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">ImageStore</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">//...省略属性、构造函数等...</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> String <span class=\"title function_\">upload</span><span class=\"params\">(Image image, String bucketName)</span> &#123;</span><br><span class=\"line\">    createBucketIfNotExisting(bucketName);</span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">accessToken</span> <span class=\"operator\">=</span> generateAccessToken();</span><br><span class=\"line\">    <span class=\"comment\">//...上传图片到阿里云...</span></span><br><span class=\"line\">    <span class=\"comment\">//...返回图片在阿里云上的地址(url)...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> Image <span class=\"title function_\">download</span><span class=\"params\">(String url)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">accessToken</span> <span class=\"operator\">=</span> generateAccessToken();</span><br><span class=\"line\">    <span class=\"comment\">//...从阿里云下载图片...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">createBucketIfNotExisting</span><span class=\"params\">(String bucketName)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...创建bucket...</span></span><br><span class=\"line\">    <span class=\"comment\">// ...失败会抛出异常..</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> String <span class=\"title function_\">generateAccessToken</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...根据accesskey/secrectkey等生成access token</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 上传下载流程改变：私有云不需要支持access token</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">PrivateImageStore</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">ImageStore</span>  &#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> String <span class=\"title function_\">upload</span><span class=\"params\">(Image image, String bucketName)</span> &#123;</span><br><span class=\"line\">    createBucketIfNotExisting(bucketName);</span><br><span class=\"line\">    <span class=\"comment\">//...上传图片到私有云...</span></span><br><span class=\"line\">    <span class=\"comment\">//...返回图片的url...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> Image <span class=\"title function_\">download</span><span class=\"params\">(String url)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//...从私有云下载图片...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">createBucketIfNotExisting</span><span class=\"params\">(String bucketName)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...创建bucket...</span></span><br><span class=\"line\">    <span class=\"comment\">// ...失败会抛出异常..</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ImageStore的使用举例</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ImageProcessingJob</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">String</span> <span class=\"variable\">BUCKET_NAME</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;ai_images_bucket&quot;</span>;</span><br><span class=\"line\">  <span class=\"comment\">//...省略其他无关代码...</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">process</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">Image</span> <span class=\"variable\">image</span> <span class=\"operator\">=</span> ...;<span class=\"comment\">//处理图片，并封装为Image对象</span></span><br><span class=\"line\">    <span class=\"type\">ImageStore</span> <span class=\"variable\">imageStore</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">PrivateImageStore</span>(...);</span><br><span class=\"line\">    imagestore.upload(image, BUCKET_NAME);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>除此之外，很多人在定义接口的时候，希望通过实现类来反推接口的定义。先把实现类写好，然后看实现类中有哪些方法，照抄到接口定义中。如果按照这种思考方式，就有可能导致接口定义不够抽象，依赖具体的实现。这样的接口设计就没有意义了。不过，如果你觉得这种思考方式更加顺畅，那也没问题，只是将实现类的方法搬移到接口定义中的时候，要有选择性的搬移，不要将跟具体实现相关的方法搬移到接口中，比如 AliyunImageStore 中的 generateAccessToken() 方法。</li>\n<li>总结一下，我们在做软件开发的时候，一定要有抽象意识、封装意识、接口意识。在定义接口的时候，不要暴露任何实现细节。接口的定义只表明做什么，而不是怎么做。而且，在设计接口的时候，我们要多思考一下，这样的接口设计是否足够通用，是否能够做到在替换具体的接口实现的时候，不需要任何接口定义的改动。</li>\n</ol>\n<h3 id=\"是否需要为每个类定义接口？\"><a href=\"#是否需要为每个类定义接口？\" class=\"headerlink\" title=\"是否需要为每个类定义接口？\"></a>是否需要为每个类定义接口？</h3><ol>\n<li>看了刚刚的讲解，你可能会有这样的疑问：为了满足这条原则，我是不是需要给每个实现类都定义对应的接口呢？在开发的时候，是不是任何代码都要只依赖接口，完全不依赖实现编程呢？</li>\n<li>做任何事情都要讲求一个“度”，过度使用这条原则，非得给每个类都定义接口，接口满天飞，也会导致不必要的开发负担。至于什么时候，该为某个类定义接口，实现基于接口的编程，什么时候不需要定义接口，直接使用实现类编程，我们做权衡的根本依据，还是要回归到设计原则诞生的初衷上来。只要搞清楚了这条原则是为了解决什么样的问题而产生的，你就会发现，很多之前模棱两可的问题，都会变得豁然开朗。</li>\n<li>前面我们也提到，这条原则的设计初衷是，将接口和实现相分离，封装不稳定的实现，暴露稳定的接口。上游系统面向接口而非实现编程，不依赖不稳定的实现细节，这样当实现发生变化的时候，上游系统的代码基本上不需要做改动，以此来降低代码间的耦合性，提高代码的扩展性。</li>\n<li>从这个设计初衷上来看，如果在我们的业务场景中，某个功能只有一种实现方式，未来也不可能被其他实现方式替换，那我们就没有必要为其设计接口，也没有必要基于接口编程，直接使用实现类就可以了。</li>\n<li>除此之外，越是不稳定的系统，我们越是要在代码的扩展性、维护性上下功夫。相反，如果某个系统特别稳定，在开发完之后，基本上不需要做维护，那我们就没有必要为其扩展性，投入不必要的开发时间。</li>\n</ol>\n<h2 id=\"多用组合少用继承\"><a href=\"#多用组合少用继承\" class=\"headerlink\" title=\"多用组合少用继承\"></a>多用组合少用继承</h2><p>在面向对象编程中，有一条非常经典的设计原则，那就是：组合优于继承，多用组合少用继承。为什么不推荐使用继承？组合相比继承有哪些优势？如何判断该用组合还是继承？今天，我们就围绕着这三个问题，来详细讲解一下这条设计原则。</p>\n<h3 id=\"为什么不推荐使用继承？\"><a href=\"#为什么不推荐使用继承？\" class=\"headerlink\" title=\"为什么不推荐使用继承？\"></a>为什么不推荐使用继承？</h3><ol>\n<li>继承是面向对象的四大特性之一，用来表示类之间的 is-a 关系，可以解决代码复用的问题。虽然继承有诸多作用，但继承层次过深、过复杂，也会影响到代码的可维护性。所以，对于是否应该在项目中使用继承，网上有很多争议。很多人觉得继承是一种反模式，应该尽量少用，甚至不用。为什么会有这样的争议？我们通过一个例子来解释一下。</li>\n<li>假设我们要设计一个关于鸟的类。我们将“鸟类”这样一个抽象的事物概念，定义为一个抽象类 AbstractBird。所有更细分的鸟，比如麻雀、鸽子、乌鸦等，都继承这个抽象类。</li>\n<li>我们知道，大部分鸟都会飞，那我们可不可以在 AbstractBird 抽象类中，定义一个 fly() 方法呢？答案是否定的。尽管大部分鸟都会飞，但也有特例，比如鸵鸟就不会飞。鸵鸟继承具有 fly() 方法的父类，那鸵鸟就具有“飞”这样的行为，这显然不符合我们对现实世界中事物的认识。当然，你可能会说，我在鸵鸟这个子类中重写（override）fly() 方法，让它抛出 UnSupportedMethodException 异常不就可以了吗？具体的代码实现如下所示：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AbstractBird</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">//...省略其他属性和方法...</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">fly</span><span class=\"params\">()</span> &#123; <span class=\"comment\">//... &#125;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Ostrich</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">AbstractBird</span> &#123; <span class=\"comment\">//鸵鸟</span></span><br><span class=\"line\">  <span class=\"comment\">//...省略其他属性和方法...</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">fly</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">UnSupportedMethodException</span>(<span class=\"string\">&quot;I can&#x27;t fly.&#x27;&quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>这种设计思路虽然可以解决问题，但不够优美。因为除了鸵鸟之外，不会飞的鸟还有很多，比如企鹅。对于这些不会飞的鸟来说，我们都需要重写 fly() 方法，抛出异常。这样的设计，一方面，徒增了编码的工作量；另一方面，也违背了我们之后要讲的最小知识原则（Least Knowledge Principle，也叫最少知识原则或者迪米特法则），暴露不该暴露的接口给外部，增加了类使用过程中被误用的概率。</li>\n<li>你可能又会说，那我们再通过 AbstractBird 类派生出两个更加细分的抽象类：会飞的鸟类 AbstractFlyableBird 和不会飞的鸟类 AbstractUnFlyableBird，让麻雀、乌鸦这些会飞的鸟都继承 AbstractFlyableBird，让鸵鸟、企鹅这些不会飞的鸟，都继承 AbstractUnFlyableBird 类，不就可以了吗？具体的继承关系如下图所示：</li>\n</ol>\n<img src=\"https://npm.elemecdn.com/youthlql@1.0.0/design_patterns/design_ideas/0001.png\"/>\n\n\n\n<ol>\n<li><p>从图中我们可以看出，继承关系变成了三层。不过，整体上来讲，目前的继承关系还比较简单，层次比较浅，也算是一种可以接受的设计思路。我们再继续加点难度。在刚刚这个场景中，我们只关注“鸟会不会飞”，但如果我们还关注“鸟会不会叫”，那这个时候，我们又该如何设计类之间的继承关系呢？</p>\n</li>\n<li><p>是否会飞？是否会叫？两个行为搭配起来会产生四种情况：会飞会叫、不会飞会叫、会飞不会叫、不会飞不会叫。如果我们继续沿用刚才的设计思路，那就需要再定义四个抽象类（AbstractFlyableTweetableBird、AbstractFlyableUnTweetableBird、AbstractUnFlyableTweetableBird、AbstractUnFlyableUnTweetableBird）。</p>\n</li>\n</ol>\n<img src=\"https://npm.elemecdn.com/youthlql@1.0.0/design_patterns/design_ideas/0002.png\"/>\n\n\n\n<ol>\n<li>如果我们还需要考虑“是否会下蛋”这样一个行为，那估计就要组合爆炸了。类的继承层次会越来越深、继承关系会越来越复杂。而这种层次很深、很复杂的继承关系，一方面，会导致代码的可读性变差。因为我们要搞清楚某个类具有哪些方法、属性，必须阅读父类的代码、父类的父类的代码……一直追溯到最顶层父类的代码。另一方面，这也破坏了类的封装特性，将父类的实现细节暴露给了子类。子类的实现依赖父类的实现，两者高度耦合，一旦父类代码修改，就会影响所有子类的逻辑。</li>\n<li>总之，继承最大的问题就在于：继承层次过深、继承关系过于复杂会影响到代码的可读性和可维护性。这也是为什么我们不推荐使用继承。那刚刚例子中继承存在的问题，我们又该如何来解决呢？你可以先自己思考一下，再听我下面的讲解。</li>\n</ol>\n<h3 id=\"组合相比继承有哪些优势？\"><a href=\"#组合相比继承有哪些优势？\" class=\"headerlink\" title=\"组合相比继承有哪些优势？\"></a>组合相比继承有哪些优势？</h3><ol>\n<li>实际上，我们可以利用组合（composition）、接口、委托（delegation）三个技术手段，一块儿来解决刚刚继承存在的问题。</li>\n<li>接口表示具有某种行为特性。针对“会飞”这样一个行为特性，我们可以定义一个 Flyable 接口，只让会飞的鸟去实现这个接口。对于会叫、会下蛋这些行为特性，我们可以类似地定义 Tweetable 接口、EggLayable 接口。我们将这个设计思路翻译成 Java 代码的话，就是下面这个样子：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">Flyable</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">void</span> <span class=\"title function_\">fly</span><span class=\"params\">()</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">Tweetable</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">void</span> <span class=\"title function_\">tweet</span><span class=\"params\">()</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">EggLayable</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">void</span> <span class=\"title function_\">layEgg</span><span class=\"params\">()</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Ostrich</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Tweetable</span>, EggLayable &#123;<span class=\"comment\">//鸵鸟</span></span><br><span class=\"line\">  <span class=\"comment\">//... 省略其他属性和方法...</span></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">tweet</span><span class=\"params\">()</span> &#123; <span class=\"comment\">//... &#125;</span></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">layEgg</span><span class=\"params\">()</span> &#123; <span class=\"comment\">//... &#125;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Sparrow</span> impelents Flyable, Tweetable, EggLayable &#123;<span class=\"comment\">//麻雀</span></span><br><span class=\"line\">  <span class=\"comment\">//... 省略其他属性和方法...</span></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">fly</span><span class=\"params\">()</span> &#123; <span class=\"comment\">//... &#125;</span></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">tweet</span><span class=\"params\">()</span> &#123; <span class=\"comment\">//... &#125;</span></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">layEgg</span><span class=\"params\">()</span> &#123; <span class=\"comment\">//... &#125;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>不过，我们知道，接口只声明方法，不定义实现。也就是说，每个会下蛋的鸟都要实现一遍 layEgg() 方法，并且实现逻辑是一样的，这就会导致代码重复的问题。那这个问题又该如何解决呢？</li>\n<li>我们可以针对三个接口再定义三个实现类，它们分别是：实现了 fly() 方法的 FlyAbility 类、实现了 tweet() 方法的 TweetAbility 类、实现了 layEgg() 方法的 EggLayAbility 类。然后，通过组合和委托技术来消除代码重复。具体的代码实现如下所示：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">Flyable</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">void</span> <span class=\"title function_\">fly</span><span class=\"params\">()</span>；</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">FlyAbility</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Flyable</span> &#123;</span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">fly</span><span class=\"params\">()</span> &#123; <span class=\"comment\">//... &#125;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//省略Tweetable/TweetAbility/EggLayable/EggLayAbility</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Ostrich</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Tweetable</span>, EggLayable &#123;<span class=\"comment\">//鸵鸟</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"type\">TweetAbility</span> <span class=\"variable\">tweetAbility</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">TweetAbility</span>(); <span class=\"comment\">//组合</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"type\">EggLayAbility</span> <span class=\"variable\">eggLayAbility</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">EggLayAbility</span>(); <span class=\"comment\">//组合</span></span><br><span class=\"line\">  <span class=\"comment\">//... 省略其他属性和方法...</span></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">tweet</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    tweetAbility.tweet(); <span class=\"comment\">// 委托</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">layEgg</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    eggLayAbility.layEgg(); <span class=\"comment\">// 委托</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>我们知道继承主要有三个作用：表示 is-a 关系，支持多态特性，代码复用。而这三个作用都可以通过其他技术手段来达成。比如 is-a 关系，我们可以通过组合和接口的 has-a 关系来替代；多态特性我们可以利用接口来实现；代码复用我们可以通过组合和委托来实现。所以，从理论上讲，通过组合、接口、委托三个技术手段，我们完全可以替换掉继承，在项目中不用或者少用继承关系，特别是一些复杂的继承关系。</p>\n<h3 id=\"如何判断该用组合还是继承？\"><a href=\"#如何判断该用组合还是继承？\" class=\"headerlink\" title=\"如何判断该用组合还是继承？\"></a>如何判断该用组合还是继承？</h3><ol>\n<li>尽管我们鼓励多用组合少用继承，但组合也并不是完美的，继承也并非一无是处。从上面的例子来看，继承改写成组合意味着要做更细粒度的类的拆分。这也就意味着，我们要定义更多的类和接口。类和接口的增多也就或多或少地增加代码的复杂程度和维护成本。所以，在实际的项目开发中，我们还是要根据具体的情况，来具体选择该用继承还是组合。</li>\n<li>如果类之间的继承结构稳定（不会轻易改变），继承层次比较浅（比如，最多有两层继承关系），继承关系不复杂，我们就可以大胆地使用继承。反之，系统越不稳定，继承层次很深，继承关系复杂，我们就尽量使用组合来替代继承。</li>\n<li>除此之外，还有一些设计模式会固定使用继承或者组合。比如，装饰者模式（decorator pattern）、策略模式（strategy pattern）、组合模式（composite pattern）等都使用了组合关系，而模板模式（template pattern）使用了继承关系。</li>\n<li>前面我们讲到继承可以实现代码复用。利用继承特性，我们把相同的属性和方法，抽取出来，定义到父类中。子类复用父类中的属性和方法，达到代码复用的目的。但是，有的时候，从业务含义上，A 类和 B 类并不一定具有继承关系。比如，Crawler 类和 PageAnalyzer 类，它们都用到了 URL 拼接和分割的功能，但并不具有继承关系（既不是父子关系，也不是兄弟关系）。仅仅为了代码复用，生硬地抽象出一个父类出来，会影响到代码的可读性。如果不熟悉背后设计思路的同事，发现 Crawler 类和 PageAnalyzer 类继承同一个父类，而父类中定义的却只是 URL 相关的操作，会觉得这个代码写得莫名其妙，理解不了。这个时候，使用组合就更加合理、更加灵活。具体的代码实现如下所示：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Url</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">//...省略属性和方法</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Crawler</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> Url url; <span class=\"comment\">// 组合</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"title function_\">Crawler</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.url = <span class=\"keyword\">new</span> <span class=\"title class_\">Url</span>();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">PageAnalyzer</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> Url url; <span class=\"comment\">// 组合</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"title function_\">PageAnalyzer</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.url = <span class=\"keyword\">new</span> <span class=\"title class_\">Url</span>();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//..</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>还有一些特殊的场景要求我们必须使用继承。如果你不能改变一个函数的入参类型，而入参又非接口，为了支持多态，只能采用继承来实现。比如下面这样一段代码，其中 FeignClient 是一个外部类，我们没有权限去修改这部分代码，但是我们希望能重写这个类在运行时执行的 encode() 函数。这个时候，我们只能采用继承来实现了。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">FeignClient</span> &#123; <span class=\"comment\">// Feign Client框架代码</span></span><br><span class=\"line\">  <span class=\"comment\">//...省略其他代码...</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">encode</span><span class=\"params\">(String url)</span> &#123; <span class=\"comment\">//... &#125;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">demofunction</span><span class=\"params\">(FeignClient feignClient)</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">//...</span></span><br><span class=\"line\">  feignClient.encode(url);</span><br><span class=\"line\">  <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">CustomizedFeignClient</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">FeignClient</span> &#123;</span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">encode</span><span class=\"params\">(String url)</span> &#123; <span class=\"comment\">//...重写encode的实现...&#125;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 调用</span></span><br><span class=\"line\"><span class=\"type\">FeignClient</span> <span class=\"variable\">client</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">CustomizedFeignClient</span>();</span><br><span class=\"line\">demofunction(client);</span><br></pre></td></tr></table></figure>\n\n<p>尽管有些人说，要杜绝继承，100% 用组合代替继承，但是我的观点没那么极端！之所以“多用组合少用继承”这个口号喊得这么响，只是因为，长期以来，我们过度使用继承。还是那句话，组合并不完美，继承也不是一无是处。只要我们控制好它们的副作用、发挥它们各自的优势，在不同的场合下，恰当地选择使用继承还是组合，这才是我们所追求的境界。</p>\n<h2 id=\"如何通过封装、抽象、模块化、中间层等解耦代码？\"><a href=\"#如何通过封装、抽象、模块化、中间层等解耦代码？\" class=\"headerlink\" title=\"如何通过封装、抽象、模块化、中间层等解耦代码？\"></a>如何通过封装、抽象、模块化、中间层等解耦代码？</h2><h3 id=\"“解耦”为何如此重要？\"><a href=\"#“解耦”为何如此重要？\" class=\"headerlink\" title=\"“解耦”为何如此重要？\"></a>“解耦”为何如此重要？</h3><ol>\n<li>软件设计与开发最重要的工作之一就是应对复杂性。人处理复杂性的能力是有限的。过于复杂的代码往往在可读性、可维护性上都不友好。那如何来控制代码的复杂性呢？手段有很多，我个人认为，最关键的就是解耦，保证代码松耦合、高内聚。如果说重构是保证代码质量不至于腐化到无可救药地步的有效手段，那么利用解耦的方法对代码重构，就是保证代码不至于复杂到无法控制的有效手段。</li>\n<li>后文迪米特法则有介绍，什么是“高内聚、松耦合”。。实际上，“高内聚、松耦合”是一个比较通用的设计思想，不仅可以指导细粒度的类和类之间关系的设计，还能指导粗粒度的系统、架构、模块的设计。相对于编码规范，它能够在更高层次上提高代码的可读性和可维护性。</li>\n<li>不管是阅读代码还是修改代码，“高内聚、松耦合”的特性可以让我们聚焦在某一模块或类中，不需要了解太多其他模块或类的代码，让我们的焦点不至于过于发散，降低了阅读和修改代码的难度。而且，因为依赖关系简单，耦合小，修改代码不至于牵一发而动全身，代码改动比较集中，引入 bug 的风险也就减少了很多。同时，“高内聚、松耦合”的代码可测试性也更加好，容易 mock 或者很少需要 mock 外部依赖的模块或者类。</li>\n<li>除此之外，代码“高内聚、松耦合”，也就意味着，代码结构清晰、分层和模块化合理、依赖关系简单、模块或类之间的耦合小，那代码整体的质量就不会差。即便某个具体的类或者模块设计得不怎么合理，代码质量不怎么高，影响的范围是非常有限的。我们可以聚焦于这个模块或者类，做相应的小型重构。而相对于代码结构的调整，这种改动范围比较集中的小型重构的难度就容易多了。</li>\n</ol>\n<h3 id=\"代码是否需要“解耦”？\"><a href=\"#代码是否需要“解耦”？\" class=\"headerlink\" title=\"代码是否需要“解耦”？\"></a>代码是否需要“解耦”？</h3><ol>\n<li>那现在问题来了，我们该怎么判断代码的耦合程度呢？或者说，怎么判断代码是否符合“高内聚、松耦合”呢？再或者说，如何判断系统是否需要解耦重构呢？</li>\n<li>间接的衡量标准有很多，前面我们讲到了一些，比如，看修改代码会不会牵一发而动全身。除此之外，还有一个直接的衡量标准，也是我在阅读源码的时候经常会用到的，那就是把模块与模块之间、类与类之间的依赖关系画出来，根据依赖关系图的复杂性来判断是否需要解耦重构。</li>\n<li>如果依赖关系复杂、混乱，那从代码结构上来讲，可读性和可维护性肯定不是太好，那我们就需要考虑是否可以通过解耦的方法，让依赖关系变得清晰、简单。当然，这种判断还是有比较强的主观色彩，但是可以作为一种参考和梳理依赖的手段，配合间接的衡量标准一块来使用。</li>\n</ol>\n<h3 id=\"如何给代码“解耦”？\"><a href=\"#如何给代码“解耦”？\" class=\"headerlink\" title=\"如何给代码“解耦”？\"></a>如何给代码“解耦”？</h3><blockquote>\n<p> 封装与抽象</p>\n</blockquote>\n<p>封装和抽象作为两个非常通用的设计思想，可以应用在很多设计场景中，比如系统、模块、lib、组件、接口、类等等的设计。封装和抽象可以有效地隐藏实现的复杂性，隔离实现的易变性，给依赖的模块提供稳定且易用的抽象接口</p>\n<blockquote>\n<p>中间层</p>\n</blockquote>\n<p>引入中间层能简化模块或类之间的依赖关系。下面这张图是引入中间层前后的依赖关系对比图。在引入数据存储中间层之前，A、B、C 三个模块都要依赖内存一级缓存、Redis 二级缓存、DB 持久化存储三个模块。在引入中间层之后，三个模块只需要依赖数据存储一个模块即可。从图上可以看出，中间层的引入明显地简化了依赖关系，让代码结构更加清晰</p>\n<img src=\"https://npm.elemecdn.com/youthlql@1.0.0/design_patterns/design_ideas/0003.png\"/>\n\n\n\n<p>除此之外，我们在进行重构的时候，引入中间层可以起到过渡的作用，能够让开发和重构同步进行，不互相干扰。比如，某个接口设计得有问题，我们需要修改它的定义，同时，所有调用这个接口的代码都要做相应的改动。如果新开发的代码也用到这个接口，那开发就跟重构冲突了。为了让重构能小步快跑，我们可以分下面四个阶段来完成接口的修改。</p>\n<ul>\n<li>第一阶段：引入一个中间层，包裹老的接口，提供新的接口定义。</li>\n<li>第二阶段：新开发的代码依赖中间层提供的新接口。</li>\n<li>第三阶段：将依赖老接口的代码改为调用新接口。</li>\n<li>第四阶段：确保所有的代码都调用新接口之后，删除掉老的接口。</li>\n</ul>\n<p>这样，每个阶段的开发工作量都不会很大，都可以在很短的时间内完成。重构跟开发冲突的概率也变小了。</p>\n<blockquote>\n<p>模块化</p>\n</blockquote>\n<p>模块化是构建复杂系统常用的手段。不仅在软件行业，在建筑、机械制造等行业，这个手段也非常有用。对于一个大型复杂系统来说，没有人能掌控所有的细节。之所以我们能搭建出如此复杂的系统，并且能维护得了，最主要的原因就是将系统划分成各个独立的模块，让不同的人负责不同的模块，这样即便在不了解全部细节的情况下，管理者也能协调各个模块，让整个系统有效运转。</p>\n<blockquote>\n<p> 其他设计思想和原则</p>\n</blockquote>\n<p>“高内聚、松耦合”是一个非常重要的设计思想，能够有效提高代码的可读性和可维护性，缩小功能改动导致的代码改动范围。实际上，在前面的章节中，我们已经多次提到过这个设计思想。很多设计原则都以实现代码的“高内聚、松耦合”为目的。我们来一块总结回顾一下都有哪些原则。</p>\n<p>(这里没有讲的，在后面文章里)</p>\n<ul>\n<li>单一职责原则</li>\n</ul>\n<p>我们前面提到，内聚性和耦合性并非独立的。高内聚会让代码更加松耦合，而实现高内聚的重要指导原则就是单一职责原则。模块或者类的职责设计得单一，而不是大而全，那依赖它的类和它依赖的类就会比较少，代码耦合也就相应的降低了。</p>\n<ul>\n<li>基于接口而非实现编程</li>\n</ul>\n<p>基于接口而非实现编程能通过接口这样一个中间层，隔离变化和具体的实现。这样做的好处是，在有依赖关系的两个模块或类之间，一个模块或者类的改动，不会影响到另一个模块或类。实际上，这就相当于将一种强依赖关系（强耦合）解耦为了弱依赖关系（弱耦合）。依赖注入</p>\n<ul>\n<li>依赖注入</li>\n</ul>\n<p>跟基于接口而非实现编程思想类似，依赖注入也是将代码之间的强耦合变为弱耦合。尽管依赖注入无法将本应该有依赖关系的两个类，解耦为没有依赖关系，但可以让耦合关系没那么紧密，容易做到插拔替换</p>\n<ul>\n<li>多用组合少用继承</li>\n</ul>\n<p>我们知道，继承是一种强依赖关系，父类与子类高度耦合，且这种耦合关系非常脆弱，牵一发而动全身，父类的每一次改动都会影响所有的子类。相反，组合关系是一种弱依赖关系，这种关系更加灵活，所以，对于继承结构比较复杂的代码，利用组合来替换继承，也是一种解耦的有效手段。</p>\n<ul>\n<li>迪米特法则</li>\n</ul>\n<p>迪米特法则讲的是，不该有直接依赖关系的类之间，不要有依赖；有依赖关系的类之间，尽量只依赖必要的接口。从定义上，我们明显可以看出，这条原则的目的就是为了实现代码的松耦合。至于如何应用这条原则来解耦代码，你可以回过头去阅读一下第 22 讲，这里我就不赘述了。除了上面讲到的这些设计思想和原则之外，还有一些设计模式也是为了解耦依赖，比如观察者模式，有关这一部分的内容，我们留在设计模式模块中慢慢讲解。</p>\n"},{"title":"设计模式-02.经典设计原则-第二节[必读]","keywords":"设计模式，经典设计原则","description":"设计模式-经典设计原则，例如：迪米特法则，依赖反转原则，KISS等等。","cover":"https://npm.elemecdn.com/lql_static@latest/logo/design_patterns.jpg","abbrlink":"994a8ed3","date":"2024-05-01T05:28:50.000Z","_content":"\n# 声明\n\n> 1. 此系列文章非本人原创，是学习笔记。\n> 2. 设计模式系列以后会持续更新，包括已经发布的设计模式文章，因为后续还要再多看一下书，教程和开源项目等，继续润色文章。\n\n# 设计模式经典设计原则-第二节\n\n## 依赖反转原则（DIP）\n\n关于 SOLID 原则，我们已经学过单一职责、开闭、里式替换、接口隔离这四个原则。今天，我们再来学习最后一个原则：依赖反转原则。在前面，我们讲到，单一职责原则和开闭原则的原理比较简单，但是，想要在实践中用好却比较难。而今天我们要讲到的依赖反转原则正好相反。这个原则用起来比较简单，但概念理解起来比较难。比如，下面这几个问题，你看看能否清晰地回答出来：\n\n- “依赖反转”这个概念指的是“谁跟谁”的“什么依赖”被反转了？“反转”两个字该如何理解？\n- 我们还经常听到另外两个概念：“控制反转”和“依赖注入”。这两个概念跟“依赖反转”有什么区别和联系呢？它们说的是同一个事情吗？\n- 如果你熟悉 Java 语言，那 Spring 框架中的 IOC 跟这些概念又有什么关系呢？\n\n\n\n### 控制反转（IOC）\n\n在讲“依赖反转原则”之前，我们先讲一讲“控制反转”。控制反转的英文翻译是 Inversion Of Control，缩写为 IOC。此处我要强调一下，暂时别把这个“IOC”跟 Spring 框架的 IOC 联系在一起。关于 Spring 的 IOC，我们待会儿还会讲到。我们先通过一个例子来看一下，什么是控制反转。\n\n```java\npublic class UserServiceTest {\n  public static boolean doTest() {\n    // ... \n  }\n  \n  public static void main(String[] args) {//这部分逻辑可以放到框架中\n    if (doTest()) {\n      System.out.println(\"Test succeed.\");\n    } else {\n      System.out.println(\"Test failed.\");\n    }\n  }\n}\n```\n\n在上面的代码中，所有的流程都由程序员来控制。如果我们抽象出一个下面这样一个框架，我们再来看，如何利用框架来实现同样的功能。具体的代码实现如下所示：\n\n\n\n```java\npublic abstract class TestCase {\n  public void run() {\n    if (doTest()) {\n      System.out.println(\"Test succeed.\");\n    } else {\n      System.out.println(\"Test failed.\");\n    }\n  }\n  \n  public abstract boolean doTest();\n}\n\npublic class JunitApplication {\n  private static final List<TestCase> testCases = new ArrayList<>();\n  \n  public static void register(TestCase testCase) {\n    testCases.add(testCase);\n  }\n  \n  public static final void main(String[] args) {\n    for (TestCase case: testCases) {\n      case.run();\n    }\n  }\n```\n\n把这个简化版本的测试框架引入到工程中之后，我们只需要在框架预留的扩展点，也就是 TestCase 类中的 doTest() 抽象函数中，填充具体的测试代码就可以实现之前的功能了，完全不需要写负责执行流程的 main() 函数了。 具体的代码如下所示：\n\n```java\npublic class UserServiceTest extends TestCase {\n  @Override\n  public boolean doTest() {\n    // ... \n  }\n}\n\n// 注册操作还可以通过配置的方式来实现，不需要程序员显示调用register()\nJunitApplication.register(new UserServiceTest();\n```\n\n\n\n1. 刚刚举的这个例子，就是典型的通过框架来实现“控制反转”的例子。框架提供了一个可扩展的代码骨架，用来组装对象、管理整个执行流程。程序员利用框架进行开发的时候，只需要往预留的扩展点上，添加跟自己业务相关的代码，就可以利用框架来驱动整个程序流程的执行。\n2. 这里的“控制”指的是对程序执行流程的控制，而“反转”指的是在没有使用框架之前，程序员自己控制整个程序的执行。在使用框架之后，整个程序的执行流程可以通过框架来控制。流程的控制权从程序员“反转”到了框架。\n3. 实际上，实现控制反转的方法有很多，除了刚才例子中所示的类似于模板设计模式的方法之外，还有马上要讲到的依赖注入等方法，所以，控制反转并不是一种具体的实现技巧，而是一个比较笼统的设计思想，一般用来指导框架层面的设计。\n\n\n\n### 依赖注入（DI）\n\n1. 接下来，我们再来看依赖注入。依赖注入跟控制反转恰恰相反，它是一种具体的编码技巧。那到底什么是依赖注入呢？我们用一句话来概括就是：不通过 new() 的方式在类内部创建依赖类对象，而是将依赖的类对象在外部创建好之后，通过构造函数、函数参数等方式传递（或注入）给类使用。\n2. 我们还是通过一个例子来解释一下。在这个例子中，Notification 类负责消息推送，依赖 MessageSender 类实现推送商品促销、验证码等消息给用户。我们分别用依赖注入和非依赖注入两种方式来实现一下。具体的实现代码如下所示：\n\n\n\n```java\n// 非依赖注入实现方式\npublic class Notification {\n  private MessageSender messageSender;\n  \n  public Notification() {\n    this.messageSender = new MessageSender(); //此处有点像hardcode\n  }\n  \n  public void sendMessage(String cellphone, String message) {\n    //...省略校验逻辑等...\n    this.messageSender.send(cellphone, message);\n  }\n}\n\npublic class MessageSender {\n  public void send(String cellphone, String message) {\n    //....\n  }\n}\n// 使用Notification\nNotification notification = new Notification();\n\n// 依赖注入的实现方式\npublic class Notification {\n  private MessageSender messageSender;\n  \n  // 通过构造函数将messageSender传递进来\n  public Notification(MessageSender messageSender) {\n    this.messageSender = messageSender;\n  }\n  \n  public void sendMessage(String cellphone, String message) {\n    //...省略校验逻辑等...\n    this.messageSender.send(cellphone, message);\n  }\n}\n//使用Notification\nMessageSender messageSender = new MessageSender();\nNotification notification = new Notification(messageSender);\n```\n\n通过依赖注入的方式来将依赖的类对象传递进来，这样就提高了代码的扩展性，我们可以灵活地替换依赖的类。这一点在我们之前讲“开闭原则”的时候也提到过。当然，上面代码还有继续优化的空间，我们还可以把 MessageSender 定义成接口，基于接口而非实现编程。改造后的代码如下所示：\n\n\n\n```java\npublic class Notification {\n  private MessageSender messageSender;\n  \n  public Notification(MessageSender messageSender) {\n    this.messageSender = messageSender;\n  }\n  \n  public void sendMessage(String cellphone, String message) {\n    this.messageSender.send(cellphone, message);\n  }\n}\n\npublic interface MessageSender {\n  void send(String cellphone, String message);\n}\n\n// 短信发送类\npublic class SmsSender implements MessageSender {\n  @Override\n  public void send(String cellphone, String message) {\n    //....\n  }\n}\n\n// 站内信发送类\npublic class InboxSender implements MessageSender {\n  @Override\n  public void send(String cellphone, String message) {\n    //....\n  }\n}\n\n//使用Notification\nMessageSender messageSender = new SmsSender();\nNotification notification = new Notification(messageSender);\n```\n\n\n\n实际上，你只需要掌握刚刚举的这个例子，就等于完全掌握了依赖注入。尽管依赖注入非常简单，但却非常有用，\n\n\n\n### 依赖注入框架（DI Framework）\n\n弄懂了什么是“依赖注入”，我们再来看一下，什么是“依赖注入框架”。我们还是借用刚刚的例子来解释。在采用依赖注入实现的 Notification 类中，虽然我们不需要用类似 hard code 的方式，在类内部通过 new 来创建 MessageSender 对象，但是，这个创建对象、组装（或注入）对象的工作仅仅是被移动到了更上层代码而已，还是需要我们程序员自己来实现。具体代码如下所示：\n\n\n\n```java\npublic class Demo {\n  public static final void main(String args[]) {\n    MessageSender sender = new SmsSender(); //创建对象\n    Notification notification = new Notification(sender);//依赖注入\n    notification.sendMessage(\"13918942177\", \"短信验证码：2346\");\n  }\n}\n```\n\n1. 在实际的软件开发中，一些项目可能会涉及几十、上百、甚至几百个类，类对象的创建和依赖注入会变得非常复杂。如果这部分工作都是靠程序员自己写代码来完成，容易出错且开发成本也比较高。而对象创建和依赖注入的工作，本身跟具体的业务无关，我们完全可以抽象成框架来自动完成。\n2. 你可能已经猜到，这个框架就是“依赖注入框架”。我们只需要通过依赖注入框架提供的扩展点，简单配置一下所有需要创建的类对象、类与类之间的依赖关系，就可以实现由框架来自动创建对象、管理对象的生命周期、依赖注入等原本需要程序员来做的事情。\n3. 实际上，现成的依赖注入框架有很多，比如 Google Guice、Java Spring、Pico Container、Butterfly Container 等。不过，如果你熟悉 Java Spring 框架，你可能会说，Spring 框架自己声称是控制反转容器（Inversion Of Control Container）。\n4. 实际上，这两种说法都没错。只是控制反转容器这种表述是一种非常宽泛的描述，DI 依赖注入框架的表述更具体、更有针对性。因为我们前面讲到实现控制反转的方式有很多，除了依赖注入，还有模板模式等，而 Spring 框架的控制反转主要是通过依赖注入来实现的。不过这点区分并不是很明显，也不是很重要，你稍微了解一下就可以了。\n\n\n\n### 什么是依赖反转原则？\n\n\n\n1. 前面讲了控制反转、依赖注入、依赖注入框架，现在，我们来讲一讲今天的主角：依赖反转原则。依赖反转原则的英文翻译是 Dependency Inversion Principle，缩写为 DIP。中文翻译有时候也叫依赖倒置原则。\n2. 英文描述：High-level modules shouldn’t depend on low-level modules. Both modules should depend on abstractions. In addition, abstractions shouldn’t depend on details. Details depend on abstractions.\n3. 我们将它翻译成中文，大概意思就是：高层模块（high-level modules）不要依赖低层模块（low-level）。高层模块和低层模块应该通过抽象（abstractions）来互相依赖。除此之外，抽象（abstractions）不要依赖具体实现细节（details），具体实现细节（details）依赖抽象（abstractions）。\n4. 所谓高层模块和低层模块的划分，简单来说就是，在调用链上，调用者属于高层，被调用者属于低层。在平时的业务代码开发中，高层模块依赖底层模块是没有任何问题的。实际上，这条原则主要还是用来指导框架层面的设计，跟前面讲到的控制反转类似。我们拿 Tomcat 这个 Servlet 容器作为例子来解释一下。\n5. Tomcat 是运行 Java Web 应用程序的容器。我们编写的 Web 应用程序代码只需要部署在 Tomcat 容器下，便可以被 Tomcat 容器调用执行。按照之前的划分原则，Tomcat 就是高层模块，我们编写的 Web 应用程序代码就是低层模块。Tomcat 和应用程序代码之间并没有直接的依赖关系，两者都依赖同一个“抽象”，也就是 Servlet 规范。Servlet 规范不依赖具体的 Tomcat 容器和应用程序的实现细节，而 Tomcat 容器和应用程序依赖 Servlet 规范。\n\n\n\n## KISS原则和YAGNI原则\n\n\n\n1. 我们学习了经典的 SOLID 原则。今天，我们讲两个设计原则：KISS 原则和 YAGNI 原则。其中，KISS 原则比较经典，耳熟能详，但 YAGNI 你可能没怎么听过，不过它理解起来也不难。\n2. 理解这两个原则时候，经常会有一个共同的问题，那就是，看一眼就感觉懂了，但深究的话，又有很多细节问题不是很清楚。比如，怎么理解 KISS 原则中“简单”两个字？什么样的代码才算“简单”？怎样的代码才算“复杂”？如何才能写出“简单”的代码？YAGNI 原则跟 KISS 原则说的是一回事吗？\n\n\n\nKISS 原则的英文描述有好几个版本，比如下面这几个。\n\n- Keep It Simple and Stupid.\n- Keep It Short and Simple.\n- Keep It Simple and Straightforward.\n\n1. 不过，仔细看你就会发现，它们要表达的意思其实差不多，翻译成中文就是：尽量保持简单。\n\n2. 我们知道，代码的可读性和可维护性是衡量代码质量非常重要的两个标准。而 KISS 原则就是保持代码可读和可维护的重要手段。代码足够简单，也就意味着很容易读懂，bug 比较难隐藏。即便出现 bug，修复起来也比较简单。不过，这条原则只是告诉我们，要保持代码“Simple and Stupid”，但并没有讲到，什么样的代码才是“Simple and Stupid”的，更没有给出特别明确的方法论，来指导如何开发出“Simple and Stupid”的代码。\n3. 所以，接下来，为了能让这条原则切实地落地，能够指导实际的项目开发，我就针对刚刚的这些问题来进一步讲讲我的理解。\n\n\n\n### 代码行数越少就越“简单”吗？\n\n我们先一起看一个例子。下面这三段代码可以实现同样一个功能：检查输入的字符串 ipAddress 是否是合法的 IP 地址。一个合法的 IP 地址由四个数字组成，并且通过“.”来进行分割。每组数字的取值范围是 0~255。第一组数字比较特殊，不允许为 0。对比这三段代码，你觉得哪一段代码最符合 KISS 原则呢？如果让你来实现这个功能，你会选择用哪种实现方法呢？你可以先自己思考一下，然后再看我下面的讲解。\n\n```java\n// 第一种实现方式: 使用正则表达式\npublic boolean isValidIpAddressV1(String ipAddress) {\n  if (StringUtils.isBlank(ipAddress)) return false;\n  String regex = \"^(1\\\\d{2}|2[0-4]\\\\d|25[0-5]|[1-9]\\\\d|[1-9])\\\\.\"\n          + \"(1\\\\d{2}|2[0-4]\\\\d|25[0-5]|[1-9]\\\\d|\\\\d)\\\\.\"\n          + \"(1\\\\d{2}|2[0-4]\\\\d|25[0-5]|[1-9]\\\\d|\\\\d)\\\\.\"\n          + \"(1\\\\d{2}|2[0-4]\\\\d|25[0-5]|[1-9]\\\\d|\\\\d)$\";\n  return ipAddress.matches(regex);\n}\n\n// 第二种实现方式: 使用现成的工具类\npublic boolean isValidIpAddressV2(String ipAddress) {\n  if (StringUtils.isBlank(ipAddress)) return false;\n  String[] ipUnits = StringUtils.split(ipAddress, '.');\n  if (ipUnits.length != 4) {\n    return false;\n  }\n  for (int i = 0; i < 4; ++i) {\n    int ipUnitIntValue;\n    try {\n      ipUnitIntValue = Integer.parseInt(ipUnits[i]);\n    } catch (NumberFormatException e) {\n      return false;\n    }\n    if (ipUnitIntValue < 0 || ipUnitIntValue > 255) {\n      return false;\n    }\n    if (i == 0 && ipUnitIntValue == 0) {\n      return false;\n    }\n  }\n  return true;\n}\n\n// 第三种实现方式: 不使用任何工具类\npublic boolean isValidIpAddressV3(String ipAddress) {\n  char[] ipChars = ipAddress.toCharArray();\n  int length = ipChars.length;\n  int ipUnitIntValue = -1;\n  boolean isFirstUnit = true;\n  int unitsCount = 0;\n  for (int i = 0; i < length; ++i) {\n    char c = ipChars[i];\n    if (c == '.') {\n      if (ipUnitIntValue < 0 || ipUnitIntValue > 255) return false;\n      if (isFirstUnit && ipUnitIntValue == 0) return false;\n      if (isFirstUnit) isFirstUnit = false;\n      ipUnitIntValue = -1;\n      unitsCount++;\n      continue;\n    }\n    if (c < '0' || c > '9') {\n      return false;\n    }\n    if (ipUnitIntValue == -1) ipUnitIntValue = 0;\n    ipUnitIntValue = ipUnitIntValue * 10 + (c - '0');\n  }\n  if (ipUnitIntValue < 0 || ipUnitIntValue > 255) return false;\n  if (unitsCount != 3) return false;\n  return true;\n}\n```\n\n\n\n1. 第一种实现方式利用的是正则表达式，只用三行代码就把这个问题搞定了。它的代码行数最少，那是不是就最符合 KISS 原则呢？答案是否定的。虽然代码行数最少，看似最简单，实际上却很复杂。这正是因为它使用了正则表达式。\n2. 一方面，正则表达式本身是比较复杂的，写出完全没有 bug 的正则表达本身就比较有挑战；另一方面，并不是每个程序员都精通正则表达式。对于不怎么懂正则表达式的同事来说，看懂并且维护这段正则表达式是比较困难的。这种实现方式会导致代码的可读性和可维护性变差，所以，从 KISS 原则的设计初衷上来讲，这种实现方式并不符合 KISS 原则。\n3. 讲完了第一种实现方式，我们再来看下其他两种实现方式。\n4. 第二种实现方式使用了 StringUtils 类、Integer 类提供的一些现成的工具函数，来处理 IP 地址字符串。第三种实现方式，不使用任何工具函数，而是通过逐一处理 IP 地址中的字符，来判断是否合法。从代码行数上来说，这两种方式差不多。但是，第三种要比第二种更加有难度，更容易写出 bug。从可读性上来说，第二种实现方式的代码逻辑更清晰、更好理解。所以，在这两种实现方式中，第二种实现方式更加“简单”，更加符合 KISS 原则。\n5. 不过，你可能会说，第三种实现方式虽然实现起来稍微有点复杂，但性能要比第二种实现方式高一些啊。从性能的角度来说，选择第三种实现方式是不是更好些呢？在回答这个问题之前，我先解释一下，为什么说第三种实现方式性能会更高一些。一般来说，工具类的功能都比较通用和全面，所以，在代码实现上，需要考虑和处理更多的细节，执行效率就会有所影响。而第三种实现方式，完全是自己操作底层字符，只针对 IP 地址这一种格式的数据输入来做处理，没有太多多余的函数调用和其他不必要的处理逻辑，所以，在执行效率上，这种类似定制化的处理代码方式肯定比通用的工具类要高些。\n6. 不过，尽管第三种实现方式性能更高些，但我还是更倾向于选择第二种实现方法。那是因为第三种实现方式实际上是一种过度优化。除非 isValidIpAddress() 函数是影响系统性能的瓶颈代码，否则，这样优化的投入产出比并不高，增加了代码实现的难度、牺牲了代码的可读性，性能上的提升却并不明显。\n\n\n\n### 代码逻辑复杂就违背 KISS 原则吗？\n\n刚刚我们提到，并不是代码行数越少就越“简单”，还要考虑逻辑复杂度、实现难度、代码的可读性等。那如果一段代码的逻辑复杂、实现难度大、可读性也不太好，是不是就一定违背 KISS 原则呢？在回答这个问题之前，我们先来看下面这段代码：\n\n```java\n// KMP algorithm: a, b分别是主串和模式串；n, m分别是主串和模式串的长度。\npublic static int kmp(char[] a, int n, char[] b, int m) {\n  int[] next = getNexts(b, m);\n  int j = 0;\n  for (int i = 0; i < n; ++i) {\n    while (j > 0 && a[i] != b[j]) { // 一直找到a[i]和b[j]\n      j = next[j - 1] + 1;\n    }\n    if (a[i] == b[j]) {\n      ++j;\n    }\n    if (j == m) { // 找到匹配模式串的了\n      return i - m + 1;\n    }\n  }\n  return -1;\n}\n\n// b表示模式串，m表示模式串的长度\nprivate static int[] getNexts(char[] b, int m) {\n  int[] next = new int[m];\n  next[0] = -1;\n  int k = -1;\n  for (int i = 1; i < m; ++i) {\n    while (k != -1 && b[k + 1] != b[i]) {\n      k = next[k];\n    }\n    if (b[k + 1] == b[i]) {\n      ++k;\n    }\n    next[i] = k;\n  }\n  return next;\n}\n```\n\n\n\n1. 这段代码是KMP 字符串匹配算法的代码实现。这段代码完全符合我们刚提到的逻辑复杂、实现难度大、可读性差的特点，但它并不违反 KISS 原则。为什么这么说呢？\n\n2. KMP 算法以快速高效著称。当我们需要处理长文本字符串匹配问题（几百 MB 大小文本内容的匹配），或者字符串匹配是某个产品的核心功能（比如 Vim、Word 等文本编辑器），又或者字符串匹配算法是系统性能瓶颈的时候，我们就应该选择尽可能高效的 KMP 算法。而 KMP 算法本身具有逻辑复杂、实现难度大、可读性差的特点。本身就复杂的问题，用复杂的方法解决，并不违背 KISS 原则。\n3. 不过，平时的项目开发中涉及的字符串匹配问题，大部分都是针对比较小的文本。在这种情况下，直接调用编程语言提供的现成的字符串匹配函数就足够了。如果非得用 KMP 算法、BM 算法来实现字符串匹配，那就真的违背 KISS 原则了。也就是说，同样的代码，在某个业务场景下满足 KISS 原则，换一个应用场景可能就不满足了。\n\n\n\n\n\n### 如何写出满足 KISS 原则的代码？\n\n\n\n实际上，我们前面已经讲到了一些方法。这里我稍微总结一下。\n\n- 不要使用同事可能不懂的技术来实现代码。比如前面例子中的正则表达式，还有一些编程语言中过于高级的语法等。\n- 不要重复造轮子，要善于使用已经有的工具类库。经验证明，自己去实现这些类库，出 bug 的概率会更高，维护的成本也比较高。\n- 不要过度优化。不要过度使用一些奇技淫巧（比如，位运算代替算术运算、复杂的条件语句代替 if-else、使用一些过于底层的函数等）来优化代码，牺牲代码的可读性。\n- 实际上，代码是否足够简单是一个挺主观的评判。同样的代码，有的人觉得简单，有的人觉得不够简单。而往往自己编写的代码，自己都会觉得够简单。所以，评判代码是否简单，还有一个很有效的间接方法，那就是 code review。如果在 code review 的时候，同事对你的代码有很多疑问，那就说明你的代码有可能不够“简单”，需要优化啦。\n\n\n\n\n\n### YAGNI 跟 KISS 说的是一回事吗？\n\n1. YAGNI 原则的英文全称是：You Ain’t Gonna Need It。直译就是：你不会需要它。这条原则也算是万金油了。当用在软件开发中的时候，它的意思是：不要去设计当前用不到的功能；不要去编写当前用不到的代码。实际上，这条原则的核心思想就是：不要做过度设计。\n2. 比如，我们的系统暂时只用 Redis 存储配置信息，以后可能会用到 ZooKeeper。根据 YAGNI 原则，在未用到 ZooKeeper 之前，我们没必要提前编写这部分代码。当然，这并不是说我们就不需要考虑代码的扩展性。我们还是要预留好扩展点，等到需要的时候，再去实现 ZooKeeper 存储配置信息这部分代码。\n3. 再比如，我们不要在项目中提前引入不需要依赖的开发包。对于 Java 程序员来说，我们经常使用 Maven 或者 Gradle 来管理依赖的类库（library）。我发现，有些同事为了避免开发中 library 包缺失而频繁地修改 Maven 或者 Gradle 配置文件，提前往项目里引入大量常用的 library 包。实际上，这样的做法也是违背 YAGNI 原则的。\n4. 从刚刚的分析我们可以看出，YAGNI 原则跟 KISS 原则并非一回事儿。KISS 原则讲的是“如何做”的问题（尽量保持简单），而 YAGNI 原则说的是“要不要做”的问题（当前不需要的就不要做）。\n\n\n\n## DRY 原则\n\nDon’t Repeat Yourself。中文直译为：不要重复自己。将它应用在编程中，可以理解为：不要写重复的代码。DRY 原则的定义非常简单，我就不再过度解读。今天，我们主要讲三种典型的代码重复情况，它们分别是：实现逻辑重复、功能语义重复和代码执行重复。这三种代码重复，有的看似违反 DRY，实际上并不违反；有的看似不违反，实际上却违反了。\n\n\n\n### 实现逻辑重复\n\n我们先来看下面这样一段代码是否违反了 DRY 原则。如果违反了，你觉得应该如何重构，才能让它满足 DRY 原则？如果没有违反，那又是为什么呢？\n\n```java\npublic class UserAuthenticator {\n  public void authenticate(String username, String password) {\n    if (!isValidUsername(username)) {\n      // ...throw InvalidUsernameException...\n    }\n    if (!isValidPassword(password)) {\n      // ...throw InvalidPasswordException...\n    }\n    //...省略其他代码...\n  }\n\n  private boolean isValidUsername(String username) {\n    // check not null, not empty\n    if (StringUtils.isBlank(username)) {\n      return false;\n    }\n    // check length: 4~64\n    int length = username.length();\n    if (length < 4 || length > 64) {\n      return false;\n    }\n    // contains only lowcase characters\n    if (!StringUtils.isAllLowerCase(username)) {\n      return false;\n    }\n    // contains only a~z,0~9,dot\n    for (int i = 0; i < length; ++i) {\n      char c = username.charAt(i);\n      if (!(c >= 'a' && c <= 'z') || (c >= '0' && c <= '9') || c == '.') {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  private boolean isValidPassword(String password) {\n    // check not null, not empty\n    if (StringUtils.isBlank(password)) {\n      return false;\n    }\n    // check length: 4~64\n    int length = password.length();\n    if (length < 4 || length > 64) {\n      return false;\n    }\n    // contains only lowcase characters\n    if (!StringUtils.isAllLowerCase(password)) {\n      return false;\n    }\n    // contains only a~z,0~9,dot\n    for (int i = 0; i < length; ++i) {\n      char c = password.charAt(i);\n      if (!(c >= 'a' && c <= 'z') || (c >= '0' && c <= '9') || c == '.') {\n        return false;\n      }\n    }\n    return true;\n  }\n}\n```\n\n代码很简单，我就不做过多解释了。在代码中，有两处非常明显的重复的代码片段：isValidUserName() 函数和 isValidPassword() 函数。重复的代码被敲了两遍，或者简单 copy-paste 了一下，看起来明显违反 DRY 原则。为了移除重复的代码，我们对上面的代码做下重构，将 isValidUserName() 函数和 isValidPassword() 函数，合并为一个更通用的函数 isValidUserNameOrPassword()。重构后的代码如下所示：\n\n```java\npublic class UserAuthenticatorV2 {\n\n  public void authenticate(String userName, String password) {\n    if (!isValidUsernameOrPassword(userName)) {\n      // ...throw InvalidUsernameException...\n    }\n\n    if (!isValidUsernameOrPassword(password)) {\n      // ...throw InvalidPasswordException...\n    }\n  }\n\n  private boolean isValidUsernameOrPassword(String usernameOrPassword) {\n    //省略实现逻辑\n    //跟原来的isValidUsername()或isValidPassword()的实现逻辑一样...\n    return true;\n  }\n}\n```\n\n1. 经过重构之后，代码行数减少了，也没有重复的代码了，是不是更好了呢？答案是否定的，这可能跟你预期的不一样，我来解释一下为什么。\n2. 单从名字上看，我们就能发现，合并之后的 isValidUserNameOrPassword() 函数，负责两件事情：验证用户名和验证密码，违反了“单一职责原则”和“接口隔离原则”。实际上，即便将两个函数合并成 isValidUserNameOrPassword()，代码仍然存在问题。\n3. 因为 isValidUserName() 和 isValidPassword() 两个函数，虽然从代码实现逻辑上看起来是重复的，但是从语义上并不重复。所谓“语义不重复”指的是：从功能上来看，这两个函数干的是完全不重复的两件事情，一个是校验用户名，另一个是校验密码。尽管在目前的设计中，两个校验逻辑是完全一样的，但如果按照第二种写法，将两个函数的合并，那就会存在潜在的问题。在未来的某一天，如果我们修改了密码的校验逻辑，比如，允许密码包含大写字符，允许密码的长度为 8 到 64 个字符，那这个时候，isValidUserName() 和 isValidPassword() 的实现逻辑就会不相同。我们就要把合并后的函数，重新拆成合并前的那两个函数。\n4. 尽管代码的实现逻辑是相同的，但语义不同，我们判定它并不违反 DRY 原则。对于包含重复代码的问题，我们可以通过抽象成更细粒度函数的方式来解决。比如将校验只包含 a~z、0~9、dot 的逻辑封装成 boolean onlyContains(String str, String charlist); 函数。\n\n\n\n### 功能语义重复\n\n1. 现在我们再来看另外一个例子。在同一个项目代码中有下面两个函数：isValidIp() 和 checkIfIpValid()。尽管两个函数的命名不同，实现逻辑不同，但功能是相同的，都是用来判定 IP 地址是否合法的。\n2. 之所以在同一个项目中会有两个功能相同的函数，那是因为这两个函数是由两个不同的同事开发的，其中一个同事在不知道已经有了 isValidIp() 的情况下，自己又定义并实现了同样用来校验 IP 地址是否合法的 checkIfIpValid() 函数。那在同一项目代码中，存在如下两个函数，是否违反 DRY 原则呢？\n\n```java\npublic boolean isValidIp(String ipAddress) {\n  if (StringUtils.isBlank(ipAddress)) return false;\n  String regex = \"^(1\\\\d{2}|2[0-4]\\\\d|25[0-5]|[1-9]\\\\d|[1-9])\\\\.\"\n          + \"(1\\\\d{2}|2[0-4]\\\\d|25[0-5]|[1-9]\\\\d|\\\\d)\\\\.\"\n          + \"(1\\\\d{2}|2[0-4]\\\\d|25[0-5]|[1-9]\\\\d|\\\\d)\\\\.\"\n          + \"(1\\\\d{2}|2[0-4]\\\\d|25[0-5]|[1-9]\\\\d|\\\\d)$\";\n  return ipAddress.matches(regex);\n}\n\npublic boolean checkIfIpValid(String ipAddress) {\n  if (StringUtils.isBlank(ipAddress)) return false;\n  String[] ipUnits = StringUtils.split(ipAddress, '.');\n  if (ipUnits.length != 4) {\n    return false;\n  }\n  for (int i = 0; i < 4; ++i) {\n    int ipUnitIntValue;\n    try {\n      ipUnitIntValue = Integer.parseInt(ipUnits[i]);\n    } catch (NumberFormatException e) {\n      return false;\n    }\n    if (ipUnitIntValue < 0 || ipUnitIntValue > 255) {\n      return false;\n    }\n    if (i == 0 && ipUnitIntValue == 0) {\n      return false;\n    }\n  }\n  return true;\n}\n```\n\n1. 这个例子跟上个例子正好相反。上一个例子是代码实现逻辑重复，但语义不重复，我们并不认为它违反了 DRY 原则。而在这个例子中，尽管两段代码的实现逻辑不重复，但语义重复，也就是功能重复，我们认为它违反了 DRY 原则。我们应该在项目中，统一一种实现思路，所有用到判断 IP 地址是否合法的地方，都统一调用同一个函数。\n2. 假设我们不统一实现思路，那有些地方调用了 isValidIp() 函数，有些地方又调用了 checkIfIpValid() 函数，这就会导致代码看起来很奇怪，相当于给代码“埋坑”，给不熟悉这部分代码的同事增加了阅读的难度。同事有可能研究了半天，觉得功能是一样的，但又有点疑惑，觉得是不是有更高深的考量，才定义了两个功能类似的函数，最终发现居然是代码设计的问题。\n3. 除此之外，如果哪天项目中 IP 地址是否合法的判定规则改变了，比如：255.255.255.255 不再被判定为合法的了，相应地，我们对 isValidIp() 的实现逻辑做了相应的修改，但却忘记了修改 checkIfIpValid() 函数。又或者，我们压根就不知道还存在一个功能相同的 checkIfIpValid() 函数，这样就会导致有些代码仍然使用老的 IP 地址判断逻辑，导致出现一些莫名其妙的 bug。\n\n\n\n### 代码执行重复\n\n前两个例子一个是实现逻辑重复，一个是语义重复，我们再来看第三个例子。其中，UserService 中 login() 函数用来校验用户登录是否成功。如果失败，就返回异常；如果成功，就返回用户信息。具体代码如下所示：\n\n```java\npublic class UserService {\n  private UserRepo userRepo;//通过依赖注入或者IOC框架注入\n\n  public User login(String email, String password) {\n    boolean existed = userRepo.checkIfUserExisted(email, password);\n    if (!existed) {\n      // ... throw AuthenticationFailureException...\n    }\n    User user = userRepo.getUserByEmail(email);\n    return user;\n  }\n}\n\npublic class UserRepo {\n  public boolean checkIfUserExisted(String email, String password) {\n    if (!EmailValidation.validate(email)) {\n      // ... throw InvalidEmailException...\n    }\n\n    if (!PasswordValidation.validate(password)) {\n      // ... throw InvalidPasswordException...\n    }\n\n    //...query db to check if email&password exists...\n  }\n\n  public User getUserByEmail(String email) {\n    if (!EmailValidation.validate(email)) {\n      // ... throw InvalidEmailException...\n    }\n    //...query db to get user by email...\n  }\n}\n```\n\n1. 上面这段代码，既没有逻辑重复，也没有语义重复，但仍然违反了 DRY 原则。这是因为代码中存在“执行重复”。我们一块儿来看下，到底哪些代码被重复执行了？\n2. 重复执行最明显的一个地方，就是在 login() 函数中，email 的校验逻辑被执行了两次。一次是在调用 checkIfUserExisted() 函数的时候，另一次是调用 getUserByEmail() 函数的时候。这个问题解决起来比较简单，我们只需要将校验逻辑从 UserRepo 中移除，统一放到 UserService 中就可以了。\n3. 除此之外，代码中还有一处比较隐蔽的执行重复，不知道你发现了没有？实际上，login() 函数并不需要调用 checkIfUserExisted() 函数，只需要调用一次 getUserByEmail() 函数，从数据库中获取到用户的 email、password 等信息，然后跟用户输入的 email、password 信息做对比，依次判断是否登录成功。\n4. 实际上，这样的优化是很有必要的。因为 checkIfUserExisted() 函数和 getUserByEmail() 函数都需要查询数据库，而数据库这类的 I/O 操作是比较耗时的。我们在写代码的时候，应当尽量减少这类 I/O 操作。\n5. 按照刚刚的修改思路，我们把代码重构一下，移除“重复执行”的代码，只校验一次 email 和 password，并且只查询一次数据库。重构之后的代码如下所示：\n\n```java\npublic class UserService {\n  private UserRepo userRepo;//通过依赖注入或者IOC框架注入\n\n  public User login(String email, String password) {\n    if (!EmailValidation.validate(email)) {\n      // ... throw InvalidEmailException...\n    }\n    if (!PasswordValidation.validate(password)) {\n      // ... throw InvalidPasswordException...\n    }\n    User user = userRepo.getUserByEmail(email);\n    if (user == null || !password.equals(user.getPassword()) {\n      // ... throw AuthenticationFailureException...\n    }\n    return user;\n  }\n}\n\npublic class UserRepo {\n  public boolean checkIfUserExisted(String email, String password) {\n    //...query db to check if email&password exists\n  }\n\n  public User getUserByEmail(String email) {\n    //...query db to get user by email...\n  }\n}\n```\n\n\n\n### 代码复用性（Code Reusability）\n\n1. 我们首先来区分三个概念：代码复用性（Code Reusability）、代码复用（Code Resue）和 DRY 原则。代码复用表示一种行为：我们在开发新功能的时候，尽量复用已经存在的代码。代码的可复用性表示一段代码可被复用的特性或能力：我们在编写代码的时候，让代码尽量可复用。DRY 原则是一条原则：不要写重复的代码。从定义描述上，它们好像有点类似，但深究起来，三者的区别还是蛮大的。\n\n2. 首先，“不重复”并不代表“可复用”。在一个项目代码中，可能不存在任何重复的代码，但也并不表示里面有可复用的代码，不重复和可复用完全是两个概念。所以，从这个角度来说，DRY 原则跟代码的可复用性讲的是两回事。\n3. 其次，“复用”和“可复用性”关注角度不同。代码“可复用性”是从代码开发者的角度来讲的，“复用”是从代码使用者的角度来讲的。比如，A 同事编写了一个 UrlUtils 类，代码的“可复用性”很好。B 同事在开发新功能的时候，直接“复用”A 同事编写的 UrlUtils 类。尽管复用、可复用性、DRY 原则这三者从理解上有所区别，但实际上要达到的目的都是类似的，都是为了减少代码量，提高代码的可读性、可维护性。除此之外，复用已经经过测试的老代码，bug 会比从零重新开发要少。\n4. “复用”这个概念不仅可以指导细粒度的模块、类、函数的设计开发，实际上，一些框架、类库、组件等的产生也都是为了达到复用的目的。比如，Spring 框架、Google Guava 类库、UI 组件等等。\n\n\n\n### 怎么提高代码复用性？\n\n实际上，我们前面已经讲到过很多提高代码可复用性的手段，今天算是集中总结一下，我总结了 7 条，具体如下。\n\n> 减少代码耦合\n\n对于高度耦合的代码，当我们希望复用其中的一个功能，想把这个功能的代码抽取出来成为一个独立的模块、类或者函数的时候，往往会发现牵一发而动全身。移动一点代码，就要牵连到很多其他相关的代码。所以，高度耦合的代码会影响到代码的复用性，我们要尽量减少代码耦合。\n\n> 满足单一职责原则\n\n我们前面讲过，如果职责不够单一，模块、类设计得大而全，那依赖它的代码或者它依赖的代码就会比较多，进而增加了代码的耦合。根据上一点，也就会影响到代码的复用性。相反，越细粒度的代码，代码的通用性会越好，越容易被复用。\n\n> 模块化\n\n这里的“模块”，不单单指一组类构成的模块，还可以理解为单个类、函数。我们要善于将功能独立的代码，封装成模块。独立的模块就像一块一块的积木，更加容易复用，可以直接拿来搭建更加复杂的系统。\n\n> 业务与非业务逻辑分离\n\n越是跟业务无关的代码越是容易复用，越是针对特定业务的代码越难复用。所以，为了复用跟业务无关的代码，我们将业务和非业务逻辑代码分离，抽取成一些通用的框架、类库、组件等。\n\n> 通用代码下沉\n\n从分层的角度来看，越底层的代码越通用、会被越多的模块调用，越应该设计得足够可复用。一般情况下，在代码分层之后，为了避免交叉调用导致调用关系混乱，我们只允许上层代码调用下层代码及同层代码之间的调用，杜绝下层代码调用上层代码。所以，通用的代码我们尽量下沉到更下层。\n\n> 继承、多态、抽象、封装\n\n在讲面向对象特性的时候，利用继承，可以将公共的代码抽取到父类，子类复用父类的属性和方法。利用多态，我们可以动态地替换一段代码的部分逻辑，让这段代码可复用。除此之外，抽象和封装，从更加广义的层面、而非狭义的面向对象特性的层面来理解的话，越抽象、越不依赖具体的实现，越容易复用。代码封装成模块，隐藏可变的细节、暴露不变的接口，就越容易复用。\n\n> 应用模板等设计模式\n\n一些设计模式，也能提高代码的复用性。比如，模板模式利用了多态来实现，可以灵活地替换其中的部分代码，整个流程模板代码可复用。关于应用设计模式提高代码复用性这一部分，我们留在后面慢慢来讲解。除了刚刚我们讲到的几点，还有一些跟编程语言相关的特性，也能提高代码的复用性，比如泛型编程等。实际上，除了上面讲到的这些方法之外，复用意识也非常重要。在写代码的时候，我们要多去思考一下，这\n\n\n\n\n\n\n\n\n\n## 迪米特法则\n\n\n\n我们讲最后一个设计原则：迪米特法则。尽管它不像 SOLID、KISS、DRY 原则那样，人尽皆知，但它却非常实用。利用这个原则，能够帮我们实现代码的“高内聚、松耦合”。今天，我们就围绕下面几个问题，并结合两个代码实战案例，来深入地学习这个法则。\n\n- 什么是“高内聚、松耦合”？\n- 如何利用迪米特法则来实现“高内聚、松耦合”？\n- 有哪些代码设计是明显违背迪米特法则的？对此又该如何重构？\n\n\n\n\n\n### 何为“高内聚、松耦合”？\n\n1. “高内聚、松耦合”是一个非常重要的设计思想，能够有效地提高代码的可读性和可维护性，缩小功能改动导致的代码改动范围。\n2. 实际上，在前面的章节中，我们已经多次提到过这个设计思想。很多设计原则都以实现代码的“高内聚、松耦合”为目的，比如单一职责原则、基于接口而非实现编程等。实际上，“高内聚、松耦合”是一个比较通用的设计思想，可以用来指导不同粒度代码的设计与开发，比如系统、模块、类，甚至是函数，也可以应用到不同的开发场景中，比如微服务、框架、组件、类库等。为了方便我讲解，接下来我以“类”作为这个设计思想的应用对象来展开讲解，其他应用场景你可以自行类比。\n3. 在这个设计思想中，“高内聚”用来指导类本身的设计，“松耦合”用来指导类与类之间依赖关系的设计。不过，这两者并非完全独立不相干。高内聚有助于松耦合，松耦合又需要高内聚的支持。\n\n\n\n> 那到底什么是“高内聚”呢？\n\n\n\n所谓高内聚，就是指相近的功能应该放到同一个类中，不相近的功能不要放到同一个类中。相近的功能往往会被同时修改，放到同一个类中，修改会比较集中，代码容易维护。实际上，我们前面讲过的单一职责原则是实现代码高内聚非常有效的设计原则。\n\n\n\n> 我们再来看一下，什么是“松耦合”？\n\n所谓松耦合是说，在代码中，类与类之间的依赖关系简单清晰。即使两个类有依赖关系，一个类的代码改动不会或者很少导致依赖类的代码改动。实际上，我们前面讲的依赖注入、接口隔离、基于接口而非实现编程，以及今天讲的迪米特法则，都是为了实现代码的松耦合\n\n\n\n\n\n> 最后，我们来看一下，“内聚”和“耦合”之间的关系\n\n前面也提到，“高内聚”有助于“松耦合”，同理，“低内聚”也会导致“紧耦合”。关于这一点，我画了一张对比图来解释。图中左边部分的代码结构是“高内聚、松耦合”；右边部分正好相反，是“低内聚、紧耦合”。\n\n<img src=\"https://npm.elemecdn.com/youthlql@1.0.0/design_patterns/design_principles/0001.png\" />\n\n\n\n\n\n1. 图中左边部分的代码设计中，类的粒度比较小，每个类的职责都比较单一。相近的功能都放到了一个类中，不相近的功能被分割到了多个类中。这样类更加独立，代码的内聚性更好。因为职责单一，所以每个类被依赖的类就会比较少，代码低耦合。一个类的修改，只会影响到一个依赖类的代码改动。我们只需要测试这一个依赖类是否还能正常工作就行了。\n2. 图中右边部分的代码设计中，类粒度比较大，低内聚，功能大而全，不相近的功能放到了一个类中。这就导致很多其他类都依赖这个类。当我们修改这个类的某一个功能代码的时候，会影响依赖它的多个类。我们需要测试这三个依赖类，是否还能正常工作。这也就是所谓的“牵一发而动全身”。\n3. 除此之外，从图中我们也可以看出，高内聚、低耦合的代码结构更加简单、清晰，相应地，在可维护性和可读性上确实要好很多。\n\n\n\n\n\n### “迪米特法则”理论描述\n\n1. 迪米特法则的英文翻译是：Law of Demeter，缩写是 LOD。单从这个名字上来看，我们完全猜不出这个原则讲的是什么。不过，它还有另外一个更加达意的名字，叫作最小知识原则，英文翻译为：The Least Knowledge Principle。\n\n2. 关于这个设计原则，我们先来看一下它最原汁原味的英文定义：\n\n   > Each unit should have only limited knowledge about other units: only units “closely” related to the current unit. Or: Each unit should only talk to its friends; Don’t talk to strangers.\n\n   我们把它直译成中文，就是下面这个样子：\n\n   > 每个模块（unit）只应该了解那些与它关系密切的模块（units: only units “closely” related to the current unit）的有限知识（knowledge）。或者说，每个模块只和自己的朋友“说话”（talk），不和陌生人“说话”（talk）。\n\n   我们之前讲过，大部分设计原则和思想都非常抽象，有各种各样的解读，要想灵活地应用到实际的开发中，需要有实战经验的积累。迪米特法则也不例外。所以，我结合我自己的理解和经验，对刚刚的定义重新描述一下。注意，为了统一讲解，我把定义描述中的“模块”替换成了“类”。\n\n   > 不该有直接依赖关系的类之间，不要有依赖；有依赖关系的类之间，尽量只依赖必要的接口（也就是定义中的“有限知识”）。从上面的描述中，我们可以看出，迪米特法则包含前后两部分，这两部分讲的是两件事情，我用两个实战案例分别来解读一下。\n\n\n\n\n\n### 理论解读与代码实战一\n\n1. 我们先来看这条原则中的前半部分，**“不该有直接依赖关系的类之间，不要有依赖”**。我举个例子解释一下。\n2. 这个例子实现了简化版的搜索引擎爬取网页的功能。代码中包含三个主要的类。其中，NetworkTransporter 类负责底层网络通信，根据请求获取数据；HtmlDownloader 类用来通过 URL 获取网页；Document 表示网页文档，后续的网页内容抽取、分词、索引都是以此为处理对象。具体的代码实现如下所示：\n\n```java\npublic class NetworkTransporter {\n    // 省略属性和其他方法...\n    public Byte[] send(HtmlRequest htmlRequest) {\n      //...\n    }\n}\n\npublic class HtmlDownloader {\n  private NetworkTransporter transporter;//通过构造函数或IOC注入\n  \n  public Html downloadHtml(String url) {\n    Byte[] rawHtml = transporter.send(new HtmlRequest(url));\n    return new Html(rawHtml);\n  }\n}\n\npublic class Document {\n  private Html html;\n  private String url;\n  \n  public Document(String url) {\n    this.url = url;\n    HtmlDownloader downloader = new HtmlDownloader();\n    this.html = downloader.downloadHtml(url);\n  }\n  //...\n}\n```\n\n1. 这段代码虽然“能用”，能实现我们想要的功能，但是它不够“好用”，有比较多的设计缺陷。你可以先试着思考一下，看看都有哪些缺陷，然后再来看我下面的讲解。\n2. 首先，我们来看 NetworkTransporter 类。作为一个底层网络通信类，我们希望它的功能尽可能通用，而不只是服务于下载 HTML，所以，我们不应该直接依赖太具体的发送对象 HtmlRequest。从这一点上讲，NetworkTransporter 类的设计违背迪米特法则，依赖了不该有直接依赖关系的 HtmlRequest 类。\n3. 我们应该如何进行重构，让 NetworkTransporter 类满足迪米特法则呢？我这里有个形象的比喻。假如你现在要去商店买东西，你肯定不会直接把钱包给收银员，让收银员自己从里面拿钱，而是你从钱包里把钱拿出来交给收银员。这里的 HtmlRequest 对象就相当于钱包，HtmlRequest 里的 address 和 content 对象就相当于钱。我们应该把 address 和 content 交给 NetworkTransporter，而非是直接把 HtmlRequest 交给 NetworkTransporter。根据这个思路，NetworkTransporter 重构之后的代码如下所示：\n\n```java\npublic class NetworkTransporter {\n    // 省略属性和其他方法...\n    public Byte[] send(String address, Byte[] data) {\n      //...\n    }\n}\n```\n\n\n\n我们再来看 HtmlDownloader 类。这个类的设计没有问题。不过，我们修改了 NetworkTransporter 的 send() 函数的定义，而这个类用到了 send() 函数，所以我们需要对它做相应的修改，修改后的代码如下所示\n\n\n\n```java\npublic class HtmlDownloader {\n  private NetworkTransporter transporter;//通过构造函数或IOC注入\n  \n  // HtmlDownloader这里也要有相应的修改\n  public Html downloadHtml(String url) {\n    HtmlRequest htmlRequest = new HtmlRequest(url);\n    Byte[] rawHtml = transporter.send(\n      htmlRequest.getAddress(), htmlRequest.getContent().getBytes());\n    return new Html(rawHtml);\n  }\n}\n```\n\n\n\n最后，我们来看下 Document 类。这个类的问题比较多，主要有三点。第一，构造函数中的 downloader.downloadHtml() 逻辑复杂，耗时长，不应该放到构造函数中，会影响代码的可测试性。代码的可测试性我们后面会讲到，这里你先知道有这回事就可以了。第二，HtmlDownloader 对象在构造函数中通过 new 来创建，违反了基于接口而非实现编程的设计思想，也会影响到代码的可测试性。第三，从业务含义上来讲，Document 网页文档没必要依赖 HtmlDownloader 类，违背了迪米特法则。\n\n虽然 Document 类的问题很多，但修改起来比较简单，只要一处改动就可以解决所有问题。修改之后的代码如下所示：\n\n```java\npublic class Document {\n  private Html html;\n  private String url;\n  \n  public Document(String url, Html html) {\n    this.html = html;\n    this.url = url;\n  }\n  //...\n}\n\n// 通过一个工厂方法来创建Document\npublic class DocumentFactory {\n  private HtmlDownloader downloader;\n  \n  public DocumentFactory(HtmlDownloader downloader) {\n    this.downloader = downloader;\n  }\n  \n  public Document createDocument(String url) {\n    Html html = downloader.downloadHtml(url);\n    return new Document(url, html);\n  }\n}\n```\n\n\n\n\n\n### 理论解读与代码实战二\n\n现在，我们再来看一下这条原则中的后半部分：“有依赖关系的类之间，尽量只依赖必要的接口”。我们还是结合一个例子来讲解。下面这段代码非常简单，Serialization 类负责对象的序列化和反序列化\n\n\n\n```java\npublic class Serialization {\n  public String serialize(Object object) {\n    String serializedResult = ...;\n    //...\n    return serializedResult;\n  }\n  \n  public Object deserialize(String str) {\n    Object deserializedResult = ...;\n    //...\n    return deserializedResult;\n  }\n}\n```\n\n\n\n1. 单看这个类的设计，没有一点问题。不过，如果我们把它放到一定的应用场景里，那就还有继续优化的空间。假设在我们的项目中，有些类只用到了序列化操作，而另一些类只用到反序列化操作。那基于迪米特法则后半部分“有依赖关系的类之间，尽量只依赖必要的接口”，只用到序列化操作的那部分类不应该依赖反序列化接口。同理，只用到反序列化操作的那部分类不应该依赖序列化接口。\n2. 根据这个思路，我们应该将 Serialization 类拆分为两个更小粒度的类，一个只负责序列化（Serializer 类），一个只负责反序列化（Deserializer 类）。拆分之后，使用序列化操作的类只需要依赖 Serializer 类，使用反序列化操作的类只需要依赖 Deserializer 类。拆分之后的代码如下所示：\n\n```java\npublic class Serializer {\n  public String serialize(Object object) {\n    String serializedResult = ...;\n    ...\n    return serializedResult;\n  }\n}\n\npublic class Deserializer {\n  public Object deserialize(String str) {\n    Object deserializedResult = ...;\n    ...\n    return deserializedResult;\n  }\n}\n```\n\n\n\n\n\n1. 不知道你有没有看出来，尽管拆分之后的代码更能满足迪米特法则，但却违背了高内聚的设计思想。高内聚要求相近的功能要放到同一个类中，这样可以方便功能修改的时候，修改的地方不至于过于分散。对于刚刚这个例子来说，如果我们修改了序列化的实现方式，比如从 JSON 换成了 XML，那反序列化的实现逻辑也需要一并修改。在未拆分的情况下，我们只需要修改一个类即可。在拆分之后，我们需要修改两个类。显然，这种设计思路的代码改动范围变大了。\n2. 如果我们既不想违背高内聚的设计思想，也不想违背迪米特法则，那我们该如何解决这个问题呢？实际上，通过引入两个接口就能轻松解决这个问题，具体的代码如下所示。实际上，我们在讲到“接口隔离原则”的时候，第三个例子就使用了类似的实现思路，你可以结合着一块儿来看。\n\n```java\npublic interface Serializable {\n  String serialize(Object object);\n}\n\npublic interface Deserializable {\n  Object deserialize(String text);\n}\n\npublic class Serialization implements Serializable, Deserializable {\n  @Override\n  public String serialize(Object object) {\n    String serializedResult = ...;\n    ...\n    return serializedResult;\n  }\n  \n  @Override\n  public Object deserialize(String str) {\n    Object deserializedResult = ...;\n    ...\n    return deserializedResult;\n  }\n}\n\npublic class DemoClass_1 {\n  private Serializable serializer;\n  \n  public Demo(Serializable serializer) {\n    this.serializer = serializer;\n  }\n  //...\n}\n\npublic class DemoClass_2 {\n  private Deserializable deserializer;\n  \n  public Demo(Deserializable deserializer) {\n    this.deserializer = deserializer;\n  }\n  //...\n}\n```\n\n1. 尽管我们还是要往 DemoClass_1 的构造函数中，传入包含序列化和反序列化的 Serialization 实现类，但是，我们依赖的 Serializable 接口只包含序列化操作，DemoClass_1 无法使用 Serialization 类中的反序列化接口，对反序列化操作无感知，这也就符合了迪米特法则后半部分所说的“依赖有限接口”的要求。\n2. 实际上，上面的的代码实现思路，也体现了“基于接口而非实现编程”的设计原则，结合迪米特法则，我们可以总结出一条新的设计原则，那就是“基于最小接口而非最大实现编程”。有些同学之前问，新的设计模式和设计原则是怎么创造出来的，实际上，就是在大量的实践中，针对开发痛点总结归纳出来的套路。\n\n\n\n### 辩证思考与灵活应用\n\n1. 对于实战二最终的设计思路，你有没有什么不同的观点呢？\n2. 整个类只包含序列化和反序列化两个操作，只用到序列化操作的使用者，即便能够感知到仅有的一个反序列化函数，问题也不大。那为了满足迪米特法则，我们将一个非常简单的类，拆分出两个接口，是否有点过度设计的意思呢？\n3. 设计原则本身没有对错，只有能否用对之说。不要为了应用设计原则而应用设计原则，我们在应用设计原则的时候，一定要具体问题具体分析。\n4. 对于刚刚这个 Serialization 类来说，只包含两个操作，确实没有太大必要拆分成两个接口。但是，如果我们对 Serialization 类添加更多的功能，实现更多更好用的序列化、反序列化函数，我们来重新考虑一下这个问题。修改之后的具体的代码如下\n\n```java\npublic class Serializer { // 参看JSON的接口定义\n  public String serialize(Object object) { //... }\n  public String serializeMap(Map map) { //... }\n  public String serializeList(List list) { //... }\n  \n  public Object deserialize(String objectString) { //... }\n  public Map deserializeMap(String mapString) { //... }\n  public List deserializeList(String listString) { //... }\n}\n```\n\n在这种场景下，第二种设计思路要更好些。因为基于之前的应用场景来说，大部分代码只需要用到序列化的功能。对于这部分使用者，没必要了解反序列化的“知识”，而修改之后的 Serialization 类，反序列化的“知识”，从一个函数变成了三个。一旦任一反序列化操作有代码改动，我们都需要检查、测试所有依赖 Serialization 类的代码是否还能正常工作。为了减少耦合和测试工作量，我们应该按照迪米特法则，将反序列化和序列化的功能隔离开来。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/2024-05-01-设计模式-02.经典设计原则-第二节[必读].md","raw":"---\ntitle: '设计模式-02.经典设计原则-第二节[必读]'\ntags:\n  - 设计模式\n  - 设计原则\ncategories:\n  - 设计模式\n  - 02.经典设计原则\nkeywords: 设计模式，经典设计原则\ndescription: 设计模式-经典设计原则，例如：迪米特法则，依赖反转原则，KISS等等。\ncover: 'https://npm.elemecdn.com/lql_static@latest/logo/design_patterns.jpg'\nabbrlink: 994a8ed3\ndate: 2024-05-01 13:28:50\n---\n\n# 声明\n\n> 1. 此系列文章非本人原创，是学习笔记。\n> 2. 设计模式系列以后会持续更新，包括已经发布的设计模式文章，因为后续还要再多看一下书，教程和开源项目等，继续润色文章。\n\n# 设计模式经典设计原则-第二节\n\n## 依赖反转原则（DIP）\n\n关于 SOLID 原则，我们已经学过单一职责、开闭、里式替换、接口隔离这四个原则。今天，我们再来学习最后一个原则：依赖反转原则。在前面，我们讲到，单一职责原则和开闭原则的原理比较简单，但是，想要在实践中用好却比较难。而今天我们要讲到的依赖反转原则正好相反。这个原则用起来比较简单，但概念理解起来比较难。比如，下面这几个问题，你看看能否清晰地回答出来：\n\n- “依赖反转”这个概念指的是“谁跟谁”的“什么依赖”被反转了？“反转”两个字该如何理解？\n- 我们还经常听到另外两个概念：“控制反转”和“依赖注入”。这两个概念跟“依赖反转”有什么区别和联系呢？它们说的是同一个事情吗？\n- 如果你熟悉 Java 语言，那 Spring 框架中的 IOC 跟这些概念又有什么关系呢？\n\n\n\n### 控制反转（IOC）\n\n在讲“依赖反转原则”之前，我们先讲一讲“控制反转”。控制反转的英文翻译是 Inversion Of Control，缩写为 IOC。此处我要强调一下，暂时别把这个“IOC”跟 Spring 框架的 IOC 联系在一起。关于 Spring 的 IOC，我们待会儿还会讲到。我们先通过一个例子来看一下，什么是控制反转。\n\n```java\npublic class UserServiceTest {\n  public static boolean doTest() {\n    // ... \n  }\n  \n  public static void main(String[] args) {//这部分逻辑可以放到框架中\n    if (doTest()) {\n      System.out.println(\"Test succeed.\");\n    } else {\n      System.out.println(\"Test failed.\");\n    }\n  }\n}\n```\n\n在上面的代码中，所有的流程都由程序员来控制。如果我们抽象出一个下面这样一个框架，我们再来看，如何利用框架来实现同样的功能。具体的代码实现如下所示：\n\n\n\n```java\npublic abstract class TestCase {\n  public void run() {\n    if (doTest()) {\n      System.out.println(\"Test succeed.\");\n    } else {\n      System.out.println(\"Test failed.\");\n    }\n  }\n  \n  public abstract boolean doTest();\n}\n\npublic class JunitApplication {\n  private static final List<TestCase> testCases = new ArrayList<>();\n  \n  public static void register(TestCase testCase) {\n    testCases.add(testCase);\n  }\n  \n  public static final void main(String[] args) {\n    for (TestCase case: testCases) {\n      case.run();\n    }\n  }\n```\n\n把这个简化版本的测试框架引入到工程中之后，我们只需要在框架预留的扩展点，也就是 TestCase 类中的 doTest() 抽象函数中，填充具体的测试代码就可以实现之前的功能了，完全不需要写负责执行流程的 main() 函数了。 具体的代码如下所示：\n\n```java\npublic class UserServiceTest extends TestCase {\n  @Override\n  public boolean doTest() {\n    // ... \n  }\n}\n\n// 注册操作还可以通过配置的方式来实现，不需要程序员显示调用register()\nJunitApplication.register(new UserServiceTest();\n```\n\n\n\n1. 刚刚举的这个例子，就是典型的通过框架来实现“控制反转”的例子。框架提供了一个可扩展的代码骨架，用来组装对象、管理整个执行流程。程序员利用框架进行开发的时候，只需要往预留的扩展点上，添加跟自己业务相关的代码，就可以利用框架来驱动整个程序流程的执行。\n2. 这里的“控制”指的是对程序执行流程的控制，而“反转”指的是在没有使用框架之前，程序员自己控制整个程序的执行。在使用框架之后，整个程序的执行流程可以通过框架来控制。流程的控制权从程序员“反转”到了框架。\n3. 实际上，实现控制反转的方法有很多，除了刚才例子中所示的类似于模板设计模式的方法之外，还有马上要讲到的依赖注入等方法，所以，控制反转并不是一种具体的实现技巧，而是一个比较笼统的设计思想，一般用来指导框架层面的设计。\n\n\n\n### 依赖注入（DI）\n\n1. 接下来，我们再来看依赖注入。依赖注入跟控制反转恰恰相反，它是一种具体的编码技巧。那到底什么是依赖注入呢？我们用一句话来概括就是：不通过 new() 的方式在类内部创建依赖类对象，而是将依赖的类对象在外部创建好之后，通过构造函数、函数参数等方式传递（或注入）给类使用。\n2. 我们还是通过一个例子来解释一下。在这个例子中，Notification 类负责消息推送，依赖 MessageSender 类实现推送商品促销、验证码等消息给用户。我们分别用依赖注入和非依赖注入两种方式来实现一下。具体的实现代码如下所示：\n\n\n\n```java\n// 非依赖注入实现方式\npublic class Notification {\n  private MessageSender messageSender;\n  \n  public Notification() {\n    this.messageSender = new MessageSender(); //此处有点像hardcode\n  }\n  \n  public void sendMessage(String cellphone, String message) {\n    //...省略校验逻辑等...\n    this.messageSender.send(cellphone, message);\n  }\n}\n\npublic class MessageSender {\n  public void send(String cellphone, String message) {\n    //....\n  }\n}\n// 使用Notification\nNotification notification = new Notification();\n\n// 依赖注入的实现方式\npublic class Notification {\n  private MessageSender messageSender;\n  \n  // 通过构造函数将messageSender传递进来\n  public Notification(MessageSender messageSender) {\n    this.messageSender = messageSender;\n  }\n  \n  public void sendMessage(String cellphone, String message) {\n    //...省略校验逻辑等...\n    this.messageSender.send(cellphone, message);\n  }\n}\n//使用Notification\nMessageSender messageSender = new MessageSender();\nNotification notification = new Notification(messageSender);\n```\n\n通过依赖注入的方式来将依赖的类对象传递进来，这样就提高了代码的扩展性，我们可以灵活地替换依赖的类。这一点在我们之前讲“开闭原则”的时候也提到过。当然，上面代码还有继续优化的空间，我们还可以把 MessageSender 定义成接口，基于接口而非实现编程。改造后的代码如下所示：\n\n\n\n```java\npublic class Notification {\n  private MessageSender messageSender;\n  \n  public Notification(MessageSender messageSender) {\n    this.messageSender = messageSender;\n  }\n  \n  public void sendMessage(String cellphone, String message) {\n    this.messageSender.send(cellphone, message);\n  }\n}\n\npublic interface MessageSender {\n  void send(String cellphone, String message);\n}\n\n// 短信发送类\npublic class SmsSender implements MessageSender {\n  @Override\n  public void send(String cellphone, String message) {\n    //....\n  }\n}\n\n// 站内信发送类\npublic class InboxSender implements MessageSender {\n  @Override\n  public void send(String cellphone, String message) {\n    //....\n  }\n}\n\n//使用Notification\nMessageSender messageSender = new SmsSender();\nNotification notification = new Notification(messageSender);\n```\n\n\n\n实际上，你只需要掌握刚刚举的这个例子，就等于完全掌握了依赖注入。尽管依赖注入非常简单，但却非常有用，\n\n\n\n### 依赖注入框架（DI Framework）\n\n弄懂了什么是“依赖注入”，我们再来看一下，什么是“依赖注入框架”。我们还是借用刚刚的例子来解释。在采用依赖注入实现的 Notification 类中，虽然我们不需要用类似 hard code 的方式，在类内部通过 new 来创建 MessageSender 对象，但是，这个创建对象、组装（或注入）对象的工作仅仅是被移动到了更上层代码而已，还是需要我们程序员自己来实现。具体代码如下所示：\n\n\n\n```java\npublic class Demo {\n  public static final void main(String args[]) {\n    MessageSender sender = new SmsSender(); //创建对象\n    Notification notification = new Notification(sender);//依赖注入\n    notification.sendMessage(\"13918942177\", \"短信验证码：2346\");\n  }\n}\n```\n\n1. 在实际的软件开发中，一些项目可能会涉及几十、上百、甚至几百个类，类对象的创建和依赖注入会变得非常复杂。如果这部分工作都是靠程序员自己写代码来完成，容易出错且开发成本也比较高。而对象创建和依赖注入的工作，本身跟具体的业务无关，我们完全可以抽象成框架来自动完成。\n2. 你可能已经猜到，这个框架就是“依赖注入框架”。我们只需要通过依赖注入框架提供的扩展点，简单配置一下所有需要创建的类对象、类与类之间的依赖关系，就可以实现由框架来自动创建对象、管理对象的生命周期、依赖注入等原本需要程序员来做的事情。\n3. 实际上，现成的依赖注入框架有很多，比如 Google Guice、Java Spring、Pico Container、Butterfly Container 等。不过，如果你熟悉 Java Spring 框架，你可能会说，Spring 框架自己声称是控制反转容器（Inversion Of Control Container）。\n4. 实际上，这两种说法都没错。只是控制反转容器这种表述是一种非常宽泛的描述，DI 依赖注入框架的表述更具体、更有针对性。因为我们前面讲到实现控制反转的方式有很多，除了依赖注入，还有模板模式等，而 Spring 框架的控制反转主要是通过依赖注入来实现的。不过这点区分并不是很明显，也不是很重要，你稍微了解一下就可以了。\n\n\n\n### 什么是依赖反转原则？\n\n\n\n1. 前面讲了控制反转、依赖注入、依赖注入框架，现在，我们来讲一讲今天的主角：依赖反转原则。依赖反转原则的英文翻译是 Dependency Inversion Principle，缩写为 DIP。中文翻译有时候也叫依赖倒置原则。\n2. 英文描述：High-level modules shouldn’t depend on low-level modules. Both modules should depend on abstractions. In addition, abstractions shouldn’t depend on details. Details depend on abstractions.\n3. 我们将它翻译成中文，大概意思就是：高层模块（high-level modules）不要依赖低层模块（low-level）。高层模块和低层模块应该通过抽象（abstractions）来互相依赖。除此之外，抽象（abstractions）不要依赖具体实现细节（details），具体实现细节（details）依赖抽象（abstractions）。\n4. 所谓高层模块和低层模块的划分，简单来说就是，在调用链上，调用者属于高层，被调用者属于低层。在平时的业务代码开发中，高层模块依赖底层模块是没有任何问题的。实际上，这条原则主要还是用来指导框架层面的设计，跟前面讲到的控制反转类似。我们拿 Tomcat 这个 Servlet 容器作为例子来解释一下。\n5. Tomcat 是运行 Java Web 应用程序的容器。我们编写的 Web 应用程序代码只需要部署在 Tomcat 容器下，便可以被 Tomcat 容器调用执行。按照之前的划分原则，Tomcat 就是高层模块，我们编写的 Web 应用程序代码就是低层模块。Tomcat 和应用程序代码之间并没有直接的依赖关系，两者都依赖同一个“抽象”，也就是 Servlet 规范。Servlet 规范不依赖具体的 Tomcat 容器和应用程序的实现细节，而 Tomcat 容器和应用程序依赖 Servlet 规范。\n\n\n\n## KISS原则和YAGNI原则\n\n\n\n1. 我们学习了经典的 SOLID 原则。今天，我们讲两个设计原则：KISS 原则和 YAGNI 原则。其中，KISS 原则比较经典，耳熟能详，但 YAGNI 你可能没怎么听过，不过它理解起来也不难。\n2. 理解这两个原则时候，经常会有一个共同的问题，那就是，看一眼就感觉懂了，但深究的话，又有很多细节问题不是很清楚。比如，怎么理解 KISS 原则中“简单”两个字？什么样的代码才算“简单”？怎样的代码才算“复杂”？如何才能写出“简单”的代码？YAGNI 原则跟 KISS 原则说的是一回事吗？\n\n\n\nKISS 原则的英文描述有好几个版本，比如下面这几个。\n\n- Keep It Simple and Stupid.\n- Keep It Short and Simple.\n- Keep It Simple and Straightforward.\n\n1. 不过，仔细看你就会发现，它们要表达的意思其实差不多，翻译成中文就是：尽量保持简单。\n\n2. 我们知道，代码的可读性和可维护性是衡量代码质量非常重要的两个标准。而 KISS 原则就是保持代码可读和可维护的重要手段。代码足够简单，也就意味着很容易读懂，bug 比较难隐藏。即便出现 bug，修复起来也比较简单。不过，这条原则只是告诉我们，要保持代码“Simple and Stupid”，但并没有讲到，什么样的代码才是“Simple and Stupid”的，更没有给出特别明确的方法论，来指导如何开发出“Simple and Stupid”的代码。\n3. 所以，接下来，为了能让这条原则切实地落地，能够指导实际的项目开发，我就针对刚刚的这些问题来进一步讲讲我的理解。\n\n\n\n### 代码行数越少就越“简单”吗？\n\n我们先一起看一个例子。下面这三段代码可以实现同样一个功能：检查输入的字符串 ipAddress 是否是合法的 IP 地址。一个合法的 IP 地址由四个数字组成，并且通过“.”来进行分割。每组数字的取值范围是 0~255。第一组数字比较特殊，不允许为 0。对比这三段代码，你觉得哪一段代码最符合 KISS 原则呢？如果让你来实现这个功能，你会选择用哪种实现方法呢？你可以先自己思考一下，然后再看我下面的讲解。\n\n```java\n// 第一种实现方式: 使用正则表达式\npublic boolean isValidIpAddressV1(String ipAddress) {\n  if (StringUtils.isBlank(ipAddress)) return false;\n  String regex = \"^(1\\\\d{2}|2[0-4]\\\\d|25[0-5]|[1-9]\\\\d|[1-9])\\\\.\"\n          + \"(1\\\\d{2}|2[0-4]\\\\d|25[0-5]|[1-9]\\\\d|\\\\d)\\\\.\"\n          + \"(1\\\\d{2}|2[0-4]\\\\d|25[0-5]|[1-9]\\\\d|\\\\d)\\\\.\"\n          + \"(1\\\\d{2}|2[0-4]\\\\d|25[0-5]|[1-9]\\\\d|\\\\d)$\";\n  return ipAddress.matches(regex);\n}\n\n// 第二种实现方式: 使用现成的工具类\npublic boolean isValidIpAddressV2(String ipAddress) {\n  if (StringUtils.isBlank(ipAddress)) return false;\n  String[] ipUnits = StringUtils.split(ipAddress, '.');\n  if (ipUnits.length != 4) {\n    return false;\n  }\n  for (int i = 0; i < 4; ++i) {\n    int ipUnitIntValue;\n    try {\n      ipUnitIntValue = Integer.parseInt(ipUnits[i]);\n    } catch (NumberFormatException e) {\n      return false;\n    }\n    if (ipUnitIntValue < 0 || ipUnitIntValue > 255) {\n      return false;\n    }\n    if (i == 0 && ipUnitIntValue == 0) {\n      return false;\n    }\n  }\n  return true;\n}\n\n// 第三种实现方式: 不使用任何工具类\npublic boolean isValidIpAddressV3(String ipAddress) {\n  char[] ipChars = ipAddress.toCharArray();\n  int length = ipChars.length;\n  int ipUnitIntValue = -1;\n  boolean isFirstUnit = true;\n  int unitsCount = 0;\n  for (int i = 0; i < length; ++i) {\n    char c = ipChars[i];\n    if (c == '.') {\n      if (ipUnitIntValue < 0 || ipUnitIntValue > 255) return false;\n      if (isFirstUnit && ipUnitIntValue == 0) return false;\n      if (isFirstUnit) isFirstUnit = false;\n      ipUnitIntValue = -1;\n      unitsCount++;\n      continue;\n    }\n    if (c < '0' || c > '9') {\n      return false;\n    }\n    if (ipUnitIntValue == -1) ipUnitIntValue = 0;\n    ipUnitIntValue = ipUnitIntValue * 10 + (c - '0');\n  }\n  if (ipUnitIntValue < 0 || ipUnitIntValue > 255) return false;\n  if (unitsCount != 3) return false;\n  return true;\n}\n```\n\n\n\n1. 第一种实现方式利用的是正则表达式，只用三行代码就把这个问题搞定了。它的代码行数最少，那是不是就最符合 KISS 原则呢？答案是否定的。虽然代码行数最少，看似最简单，实际上却很复杂。这正是因为它使用了正则表达式。\n2. 一方面，正则表达式本身是比较复杂的，写出完全没有 bug 的正则表达本身就比较有挑战；另一方面，并不是每个程序员都精通正则表达式。对于不怎么懂正则表达式的同事来说，看懂并且维护这段正则表达式是比较困难的。这种实现方式会导致代码的可读性和可维护性变差，所以，从 KISS 原则的设计初衷上来讲，这种实现方式并不符合 KISS 原则。\n3. 讲完了第一种实现方式，我们再来看下其他两种实现方式。\n4. 第二种实现方式使用了 StringUtils 类、Integer 类提供的一些现成的工具函数，来处理 IP 地址字符串。第三种实现方式，不使用任何工具函数，而是通过逐一处理 IP 地址中的字符，来判断是否合法。从代码行数上来说，这两种方式差不多。但是，第三种要比第二种更加有难度，更容易写出 bug。从可读性上来说，第二种实现方式的代码逻辑更清晰、更好理解。所以，在这两种实现方式中，第二种实现方式更加“简单”，更加符合 KISS 原则。\n5. 不过，你可能会说，第三种实现方式虽然实现起来稍微有点复杂，但性能要比第二种实现方式高一些啊。从性能的角度来说，选择第三种实现方式是不是更好些呢？在回答这个问题之前，我先解释一下，为什么说第三种实现方式性能会更高一些。一般来说，工具类的功能都比较通用和全面，所以，在代码实现上，需要考虑和处理更多的细节，执行效率就会有所影响。而第三种实现方式，完全是自己操作底层字符，只针对 IP 地址这一种格式的数据输入来做处理，没有太多多余的函数调用和其他不必要的处理逻辑，所以，在执行效率上，这种类似定制化的处理代码方式肯定比通用的工具类要高些。\n6. 不过，尽管第三种实现方式性能更高些，但我还是更倾向于选择第二种实现方法。那是因为第三种实现方式实际上是一种过度优化。除非 isValidIpAddress() 函数是影响系统性能的瓶颈代码，否则，这样优化的投入产出比并不高，增加了代码实现的难度、牺牲了代码的可读性，性能上的提升却并不明显。\n\n\n\n### 代码逻辑复杂就违背 KISS 原则吗？\n\n刚刚我们提到，并不是代码行数越少就越“简单”，还要考虑逻辑复杂度、实现难度、代码的可读性等。那如果一段代码的逻辑复杂、实现难度大、可读性也不太好，是不是就一定违背 KISS 原则呢？在回答这个问题之前，我们先来看下面这段代码：\n\n```java\n// KMP algorithm: a, b分别是主串和模式串；n, m分别是主串和模式串的长度。\npublic static int kmp(char[] a, int n, char[] b, int m) {\n  int[] next = getNexts(b, m);\n  int j = 0;\n  for (int i = 0; i < n; ++i) {\n    while (j > 0 && a[i] != b[j]) { // 一直找到a[i]和b[j]\n      j = next[j - 1] + 1;\n    }\n    if (a[i] == b[j]) {\n      ++j;\n    }\n    if (j == m) { // 找到匹配模式串的了\n      return i - m + 1;\n    }\n  }\n  return -1;\n}\n\n// b表示模式串，m表示模式串的长度\nprivate static int[] getNexts(char[] b, int m) {\n  int[] next = new int[m];\n  next[0] = -1;\n  int k = -1;\n  for (int i = 1; i < m; ++i) {\n    while (k != -1 && b[k + 1] != b[i]) {\n      k = next[k];\n    }\n    if (b[k + 1] == b[i]) {\n      ++k;\n    }\n    next[i] = k;\n  }\n  return next;\n}\n```\n\n\n\n1. 这段代码是KMP 字符串匹配算法的代码实现。这段代码完全符合我们刚提到的逻辑复杂、实现难度大、可读性差的特点，但它并不违反 KISS 原则。为什么这么说呢？\n\n2. KMP 算法以快速高效著称。当我们需要处理长文本字符串匹配问题（几百 MB 大小文本内容的匹配），或者字符串匹配是某个产品的核心功能（比如 Vim、Word 等文本编辑器），又或者字符串匹配算法是系统性能瓶颈的时候，我们就应该选择尽可能高效的 KMP 算法。而 KMP 算法本身具有逻辑复杂、实现难度大、可读性差的特点。本身就复杂的问题，用复杂的方法解决，并不违背 KISS 原则。\n3. 不过，平时的项目开发中涉及的字符串匹配问题，大部分都是针对比较小的文本。在这种情况下，直接调用编程语言提供的现成的字符串匹配函数就足够了。如果非得用 KMP 算法、BM 算法来实现字符串匹配，那就真的违背 KISS 原则了。也就是说，同样的代码，在某个业务场景下满足 KISS 原则，换一个应用场景可能就不满足了。\n\n\n\n\n\n### 如何写出满足 KISS 原则的代码？\n\n\n\n实际上，我们前面已经讲到了一些方法。这里我稍微总结一下。\n\n- 不要使用同事可能不懂的技术来实现代码。比如前面例子中的正则表达式，还有一些编程语言中过于高级的语法等。\n- 不要重复造轮子，要善于使用已经有的工具类库。经验证明，自己去实现这些类库，出 bug 的概率会更高，维护的成本也比较高。\n- 不要过度优化。不要过度使用一些奇技淫巧（比如，位运算代替算术运算、复杂的条件语句代替 if-else、使用一些过于底层的函数等）来优化代码，牺牲代码的可读性。\n- 实际上，代码是否足够简单是一个挺主观的评判。同样的代码，有的人觉得简单，有的人觉得不够简单。而往往自己编写的代码，自己都会觉得够简单。所以，评判代码是否简单，还有一个很有效的间接方法，那就是 code review。如果在 code review 的时候，同事对你的代码有很多疑问，那就说明你的代码有可能不够“简单”，需要优化啦。\n\n\n\n\n\n### YAGNI 跟 KISS 说的是一回事吗？\n\n1. YAGNI 原则的英文全称是：You Ain’t Gonna Need It。直译就是：你不会需要它。这条原则也算是万金油了。当用在软件开发中的时候，它的意思是：不要去设计当前用不到的功能；不要去编写当前用不到的代码。实际上，这条原则的核心思想就是：不要做过度设计。\n2. 比如，我们的系统暂时只用 Redis 存储配置信息，以后可能会用到 ZooKeeper。根据 YAGNI 原则，在未用到 ZooKeeper 之前，我们没必要提前编写这部分代码。当然，这并不是说我们就不需要考虑代码的扩展性。我们还是要预留好扩展点，等到需要的时候，再去实现 ZooKeeper 存储配置信息这部分代码。\n3. 再比如，我们不要在项目中提前引入不需要依赖的开发包。对于 Java 程序员来说，我们经常使用 Maven 或者 Gradle 来管理依赖的类库（library）。我发现，有些同事为了避免开发中 library 包缺失而频繁地修改 Maven 或者 Gradle 配置文件，提前往项目里引入大量常用的 library 包。实际上，这样的做法也是违背 YAGNI 原则的。\n4. 从刚刚的分析我们可以看出，YAGNI 原则跟 KISS 原则并非一回事儿。KISS 原则讲的是“如何做”的问题（尽量保持简单），而 YAGNI 原则说的是“要不要做”的问题（当前不需要的就不要做）。\n\n\n\n## DRY 原则\n\nDon’t Repeat Yourself。中文直译为：不要重复自己。将它应用在编程中，可以理解为：不要写重复的代码。DRY 原则的定义非常简单，我就不再过度解读。今天，我们主要讲三种典型的代码重复情况，它们分别是：实现逻辑重复、功能语义重复和代码执行重复。这三种代码重复，有的看似违反 DRY，实际上并不违反；有的看似不违反，实际上却违反了。\n\n\n\n### 实现逻辑重复\n\n我们先来看下面这样一段代码是否违反了 DRY 原则。如果违反了，你觉得应该如何重构，才能让它满足 DRY 原则？如果没有违反，那又是为什么呢？\n\n```java\npublic class UserAuthenticator {\n  public void authenticate(String username, String password) {\n    if (!isValidUsername(username)) {\n      // ...throw InvalidUsernameException...\n    }\n    if (!isValidPassword(password)) {\n      // ...throw InvalidPasswordException...\n    }\n    //...省略其他代码...\n  }\n\n  private boolean isValidUsername(String username) {\n    // check not null, not empty\n    if (StringUtils.isBlank(username)) {\n      return false;\n    }\n    // check length: 4~64\n    int length = username.length();\n    if (length < 4 || length > 64) {\n      return false;\n    }\n    // contains only lowcase characters\n    if (!StringUtils.isAllLowerCase(username)) {\n      return false;\n    }\n    // contains only a~z,0~9,dot\n    for (int i = 0; i < length; ++i) {\n      char c = username.charAt(i);\n      if (!(c >= 'a' && c <= 'z') || (c >= '0' && c <= '9') || c == '.') {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  private boolean isValidPassword(String password) {\n    // check not null, not empty\n    if (StringUtils.isBlank(password)) {\n      return false;\n    }\n    // check length: 4~64\n    int length = password.length();\n    if (length < 4 || length > 64) {\n      return false;\n    }\n    // contains only lowcase characters\n    if (!StringUtils.isAllLowerCase(password)) {\n      return false;\n    }\n    // contains only a~z,0~9,dot\n    for (int i = 0; i < length; ++i) {\n      char c = password.charAt(i);\n      if (!(c >= 'a' && c <= 'z') || (c >= '0' && c <= '9') || c == '.') {\n        return false;\n      }\n    }\n    return true;\n  }\n}\n```\n\n代码很简单，我就不做过多解释了。在代码中，有两处非常明显的重复的代码片段：isValidUserName() 函数和 isValidPassword() 函数。重复的代码被敲了两遍，或者简单 copy-paste 了一下，看起来明显违反 DRY 原则。为了移除重复的代码，我们对上面的代码做下重构，将 isValidUserName() 函数和 isValidPassword() 函数，合并为一个更通用的函数 isValidUserNameOrPassword()。重构后的代码如下所示：\n\n```java\npublic class UserAuthenticatorV2 {\n\n  public void authenticate(String userName, String password) {\n    if (!isValidUsernameOrPassword(userName)) {\n      // ...throw InvalidUsernameException...\n    }\n\n    if (!isValidUsernameOrPassword(password)) {\n      // ...throw InvalidPasswordException...\n    }\n  }\n\n  private boolean isValidUsernameOrPassword(String usernameOrPassword) {\n    //省略实现逻辑\n    //跟原来的isValidUsername()或isValidPassword()的实现逻辑一样...\n    return true;\n  }\n}\n```\n\n1. 经过重构之后，代码行数减少了，也没有重复的代码了，是不是更好了呢？答案是否定的，这可能跟你预期的不一样，我来解释一下为什么。\n2. 单从名字上看，我们就能发现，合并之后的 isValidUserNameOrPassword() 函数，负责两件事情：验证用户名和验证密码，违反了“单一职责原则”和“接口隔离原则”。实际上，即便将两个函数合并成 isValidUserNameOrPassword()，代码仍然存在问题。\n3. 因为 isValidUserName() 和 isValidPassword() 两个函数，虽然从代码实现逻辑上看起来是重复的，但是从语义上并不重复。所谓“语义不重复”指的是：从功能上来看，这两个函数干的是完全不重复的两件事情，一个是校验用户名，另一个是校验密码。尽管在目前的设计中，两个校验逻辑是完全一样的，但如果按照第二种写法，将两个函数的合并，那就会存在潜在的问题。在未来的某一天，如果我们修改了密码的校验逻辑，比如，允许密码包含大写字符，允许密码的长度为 8 到 64 个字符，那这个时候，isValidUserName() 和 isValidPassword() 的实现逻辑就会不相同。我们就要把合并后的函数，重新拆成合并前的那两个函数。\n4. 尽管代码的实现逻辑是相同的，但语义不同，我们判定它并不违反 DRY 原则。对于包含重复代码的问题，我们可以通过抽象成更细粒度函数的方式来解决。比如将校验只包含 a~z、0~9、dot 的逻辑封装成 boolean onlyContains(String str, String charlist); 函数。\n\n\n\n### 功能语义重复\n\n1. 现在我们再来看另外一个例子。在同一个项目代码中有下面两个函数：isValidIp() 和 checkIfIpValid()。尽管两个函数的命名不同，实现逻辑不同，但功能是相同的，都是用来判定 IP 地址是否合法的。\n2. 之所以在同一个项目中会有两个功能相同的函数，那是因为这两个函数是由两个不同的同事开发的，其中一个同事在不知道已经有了 isValidIp() 的情况下，自己又定义并实现了同样用来校验 IP 地址是否合法的 checkIfIpValid() 函数。那在同一项目代码中，存在如下两个函数，是否违反 DRY 原则呢？\n\n```java\npublic boolean isValidIp(String ipAddress) {\n  if (StringUtils.isBlank(ipAddress)) return false;\n  String regex = \"^(1\\\\d{2}|2[0-4]\\\\d|25[0-5]|[1-9]\\\\d|[1-9])\\\\.\"\n          + \"(1\\\\d{2}|2[0-4]\\\\d|25[0-5]|[1-9]\\\\d|\\\\d)\\\\.\"\n          + \"(1\\\\d{2}|2[0-4]\\\\d|25[0-5]|[1-9]\\\\d|\\\\d)\\\\.\"\n          + \"(1\\\\d{2}|2[0-4]\\\\d|25[0-5]|[1-9]\\\\d|\\\\d)$\";\n  return ipAddress.matches(regex);\n}\n\npublic boolean checkIfIpValid(String ipAddress) {\n  if (StringUtils.isBlank(ipAddress)) return false;\n  String[] ipUnits = StringUtils.split(ipAddress, '.');\n  if (ipUnits.length != 4) {\n    return false;\n  }\n  for (int i = 0; i < 4; ++i) {\n    int ipUnitIntValue;\n    try {\n      ipUnitIntValue = Integer.parseInt(ipUnits[i]);\n    } catch (NumberFormatException e) {\n      return false;\n    }\n    if (ipUnitIntValue < 0 || ipUnitIntValue > 255) {\n      return false;\n    }\n    if (i == 0 && ipUnitIntValue == 0) {\n      return false;\n    }\n  }\n  return true;\n}\n```\n\n1. 这个例子跟上个例子正好相反。上一个例子是代码实现逻辑重复，但语义不重复，我们并不认为它违反了 DRY 原则。而在这个例子中，尽管两段代码的实现逻辑不重复，但语义重复，也就是功能重复，我们认为它违反了 DRY 原则。我们应该在项目中，统一一种实现思路，所有用到判断 IP 地址是否合法的地方，都统一调用同一个函数。\n2. 假设我们不统一实现思路，那有些地方调用了 isValidIp() 函数，有些地方又调用了 checkIfIpValid() 函数，这就会导致代码看起来很奇怪，相当于给代码“埋坑”，给不熟悉这部分代码的同事增加了阅读的难度。同事有可能研究了半天，觉得功能是一样的，但又有点疑惑，觉得是不是有更高深的考量，才定义了两个功能类似的函数，最终发现居然是代码设计的问题。\n3. 除此之外，如果哪天项目中 IP 地址是否合法的判定规则改变了，比如：255.255.255.255 不再被判定为合法的了，相应地，我们对 isValidIp() 的实现逻辑做了相应的修改，但却忘记了修改 checkIfIpValid() 函数。又或者，我们压根就不知道还存在一个功能相同的 checkIfIpValid() 函数，这样就会导致有些代码仍然使用老的 IP 地址判断逻辑，导致出现一些莫名其妙的 bug。\n\n\n\n### 代码执行重复\n\n前两个例子一个是实现逻辑重复，一个是语义重复，我们再来看第三个例子。其中，UserService 中 login() 函数用来校验用户登录是否成功。如果失败，就返回异常；如果成功，就返回用户信息。具体代码如下所示：\n\n```java\npublic class UserService {\n  private UserRepo userRepo;//通过依赖注入或者IOC框架注入\n\n  public User login(String email, String password) {\n    boolean existed = userRepo.checkIfUserExisted(email, password);\n    if (!existed) {\n      // ... throw AuthenticationFailureException...\n    }\n    User user = userRepo.getUserByEmail(email);\n    return user;\n  }\n}\n\npublic class UserRepo {\n  public boolean checkIfUserExisted(String email, String password) {\n    if (!EmailValidation.validate(email)) {\n      // ... throw InvalidEmailException...\n    }\n\n    if (!PasswordValidation.validate(password)) {\n      // ... throw InvalidPasswordException...\n    }\n\n    //...query db to check if email&password exists...\n  }\n\n  public User getUserByEmail(String email) {\n    if (!EmailValidation.validate(email)) {\n      // ... throw InvalidEmailException...\n    }\n    //...query db to get user by email...\n  }\n}\n```\n\n1. 上面这段代码，既没有逻辑重复，也没有语义重复，但仍然违反了 DRY 原则。这是因为代码中存在“执行重复”。我们一块儿来看下，到底哪些代码被重复执行了？\n2. 重复执行最明显的一个地方，就是在 login() 函数中，email 的校验逻辑被执行了两次。一次是在调用 checkIfUserExisted() 函数的时候，另一次是调用 getUserByEmail() 函数的时候。这个问题解决起来比较简单，我们只需要将校验逻辑从 UserRepo 中移除，统一放到 UserService 中就可以了。\n3. 除此之外，代码中还有一处比较隐蔽的执行重复，不知道你发现了没有？实际上，login() 函数并不需要调用 checkIfUserExisted() 函数，只需要调用一次 getUserByEmail() 函数，从数据库中获取到用户的 email、password 等信息，然后跟用户输入的 email、password 信息做对比，依次判断是否登录成功。\n4. 实际上，这样的优化是很有必要的。因为 checkIfUserExisted() 函数和 getUserByEmail() 函数都需要查询数据库，而数据库这类的 I/O 操作是比较耗时的。我们在写代码的时候，应当尽量减少这类 I/O 操作。\n5. 按照刚刚的修改思路，我们把代码重构一下，移除“重复执行”的代码，只校验一次 email 和 password，并且只查询一次数据库。重构之后的代码如下所示：\n\n```java\npublic class UserService {\n  private UserRepo userRepo;//通过依赖注入或者IOC框架注入\n\n  public User login(String email, String password) {\n    if (!EmailValidation.validate(email)) {\n      // ... throw InvalidEmailException...\n    }\n    if (!PasswordValidation.validate(password)) {\n      // ... throw InvalidPasswordException...\n    }\n    User user = userRepo.getUserByEmail(email);\n    if (user == null || !password.equals(user.getPassword()) {\n      // ... throw AuthenticationFailureException...\n    }\n    return user;\n  }\n}\n\npublic class UserRepo {\n  public boolean checkIfUserExisted(String email, String password) {\n    //...query db to check if email&password exists\n  }\n\n  public User getUserByEmail(String email) {\n    //...query db to get user by email...\n  }\n}\n```\n\n\n\n### 代码复用性（Code Reusability）\n\n1. 我们首先来区分三个概念：代码复用性（Code Reusability）、代码复用（Code Resue）和 DRY 原则。代码复用表示一种行为：我们在开发新功能的时候，尽量复用已经存在的代码。代码的可复用性表示一段代码可被复用的特性或能力：我们在编写代码的时候，让代码尽量可复用。DRY 原则是一条原则：不要写重复的代码。从定义描述上，它们好像有点类似，但深究起来，三者的区别还是蛮大的。\n\n2. 首先，“不重复”并不代表“可复用”。在一个项目代码中，可能不存在任何重复的代码，但也并不表示里面有可复用的代码，不重复和可复用完全是两个概念。所以，从这个角度来说，DRY 原则跟代码的可复用性讲的是两回事。\n3. 其次，“复用”和“可复用性”关注角度不同。代码“可复用性”是从代码开发者的角度来讲的，“复用”是从代码使用者的角度来讲的。比如，A 同事编写了一个 UrlUtils 类，代码的“可复用性”很好。B 同事在开发新功能的时候，直接“复用”A 同事编写的 UrlUtils 类。尽管复用、可复用性、DRY 原则这三者从理解上有所区别，但实际上要达到的目的都是类似的，都是为了减少代码量，提高代码的可读性、可维护性。除此之外，复用已经经过测试的老代码，bug 会比从零重新开发要少。\n4. “复用”这个概念不仅可以指导细粒度的模块、类、函数的设计开发，实际上，一些框架、类库、组件等的产生也都是为了达到复用的目的。比如，Spring 框架、Google Guava 类库、UI 组件等等。\n\n\n\n### 怎么提高代码复用性？\n\n实际上，我们前面已经讲到过很多提高代码可复用性的手段，今天算是集中总结一下，我总结了 7 条，具体如下。\n\n> 减少代码耦合\n\n对于高度耦合的代码，当我们希望复用其中的一个功能，想把这个功能的代码抽取出来成为一个独立的模块、类或者函数的时候，往往会发现牵一发而动全身。移动一点代码，就要牵连到很多其他相关的代码。所以，高度耦合的代码会影响到代码的复用性，我们要尽量减少代码耦合。\n\n> 满足单一职责原则\n\n我们前面讲过，如果职责不够单一，模块、类设计得大而全，那依赖它的代码或者它依赖的代码就会比较多，进而增加了代码的耦合。根据上一点，也就会影响到代码的复用性。相反，越细粒度的代码，代码的通用性会越好，越容易被复用。\n\n> 模块化\n\n这里的“模块”，不单单指一组类构成的模块，还可以理解为单个类、函数。我们要善于将功能独立的代码，封装成模块。独立的模块就像一块一块的积木，更加容易复用，可以直接拿来搭建更加复杂的系统。\n\n> 业务与非业务逻辑分离\n\n越是跟业务无关的代码越是容易复用，越是针对特定业务的代码越难复用。所以，为了复用跟业务无关的代码，我们将业务和非业务逻辑代码分离，抽取成一些通用的框架、类库、组件等。\n\n> 通用代码下沉\n\n从分层的角度来看，越底层的代码越通用、会被越多的模块调用，越应该设计得足够可复用。一般情况下，在代码分层之后，为了避免交叉调用导致调用关系混乱，我们只允许上层代码调用下层代码及同层代码之间的调用，杜绝下层代码调用上层代码。所以，通用的代码我们尽量下沉到更下层。\n\n> 继承、多态、抽象、封装\n\n在讲面向对象特性的时候，利用继承，可以将公共的代码抽取到父类，子类复用父类的属性和方法。利用多态，我们可以动态地替换一段代码的部分逻辑，让这段代码可复用。除此之外，抽象和封装，从更加广义的层面、而非狭义的面向对象特性的层面来理解的话，越抽象、越不依赖具体的实现，越容易复用。代码封装成模块，隐藏可变的细节、暴露不变的接口，就越容易复用。\n\n> 应用模板等设计模式\n\n一些设计模式，也能提高代码的复用性。比如，模板模式利用了多态来实现，可以灵活地替换其中的部分代码，整个流程模板代码可复用。关于应用设计模式提高代码复用性这一部分，我们留在后面慢慢来讲解。除了刚刚我们讲到的几点，还有一些跟编程语言相关的特性，也能提高代码的复用性，比如泛型编程等。实际上，除了上面讲到的这些方法之外，复用意识也非常重要。在写代码的时候，我们要多去思考一下，这\n\n\n\n\n\n\n\n\n\n## 迪米特法则\n\n\n\n我们讲最后一个设计原则：迪米特法则。尽管它不像 SOLID、KISS、DRY 原则那样，人尽皆知，但它却非常实用。利用这个原则，能够帮我们实现代码的“高内聚、松耦合”。今天，我们就围绕下面几个问题，并结合两个代码实战案例，来深入地学习这个法则。\n\n- 什么是“高内聚、松耦合”？\n- 如何利用迪米特法则来实现“高内聚、松耦合”？\n- 有哪些代码设计是明显违背迪米特法则的？对此又该如何重构？\n\n\n\n\n\n### 何为“高内聚、松耦合”？\n\n1. “高内聚、松耦合”是一个非常重要的设计思想，能够有效地提高代码的可读性和可维护性，缩小功能改动导致的代码改动范围。\n2. 实际上，在前面的章节中，我们已经多次提到过这个设计思想。很多设计原则都以实现代码的“高内聚、松耦合”为目的，比如单一职责原则、基于接口而非实现编程等。实际上，“高内聚、松耦合”是一个比较通用的设计思想，可以用来指导不同粒度代码的设计与开发，比如系统、模块、类，甚至是函数，也可以应用到不同的开发场景中，比如微服务、框架、组件、类库等。为了方便我讲解，接下来我以“类”作为这个设计思想的应用对象来展开讲解，其他应用场景你可以自行类比。\n3. 在这个设计思想中，“高内聚”用来指导类本身的设计，“松耦合”用来指导类与类之间依赖关系的设计。不过，这两者并非完全独立不相干。高内聚有助于松耦合，松耦合又需要高内聚的支持。\n\n\n\n> 那到底什么是“高内聚”呢？\n\n\n\n所谓高内聚，就是指相近的功能应该放到同一个类中，不相近的功能不要放到同一个类中。相近的功能往往会被同时修改，放到同一个类中，修改会比较集中，代码容易维护。实际上，我们前面讲过的单一职责原则是实现代码高内聚非常有效的设计原则。\n\n\n\n> 我们再来看一下，什么是“松耦合”？\n\n所谓松耦合是说，在代码中，类与类之间的依赖关系简单清晰。即使两个类有依赖关系，一个类的代码改动不会或者很少导致依赖类的代码改动。实际上，我们前面讲的依赖注入、接口隔离、基于接口而非实现编程，以及今天讲的迪米特法则，都是为了实现代码的松耦合\n\n\n\n\n\n> 最后，我们来看一下，“内聚”和“耦合”之间的关系\n\n前面也提到，“高内聚”有助于“松耦合”，同理，“低内聚”也会导致“紧耦合”。关于这一点，我画了一张对比图来解释。图中左边部分的代码结构是“高内聚、松耦合”；右边部分正好相反，是“低内聚、紧耦合”。\n\n<img src=\"https://npm.elemecdn.com/youthlql@1.0.0/design_patterns/design_principles/0001.png\" />\n\n\n\n\n\n1. 图中左边部分的代码设计中，类的粒度比较小，每个类的职责都比较单一。相近的功能都放到了一个类中，不相近的功能被分割到了多个类中。这样类更加独立，代码的内聚性更好。因为职责单一，所以每个类被依赖的类就会比较少，代码低耦合。一个类的修改，只会影响到一个依赖类的代码改动。我们只需要测试这一个依赖类是否还能正常工作就行了。\n2. 图中右边部分的代码设计中，类粒度比较大，低内聚，功能大而全，不相近的功能放到了一个类中。这就导致很多其他类都依赖这个类。当我们修改这个类的某一个功能代码的时候，会影响依赖它的多个类。我们需要测试这三个依赖类，是否还能正常工作。这也就是所谓的“牵一发而动全身”。\n3. 除此之外，从图中我们也可以看出，高内聚、低耦合的代码结构更加简单、清晰，相应地，在可维护性和可读性上确实要好很多。\n\n\n\n\n\n### “迪米特法则”理论描述\n\n1. 迪米特法则的英文翻译是：Law of Demeter，缩写是 LOD。单从这个名字上来看，我们完全猜不出这个原则讲的是什么。不过，它还有另外一个更加达意的名字，叫作最小知识原则，英文翻译为：The Least Knowledge Principle。\n\n2. 关于这个设计原则，我们先来看一下它最原汁原味的英文定义：\n\n   > Each unit should have only limited knowledge about other units: only units “closely” related to the current unit. Or: Each unit should only talk to its friends; Don’t talk to strangers.\n\n   我们把它直译成中文，就是下面这个样子：\n\n   > 每个模块（unit）只应该了解那些与它关系密切的模块（units: only units “closely” related to the current unit）的有限知识（knowledge）。或者说，每个模块只和自己的朋友“说话”（talk），不和陌生人“说话”（talk）。\n\n   我们之前讲过，大部分设计原则和思想都非常抽象，有各种各样的解读，要想灵活地应用到实际的开发中，需要有实战经验的积累。迪米特法则也不例外。所以，我结合我自己的理解和经验，对刚刚的定义重新描述一下。注意，为了统一讲解，我把定义描述中的“模块”替换成了“类”。\n\n   > 不该有直接依赖关系的类之间，不要有依赖；有依赖关系的类之间，尽量只依赖必要的接口（也就是定义中的“有限知识”）。从上面的描述中，我们可以看出，迪米特法则包含前后两部分，这两部分讲的是两件事情，我用两个实战案例分别来解读一下。\n\n\n\n\n\n### 理论解读与代码实战一\n\n1. 我们先来看这条原则中的前半部分，**“不该有直接依赖关系的类之间，不要有依赖”**。我举个例子解释一下。\n2. 这个例子实现了简化版的搜索引擎爬取网页的功能。代码中包含三个主要的类。其中，NetworkTransporter 类负责底层网络通信，根据请求获取数据；HtmlDownloader 类用来通过 URL 获取网页；Document 表示网页文档，后续的网页内容抽取、分词、索引都是以此为处理对象。具体的代码实现如下所示：\n\n```java\npublic class NetworkTransporter {\n    // 省略属性和其他方法...\n    public Byte[] send(HtmlRequest htmlRequest) {\n      //...\n    }\n}\n\npublic class HtmlDownloader {\n  private NetworkTransporter transporter;//通过构造函数或IOC注入\n  \n  public Html downloadHtml(String url) {\n    Byte[] rawHtml = transporter.send(new HtmlRequest(url));\n    return new Html(rawHtml);\n  }\n}\n\npublic class Document {\n  private Html html;\n  private String url;\n  \n  public Document(String url) {\n    this.url = url;\n    HtmlDownloader downloader = new HtmlDownloader();\n    this.html = downloader.downloadHtml(url);\n  }\n  //...\n}\n```\n\n1. 这段代码虽然“能用”，能实现我们想要的功能，但是它不够“好用”，有比较多的设计缺陷。你可以先试着思考一下，看看都有哪些缺陷，然后再来看我下面的讲解。\n2. 首先，我们来看 NetworkTransporter 类。作为一个底层网络通信类，我们希望它的功能尽可能通用，而不只是服务于下载 HTML，所以，我们不应该直接依赖太具体的发送对象 HtmlRequest。从这一点上讲，NetworkTransporter 类的设计违背迪米特法则，依赖了不该有直接依赖关系的 HtmlRequest 类。\n3. 我们应该如何进行重构，让 NetworkTransporter 类满足迪米特法则呢？我这里有个形象的比喻。假如你现在要去商店买东西，你肯定不会直接把钱包给收银员，让收银员自己从里面拿钱，而是你从钱包里把钱拿出来交给收银员。这里的 HtmlRequest 对象就相当于钱包，HtmlRequest 里的 address 和 content 对象就相当于钱。我们应该把 address 和 content 交给 NetworkTransporter，而非是直接把 HtmlRequest 交给 NetworkTransporter。根据这个思路，NetworkTransporter 重构之后的代码如下所示：\n\n```java\npublic class NetworkTransporter {\n    // 省略属性和其他方法...\n    public Byte[] send(String address, Byte[] data) {\n      //...\n    }\n}\n```\n\n\n\n我们再来看 HtmlDownloader 类。这个类的设计没有问题。不过，我们修改了 NetworkTransporter 的 send() 函数的定义，而这个类用到了 send() 函数，所以我们需要对它做相应的修改，修改后的代码如下所示\n\n\n\n```java\npublic class HtmlDownloader {\n  private NetworkTransporter transporter;//通过构造函数或IOC注入\n  \n  // HtmlDownloader这里也要有相应的修改\n  public Html downloadHtml(String url) {\n    HtmlRequest htmlRequest = new HtmlRequest(url);\n    Byte[] rawHtml = transporter.send(\n      htmlRequest.getAddress(), htmlRequest.getContent().getBytes());\n    return new Html(rawHtml);\n  }\n}\n```\n\n\n\n最后，我们来看下 Document 类。这个类的问题比较多，主要有三点。第一，构造函数中的 downloader.downloadHtml() 逻辑复杂，耗时长，不应该放到构造函数中，会影响代码的可测试性。代码的可测试性我们后面会讲到，这里你先知道有这回事就可以了。第二，HtmlDownloader 对象在构造函数中通过 new 来创建，违反了基于接口而非实现编程的设计思想，也会影响到代码的可测试性。第三，从业务含义上来讲，Document 网页文档没必要依赖 HtmlDownloader 类，违背了迪米特法则。\n\n虽然 Document 类的问题很多，但修改起来比较简单，只要一处改动就可以解决所有问题。修改之后的代码如下所示：\n\n```java\npublic class Document {\n  private Html html;\n  private String url;\n  \n  public Document(String url, Html html) {\n    this.html = html;\n    this.url = url;\n  }\n  //...\n}\n\n// 通过一个工厂方法来创建Document\npublic class DocumentFactory {\n  private HtmlDownloader downloader;\n  \n  public DocumentFactory(HtmlDownloader downloader) {\n    this.downloader = downloader;\n  }\n  \n  public Document createDocument(String url) {\n    Html html = downloader.downloadHtml(url);\n    return new Document(url, html);\n  }\n}\n```\n\n\n\n\n\n### 理论解读与代码实战二\n\n现在，我们再来看一下这条原则中的后半部分：“有依赖关系的类之间，尽量只依赖必要的接口”。我们还是结合一个例子来讲解。下面这段代码非常简单，Serialization 类负责对象的序列化和反序列化\n\n\n\n```java\npublic class Serialization {\n  public String serialize(Object object) {\n    String serializedResult = ...;\n    //...\n    return serializedResult;\n  }\n  \n  public Object deserialize(String str) {\n    Object deserializedResult = ...;\n    //...\n    return deserializedResult;\n  }\n}\n```\n\n\n\n1. 单看这个类的设计，没有一点问题。不过，如果我们把它放到一定的应用场景里，那就还有继续优化的空间。假设在我们的项目中，有些类只用到了序列化操作，而另一些类只用到反序列化操作。那基于迪米特法则后半部分“有依赖关系的类之间，尽量只依赖必要的接口”，只用到序列化操作的那部分类不应该依赖反序列化接口。同理，只用到反序列化操作的那部分类不应该依赖序列化接口。\n2. 根据这个思路，我们应该将 Serialization 类拆分为两个更小粒度的类，一个只负责序列化（Serializer 类），一个只负责反序列化（Deserializer 类）。拆分之后，使用序列化操作的类只需要依赖 Serializer 类，使用反序列化操作的类只需要依赖 Deserializer 类。拆分之后的代码如下所示：\n\n```java\npublic class Serializer {\n  public String serialize(Object object) {\n    String serializedResult = ...;\n    ...\n    return serializedResult;\n  }\n}\n\npublic class Deserializer {\n  public Object deserialize(String str) {\n    Object deserializedResult = ...;\n    ...\n    return deserializedResult;\n  }\n}\n```\n\n\n\n\n\n1. 不知道你有没有看出来，尽管拆分之后的代码更能满足迪米特法则，但却违背了高内聚的设计思想。高内聚要求相近的功能要放到同一个类中，这样可以方便功能修改的时候，修改的地方不至于过于分散。对于刚刚这个例子来说，如果我们修改了序列化的实现方式，比如从 JSON 换成了 XML，那反序列化的实现逻辑也需要一并修改。在未拆分的情况下，我们只需要修改一个类即可。在拆分之后，我们需要修改两个类。显然，这种设计思路的代码改动范围变大了。\n2. 如果我们既不想违背高内聚的设计思想，也不想违背迪米特法则，那我们该如何解决这个问题呢？实际上，通过引入两个接口就能轻松解决这个问题，具体的代码如下所示。实际上，我们在讲到“接口隔离原则”的时候，第三个例子就使用了类似的实现思路，你可以结合着一块儿来看。\n\n```java\npublic interface Serializable {\n  String serialize(Object object);\n}\n\npublic interface Deserializable {\n  Object deserialize(String text);\n}\n\npublic class Serialization implements Serializable, Deserializable {\n  @Override\n  public String serialize(Object object) {\n    String serializedResult = ...;\n    ...\n    return serializedResult;\n  }\n  \n  @Override\n  public Object deserialize(String str) {\n    Object deserializedResult = ...;\n    ...\n    return deserializedResult;\n  }\n}\n\npublic class DemoClass_1 {\n  private Serializable serializer;\n  \n  public Demo(Serializable serializer) {\n    this.serializer = serializer;\n  }\n  //...\n}\n\npublic class DemoClass_2 {\n  private Deserializable deserializer;\n  \n  public Demo(Deserializable deserializer) {\n    this.deserializer = deserializer;\n  }\n  //...\n}\n```\n\n1. 尽管我们还是要往 DemoClass_1 的构造函数中，传入包含序列化和反序列化的 Serialization 实现类，但是，我们依赖的 Serializable 接口只包含序列化操作，DemoClass_1 无法使用 Serialization 类中的反序列化接口，对反序列化操作无感知，这也就符合了迪米特法则后半部分所说的“依赖有限接口”的要求。\n2. 实际上，上面的的代码实现思路，也体现了“基于接口而非实现编程”的设计原则，结合迪米特法则，我们可以总结出一条新的设计原则，那就是“基于最小接口而非最大实现编程”。有些同学之前问，新的设计模式和设计原则是怎么创造出来的，实际上，就是在大量的实践中，针对开发痛点总结归纳出来的套路。\n\n\n\n### 辩证思考与灵活应用\n\n1. 对于实战二最终的设计思路，你有没有什么不同的观点呢？\n2. 整个类只包含序列化和反序列化两个操作，只用到序列化操作的使用者，即便能够感知到仅有的一个反序列化函数，问题也不大。那为了满足迪米特法则，我们将一个非常简单的类，拆分出两个接口，是否有点过度设计的意思呢？\n3. 设计原则本身没有对错，只有能否用对之说。不要为了应用设计原则而应用设计原则，我们在应用设计原则的时候，一定要具体问题具体分析。\n4. 对于刚刚这个 Serialization 类来说，只包含两个操作，确实没有太大必要拆分成两个接口。但是，如果我们对 Serialization 类添加更多的功能，实现更多更好用的序列化、反序列化函数，我们来重新考虑一下这个问题。修改之后的具体的代码如下\n\n```java\npublic class Serializer { // 参看JSON的接口定义\n  public String serialize(Object object) { //... }\n  public String serializeMap(Map map) { //... }\n  public String serializeList(List list) { //... }\n  \n  public Object deserialize(String objectString) { //... }\n  public Map deserializeMap(String mapString) { //... }\n  public List deserializeList(String listString) { //... }\n}\n```\n\n在这种场景下，第二种设计思路要更好些。因为基于之前的应用场景来说，大部分代码只需要用到序列化的功能。对于这部分使用者，没必要了解反序列化的“知识”，而修改之后的 Serialization 类，反序列化的“知识”，从一个函数变成了三个。一旦任一反序列化操作有代码改动，我们都需要检查、测试所有依赖 Serialization 类的代码是否还能正常工作。为了减少耦合和测试工作量，我们应该按照迪米特法则，将反序列化和序列化的功能隔离开来。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"2024-05-01-设计模式-02.经典设计原则-第二节[必读]","published":1,"updated":"2024-05-01T05:28:39.562Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cly2c4k3t000uqsvd9if07q1c","content":"<h1 id=\"声明\"><a href=\"#声明\" class=\"headerlink\" title=\"声明\"></a>声明</h1><blockquote>\n<ol>\n<li>此系列文章非本人原创，是学习笔记。</li>\n<li>设计模式系列以后会持续更新，包括已经发布的设计模式文章，因为后续还要再多看一下书，教程和开源项目等，继续润色文章。</li>\n</ol>\n</blockquote>\n<h1 id=\"设计模式经典设计原则-第二节\"><a href=\"#设计模式经典设计原则-第二节\" class=\"headerlink\" title=\"设计模式经典设计原则-第二节\"></a>设计模式经典设计原则-第二节</h1><h2 id=\"依赖反转原则（DIP）\"><a href=\"#依赖反转原则（DIP）\" class=\"headerlink\" title=\"依赖反转原则（DIP）\"></a>依赖反转原则（DIP）</h2><p>关于 SOLID 原则，我们已经学过单一职责、开闭、里式替换、接口隔离这四个原则。今天，我们再来学习最后一个原则：依赖反转原则。在前面，我们讲到，单一职责原则和开闭原则的原理比较简单，但是，想要在实践中用好却比较难。而今天我们要讲到的依赖反转原则正好相反。这个原则用起来比较简单，但概念理解起来比较难。比如，下面这几个问题，你看看能否清晰地回答出来：</p>\n<ul>\n<li>“依赖反转”这个概念指的是“谁跟谁”的“什么依赖”被反转了？“反转”两个字该如何理解？</li>\n<li>我们还经常听到另外两个概念：“控制反转”和“依赖注入”。这两个概念跟“依赖反转”有什么区别和联系呢？它们说的是同一个事情吗？</li>\n<li>如果你熟悉 Java 语言，那 Spring 框架中的 IOC 跟这些概念又有什么关系呢？</li>\n</ul>\n<h3 id=\"控制反转（IOC）\"><a href=\"#控制反转（IOC）\" class=\"headerlink\" title=\"控制反转（IOC）\"></a>控制反转（IOC）</h3><p>在讲“依赖反转原则”之前，我们先讲一讲“控制反转”。控制反转的英文翻译是 Inversion Of Control，缩写为 IOC。此处我要强调一下，暂时别把这个“IOC”跟 Spring 框架的 IOC 联系在一起。关于 Spring 的 IOC，我们待会儿还会讲到。我们先通过一个例子来看一下，什么是控制反转。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">UserServiceTest</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"type\">boolean</span> <span class=\"title function_\">doTest</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ... </span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;<span class=\"comment\">//这部分逻辑可以放到框架中</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (doTest()) &#123;</span><br><span class=\"line\">      System.out.println(<span class=\"string\">&quot;Test succeed.&quot;</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      System.out.println(<span class=\"string\">&quot;Test failed.&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在上面的代码中，所有的流程都由程序员来控制。如果我们抽象出一个下面这样一个框架，我们再来看，如何利用框架来实现同样的功能。具体的代码实现如下所示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">class</span> <span class=\"title class_\">TestCase</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (doTest()) &#123;</span><br><span class=\"line\">      System.out.println(<span class=\"string\">&quot;Test succeed.&quot;</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      System.out.println(<span class=\"string\">&quot;Test failed.&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"type\">boolean</span> <span class=\"title function_\">doTest</span><span class=\"params\">()</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">JunitApplication</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> List&lt;TestCase&gt; testCases = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">register</span><span class=\"params\">(TestCase testCase)</span> &#123;</span><br><span class=\"line\">    testCases.add(testCase);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (TestCase <span class=\"keyword\">case</span>: testCases) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">case</span>.run();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n<p>把这个简化版本的测试框架引入到工程中之后，我们只需要在框架预留的扩展点，也就是 TestCase 类中的 doTest() 抽象函数中，填充具体的测试代码就可以实现之前的功能了，完全不需要写负责执行流程的 main() 函数了。 具体的代码如下所示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">UserServiceTest</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">TestCase</span> &#123;</span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">doTest</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ... </span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 注册操作还可以通过配置的方式来实现，不需要程序员显示调用register()</span></span><br><span class=\"line\">JunitApplication.register(<span class=\"keyword\">new</span> <span class=\"title class_\">UserServiceTest</span>();</span><br></pre></td></tr></table></figure>\n\n\n\n<ol>\n<li>刚刚举的这个例子，就是典型的通过框架来实现“控制反转”的例子。框架提供了一个可扩展的代码骨架，用来组装对象、管理整个执行流程。程序员利用框架进行开发的时候，只需要往预留的扩展点上，添加跟自己业务相关的代码，就可以利用框架来驱动整个程序流程的执行。</li>\n<li>这里的“控制”指的是对程序执行流程的控制，而“反转”指的是在没有使用框架之前，程序员自己控制整个程序的执行。在使用框架之后，整个程序的执行流程可以通过框架来控制。流程的控制权从程序员“反转”到了框架。</li>\n<li>实际上，实现控制反转的方法有很多，除了刚才例子中所示的类似于模板设计模式的方法之外，还有马上要讲到的依赖注入等方法，所以，控制反转并不是一种具体的实现技巧，而是一个比较笼统的设计思想，一般用来指导框架层面的设计。</li>\n</ol>\n<h3 id=\"依赖注入（DI）\"><a href=\"#依赖注入（DI）\" class=\"headerlink\" title=\"依赖注入（DI）\"></a>依赖注入（DI）</h3><ol>\n<li>接下来，我们再来看依赖注入。依赖注入跟控制反转恰恰相反，它是一种具体的编码技巧。那到底什么是依赖注入呢？我们用一句话来概括就是：不通过 new() 的方式在类内部创建依赖类对象，而是将依赖的类对象在外部创建好之后，通过构造函数、函数参数等方式传递（或注入）给类使用。</li>\n<li>我们还是通过一个例子来解释一下。在这个例子中，Notification 类负责消息推送，依赖 MessageSender 类实现推送商品促销、验证码等消息给用户。我们分别用依赖注入和非依赖注入两种方式来实现一下。具体的实现代码如下所示：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 非依赖注入实现方式</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Notification</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> MessageSender messageSender;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"title function_\">Notification</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.messageSender = <span class=\"keyword\">new</span> <span class=\"title class_\">MessageSender</span>(); <span class=\"comment\">//此处有点像hardcode</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">sendMessage</span><span class=\"params\">(String cellphone, String message)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//...省略校验逻辑等...</span></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.messageSender.send(cellphone, message);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">MessageSender</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">send</span><span class=\"params\">(String cellphone, String message)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//....</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 使用Notification</span></span><br><span class=\"line\"><span class=\"type\">Notification</span> <span class=\"variable\">notification</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Notification</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 依赖注入的实现方式</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Notification</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> MessageSender messageSender;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">// 通过构造函数将messageSender传递进来</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"title function_\">Notification</span><span class=\"params\">(MessageSender messageSender)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.messageSender = messageSender;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">sendMessage</span><span class=\"params\">(String cellphone, String message)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//...省略校验逻辑等...</span></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.messageSender.send(cellphone, message);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//使用Notification</span></span><br><span class=\"line\"><span class=\"type\">MessageSender</span> <span class=\"variable\">messageSender</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">MessageSender</span>();</span><br><span class=\"line\"><span class=\"type\">Notification</span> <span class=\"variable\">notification</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Notification</span>(messageSender);</span><br></pre></td></tr></table></figure>\n\n<p>通过依赖注入的方式来将依赖的类对象传递进来，这样就提高了代码的扩展性，我们可以灵活地替换依赖的类。这一点在我们之前讲“开闭原则”的时候也提到过。当然，上面代码还有继续优化的空间，我们还可以把 MessageSender 定义成接口，基于接口而非实现编程。改造后的代码如下所示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Notification</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> MessageSender messageSender;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"title function_\">Notification</span><span class=\"params\">(MessageSender messageSender)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.messageSender = messageSender;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">sendMessage</span><span class=\"params\">(String cellphone, String message)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.messageSender.send(cellphone, message);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">MessageSender</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">void</span> <span class=\"title function_\">send</span><span class=\"params\">(String cellphone, String message)</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 短信发送类</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">SmsSender</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">MessageSender</span> &#123;</span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">send</span><span class=\"params\">(String cellphone, String message)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//....</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 站内信发送类</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">InboxSender</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">MessageSender</span> &#123;</span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">send</span><span class=\"params\">(String cellphone, String message)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//....</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//使用Notification</span></span><br><span class=\"line\"><span class=\"type\">MessageSender</span> <span class=\"variable\">messageSender</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">SmsSender</span>();</span><br><span class=\"line\"><span class=\"type\">Notification</span> <span class=\"variable\">notification</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Notification</span>(messageSender);</span><br></pre></td></tr></table></figure>\n\n\n\n<p>实际上，你只需要掌握刚刚举的这个例子，就等于完全掌握了依赖注入。尽管依赖注入非常简单，但却非常有用，</p>\n<h3 id=\"依赖注入框架（DI-Framework）\"><a href=\"#依赖注入框架（DI-Framework）\" class=\"headerlink\" title=\"依赖注入框架（DI Framework）\"></a>依赖注入框架（DI Framework）</h3><p>弄懂了什么是“依赖注入”，我们再来看一下，什么是“依赖注入框架”。我们还是借用刚刚的例子来解释。在采用依赖注入实现的 Notification 类中，虽然我们不需要用类似 hard code 的方式，在类内部通过 new 来创建 MessageSender 对象，但是，这个创建对象、组装（或注入）对象的工作仅仅是被移动到了更上层代码而已，还是需要我们程序员自己来实现。具体代码如下所示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Demo</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String args[])</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">MessageSender</span> <span class=\"variable\">sender</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">SmsSender</span>(); <span class=\"comment\">//创建对象</span></span><br><span class=\"line\">    <span class=\"type\">Notification</span> <span class=\"variable\">notification</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Notification</span>(sender);<span class=\"comment\">//依赖注入</span></span><br><span class=\"line\">    notification.sendMessage(<span class=\"string\">&quot;13918942177&quot;</span>, <span class=\"string\">&quot;短信验证码：2346&quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>在实际的软件开发中，一些项目可能会涉及几十、上百、甚至几百个类，类对象的创建和依赖注入会变得非常复杂。如果这部分工作都是靠程序员自己写代码来完成，容易出错且开发成本也比较高。而对象创建和依赖注入的工作，本身跟具体的业务无关，我们完全可以抽象成框架来自动完成。</li>\n<li>你可能已经猜到，这个框架就是“依赖注入框架”。我们只需要通过依赖注入框架提供的扩展点，简单配置一下所有需要创建的类对象、类与类之间的依赖关系，就可以实现由框架来自动创建对象、管理对象的生命周期、依赖注入等原本需要程序员来做的事情。</li>\n<li>实际上，现成的依赖注入框架有很多，比如 Google Guice、Java Spring、Pico Container、Butterfly Container 等。不过，如果你熟悉 Java Spring 框架，你可能会说，Spring 框架自己声称是控制反转容器（Inversion Of Control Container）。</li>\n<li>实际上，这两种说法都没错。只是控制反转容器这种表述是一种非常宽泛的描述，DI 依赖注入框架的表述更具体、更有针对性。因为我们前面讲到实现控制反转的方式有很多，除了依赖注入，还有模板模式等，而 Spring 框架的控制反转主要是通过依赖注入来实现的。不过这点区分并不是很明显，也不是很重要，你稍微了解一下就可以了。</li>\n</ol>\n<h3 id=\"什么是依赖反转原则？\"><a href=\"#什么是依赖反转原则？\" class=\"headerlink\" title=\"什么是依赖反转原则？\"></a>什么是依赖反转原则？</h3><ol>\n<li>前面讲了控制反转、依赖注入、依赖注入框架，现在，我们来讲一讲今天的主角：依赖反转原则。依赖反转原则的英文翻译是 Dependency Inversion Principle，缩写为 DIP。中文翻译有时候也叫依赖倒置原则。</li>\n<li>英文描述：High-level modules shouldn’t depend on low-level modules. Both modules should depend on abstractions. In addition, abstractions shouldn’t depend on details. Details depend on abstractions.</li>\n<li>我们将它翻译成中文，大概意思就是：高层模块（high-level modules）不要依赖低层模块（low-level）。高层模块和低层模块应该通过抽象（abstractions）来互相依赖。除此之外，抽象（abstractions）不要依赖具体实现细节（details），具体实现细节（details）依赖抽象（abstractions）。</li>\n<li>所谓高层模块和低层模块的划分，简单来说就是，在调用链上，调用者属于高层，被调用者属于低层。在平时的业务代码开发中，高层模块依赖底层模块是没有任何问题的。实际上，这条原则主要还是用来指导框架层面的设计，跟前面讲到的控制反转类似。我们拿 Tomcat 这个 Servlet 容器作为例子来解释一下。</li>\n<li>Tomcat 是运行 Java Web 应用程序的容器。我们编写的 Web 应用程序代码只需要部署在 Tomcat 容器下，便可以被 Tomcat 容器调用执行。按照之前的划分原则，Tomcat 就是高层模块，我们编写的 Web 应用程序代码就是低层模块。Tomcat 和应用程序代码之间并没有直接的依赖关系，两者都依赖同一个“抽象”，也就是 Servlet 规范。Servlet 规范不依赖具体的 Tomcat 容器和应用程序的实现细节，而 Tomcat 容器和应用程序依赖 Servlet 规范。</li>\n</ol>\n<h2 id=\"KISS原则和YAGNI原则\"><a href=\"#KISS原则和YAGNI原则\" class=\"headerlink\" title=\"KISS原则和YAGNI原则\"></a>KISS原则和YAGNI原则</h2><ol>\n<li>我们学习了经典的 SOLID 原则。今天，我们讲两个设计原则：KISS 原则和 YAGNI 原则。其中，KISS 原则比较经典，耳熟能详，但 YAGNI 你可能没怎么听过，不过它理解起来也不难。</li>\n<li>理解这两个原则时候，经常会有一个共同的问题，那就是，看一眼就感觉懂了，但深究的话，又有很多细节问题不是很清楚。比如，怎么理解 KISS 原则中“简单”两个字？什么样的代码才算“简单”？怎样的代码才算“复杂”？如何才能写出“简单”的代码？YAGNI 原则跟 KISS 原则说的是一回事吗？</li>\n</ol>\n<p>KISS 原则的英文描述有好几个版本，比如下面这几个。</p>\n<ul>\n<li>Keep It Simple and Stupid.</li>\n<li>Keep It Short and Simple.</li>\n<li>Keep It Simple and Straightforward.</li>\n</ul>\n<ol>\n<li><p>不过，仔细看你就会发现，它们要表达的意思其实差不多，翻译成中文就是：尽量保持简单。</p>\n</li>\n<li><p>我们知道，代码的可读性和可维护性是衡量代码质量非常重要的两个标准。而 KISS 原则就是保持代码可读和可维护的重要手段。代码足够简单，也就意味着很容易读懂，bug 比较难隐藏。即便出现 bug，修复起来也比较简单。不过，这条原则只是告诉我们，要保持代码“Simple and Stupid”，但并没有讲到，什么样的代码才是“Simple and Stupid”的，更没有给出特别明确的方法论，来指导如何开发出“Simple and Stupid”的代码。</p>\n</li>\n<li><p>所以，接下来，为了能让这条原则切实地落地，能够指导实际的项目开发，我就针对刚刚的这些问题来进一步讲讲我的理解。</p>\n</li>\n</ol>\n<h3 id=\"代码行数越少就越“简单”吗？\"><a href=\"#代码行数越少就越“简单”吗？\" class=\"headerlink\" title=\"代码行数越少就越“简单”吗？\"></a>代码行数越少就越“简单”吗？</h3><p>我们先一起看一个例子。下面这三段代码可以实现同样一个功能：检查输入的字符串 ipAddress 是否是合法的 IP 地址。一个合法的 IP 地址由四个数字组成，并且通过“.”来进行分割。每组数字的取值范围是 0~255。第一组数字比较特殊，不允许为 0。对比这三段代码，你觉得哪一段代码最符合 KISS 原则呢？如果让你来实现这个功能，你会选择用哪种实现方法呢？你可以先自己思考一下，然后再看我下面的讲解。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 第一种实现方式: 使用正则表达式</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">isValidIpAddressV1</span><span class=\"params\">(String ipAddress)</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (StringUtils.isBlank(ipAddress)) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  <span class=\"type\">String</span> <span class=\"variable\">regex</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;^(1\\\\d&#123;2&#125;|2[0-4]\\\\d|25[0-5]|[1-9]\\\\d|[1-9])\\\\.&quot;</span></span><br><span class=\"line\">          + <span class=\"string\">&quot;(1\\\\d&#123;2&#125;|2[0-4]\\\\d|25[0-5]|[1-9]\\\\d|\\\\d)\\\\.&quot;</span></span><br><span class=\"line\">          + <span class=\"string\">&quot;(1\\\\d&#123;2&#125;|2[0-4]\\\\d|25[0-5]|[1-9]\\\\d|\\\\d)\\\\.&quot;</span></span><br><span class=\"line\">          + <span class=\"string\">&quot;(1\\\\d&#123;2&#125;|2[0-4]\\\\d|25[0-5]|[1-9]\\\\d|\\\\d)$&quot;</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> ipAddress.matches(regex);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 第二种实现方式: 使用现成的工具类</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">isValidIpAddressV2</span><span class=\"params\">(String ipAddress)</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (StringUtils.isBlank(ipAddress)) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  String[] ipUnits = StringUtils.split(ipAddress, <span class=\"string\">&#x27;.&#x27;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (ipUnits.length != <span class=\"number\">4</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">4</span>; ++i) &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> ipUnitIntValue;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      ipUnitIntValue = Integer.parseInt(ipUnits[i]);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (NumberFormatException e) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ipUnitIntValue &lt; <span class=\"number\">0</span> || ipUnitIntValue &gt; <span class=\"number\">255</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (i == <span class=\"number\">0</span> &amp;&amp; ipUnitIntValue == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 第三种实现方式: 不使用任何工具类</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">isValidIpAddressV3</span><span class=\"params\">(String ipAddress)</span> &#123;</span><br><span class=\"line\">  <span class=\"type\">char</span>[] ipChars = ipAddress.toCharArray();</span><br><span class=\"line\">  <span class=\"type\">int</span> <span class=\"variable\">length</span> <span class=\"operator\">=</span> ipChars.length;</span><br><span class=\"line\">  <span class=\"type\">int</span> <span class=\"variable\">ipUnitIntValue</span> <span class=\"operator\">=</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"type\">boolean</span> <span class=\"variable\">isFirstUnit</span> <span class=\"operator\">=</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">  <span class=\"type\">int</span> <span class=\"variable\">unitsCount</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; length; ++i) &#123;</span><br><span class=\"line\">    <span class=\"type\">char</span> <span class=\"variable\">c</span> <span class=\"operator\">=</span> ipChars[i];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (c == <span class=\"string\">&#x27;.&#x27;</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (ipUnitIntValue &lt; <span class=\"number\">0</span> || ipUnitIntValue &gt; <span class=\"number\">255</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (isFirstUnit &amp;&amp; ipUnitIntValue == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (isFirstUnit) isFirstUnit = <span class=\"literal\">false</span>;</span><br><span class=\"line\">      ipUnitIntValue = -<span class=\"number\">1</span>;</span><br><span class=\"line\">      unitsCount++;</span><br><span class=\"line\">      <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (c &lt; <span class=\"string\">&#x27;0&#x27;</span> || c &gt; <span class=\"string\">&#x27;9&#x27;</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ipUnitIntValue == -<span class=\"number\">1</span>) ipUnitIntValue = <span class=\"number\">0</span>;</span><br><span class=\"line\">    ipUnitIntValue = ipUnitIntValue * <span class=\"number\">10</span> + (c - <span class=\"string\">&#x27;0&#x27;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (ipUnitIntValue &lt; <span class=\"number\">0</span> || ipUnitIntValue &gt; <span class=\"number\">255</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (unitsCount != <span class=\"number\">3</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<ol>\n<li>第一种实现方式利用的是正则表达式，只用三行代码就把这个问题搞定了。它的代码行数最少，那是不是就最符合 KISS 原则呢？答案是否定的。虽然代码行数最少，看似最简单，实际上却很复杂。这正是因为它使用了正则表达式。</li>\n<li>一方面，正则表达式本身是比较复杂的，写出完全没有 bug 的正则表达本身就比较有挑战；另一方面，并不是每个程序员都精通正则表达式。对于不怎么懂正则表达式的同事来说，看懂并且维护这段正则表达式是比较困难的。这种实现方式会导致代码的可读性和可维护性变差，所以，从 KISS 原则的设计初衷上来讲，这种实现方式并不符合 KISS 原则。</li>\n<li>讲完了第一种实现方式，我们再来看下其他两种实现方式。</li>\n<li>第二种实现方式使用了 StringUtils 类、Integer 类提供的一些现成的工具函数，来处理 IP 地址字符串。第三种实现方式，不使用任何工具函数，而是通过逐一处理 IP 地址中的字符，来判断是否合法。从代码行数上来说，这两种方式差不多。但是，第三种要比第二种更加有难度，更容易写出 bug。从可读性上来说，第二种实现方式的代码逻辑更清晰、更好理解。所以，在这两种实现方式中，第二种实现方式更加“简单”，更加符合 KISS 原则。</li>\n<li>不过，你可能会说，第三种实现方式虽然实现起来稍微有点复杂，但性能要比第二种实现方式高一些啊。从性能的角度来说，选择第三种实现方式是不是更好些呢？在回答这个问题之前，我先解释一下，为什么说第三种实现方式性能会更高一些。一般来说，工具类的功能都比较通用和全面，所以，在代码实现上，需要考虑和处理更多的细节，执行效率就会有所影响。而第三种实现方式，完全是自己操作底层字符，只针对 IP 地址这一种格式的数据输入来做处理，没有太多多余的函数调用和其他不必要的处理逻辑，所以，在执行效率上，这种类似定制化的处理代码方式肯定比通用的工具类要高些。</li>\n<li>不过，尽管第三种实现方式性能更高些，但我还是更倾向于选择第二种实现方法。那是因为第三种实现方式实际上是一种过度优化。除非 isValidIpAddress() 函数是影响系统性能的瓶颈代码，否则，这样优化的投入产出比并不高，增加了代码实现的难度、牺牲了代码的可读性，性能上的提升却并不明显。</li>\n</ol>\n<h3 id=\"代码逻辑复杂就违背-KISS-原则吗？\"><a href=\"#代码逻辑复杂就违背-KISS-原则吗？\" class=\"headerlink\" title=\"代码逻辑复杂就违背 KISS 原则吗？\"></a>代码逻辑复杂就违背 KISS 原则吗？</h3><p>刚刚我们提到，并不是代码行数越少就越“简单”，还要考虑逻辑复杂度、实现难度、代码的可读性等。那如果一段代码的逻辑复杂、实现难度大、可读性也不太好，是不是就一定违背 KISS 原则呢？在回答这个问题之前，我们先来看下面这段代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// KMP algorithm: a, b分别是主串和模式串；n, m分别是主串和模式串的长度。</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">kmp</span><span class=\"params\">(<span class=\"type\">char</span>[] a, <span class=\"type\">int</span> n, <span class=\"type\">char</span>[] b, <span class=\"type\">int</span> m)</span> &#123;</span><br><span class=\"line\">  <span class=\"type\">int</span>[] next = getNexts(b, m);</span><br><span class=\"line\">  <span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; n; ++i) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (j &gt; <span class=\"number\">0</span> &amp;&amp; a[i] != b[j]) &#123; <span class=\"comment\">// 一直找到a[i]和b[j]</span></span><br><span class=\"line\">      j = next[j - <span class=\"number\">1</span>] + <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (a[i] == b[j]) &#123;</span><br><span class=\"line\">      ++j;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (j == m) &#123; <span class=\"comment\">// 找到匹配模式串的了</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> i - m + <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// b表示模式串，m表示模式串的长度</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">int</span>[] getNexts(<span class=\"type\">char</span>[] b, <span class=\"type\">int</span> m) &#123;</span><br><span class=\"line\">  <span class=\"type\">int</span>[] next = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[m];</span><br><span class=\"line\">  next[<span class=\"number\">0</span>] = -<span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"type\">int</span> <span class=\"variable\">k</span> <span class=\"operator\">=</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; i &lt; m; ++i) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (k != -<span class=\"number\">1</span> &amp;&amp; b[k + <span class=\"number\">1</span>] != b[i]) &#123;</span><br><span class=\"line\">      k = next[k];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (b[k + <span class=\"number\">1</span>] == b[i]) &#123;</span><br><span class=\"line\">      ++k;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    next[i] = k;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> next;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<ol>\n<li><p>这段代码是KMP 字符串匹配算法的代码实现。这段代码完全符合我们刚提到的逻辑复杂、实现难度大、可读性差的特点，但它并不违反 KISS 原则。为什么这么说呢？</p>\n</li>\n<li><p>KMP 算法以快速高效著称。当我们需要处理长文本字符串匹配问题（几百 MB 大小文本内容的匹配），或者字符串匹配是某个产品的核心功能（比如 Vim、Word 等文本编辑器），又或者字符串匹配算法是系统性能瓶颈的时候，我们就应该选择尽可能高效的 KMP 算法。而 KMP 算法本身具有逻辑复杂、实现难度大、可读性差的特点。本身就复杂的问题，用复杂的方法解决，并不违背 KISS 原则。</p>\n</li>\n<li><p>不过，平时的项目开发中涉及的字符串匹配问题，大部分都是针对比较小的文本。在这种情况下，直接调用编程语言提供的现成的字符串匹配函数就足够了。如果非得用 KMP 算法、BM 算法来实现字符串匹配，那就真的违背 KISS 原则了。也就是说，同样的代码，在某个业务场景下满足 KISS 原则，换一个应用场景可能就不满足了。</p>\n</li>\n</ol>\n<h3 id=\"如何写出满足-KISS-原则的代码？\"><a href=\"#如何写出满足-KISS-原则的代码？\" class=\"headerlink\" title=\"如何写出满足 KISS 原则的代码？\"></a>如何写出满足 KISS 原则的代码？</h3><p>实际上，我们前面已经讲到了一些方法。这里我稍微总结一下。</p>\n<ul>\n<li>不要使用同事可能不懂的技术来实现代码。比如前面例子中的正则表达式，还有一些编程语言中过于高级的语法等。</li>\n<li>不要重复造轮子，要善于使用已经有的工具类库。经验证明，自己去实现这些类库，出 bug 的概率会更高，维护的成本也比较高。</li>\n<li>不要过度优化。不要过度使用一些奇技淫巧（比如，位运算代替算术运算、复杂的条件语句代替 if-else、使用一些过于底层的函数等）来优化代码，牺牲代码的可读性。</li>\n<li>实际上，代码是否足够简单是一个挺主观的评判。同样的代码，有的人觉得简单，有的人觉得不够简单。而往往自己编写的代码，自己都会觉得够简单。所以，评判代码是否简单，还有一个很有效的间接方法，那就是 code review。如果在 code review 的时候，同事对你的代码有很多疑问，那就说明你的代码有可能不够“简单”，需要优化啦。</li>\n</ul>\n<h3 id=\"YAGNI-跟-KISS-说的是一回事吗？\"><a href=\"#YAGNI-跟-KISS-说的是一回事吗？\" class=\"headerlink\" title=\"YAGNI 跟 KISS 说的是一回事吗？\"></a>YAGNI 跟 KISS 说的是一回事吗？</h3><ol>\n<li>YAGNI 原则的英文全称是：You Ain’t Gonna Need It。直译就是：你不会需要它。这条原则也算是万金油了。当用在软件开发中的时候，它的意思是：不要去设计当前用不到的功能；不要去编写当前用不到的代码。实际上，这条原则的核心思想就是：不要做过度设计。</li>\n<li>比如，我们的系统暂时只用 Redis 存储配置信息，以后可能会用到 ZooKeeper。根据 YAGNI 原则，在未用到 ZooKeeper 之前，我们没必要提前编写这部分代码。当然，这并不是说我们就不需要考虑代码的扩展性。我们还是要预留好扩展点，等到需要的时候，再去实现 ZooKeeper 存储配置信息这部分代码。</li>\n<li>再比如，我们不要在项目中提前引入不需要依赖的开发包。对于 Java 程序员来说，我们经常使用 Maven 或者 Gradle 来管理依赖的类库（library）。我发现，有些同事为了避免开发中 library 包缺失而频繁地修改 Maven 或者 Gradle 配置文件，提前往项目里引入大量常用的 library 包。实际上，这样的做法也是违背 YAGNI 原则的。</li>\n<li>从刚刚的分析我们可以看出，YAGNI 原则跟 KISS 原则并非一回事儿。KISS 原则讲的是“如何做”的问题（尽量保持简单），而 YAGNI 原则说的是“要不要做”的问题（当前不需要的就不要做）。</li>\n</ol>\n<h2 id=\"DRY-原则\"><a href=\"#DRY-原则\" class=\"headerlink\" title=\"DRY 原则\"></a>DRY 原则</h2><p>Don’t Repeat Yourself。中文直译为：不要重复自己。将它应用在编程中，可以理解为：不要写重复的代码。DRY 原则的定义非常简单，我就不再过度解读。今天，我们主要讲三种典型的代码重复情况，它们分别是：实现逻辑重复、功能语义重复和代码执行重复。这三种代码重复，有的看似违反 DRY，实际上并不违反；有的看似不违反，实际上却违反了。</p>\n<h3 id=\"实现逻辑重复\"><a href=\"#实现逻辑重复\" class=\"headerlink\" title=\"实现逻辑重复\"></a>实现逻辑重复</h3><p>我们先来看下面这样一段代码是否违反了 DRY 原则。如果违反了，你觉得应该如何重构，才能让它满足 DRY 原则？如果没有违反，那又是为什么呢？</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">UserAuthenticator</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">authenticate</span><span class=\"params\">(String username, String password)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!isValidUsername(username)) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// ...throw InvalidUsernameException...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!isValidPassword(password)) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// ...throw InvalidPasswordException...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//...省略其他代码...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"type\">boolean</span> <span class=\"title function_\">isValidUsername</span><span class=\"params\">(String username)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// check not null, not empty</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (StringUtils.isBlank(username)) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// check length: 4~64</span></span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">length</span> <span class=\"operator\">=</span> username.length();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (length &lt; <span class=\"number\">4</span> || length &gt; <span class=\"number\">64</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// contains only lowcase characters</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!StringUtils.isAllLowerCase(username)) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// contains only a~z,0~9,dot</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; length; ++i) &#123;</span><br><span class=\"line\">      <span class=\"type\">char</span> <span class=\"variable\">c</span> <span class=\"operator\">=</span> username.charAt(i);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!(c &gt;= <span class=\"string\">&#x27;a&#x27;</span> &amp;&amp; c &lt;= <span class=\"string\">&#x27;z&#x27;</span>) || (c &gt;= <span class=\"string\">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class=\"string\">&#x27;9&#x27;</span>) || c == <span class=\"string\">&#x27;.&#x27;</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"type\">boolean</span> <span class=\"title function_\">isValidPassword</span><span class=\"params\">(String password)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// check not null, not empty</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (StringUtils.isBlank(password)) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// check length: 4~64</span></span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">length</span> <span class=\"operator\">=</span> password.length();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (length &lt; <span class=\"number\">4</span> || length &gt; <span class=\"number\">64</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// contains only lowcase characters</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!StringUtils.isAllLowerCase(password)) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// contains only a~z,0~9,dot</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; length; ++i) &#123;</span><br><span class=\"line\">      <span class=\"type\">char</span> <span class=\"variable\">c</span> <span class=\"operator\">=</span> password.charAt(i);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!(c &gt;= <span class=\"string\">&#x27;a&#x27;</span> &amp;&amp; c &lt;= <span class=\"string\">&#x27;z&#x27;</span>) || (c &gt;= <span class=\"string\">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class=\"string\">&#x27;9&#x27;</span>) || c == <span class=\"string\">&#x27;.&#x27;</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>代码很简单，我就不做过多解释了。在代码中，有两处非常明显的重复的代码片段：isValidUserName() 函数和 isValidPassword() 函数。重复的代码被敲了两遍，或者简单 copy-paste 了一下，看起来明显违反 DRY 原则。为了移除重复的代码，我们对上面的代码做下重构，将 isValidUserName() 函数和 isValidPassword() 函数，合并为一个更通用的函数 isValidUserNameOrPassword()。重构后的代码如下所示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">UserAuthenticatorV2</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">authenticate</span><span class=\"params\">(String userName, String password)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!isValidUsernameOrPassword(userName)) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// ...throw InvalidUsernameException...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!isValidUsernameOrPassword(password)) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// ...throw InvalidPasswordException...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"type\">boolean</span> <span class=\"title function_\">isValidUsernameOrPassword</span><span class=\"params\">(String usernameOrPassword)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//省略实现逻辑</span></span><br><span class=\"line\">    <span class=\"comment\">//跟原来的isValidUsername()或isValidPassword()的实现逻辑一样...</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>经过重构之后，代码行数减少了，也没有重复的代码了，是不是更好了呢？答案是否定的，这可能跟你预期的不一样，我来解释一下为什么。</li>\n<li>单从名字上看，我们就能发现，合并之后的 isValidUserNameOrPassword() 函数，负责两件事情：验证用户名和验证密码，违反了“单一职责原则”和“接口隔离原则”。实际上，即便将两个函数合并成 isValidUserNameOrPassword()，代码仍然存在问题。</li>\n<li>因为 isValidUserName() 和 isValidPassword() 两个函数，虽然从代码实现逻辑上看起来是重复的，但是从语义上并不重复。所谓“语义不重复”指的是：从功能上来看，这两个函数干的是完全不重复的两件事情，一个是校验用户名，另一个是校验密码。尽管在目前的设计中，两个校验逻辑是完全一样的，但如果按照第二种写法，将两个函数的合并，那就会存在潜在的问题。在未来的某一天，如果我们修改了密码的校验逻辑，比如，允许密码包含大写字符，允许密码的长度为 8 到 64 个字符，那这个时候，isValidUserName() 和 isValidPassword() 的实现逻辑就会不相同。我们就要把合并后的函数，重新拆成合并前的那两个函数。</li>\n<li>尽管代码的实现逻辑是相同的，但语义不同，我们判定它并不违反 DRY 原则。对于包含重复代码的问题，我们可以通过抽象成更细粒度函数的方式来解决。比如将校验只包含 a<del>z、0</del>9、dot 的逻辑封装成 boolean onlyContains(String str, String charlist); 函数。</li>\n</ol>\n<h3 id=\"功能语义重复\"><a href=\"#功能语义重复\" class=\"headerlink\" title=\"功能语义重复\"></a>功能语义重复</h3><ol>\n<li>现在我们再来看另外一个例子。在同一个项目代码中有下面两个函数：isValidIp() 和 checkIfIpValid()。尽管两个函数的命名不同，实现逻辑不同，但功能是相同的，都是用来判定 IP 地址是否合法的。</li>\n<li>之所以在同一个项目中会有两个功能相同的函数，那是因为这两个函数是由两个不同的同事开发的，其中一个同事在不知道已经有了 isValidIp() 的情况下，自己又定义并实现了同样用来校验 IP 地址是否合法的 checkIfIpValid() 函数。那在同一项目代码中，存在如下两个函数，是否违反 DRY 原则呢？</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">isValidIp</span><span class=\"params\">(String ipAddress)</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (StringUtils.isBlank(ipAddress)) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  <span class=\"type\">String</span> <span class=\"variable\">regex</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;^(1\\\\d&#123;2&#125;|2[0-4]\\\\d|25[0-5]|[1-9]\\\\d|[1-9])\\\\.&quot;</span></span><br><span class=\"line\">          + <span class=\"string\">&quot;(1\\\\d&#123;2&#125;|2[0-4]\\\\d|25[0-5]|[1-9]\\\\d|\\\\d)\\\\.&quot;</span></span><br><span class=\"line\">          + <span class=\"string\">&quot;(1\\\\d&#123;2&#125;|2[0-4]\\\\d|25[0-5]|[1-9]\\\\d|\\\\d)\\\\.&quot;</span></span><br><span class=\"line\">          + <span class=\"string\">&quot;(1\\\\d&#123;2&#125;|2[0-4]\\\\d|25[0-5]|[1-9]\\\\d|\\\\d)$&quot;</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> ipAddress.matches(regex);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">checkIfIpValid</span><span class=\"params\">(String ipAddress)</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (StringUtils.isBlank(ipAddress)) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  String[] ipUnits = StringUtils.split(ipAddress, <span class=\"string\">&#x27;.&#x27;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (ipUnits.length != <span class=\"number\">4</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">4</span>; ++i) &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> ipUnitIntValue;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      ipUnitIntValue = Integer.parseInt(ipUnits[i]);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (NumberFormatException e) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ipUnitIntValue &lt; <span class=\"number\">0</span> || ipUnitIntValue &gt; <span class=\"number\">255</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (i == <span class=\"number\">0</span> &amp;&amp; ipUnitIntValue == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>这个例子跟上个例子正好相反。上一个例子是代码实现逻辑重复，但语义不重复，我们并不认为它违反了 DRY 原则。而在这个例子中，尽管两段代码的实现逻辑不重复，但语义重复，也就是功能重复，我们认为它违反了 DRY 原则。我们应该在项目中，统一一种实现思路，所有用到判断 IP 地址是否合法的地方，都统一调用同一个函数。</li>\n<li>假设我们不统一实现思路，那有些地方调用了 isValidIp() 函数，有些地方又调用了 checkIfIpValid() 函数，这就会导致代码看起来很奇怪，相当于给代码“埋坑”，给不熟悉这部分代码的同事增加了阅读的难度。同事有可能研究了半天，觉得功能是一样的，但又有点疑惑，觉得是不是有更高深的考量，才定义了两个功能类似的函数，最终发现居然是代码设计的问题。</li>\n<li>除此之外，如果哪天项目中 IP 地址是否合法的判定规则改变了，比如：255.255.255.255 不再被判定为合法的了，相应地，我们对 isValidIp() 的实现逻辑做了相应的修改，但却忘记了修改 checkIfIpValid() 函数。又或者，我们压根就不知道还存在一个功能相同的 checkIfIpValid() 函数，这样就会导致有些代码仍然使用老的 IP 地址判断逻辑，导致出现一些莫名其妙的 bug。</li>\n</ol>\n<h3 id=\"代码执行重复\"><a href=\"#代码执行重复\" class=\"headerlink\" title=\"代码执行重复\"></a>代码执行重复</h3><p>前两个例子一个是实现逻辑重复，一个是语义重复，我们再来看第三个例子。其中，UserService 中 login() 函数用来校验用户登录是否成功。如果失败，就返回异常；如果成功，就返回用户信息。具体代码如下所示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">UserService</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> UserRepo userRepo;<span class=\"comment\">//通过依赖注入或者IOC框架注入</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> User <span class=\"title function_\">login</span><span class=\"params\">(String email, String password)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">boolean</span> <span class=\"variable\">existed</span> <span class=\"operator\">=</span> userRepo.checkIfUserExisted(email, password);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!existed) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// ... throw AuthenticationFailureException...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">User</span> <span class=\"variable\">user</span> <span class=\"operator\">=</span> userRepo.getUserByEmail(email);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> user;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">UserRepo</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">checkIfUserExisted</span><span class=\"params\">(String email, String password)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!EmailValidation.validate(email)) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// ... throw InvalidEmailException...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!PasswordValidation.validate(password)) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// ... throw InvalidPasswordException...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//...query db to check if email&amp;password exists...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> User <span class=\"title function_\">getUserByEmail</span><span class=\"params\">(String email)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!EmailValidation.validate(email)) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// ... throw InvalidEmailException...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//...query db to get user by email...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>上面这段代码，既没有逻辑重复，也没有语义重复，但仍然违反了 DRY 原则。这是因为代码中存在“执行重复”。我们一块儿来看下，到底哪些代码被重复执行了？</li>\n<li>重复执行最明显的一个地方，就是在 login() 函数中，email 的校验逻辑被执行了两次。一次是在调用 checkIfUserExisted() 函数的时候，另一次是调用 getUserByEmail() 函数的时候。这个问题解决起来比较简单，我们只需要将校验逻辑从 UserRepo 中移除，统一放到 UserService 中就可以了。</li>\n<li>除此之外，代码中还有一处比较隐蔽的执行重复，不知道你发现了没有？实际上，login() 函数并不需要调用 checkIfUserExisted() 函数，只需要调用一次 getUserByEmail() 函数，从数据库中获取到用户的 email、password 等信息，然后跟用户输入的 email、password 信息做对比，依次判断是否登录成功。</li>\n<li>实际上，这样的优化是很有必要的。因为 checkIfUserExisted() 函数和 getUserByEmail() 函数都需要查询数据库，而数据库这类的 I&#x2F;O 操作是比较耗时的。我们在写代码的时候，应当尽量减少这类 I&#x2F;O 操作。</li>\n<li>按照刚刚的修改思路，我们把代码重构一下，移除“重复执行”的代码，只校验一次 email 和 password，并且只查询一次数据库。重构之后的代码如下所示：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">UserService</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> UserRepo userRepo;<span class=\"comment\">//通过依赖注入或者IOC框架注入</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> User <span class=\"title function_\">login</span><span class=\"params\">(String email, String password)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!EmailValidation.validate(email)) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// ... throw InvalidEmailException...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!PasswordValidation.validate(password)) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// ... throw InvalidPasswordException...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">User</span> <span class=\"variable\">user</span> <span class=\"operator\">=</span> userRepo.getUserByEmail(email);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (user == <span class=\"literal\">null</span> || !password.equals(user.getPassword()) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// ... throw AuthenticationFailureException...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> user;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">UserRepo</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">checkIfUserExisted</span><span class=\"params\">(String email, String password)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//...query db to check if email&amp;password exists</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> User <span class=\"title function_\">getUserByEmail</span><span class=\"params\">(String email)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//...query db to get user by email...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"代码复用性（Code-Reusability）\"><a href=\"#代码复用性（Code-Reusability）\" class=\"headerlink\" title=\"代码复用性（Code Reusability）\"></a>代码复用性（Code Reusability）</h3><ol>\n<li><p>我们首先来区分三个概念：代码复用性（Code Reusability）、代码复用（Code Resue）和 DRY 原则。代码复用表示一种行为：我们在开发新功能的时候，尽量复用已经存在的代码。代码的可复用性表示一段代码可被复用的特性或能力：我们在编写代码的时候，让代码尽量可复用。DRY 原则是一条原则：不要写重复的代码。从定义描述上，它们好像有点类似，但深究起来，三者的区别还是蛮大的。</p>\n</li>\n<li><p>首先，“不重复”并不代表“可复用”。在一个项目代码中，可能不存在任何重复的代码，但也并不表示里面有可复用的代码，不重复和可复用完全是两个概念。所以，从这个角度来说，DRY 原则跟代码的可复用性讲的是两回事。</p>\n</li>\n<li><p>其次，“复用”和“可复用性”关注角度不同。代码“可复用性”是从代码开发者的角度来讲的，“复用”是从代码使用者的角度来讲的。比如，A 同事编写了一个 UrlUtils 类，代码的“可复用性”很好。B 同事在开发新功能的时候，直接“复用”A 同事编写的 UrlUtils 类。尽管复用、可复用性、DRY 原则这三者从理解上有所区别，但实际上要达到的目的都是类似的，都是为了减少代码量，提高代码的可读性、可维护性。除此之外，复用已经经过测试的老代码，bug 会比从零重新开发要少。</p>\n</li>\n<li><p>“复用”这个概念不仅可以指导细粒度的模块、类、函数的设计开发，实际上，一些框架、类库、组件等的产生也都是为了达到复用的目的。比如，Spring 框架、Google Guava 类库、UI 组件等等。</p>\n</li>\n</ol>\n<h3 id=\"怎么提高代码复用性？\"><a href=\"#怎么提高代码复用性？\" class=\"headerlink\" title=\"怎么提高代码复用性？\"></a>怎么提高代码复用性？</h3><p>实际上，我们前面已经讲到过很多提高代码可复用性的手段，今天算是集中总结一下，我总结了 7 条，具体如下。</p>\n<blockquote>\n<p>减少代码耦合</p>\n</blockquote>\n<p>对于高度耦合的代码，当我们希望复用其中的一个功能，想把这个功能的代码抽取出来成为一个独立的模块、类或者函数的时候，往往会发现牵一发而动全身。移动一点代码，就要牵连到很多其他相关的代码。所以，高度耦合的代码会影响到代码的复用性，我们要尽量减少代码耦合。</p>\n<blockquote>\n<p>满足单一职责原则</p>\n</blockquote>\n<p>我们前面讲过，如果职责不够单一，模块、类设计得大而全，那依赖它的代码或者它依赖的代码就会比较多，进而增加了代码的耦合。根据上一点，也就会影响到代码的复用性。相反，越细粒度的代码，代码的通用性会越好，越容易被复用。</p>\n<blockquote>\n<p>模块化</p>\n</blockquote>\n<p>这里的“模块”，不单单指一组类构成的模块，还可以理解为单个类、函数。我们要善于将功能独立的代码，封装成模块。独立的模块就像一块一块的积木，更加容易复用，可以直接拿来搭建更加复杂的系统。</p>\n<blockquote>\n<p>业务与非业务逻辑分离</p>\n</blockquote>\n<p>越是跟业务无关的代码越是容易复用，越是针对特定业务的代码越难复用。所以，为了复用跟业务无关的代码，我们将业务和非业务逻辑代码分离，抽取成一些通用的框架、类库、组件等。</p>\n<blockquote>\n<p>通用代码下沉</p>\n</blockquote>\n<p>从分层的角度来看，越底层的代码越通用、会被越多的模块调用，越应该设计得足够可复用。一般情况下，在代码分层之后，为了避免交叉调用导致调用关系混乱，我们只允许上层代码调用下层代码及同层代码之间的调用，杜绝下层代码调用上层代码。所以，通用的代码我们尽量下沉到更下层。</p>\n<blockquote>\n<p>继承、多态、抽象、封装</p>\n</blockquote>\n<p>在讲面向对象特性的时候，利用继承，可以将公共的代码抽取到父类，子类复用父类的属性和方法。利用多态，我们可以动态地替换一段代码的部分逻辑，让这段代码可复用。除此之外，抽象和封装，从更加广义的层面、而非狭义的面向对象特性的层面来理解的话，越抽象、越不依赖具体的实现，越容易复用。代码封装成模块，隐藏可变的细节、暴露不变的接口，就越容易复用。</p>\n<blockquote>\n<p>应用模板等设计模式</p>\n</blockquote>\n<p>一些设计模式，也能提高代码的复用性。比如，模板模式利用了多态来实现，可以灵活地替换其中的部分代码，整个流程模板代码可复用。关于应用设计模式提高代码复用性这一部分，我们留在后面慢慢来讲解。除了刚刚我们讲到的几点，还有一些跟编程语言相关的特性，也能提高代码的复用性，比如泛型编程等。实际上，除了上面讲到的这些方法之外，复用意识也非常重要。在写代码的时候，我们要多去思考一下，这</p>\n<h2 id=\"迪米特法则\"><a href=\"#迪米特法则\" class=\"headerlink\" title=\"迪米特法则\"></a>迪米特法则</h2><p>我们讲最后一个设计原则：迪米特法则。尽管它不像 SOLID、KISS、DRY 原则那样，人尽皆知，但它却非常实用。利用这个原则，能够帮我们实现代码的“高内聚、松耦合”。今天，我们就围绕下面几个问题，并结合两个代码实战案例，来深入地学习这个法则。</p>\n<ul>\n<li>什么是“高内聚、松耦合”？</li>\n<li>如何利用迪米特法则来实现“高内聚、松耦合”？</li>\n<li>有哪些代码设计是明显违背迪米特法则的？对此又该如何重构？</li>\n</ul>\n<h3 id=\"何为“高内聚、松耦合”？\"><a href=\"#何为“高内聚、松耦合”？\" class=\"headerlink\" title=\"何为“高内聚、松耦合”？\"></a>何为“高内聚、松耦合”？</h3><ol>\n<li>“高内聚、松耦合”是一个非常重要的设计思想，能够有效地提高代码的可读性和可维护性，缩小功能改动导致的代码改动范围。</li>\n<li>实际上，在前面的章节中，我们已经多次提到过这个设计思想。很多设计原则都以实现代码的“高内聚、松耦合”为目的，比如单一职责原则、基于接口而非实现编程等。实际上，“高内聚、松耦合”是一个比较通用的设计思想，可以用来指导不同粒度代码的设计与开发，比如系统、模块、类，甚至是函数，也可以应用到不同的开发场景中，比如微服务、框架、组件、类库等。为了方便我讲解，接下来我以“类”作为这个设计思想的应用对象来展开讲解，其他应用场景你可以自行类比。</li>\n<li>在这个设计思想中，“高内聚”用来指导类本身的设计，“松耦合”用来指导类与类之间依赖关系的设计。不过，这两者并非完全独立不相干。高内聚有助于松耦合，松耦合又需要高内聚的支持。</li>\n</ol>\n<blockquote>\n<p>那到底什么是“高内聚”呢？</p>\n</blockquote>\n<p>所谓高内聚，就是指相近的功能应该放到同一个类中，不相近的功能不要放到同一个类中。相近的功能往往会被同时修改，放到同一个类中，修改会比较集中，代码容易维护。实际上，我们前面讲过的单一职责原则是实现代码高内聚非常有效的设计原则。</p>\n<blockquote>\n<p>我们再来看一下，什么是“松耦合”？</p>\n</blockquote>\n<p>所谓松耦合是说，在代码中，类与类之间的依赖关系简单清晰。即使两个类有依赖关系，一个类的代码改动不会或者很少导致依赖类的代码改动。实际上，我们前面讲的依赖注入、接口隔离、基于接口而非实现编程，以及今天讲的迪米特法则，都是为了实现代码的松耦合</p>\n<blockquote>\n<p>最后，我们来看一下，“内聚”和“耦合”之间的关系</p>\n</blockquote>\n<p>前面也提到，“高内聚”有助于“松耦合”，同理，“低内聚”也会导致“紧耦合”。关于这一点，我画了一张对比图来解释。图中左边部分的代码结构是“高内聚、松耦合”；右边部分正好相反，是“低内聚、紧耦合”。</p>\n<img src=\"https://npm.elemecdn.com/youthlql@1.0.0/design_patterns/design_principles/0001.png\" />\n\n\n\n\n\n<ol>\n<li>图中左边部分的代码设计中，类的粒度比较小，每个类的职责都比较单一。相近的功能都放到了一个类中，不相近的功能被分割到了多个类中。这样类更加独立，代码的内聚性更好。因为职责单一，所以每个类被依赖的类就会比较少，代码低耦合。一个类的修改，只会影响到一个依赖类的代码改动。我们只需要测试这一个依赖类是否还能正常工作就行了。</li>\n<li>图中右边部分的代码设计中，类粒度比较大，低内聚，功能大而全，不相近的功能放到了一个类中。这就导致很多其他类都依赖这个类。当我们修改这个类的某一个功能代码的时候，会影响依赖它的多个类。我们需要测试这三个依赖类，是否还能正常工作。这也就是所谓的“牵一发而动全身”。</li>\n<li>除此之外，从图中我们也可以看出，高内聚、低耦合的代码结构更加简单、清晰，相应地，在可维护性和可读性上确实要好很多。</li>\n</ol>\n<h3 id=\"“迪米特法则”理论描述\"><a href=\"#“迪米特法则”理论描述\" class=\"headerlink\" title=\"“迪米特法则”理论描述\"></a>“迪米特法则”理论描述</h3><ol>\n<li><p>迪米特法则的英文翻译是：Law of Demeter，缩写是 LOD。单从这个名字上来看，我们完全猜不出这个原则讲的是什么。不过，它还有另外一个更加达意的名字，叫作最小知识原则，英文翻译为：The Least Knowledge Principle。</p>\n</li>\n<li><p>关于这个设计原则，我们先来看一下它最原汁原味的英文定义：</p>\n<blockquote>\n<p>Each unit should have only limited knowledge about other units: only units “closely” related to the current unit. Or: Each unit should only talk to its friends; Don’t talk to strangers.</p>\n</blockquote>\n<p>我们把它直译成中文，就是下面这个样子：</p>\n<blockquote>\n<p>每个模块（unit）只应该了解那些与它关系密切的模块（units: only units “closely” related to the current unit）的有限知识（knowledge）。或者说，每个模块只和自己的朋友“说话”（talk），不和陌生人“说话”（talk）。</p>\n</blockquote>\n<p>我们之前讲过，大部分设计原则和思想都非常抽象，有各种各样的解读，要想灵活地应用到实际的开发中，需要有实战经验的积累。迪米特法则也不例外。所以，我结合我自己的理解和经验，对刚刚的定义重新描述一下。注意，为了统一讲解，我把定义描述中的“模块”替换成了“类”。</p>\n<blockquote>\n<p>不该有直接依赖关系的类之间，不要有依赖；有依赖关系的类之间，尽量只依赖必要的接口（也就是定义中的“有限知识”）。从上面的描述中，我们可以看出，迪米特法则包含前后两部分，这两部分讲的是两件事情，我用两个实战案例分别来解读一下。</p>\n</blockquote>\n</li>\n</ol>\n<h3 id=\"理论解读与代码实战一\"><a href=\"#理论解读与代码实战一\" class=\"headerlink\" title=\"理论解读与代码实战一\"></a>理论解读与代码实战一</h3><ol>\n<li>我们先来看这条原则中的前半部分，<strong>“不该有直接依赖关系的类之间，不要有依赖”</strong>。我举个例子解释一下。</li>\n<li>这个例子实现了简化版的搜索引擎爬取网页的功能。代码中包含三个主要的类。其中，NetworkTransporter 类负责底层网络通信，根据请求获取数据；HtmlDownloader 类用来通过 URL 获取网页；Document 表示网页文档，后续的网页内容抽取、分词、索引都是以此为处理对象。具体的代码实现如下所示：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">NetworkTransporter</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 省略属性和其他方法...</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Byte[] send(HtmlRequest htmlRequest) &#123;</span><br><span class=\"line\">      <span class=\"comment\">//...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">HtmlDownloader</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> NetworkTransporter transporter;<span class=\"comment\">//通过构造函数或IOC注入</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">public</span> Html <span class=\"title function_\">downloadHtml</span><span class=\"params\">(String url)</span> &#123;</span><br><span class=\"line\">    Byte[] rawHtml = transporter.send(<span class=\"keyword\">new</span> <span class=\"title class_\">HtmlRequest</span>(url));</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Html</span>(rawHtml);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Document</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> Html html;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> String url;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"title function_\">Document</span><span class=\"params\">(String url)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.url = url;</span><br><span class=\"line\">    <span class=\"type\">HtmlDownloader</span> <span class=\"variable\">downloader</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">HtmlDownloader</span>();</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.html = downloader.downloadHtml(url);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>这段代码虽然“能用”，能实现我们想要的功能，但是它不够“好用”，有比较多的设计缺陷。你可以先试着思考一下，看看都有哪些缺陷，然后再来看我下面的讲解。</li>\n<li>首先，我们来看 NetworkTransporter 类。作为一个底层网络通信类，我们希望它的功能尽可能通用，而不只是服务于下载 HTML，所以，我们不应该直接依赖太具体的发送对象 HtmlRequest。从这一点上讲，NetworkTransporter 类的设计违背迪米特法则，依赖了不该有直接依赖关系的 HtmlRequest 类。</li>\n<li>我们应该如何进行重构，让 NetworkTransporter 类满足迪米特法则呢？我这里有个形象的比喻。假如你现在要去商店买东西，你肯定不会直接把钱包给收银员，让收银员自己从里面拿钱，而是你从钱包里把钱拿出来交给收银员。这里的 HtmlRequest 对象就相当于钱包，HtmlRequest 里的 address 和 content 对象就相当于钱。我们应该把 address 和 content 交给 NetworkTransporter，而非是直接把 HtmlRequest 交给 NetworkTransporter。根据这个思路，NetworkTransporter 重构之后的代码如下所示：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">NetworkTransporter</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 省略属性和其他方法...</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Byte[] send(String address, Byte[] data) &#123;</span><br><span class=\"line\">      <span class=\"comment\">//...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>我们再来看 HtmlDownloader 类。这个类的设计没有问题。不过，我们修改了 NetworkTransporter 的 send() 函数的定义，而这个类用到了 send() 函数，所以我们需要对它做相应的修改，修改后的代码如下所示</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">HtmlDownloader</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> NetworkTransporter transporter;<span class=\"comment\">//通过构造函数或IOC注入</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">// HtmlDownloader这里也要有相应的修改</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> Html <span class=\"title function_\">downloadHtml</span><span class=\"params\">(String url)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">HtmlRequest</span> <span class=\"variable\">htmlRequest</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">HtmlRequest</span>(url);</span><br><span class=\"line\">    Byte[] rawHtml = transporter.send(</span><br><span class=\"line\">      htmlRequest.getAddress(), htmlRequest.getContent().getBytes());</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Html</span>(rawHtml);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>最后，我们来看下 Document 类。这个类的问题比较多，主要有三点。第一，构造函数中的 downloader.downloadHtml() 逻辑复杂，耗时长，不应该放到构造函数中，会影响代码的可测试性。代码的可测试性我们后面会讲到，这里你先知道有这回事就可以了。第二，HtmlDownloader 对象在构造函数中通过 new 来创建，违反了基于接口而非实现编程的设计思想，也会影响到代码的可测试性。第三，从业务含义上来讲，Document 网页文档没必要依赖 HtmlDownloader 类，违背了迪米特法则。</p>\n<p>虽然 Document 类的问题很多，但修改起来比较简单，只要一处改动就可以解决所有问题。修改之后的代码如下所示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Document</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> Html html;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> String url;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"title function_\">Document</span><span class=\"params\">(String url, Html html)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.html = html;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.url = url;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 通过一个工厂方法来创建Document</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">DocumentFactory</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> HtmlDownloader downloader;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"title function_\">DocumentFactory</span><span class=\"params\">(HtmlDownloader downloader)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.downloader = downloader;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">public</span> Document <span class=\"title function_\">createDocument</span><span class=\"params\">(String url)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">Html</span> <span class=\"variable\">html</span> <span class=\"operator\">=</span> downloader.downloadHtml(url);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Document</span>(url, html);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h3 id=\"理论解读与代码实战二\"><a href=\"#理论解读与代码实战二\" class=\"headerlink\" title=\"理论解读与代码实战二\"></a>理论解读与代码实战二</h3><p>现在，我们再来看一下这条原则中的后半部分：“有依赖关系的类之间，尽量只依赖必要的接口”。我们还是结合一个例子来讲解。下面这段代码非常简单，Serialization 类负责对象的序列化和反序列化</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Serialization</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> String <span class=\"title function_\">serialize</span><span class=\"params\">(Object object)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">serializedResult</span> <span class=\"operator\">=</span> ...;</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> serializedResult;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">public</span> Object <span class=\"title function_\">deserialize</span><span class=\"params\">(String str)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">Object</span> <span class=\"variable\">deserializedResult</span> <span class=\"operator\">=</span> ...;</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> deserializedResult;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<ol>\n<li>单看这个类的设计，没有一点问题。不过，如果我们把它放到一定的应用场景里，那就还有继续优化的空间。假设在我们的项目中，有些类只用到了序列化操作，而另一些类只用到反序列化操作。那基于迪米特法则后半部分“有依赖关系的类之间，尽量只依赖必要的接口”，只用到序列化操作的那部分类不应该依赖反序列化接口。同理，只用到反序列化操作的那部分类不应该依赖序列化接口。</li>\n<li>根据这个思路，我们应该将 Serialization 类拆分为两个更小粒度的类，一个只负责序列化（Serializer 类），一个只负责反序列化（Deserializer 类）。拆分之后，使用序列化操作的类只需要依赖 Serializer 类，使用反序列化操作的类只需要依赖 Deserializer 类。拆分之后的代码如下所示：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Serializer</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> String <span class=\"title function_\">serialize</span><span class=\"params\">(Object object)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">serializedResult</span> <span class=\"operator\">=</span> ...;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">return</span> serializedResult;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Deserializer</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> Object <span class=\"title function_\">deserialize</span><span class=\"params\">(String str)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">Object</span> <span class=\"variable\">deserializedResult</span> <span class=\"operator\">=</span> ...;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">return</span> deserializedResult;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<ol>\n<li>不知道你有没有看出来，尽管拆分之后的代码更能满足迪米特法则，但却违背了高内聚的设计思想。高内聚要求相近的功能要放到同一个类中，这样可以方便功能修改的时候，修改的地方不至于过于分散。对于刚刚这个例子来说，如果我们修改了序列化的实现方式，比如从 JSON 换成了 XML，那反序列化的实现逻辑也需要一并修改。在未拆分的情况下，我们只需要修改一个类即可。在拆分之后，我们需要修改两个类。显然，这种设计思路的代码改动范围变大了。</li>\n<li>如果我们既不想违背高内聚的设计思想，也不想违背迪米特法则，那我们该如何解决这个问题呢？实际上，通过引入两个接口就能轻松解决这个问题，具体的代码如下所示。实际上，我们在讲到“接口隔离原则”的时候，第三个例子就使用了类似的实现思路，你可以结合着一块儿来看。</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">Serializable</span> &#123;</span><br><span class=\"line\">  String <span class=\"title function_\">serialize</span><span class=\"params\">(Object object)</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">Deserializable</span> &#123;</span><br><span class=\"line\">  Object <span class=\"title function_\">deserialize</span><span class=\"params\">(String text)</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Serialization</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Serializable</span>, Deserializable &#123;</span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> String <span class=\"title function_\">serialize</span><span class=\"params\">(Object object)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">serializedResult</span> <span class=\"operator\">=</span> ...;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">return</span> serializedResult;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> Object <span class=\"title function_\">deserialize</span><span class=\"params\">(String str)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">Object</span> <span class=\"variable\">deserializedResult</span> <span class=\"operator\">=</span> ...;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">return</span> deserializedResult;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">DemoClass_1</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> Serializable serializer;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"title function_\">Demo</span><span class=\"params\">(Serializable serializer)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.serializer = serializer;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">DemoClass_2</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> Deserializable deserializer;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"title function_\">Demo</span><span class=\"params\">(Deserializable deserializer)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.deserializer = deserializer;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>尽管我们还是要往 DemoClass_1 的构造函数中，传入包含序列化和反序列化的 Serialization 实现类，但是，我们依赖的 Serializable 接口只包含序列化操作，DemoClass_1 无法使用 Serialization 类中的反序列化接口，对反序列化操作无感知，这也就符合了迪米特法则后半部分所说的“依赖有限接口”的要求。</li>\n<li>实际上，上面的的代码实现思路，也体现了“基于接口而非实现编程”的设计原则，结合迪米特法则，我们可以总结出一条新的设计原则，那就是“基于最小接口而非最大实现编程”。有些同学之前问，新的设计模式和设计原则是怎么创造出来的，实际上，就是在大量的实践中，针对开发痛点总结归纳出来的套路。</li>\n</ol>\n<h3 id=\"辩证思考与灵活应用\"><a href=\"#辩证思考与灵活应用\" class=\"headerlink\" title=\"辩证思考与灵活应用\"></a>辩证思考与灵活应用</h3><ol>\n<li>对于实战二最终的设计思路，你有没有什么不同的观点呢？</li>\n<li>整个类只包含序列化和反序列化两个操作，只用到序列化操作的使用者，即便能够感知到仅有的一个反序列化函数，问题也不大。那为了满足迪米特法则，我们将一个非常简单的类，拆分出两个接口，是否有点过度设计的意思呢？</li>\n<li>设计原则本身没有对错，只有能否用对之说。不要为了应用设计原则而应用设计原则，我们在应用设计原则的时候，一定要具体问题具体分析。</li>\n<li>对于刚刚这个 Serialization 类来说，只包含两个操作，确实没有太大必要拆分成两个接口。但是，如果我们对 Serialization 类添加更多的功能，实现更多更好用的序列化、反序列化函数，我们来重新考虑一下这个问题。修改之后的具体的代码如下</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Serializer</span> &#123; <span class=\"comment\">// 参看JSON的接口定义</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> String <span class=\"title function_\">serialize</span><span class=\"params\">(Object object)</span> &#123; <span class=\"comment\">//... &#125;</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> String <span class=\"title function_\">serializeMap</span><span class=\"params\">(Map map)</span> &#123; <span class=\"comment\">//... &#125;</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> String <span class=\"title function_\">serializeList</span><span class=\"params\">(List list)</span> &#123; <span class=\"comment\">//... &#125;</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">public</span> Object <span class=\"title function_\">deserialize</span><span class=\"params\">(String objectString)</span> &#123; <span class=\"comment\">//... &#125;</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> Map <span class=\"title function_\">deserializeMap</span><span class=\"params\">(String mapString)</span> &#123; <span class=\"comment\">//... &#125;</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> List <span class=\"title function_\">deserializeList</span><span class=\"params\">(String listString)</span> &#123; <span class=\"comment\">//... &#125;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在这种场景下，第二种设计思路要更好些。因为基于之前的应用场景来说，大部分代码只需要用到序列化的功能。对于这部分使用者，没必要了解反序列化的“知识”，而修改之后的 Serialization 类，反序列化的“知识”，从一个函数变成了三个。一旦任一反序列化操作有代码改动，我们都需要检查、测试所有依赖 Serialization 类的代码是否还能正常工作。为了减少耦合和测试工作量，我们应该按照迪米特法则，将反序列化和序列化的功能隔离开来。</p>\n","site":{"data":{}},"cover_type":"img","excerpt":"","more":"<h1 id=\"声明\"><a href=\"#声明\" class=\"headerlink\" title=\"声明\"></a>声明</h1><blockquote>\n<ol>\n<li>此系列文章非本人原创，是学习笔记。</li>\n<li>设计模式系列以后会持续更新，包括已经发布的设计模式文章，因为后续还要再多看一下书，教程和开源项目等，继续润色文章。</li>\n</ol>\n</blockquote>\n<h1 id=\"设计模式经典设计原则-第二节\"><a href=\"#设计模式经典设计原则-第二节\" class=\"headerlink\" title=\"设计模式经典设计原则-第二节\"></a>设计模式经典设计原则-第二节</h1><h2 id=\"依赖反转原则（DIP）\"><a href=\"#依赖反转原则（DIP）\" class=\"headerlink\" title=\"依赖反转原则（DIP）\"></a>依赖反转原则（DIP）</h2><p>关于 SOLID 原则，我们已经学过单一职责、开闭、里式替换、接口隔离这四个原则。今天，我们再来学习最后一个原则：依赖反转原则。在前面，我们讲到，单一职责原则和开闭原则的原理比较简单，但是，想要在实践中用好却比较难。而今天我们要讲到的依赖反转原则正好相反。这个原则用起来比较简单，但概念理解起来比较难。比如，下面这几个问题，你看看能否清晰地回答出来：</p>\n<ul>\n<li>“依赖反转”这个概念指的是“谁跟谁”的“什么依赖”被反转了？“反转”两个字该如何理解？</li>\n<li>我们还经常听到另外两个概念：“控制反转”和“依赖注入”。这两个概念跟“依赖反转”有什么区别和联系呢？它们说的是同一个事情吗？</li>\n<li>如果你熟悉 Java 语言，那 Spring 框架中的 IOC 跟这些概念又有什么关系呢？</li>\n</ul>\n<h3 id=\"控制反转（IOC）\"><a href=\"#控制反转（IOC）\" class=\"headerlink\" title=\"控制反转（IOC）\"></a>控制反转（IOC）</h3><p>在讲“依赖反转原则”之前，我们先讲一讲“控制反转”。控制反转的英文翻译是 Inversion Of Control，缩写为 IOC。此处我要强调一下，暂时别把这个“IOC”跟 Spring 框架的 IOC 联系在一起。关于 Spring 的 IOC，我们待会儿还会讲到。我们先通过一个例子来看一下，什么是控制反转。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">UserServiceTest</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"type\">boolean</span> <span class=\"title function_\">doTest</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ... </span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;<span class=\"comment\">//这部分逻辑可以放到框架中</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (doTest()) &#123;</span><br><span class=\"line\">      System.out.println(<span class=\"string\">&quot;Test succeed.&quot;</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      System.out.println(<span class=\"string\">&quot;Test failed.&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在上面的代码中，所有的流程都由程序员来控制。如果我们抽象出一个下面这样一个框架，我们再来看，如何利用框架来实现同样的功能。具体的代码实现如下所示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">class</span> <span class=\"title class_\">TestCase</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (doTest()) &#123;</span><br><span class=\"line\">      System.out.println(<span class=\"string\">&quot;Test succeed.&quot;</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      System.out.println(<span class=\"string\">&quot;Test failed.&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"type\">boolean</span> <span class=\"title function_\">doTest</span><span class=\"params\">()</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">JunitApplication</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> List&lt;TestCase&gt; testCases = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">register</span><span class=\"params\">(TestCase testCase)</span> &#123;</span><br><span class=\"line\">    testCases.add(testCase);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (TestCase <span class=\"keyword\">case</span>: testCases) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">case</span>.run();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n<p>把这个简化版本的测试框架引入到工程中之后，我们只需要在框架预留的扩展点，也就是 TestCase 类中的 doTest() 抽象函数中，填充具体的测试代码就可以实现之前的功能了，完全不需要写负责执行流程的 main() 函数了。 具体的代码如下所示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">UserServiceTest</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">TestCase</span> &#123;</span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">doTest</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ... </span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 注册操作还可以通过配置的方式来实现，不需要程序员显示调用register()</span></span><br><span class=\"line\">JunitApplication.register(<span class=\"keyword\">new</span> <span class=\"title class_\">UserServiceTest</span>();</span><br></pre></td></tr></table></figure>\n\n\n\n<ol>\n<li>刚刚举的这个例子，就是典型的通过框架来实现“控制反转”的例子。框架提供了一个可扩展的代码骨架，用来组装对象、管理整个执行流程。程序员利用框架进行开发的时候，只需要往预留的扩展点上，添加跟自己业务相关的代码，就可以利用框架来驱动整个程序流程的执行。</li>\n<li>这里的“控制”指的是对程序执行流程的控制，而“反转”指的是在没有使用框架之前，程序员自己控制整个程序的执行。在使用框架之后，整个程序的执行流程可以通过框架来控制。流程的控制权从程序员“反转”到了框架。</li>\n<li>实际上，实现控制反转的方法有很多，除了刚才例子中所示的类似于模板设计模式的方法之外，还有马上要讲到的依赖注入等方法，所以，控制反转并不是一种具体的实现技巧，而是一个比较笼统的设计思想，一般用来指导框架层面的设计。</li>\n</ol>\n<h3 id=\"依赖注入（DI）\"><a href=\"#依赖注入（DI）\" class=\"headerlink\" title=\"依赖注入（DI）\"></a>依赖注入（DI）</h3><ol>\n<li>接下来，我们再来看依赖注入。依赖注入跟控制反转恰恰相反，它是一种具体的编码技巧。那到底什么是依赖注入呢？我们用一句话来概括就是：不通过 new() 的方式在类内部创建依赖类对象，而是将依赖的类对象在外部创建好之后，通过构造函数、函数参数等方式传递（或注入）给类使用。</li>\n<li>我们还是通过一个例子来解释一下。在这个例子中，Notification 类负责消息推送，依赖 MessageSender 类实现推送商品促销、验证码等消息给用户。我们分别用依赖注入和非依赖注入两种方式来实现一下。具体的实现代码如下所示：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 非依赖注入实现方式</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Notification</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> MessageSender messageSender;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"title function_\">Notification</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.messageSender = <span class=\"keyword\">new</span> <span class=\"title class_\">MessageSender</span>(); <span class=\"comment\">//此处有点像hardcode</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">sendMessage</span><span class=\"params\">(String cellphone, String message)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//...省略校验逻辑等...</span></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.messageSender.send(cellphone, message);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">MessageSender</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">send</span><span class=\"params\">(String cellphone, String message)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//....</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 使用Notification</span></span><br><span class=\"line\"><span class=\"type\">Notification</span> <span class=\"variable\">notification</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Notification</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 依赖注入的实现方式</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Notification</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> MessageSender messageSender;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">// 通过构造函数将messageSender传递进来</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"title function_\">Notification</span><span class=\"params\">(MessageSender messageSender)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.messageSender = messageSender;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">sendMessage</span><span class=\"params\">(String cellphone, String message)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//...省略校验逻辑等...</span></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.messageSender.send(cellphone, message);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//使用Notification</span></span><br><span class=\"line\"><span class=\"type\">MessageSender</span> <span class=\"variable\">messageSender</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">MessageSender</span>();</span><br><span class=\"line\"><span class=\"type\">Notification</span> <span class=\"variable\">notification</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Notification</span>(messageSender);</span><br></pre></td></tr></table></figure>\n\n<p>通过依赖注入的方式来将依赖的类对象传递进来，这样就提高了代码的扩展性，我们可以灵活地替换依赖的类。这一点在我们之前讲“开闭原则”的时候也提到过。当然，上面代码还有继续优化的空间，我们还可以把 MessageSender 定义成接口，基于接口而非实现编程。改造后的代码如下所示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Notification</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> MessageSender messageSender;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"title function_\">Notification</span><span class=\"params\">(MessageSender messageSender)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.messageSender = messageSender;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">sendMessage</span><span class=\"params\">(String cellphone, String message)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.messageSender.send(cellphone, message);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">MessageSender</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">void</span> <span class=\"title function_\">send</span><span class=\"params\">(String cellphone, String message)</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 短信发送类</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">SmsSender</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">MessageSender</span> &#123;</span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">send</span><span class=\"params\">(String cellphone, String message)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//....</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 站内信发送类</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">InboxSender</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">MessageSender</span> &#123;</span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">send</span><span class=\"params\">(String cellphone, String message)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//....</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//使用Notification</span></span><br><span class=\"line\"><span class=\"type\">MessageSender</span> <span class=\"variable\">messageSender</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">SmsSender</span>();</span><br><span class=\"line\"><span class=\"type\">Notification</span> <span class=\"variable\">notification</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Notification</span>(messageSender);</span><br></pre></td></tr></table></figure>\n\n\n\n<p>实际上，你只需要掌握刚刚举的这个例子，就等于完全掌握了依赖注入。尽管依赖注入非常简单，但却非常有用，</p>\n<h3 id=\"依赖注入框架（DI-Framework）\"><a href=\"#依赖注入框架（DI-Framework）\" class=\"headerlink\" title=\"依赖注入框架（DI Framework）\"></a>依赖注入框架（DI Framework）</h3><p>弄懂了什么是“依赖注入”，我们再来看一下，什么是“依赖注入框架”。我们还是借用刚刚的例子来解释。在采用依赖注入实现的 Notification 类中，虽然我们不需要用类似 hard code 的方式，在类内部通过 new 来创建 MessageSender 对象，但是，这个创建对象、组装（或注入）对象的工作仅仅是被移动到了更上层代码而已，还是需要我们程序员自己来实现。具体代码如下所示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Demo</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String args[])</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">MessageSender</span> <span class=\"variable\">sender</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">SmsSender</span>(); <span class=\"comment\">//创建对象</span></span><br><span class=\"line\">    <span class=\"type\">Notification</span> <span class=\"variable\">notification</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Notification</span>(sender);<span class=\"comment\">//依赖注入</span></span><br><span class=\"line\">    notification.sendMessage(<span class=\"string\">&quot;13918942177&quot;</span>, <span class=\"string\">&quot;短信验证码：2346&quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>在实际的软件开发中，一些项目可能会涉及几十、上百、甚至几百个类，类对象的创建和依赖注入会变得非常复杂。如果这部分工作都是靠程序员自己写代码来完成，容易出错且开发成本也比较高。而对象创建和依赖注入的工作，本身跟具体的业务无关，我们完全可以抽象成框架来自动完成。</li>\n<li>你可能已经猜到，这个框架就是“依赖注入框架”。我们只需要通过依赖注入框架提供的扩展点，简单配置一下所有需要创建的类对象、类与类之间的依赖关系，就可以实现由框架来自动创建对象、管理对象的生命周期、依赖注入等原本需要程序员来做的事情。</li>\n<li>实际上，现成的依赖注入框架有很多，比如 Google Guice、Java Spring、Pico Container、Butterfly Container 等。不过，如果你熟悉 Java Spring 框架，你可能会说，Spring 框架自己声称是控制反转容器（Inversion Of Control Container）。</li>\n<li>实际上，这两种说法都没错。只是控制反转容器这种表述是一种非常宽泛的描述，DI 依赖注入框架的表述更具体、更有针对性。因为我们前面讲到实现控制反转的方式有很多，除了依赖注入，还有模板模式等，而 Spring 框架的控制反转主要是通过依赖注入来实现的。不过这点区分并不是很明显，也不是很重要，你稍微了解一下就可以了。</li>\n</ol>\n<h3 id=\"什么是依赖反转原则？\"><a href=\"#什么是依赖反转原则？\" class=\"headerlink\" title=\"什么是依赖反转原则？\"></a>什么是依赖反转原则？</h3><ol>\n<li>前面讲了控制反转、依赖注入、依赖注入框架，现在，我们来讲一讲今天的主角：依赖反转原则。依赖反转原则的英文翻译是 Dependency Inversion Principle，缩写为 DIP。中文翻译有时候也叫依赖倒置原则。</li>\n<li>英文描述：High-level modules shouldn’t depend on low-level modules. Both modules should depend on abstractions. In addition, abstractions shouldn’t depend on details. Details depend on abstractions.</li>\n<li>我们将它翻译成中文，大概意思就是：高层模块（high-level modules）不要依赖低层模块（low-level）。高层模块和低层模块应该通过抽象（abstractions）来互相依赖。除此之外，抽象（abstractions）不要依赖具体实现细节（details），具体实现细节（details）依赖抽象（abstractions）。</li>\n<li>所谓高层模块和低层模块的划分，简单来说就是，在调用链上，调用者属于高层，被调用者属于低层。在平时的业务代码开发中，高层模块依赖底层模块是没有任何问题的。实际上，这条原则主要还是用来指导框架层面的设计，跟前面讲到的控制反转类似。我们拿 Tomcat 这个 Servlet 容器作为例子来解释一下。</li>\n<li>Tomcat 是运行 Java Web 应用程序的容器。我们编写的 Web 应用程序代码只需要部署在 Tomcat 容器下，便可以被 Tomcat 容器调用执行。按照之前的划分原则，Tomcat 就是高层模块，我们编写的 Web 应用程序代码就是低层模块。Tomcat 和应用程序代码之间并没有直接的依赖关系，两者都依赖同一个“抽象”，也就是 Servlet 规范。Servlet 规范不依赖具体的 Tomcat 容器和应用程序的实现细节，而 Tomcat 容器和应用程序依赖 Servlet 规范。</li>\n</ol>\n<h2 id=\"KISS原则和YAGNI原则\"><a href=\"#KISS原则和YAGNI原则\" class=\"headerlink\" title=\"KISS原则和YAGNI原则\"></a>KISS原则和YAGNI原则</h2><ol>\n<li>我们学习了经典的 SOLID 原则。今天，我们讲两个设计原则：KISS 原则和 YAGNI 原则。其中，KISS 原则比较经典，耳熟能详，但 YAGNI 你可能没怎么听过，不过它理解起来也不难。</li>\n<li>理解这两个原则时候，经常会有一个共同的问题，那就是，看一眼就感觉懂了，但深究的话，又有很多细节问题不是很清楚。比如，怎么理解 KISS 原则中“简单”两个字？什么样的代码才算“简单”？怎样的代码才算“复杂”？如何才能写出“简单”的代码？YAGNI 原则跟 KISS 原则说的是一回事吗？</li>\n</ol>\n<p>KISS 原则的英文描述有好几个版本，比如下面这几个。</p>\n<ul>\n<li>Keep It Simple and Stupid.</li>\n<li>Keep It Short and Simple.</li>\n<li>Keep It Simple and Straightforward.</li>\n</ul>\n<ol>\n<li><p>不过，仔细看你就会发现，它们要表达的意思其实差不多，翻译成中文就是：尽量保持简单。</p>\n</li>\n<li><p>我们知道，代码的可读性和可维护性是衡量代码质量非常重要的两个标准。而 KISS 原则就是保持代码可读和可维护的重要手段。代码足够简单，也就意味着很容易读懂，bug 比较难隐藏。即便出现 bug，修复起来也比较简单。不过，这条原则只是告诉我们，要保持代码“Simple and Stupid”，但并没有讲到，什么样的代码才是“Simple and Stupid”的，更没有给出特别明确的方法论，来指导如何开发出“Simple and Stupid”的代码。</p>\n</li>\n<li><p>所以，接下来，为了能让这条原则切实地落地，能够指导实际的项目开发，我就针对刚刚的这些问题来进一步讲讲我的理解。</p>\n</li>\n</ol>\n<h3 id=\"代码行数越少就越“简单”吗？\"><a href=\"#代码行数越少就越“简单”吗？\" class=\"headerlink\" title=\"代码行数越少就越“简单”吗？\"></a>代码行数越少就越“简单”吗？</h3><p>我们先一起看一个例子。下面这三段代码可以实现同样一个功能：检查输入的字符串 ipAddress 是否是合法的 IP 地址。一个合法的 IP 地址由四个数字组成，并且通过“.”来进行分割。每组数字的取值范围是 0~255。第一组数字比较特殊，不允许为 0。对比这三段代码，你觉得哪一段代码最符合 KISS 原则呢？如果让你来实现这个功能，你会选择用哪种实现方法呢？你可以先自己思考一下，然后再看我下面的讲解。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 第一种实现方式: 使用正则表达式</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">isValidIpAddressV1</span><span class=\"params\">(String ipAddress)</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (StringUtils.isBlank(ipAddress)) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  <span class=\"type\">String</span> <span class=\"variable\">regex</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;^(1\\\\d&#123;2&#125;|2[0-4]\\\\d|25[0-5]|[1-9]\\\\d|[1-9])\\\\.&quot;</span></span><br><span class=\"line\">          + <span class=\"string\">&quot;(1\\\\d&#123;2&#125;|2[0-4]\\\\d|25[0-5]|[1-9]\\\\d|\\\\d)\\\\.&quot;</span></span><br><span class=\"line\">          + <span class=\"string\">&quot;(1\\\\d&#123;2&#125;|2[0-4]\\\\d|25[0-5]|[1-9]\\\\d|\\\\d)\\\\.&quot;</span></span><br><span class=\"line\">          + <span class=\"string\">&quot;(1\\\\d&#123;2&#125;|2[0-4]\\\\d|25[0-5]|[1-9]\\\\d|\\\\d)$&quot;</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> ipAddress.matches(regex);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 第二种实现方式: 使用现成的工具类</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">isValidIpAddressV2</span><span class=\"params\">(String ipAddress)</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (StringUtils.isBlank(ipAddress)) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  String[] ipUnits = StringUtils.split(ipAddress, <span class=\"string\">&#x27;.&#x27;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (ipUnits.length != <span class=\"number\">4</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">4</span>; ++i) &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> ipUnitIntValue;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      ipUnitIntValue = Integer.parseInt(ipUnits[i]);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (NumberFormatException e) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ipUnitIntValue &lt; <span class=\"number\">0</span> || ipUnitIntValue &gt; <span class=\"number\">255</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (i == <span class=\"number\">0</span> &amp;&amp; ipUnitIntValue == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 第三种实现方式: 不使用任何工具类</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">isValidIpAddressV3</span><span class=\"params\">(String ipAddress)</span> &#123;</span><br><span class=\"line\">  <span class=\"type\">char</span>[] ipChars = ipAddress.toCharArray();</span><br><span class=\"line\">  <span class=\"type\">int</span> <span class=\"variable\">length</span> <span class=\"operator\">=</span> ipChars.length;</span><br><span class=\"line\">  <span class=\"type\">int</span> <span class=\"variable\">ipUnitIntValue</span> <span class=\"operator\">=</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"type\">boolean</span> <span class=\"variable\">isFirstUnit</span> <span class=\"operator\">=</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">  <span class=\"type\">int</span> <span class=\"variable\">unitsCount</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; length; ++i) &#123;</span><br><span class=\"line\">    <span class=\"type\">char</span> <span class=\"variable\">c</span> <span class=\"operator\">=</span> ipChars[i];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (c == <span class=\"string\">&#x27;.&#x27;</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (ipUnitIntValue &lt; <span class=\"number\">0</span> || ipUnitIntValue &gt; <span class=\"number\">255</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (isFirstUnit &amp;&amp; ipUnitIntValue == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (isFirstUnit) isFirstUnit = <span class=\"literal\">false</span>;</span><br><span class=\"line\">      ipUnitIntValue = -<span class=\"number\">1</span>;</span><br><span class=\"line\">      unitsCount++;</span><br><span class=\"line\">      <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (c &lt; <span class=\"string\">&#x27;0&#x27;</span> || c &gt; <span class=\"string\">&#x27;9&#x27;</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ipUnitIntValue == -<span class=\"number\">1</span>) ipUnitIntValue = <span class=\"number\">0</span>;</span><br><span class=\"line\">    ipUnitIntValue = ipUnitIntValue * <span class=\"number\">10</span> + (c - <span class=\"string\">&#x27;0&#x27;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (ipUnitIntValue &lt; <span class=\"number\">0</span> || ipUnitIntValue &gt; <span class=\"number\">255</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (unitsCount != <span class=\"number\">3</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<ol>\n<li>第一种实现方式利用的是正则表达式，只用三行代码就把这个问题搞定了。它的代码行数最少，那是不是就最符合 KISS 原则呢？答案是否定的。虽然代码行数最少，看似最简单，实际上却很复杂。这正是因为它使用了正则表达式。</li>\n<li>一方面，正则表达式本身是比较复杂的，写出完全没有 bug 的正则表达本身就比较有挑战；另一方面，并不是每个程序员都精通正则表达式。对于不怎么懂正则表达式的同事来说，看懂并且维护这段正则表达式是比较困难的。这种实现方式会导致代码的可读性和可维护性变差，所以，从 KISS 原则的设计初衷上来讲，这种实现方式并不符合 KISS 原则。</li>\n<li>讲完了第一种实现方式，我们再来看下其他两种实现方式。</li>\n<li>第二种实现方式使用了 StringUtils 类、Integer 类提供的一些现成的工具函数，来处理 IP 地址字符串。第三种实现方式，不使用任何工具函数，而是通过逐一处理 IP 地址中的字符，来判断是否合法。从代码行数上来说，这两种方式差不多。但是，第三种要比第二种更加有难度，更容易写出 bug。从可读性上来说，第二种实现方式的代码逻辑更清晰、更好理解。所以，在这两种实现方式中，第二种实现方式更加“简单”，更加符合 KISS 原则。</li>\n<li>不过，你可能会说，第三种实现方式虽然实现起来稍微有点复杂，但性能要比第二种实现方式高一些啊。从性能的角度来说，选择第三种实现方式是不是更好些呢？在回答这个问题之前，我先解释一下，为什么说第三种实现方式性能会更高一些。一般来说，工具类的功能都比较通用和全面，所以，在代码实现上，需要考虑和处理更多的细节，执行效率就会有所影响。而第三种实现方式，完全是自己操作底层字符，只针对 IP 地址这一种格式的数据输入来做处理，没有太多多余的函数调用和其他不必要的处理逻辑，所以，在执行效率上，这种类似定制化的处理代码方式肯定比通用的工具类要高些。</li>\n<li>不过，尽管第三种实现方式性能更高些，但我还是更倾向于选择第二种实现方法。那是因为第三种实现方式实际上是一种过度优化。除非 isValidIpAddress() 函数是影响系统性能的瓶颈代码，否则，这样优化的投入产出比并不高，增加了代码实现的难度、牺牲了代码的可读性，性能上的提升却并不明显。</li>\n</ol>\n<h3 id=\"代码逻辑复杂就违背-KISS-原则吗？\"><a href=\"#代码逻辑复杂就违背-KISS-原则吗？\" class=\"headerlink\" title=\"代码逻辑复杂就违背 KISS 原则吗？\"></a>代码逻辑复杂就违背 KISS 原则吗？</h3><p>刚刚我们提到，并不是代码行数越少就越“简单”，还要考虑逻辑复杂度、实现难度、代码的可读性等。那如果一段代码的逻辑复杂、实现难度大、可读性也不太好，是不是就一定违背 KISS 原则呢？在回答这个问题之前，我们先来看下面这段代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// KMP algorithm: a, b分别是主串和模式串；n, m分别是主串和模式串的长度。</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">kmp</span><span class=\"params\">(<span class=\"type\">char</span>[] a, <span class=\"type\">int</span> n, <span class=\"type\">char</span>[] b, <span class=\"type\">int</span> m)</span> &#123;</span><br><span class=\"line\">  <span class=\"type\">int</span>[] next = getNexts(b, m);</span><br><span class=\"line\">  <span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; n; ++i) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (j &gt; <span class=\"number\">0</span> &amp;&amp; a[i] != b[j]) &#123; <span class=\"comment\">// 一直找到a[i]和b[j]</span></span><br><span class=\"line\">      j = next[j - <span class=\"number\">1</span>] + <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (a[i] == b[j]) &#123;</span><br><span class=\"line\">      ++j;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (j == m) &#123; <span class=\"comment\">// 找到匹配模式串的了</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> i - m + <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// b表示模式串，m表示模式串的长度</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">int</span>[] getNexts(<span class=\"type\">char</span>[] b, <span class=\"type\">int</span> m) &#123;</span><br><span class=\"line\">  <span class=\"type\">int</span>[] next = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[m];</span><br><span class=\"line\">  next[<span class=\"number\">0</span>] = -<span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"type\">int</span> <span class=\"variable\">k</span> <span class=\"operator\">=</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; i &lt; m; ++i) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (k != -<span class=\"number\">1</span> &amp;&amp; b[k + <span class=\"number\">1</span>] != b[i]) &#123;</span><br><span class=\"line\">      k = next[k];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (b[k + <span class=\"number\">1</span>] == b[i]) &#123;</span><br><span class=\"line\">      ++k;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    next[i] = k;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> next;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<ol>\n<li><p>这段代码是KMP 字符串匹配算法的代码实现。这段代码完全符合我们刚提到的逻辑复杂、实现难度大、可读性差的特点，但它并不违反 KISS 原则。为什么这么说呢？</p>\n</li>\n<li><p>KMP 算法以快速高效著称。当我们需要处理长文本字符串匹配问题（几百 MB 大小文本内容的匹配），或者字符串匹配是某个产品的核心功能（比如 Vim、Word 等文本编辑器），又或者字符串匹配算法是系统性能瓶颈的时候，我们就应该选择尽可能高效的 KMP 算法。而 KMP 算法本身具有逻辑复杂、实现难度大、可读性差的特点。本身就复杂的问题，用复杂的方法解决，并不违背 KISS 原则。</p>\n</li>\n<li><p>不过，平时的项目开发中涉及的字符串匹配问题，大部分都是针对比较小的文本。在这种情况下，直接调用编程语言提供的现成的字符串匹配函数就足够了。如果非得用 KMP 算法、BM 算法来实现字符串匹配，那就真的违背 KISS 原则了。也就是说，同样的代码，在某个业务场景下满足 KISS 原则，换一个应用场景可能就不满足了。</p>\n</li>\n</ol>\n<h3 id=\"如何写出满足-KISS-原则的代码？\"><a href=\"#如何写出满足-KISS-原则的代码？\" class=\"headerlink\" title=\"如何写出满足 KISS 原则的代码？\"></a>如何写出满足 KISS 原则的代码？</h3><p>实际上，我们前面已经讲到了一些方法。这里我稍微总结一下。</p>\n<ul>\n<li>不要使用同事可能不懂的技术来实现代码。比如前面例子中的正则表达式，还有一些编程语言中过于高级的语法等。</li>\n<li>不要重复造轮子，要善于使用已经有的工具类库。经验证明，自己去实现这些类库，出 bug 的概率会更高，维护的成本也比较高。</li>\n<li>不要过度优化。不要过度使用一些奇技淫巧（比如，位运算代替算术运算、复杂的条件语句代替 if-else、使用一些过于底层的函数等）来优化代码，牺牲代码的可读性。</li>\n<li>实际上，代码是否足够简单是一个挺主观的评判。同样的代码，有的人觉得简单，有的人觉得不够简单。而往往自己编写的代码，自己都会觉得够简单。所以，评判代码是否简单，还有一个很有效的间接方法，那就是 code review。如果在 code review 的时候，同事对你的代码有很多疑问，那就说明你的代码有可能不够“简单”，需要优化啦。</li>\n</ul>\n<h3 id=\"YAGNI-跟-KISS-说的是一回事吗？\"><a href=\"#YAGNI-跟-KISS-说的是一回事吗？\" class=\"headerlink\" title=\"YAGNI 跟 KISS 说的是一回事吗？\"></a>YAGNI 跟 KISS 说的是一回事吗？</h3><ol>\n<li>YAGNI 原则的英文全称是：You Ain’t Gonna Need It。直译就是：你不会需要它。这条原则也算是万金油了。当用在软件开发中的时候，它的意思是：不要去设计当前用不到的功能；不要去编写当前用不到的代码。实际上，这条原则的核心思想就是：不要做过度设计。</li>\n<li>比如，我们的系统暂时只用 Redis 存储配置信息，以后可能会用到 ZooKeeper。根据 YAGNI 原则，在未用到 ZooKeeper 之前，我们没必要提前编写这部分代码。当然，这并不是说我们就不需要考虑代码的扩展性。我们还是要预留好扩展点，等到需要的时候，再去实现 ZooKeeper 存储配置信息这部分代码。</li>\n<li>再比如，我们不要在项目中提前引入不需要依赖的开发包。对于 Java 程序员来说，我们经常使用 Maven 或者 Gradle 来管理依赖的类库（library）。我发现，有些同事为了避免开发中 library 包缺失而频繁地修改 Maven 或者 Gradle 配置文件，提前往项目里引入大量常用的 library 包。实际上，这样的做法也是违背 YAGNI 原则的。</li>\n<li>从刚刚的分析我们可以看出，YAGNI 原则跟 KISS 原则并非一回事儿。KISS 原则讲的是“如何做”的问题（尽量保持简单），而 YAGNI 原则说的是“要不要做”的问题（当前不需要的就不要做）。</li>\n</ol>\n<h2 id=\"DRY-原则\"><a href=\"#DRY-原则\" class=\"headerlink\" title=\"DRY 原则\"></a>DRY 原则</h2><p>Don’t Repeat Yourself。中文直译为：不要重复自己。将它应用在编程中，可以理解为：不要写重复的代码。DRY 原则的定义非常简单，我就不再过度解读。今天，我们主要讲三种典型的代码重复情况，它们分别是：实现逻辑重复、功能语义重复和代码执行重复。这三种代码重复，有的看似违反 DRY，实际上并不违反；有的看似不违反，实际上却违反了。</p>\n<h3 id=\"实现逻辑重复\"><a href=\"#实现逻辑重复\" class=\"headerlink\" title=\"实现逻辑重复\"></a>实现逻辑重复</h3><p>我们先来看下面这样一段代码是否违反了 DRY 原则。如果违反了，你觉得应该如何重构，才能让它满足 DRY 原则？如果没有违反，那又是为什么呢？</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">UserAuthenticator</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">authenticate</span><span class=\"params\">(String username, String password)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!isValidUsername(username)) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// ...throw InvalidUsernameException...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!isValidPassword(password)) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// ...throw InvalidPasswordException...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//...省略其他代码...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"type\">boolean</span> <span class=\"title function_\">isValidUsername</span><span class=\"params\">(String username)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// check not null, not empty</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (StringUtils.isBlank(username)) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// check length: 4~64</span></span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">length</span> <span class=\"operator\">=</span> username.length();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (length &lt; <span class=\"number\">4</span> || length &gt; <span class=\"number\">64</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// contains only lowcase characters</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!StringUtils.isAllLowerCase(username)) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// contains only a~z,0~9,dot</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; length; ++i) &#123;</span><br><span class=\"line\">      <span class=\"type\">char</span> <span class=\"variable\">c</span> <span class=\"operator\">=</span> username.charAt(i);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!(c &gt;= <span class=\"string\">&#x27;a&#x27;</span> &amp;&amp; c &lt;= <span class=\"string\">&#x27;z&#x27;</span>) || (c &gt;= <span class=\"string\">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class=\"string\">&#x27;9&#x27;</span>) || c == <span class=\"string\">&#x27;.&#x27;</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"type\">boolean</span> <span class=\"title function_\">isValidPassword</span><span class=\"params\">(String password)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// check not null, not empty</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (StringUtils.isBlank(password)) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// check length: 4~64</span></span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">length</span> <span class=\"operator\">=</span> password.length();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (length &lt; <span class=\"number\">4</span> || length &gt; <span class=\"number\">64</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// contains only lowcase characters</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!StringUtils.isAllLowerCase(password)) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// contains only a~z,0~9,dot</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; length; ++i) &#123;</span><br><span class=\"line\">      <span class=\"type\">char</span> <span class=\"variable\">c</span> <span class=\"operator\">=</span> password.charAt(i);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!(c &gt;= <span class=\"string\">&#x27;a&#x27;</span> &amp;&amp; c &lt;= <span class=\"string\">&#x27;z&#x27;</span>) || (c &gt;= <span class=\"string\">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class=\"string\">&#x27;9&#x27;</span>) || c == <span class=\"string\">&#x27;.&#x27;</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>代码很简单，我就不做过多解释了。在代码中，有两处非常明显的重复的代码片段：isValidUserName() 函数和 isValidPassword() 函数。重复的代码被敲了两遍，或者简单 copy-paste 了一下，看起来明显违反 DRY 原则。为了移除重复的代码，我们对上面的代码做下重构，将 isValidUserName() 函数和 isValidPassword() 函数，合并为一个更通用的函数 isValidUserNameOrPassword()。重构后的代码如下所示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">UserAuthenticatorV2</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">authenticate</span><span class=\"params\">(String userName, String password)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!isValidUsernameOrPassword(userName)) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// ...throw InvalidUsernameException...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!isValidUsernameOrPassword(password)) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// ...throw InvalidPasswordException...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"type\">boolean</span> <span class=\"title function_\">isValidUsernameOrPassword</span><span class=\"params\">(String usernameOrPassword)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//省略实现逻辑</span></span><br><span class=\"line\">    <span class=\"comment\">//跟原来的isValidUsername()或isValidPassword()的实现逻辑一样...</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>经过重构之后，代码行数减少了，也没有重复的代码了，是不是更好了呢？答案是否定的，这可能跟你预期的不一样，我来解释一下为什么。</li>\n<li>单从名字上看，我们就能发现，合并之后的 isValidUserNameOrPassword() 函数，负责两件事情：验证用户名和验证密码，违反了“单一职责原则”和“接口隔离原则”。实际上，即便将两个函数合并成 isValidUserNameOrPassword()，代码仍然存在问题。</li>\n<li>因为 isValidUserName() 和 isValidPassword() 两个函数，虽然从代码实现逻辑上看起来是重复的，但是从语义上并不重复。所谓“语义不重复”指的是：从功能上来看，这两个函数干的是完全不重复的两件事情，一个是校验用户名，另一个是校验密码。尽管在目前的设计中，两个校验逻辑是完全一样的，但如果按照第二种写法，将两个函数的合并，那就会存在潜在的问题。在未来的某一天，如果我们修改了密码的校验逻辑，比如，允许密码包含大写字符，允许密码的长度为 8 到 64 个字符，那这个时候，isValidUserName() 和 isValidPassword() 的实现逻辑就会不相同。我们就要把合并后的函数，重新拆成合并前的那两个函数。</li>\n<li>尽管代码的实现逻辑是相同的，但语义不同，我们判定它并不违反 DRY 原则。对于包含重复代码的问题，我们可以通过抽象成更细粒度函数的方式来解决。比如将校验只包含 a<del>z、0</del>9、dot 的逻辑封装成 boolean onlyContains(String str, String charlist); 函数。</li>\n</ol>\n<h3 id=\"功能语义重复\"><a href=\"#功能语义重复\" class=\"headerlink\" title=\"功能语义重复\"></a>功能语义重复</h3><ol>\n<li>现在我们再来看另外一个例子。在同一个项目代码中有下面两个函数：isValidIp() 和 checkIfIpValid()。尽管两个函数的命名不同，实现逻辑不同，但功能是相同的，都是用来判定 IP 地址是否合法的。</li>\n<li>之所以在同一个项目中会有两个功能相同的函数，那是因为这两个函数是由两个不同的同事开发的，其中一个同事在不知道已经有了 isValidIp() 的情况下，自己又定义并实现了同样用来校验 IP 地址是否合法的 checkIfIpValid() 函数。那在同一项目代码中，存在如下两个函数，是否违反 DRY 原则呢？</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">isValidIp</span><span class=\"params\">(String ipAddress)</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (StringUtils.isBlank(ipAddress)) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  <span class=\"type\">String</span> <span class=\"variable\">regex</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;^(1\\\\d&#123;2&#125;|2[0-4]\\\\d|25[0-5]|[1-9]\\\\d|[1-9])\\\\.&quot;</span></span><br><span class=\"line\">          + <span class=\"string\">&quot;(1\\\\d&#123;2&#125;|2[0-4]\\\\d|25[0-5]|[1-9]\\\\d|\\\\d)\\\\.&quot;</span></span><br><span class=\"line\">          + <span class=\"string\">&quot;(1\\\\d&#123;2&#125;|2[0-4]\\\\d|25[0-5]|[1-9]\\\\d|\\\\d)\\\\.&quot;</span></span><br><span class=\"line\">          + <span class=\"string\">&quot;(1\\\\d&#123;2&#125;|2[0-4]\\\\d|25[0-5]|[1-9]\\\\d|\\\\d)$&quot;</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> ipAddress.matches(regex);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">checkIfIpValid</span><span class=\"params\">(String ipAddress)</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (StringUtils.isBlank(ipAddress)) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  String[] ipUnits = StringUtils.split(ipAddress, <span class=\"string\">&#x27;.&#x27;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (ipUnits.length != <span class=\"number\">4</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">4</span>; ++i) &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> ipUnitIntValue;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      ipUnitIntValue = Integer.parseInt(ipUnits[i]);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (NumberFormatException e) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ipUnitIntValue &lt; <span class=\"number\">0</span> || ipUnitIntValue &gt; <span class=\"number\">255</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (i == <span class=\"number\">0</span> &amp;&amp; ipUnitIntValue == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>这个例子跟上个例子正好相反。上一个例子是代码实现逻辑重复，但语义不重复，我们并不认为它违反了 DRY 原则。而在这个例子中，尽管两段代码的实现逻辑不重复，但语义重复，也就是功能重复，我们认为它违反了 DRY 原则。我们应该在项目中，统一一种实现思路，所有用到判断 IP 地址是否合法的地方，都统一调用同一个函数。</li>\n<li>假设我们不统一实现思路，那有些地方调用了 isValidIp() 函数，有些地方又调用了 checkIfIpValid() 函数，这就会导致代码看起来很奇怪，相当于给代码“埋坑”，给不熟悉这部分代码的同事增加了阅读的难度。同事有可能研究了半天，觉得功能是一样的，但又有点疑惑，觉得是不是有更高深的考量，才定义了两个功能类似的函数，最终发现居然是代码设计的问题。</li>\n<li>除此之外，如果哪天项目中 IP 地址是否合法的判定规则改变了，比如：255.255.255.255 不再被判定为合法的了，相应地，我们对 isValidIp() 的实现逻辑做了相应的修改，但却忘记了修改 checkIfIpValid() 函数。又或者，我们压根就不知道还存在一个功能相同的 checkIfIpValid() 函数，这样就会导致有些代码仍然使用老的 IP 地址判断逻辑，导致出现一些莫名其妙的 bug。</li>\n</ol>\n<h3 id=\"代码执行重复\"><a href=\"#代码执行重复\" class=\"headerlink\" title=\"代码执行重复\"></a>代码执行重复</h3><p>前两个例子一个是实现逻辑重复，一个是语义重复，我们再来看第三个例子。其中，UserService 中 login() 函数用来校验用户登录是否成功。如果失败，就返回异常；如果成功，就返回用户信息。具体代码如下所示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">UserService</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> UserRepo userRepo;<span class=\"comment\">//通过依赖注入或者IOC框架注入</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> User <span class=\"title function_\">login</span><span class=\"params\">(String email, String password)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">boolean</span> <span class=\"variable\">existed</span> <span class=\"operator\">=</span> userRepo.checkIfUserExisted(email, password);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!existed) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// ... throw AuthenticationFailureException...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">User</span> <span class=\"variable\">user</span> <span class=\"operator\">=</span> userRepo.getUserByEmail(email);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> user;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">UserRepo</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">checkIfUserExisted</span><span class=\"params\">(String email, String password)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!EmailValidation.validate(email)) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// ... throw InvalidEmailException...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!PasswordValidation.validate(password)) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// ... throw InvalidPasswordException...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//...query db to check if email&amp;password exists...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> User <span class=\"title function_\">getUserByEmail</span><span class=\"params\">(String email)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!EmailValidation.validate(email)) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// ... throw InvalidEmailException...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//...query db to get user by email...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>上面这段代码，既没有逻辑重复，也没有语义重复，但仍然违反了 DRY 原则。这是因为代码中存在“执行重复”。我们一块儿来看下，到底哪些代码被重复执行了？</li>\n<li>重复执行最明显的一个地方，就是在 login() 函数中，email 的校验逻辑被执行了两次。一次是在调用 checkIfUserExisted() 函数的时候，另一次是调用 getUserByEmail() 函数的时候。这个问题解决起来比较简单，我们只需要将校验逻辑从 UserRepo 中移除，统一放到 UserService 中就可以了。</li>\n<li>除此之外，代码中还有一处比较隐蔽的执行重复，不知道你发现了没有？实际上，login() 函数并不需要调用 checkIfUserExisted() 函数，只需要调用一次 getUserByEmail() 函数，从数据库中获取到用户的 email、password 等信息，然后跟用户输入的 email、password 信息做对比，依次判断是否登录成功。</li>\n<li>实际上，这样的优化是很有必要的。因为 checkIfUserExisted() 函数和 getUserByEmail() 函数都需要查询数据库，而数据库这类的 I&#x2F;O 操作是比较耗时的。我们在写代码的时候，应当尽量减少这类 I&#x2F;O 操作。</li>\n<li>按照刚刚的修改思路，我们把代码重构一下，移除“重复执行”的代码，只校验一次 email 和 password，并且只查询一次数据库。重构之后的代码如下所示：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">UserService</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> UserRepo userRepo;<span class=\"comment\">//通过依赖注入或者IOC框架注入</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> User <span class=\"title function_\">login</span><span class=\"params\">(String email, String password)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!EmailValidation.validate(email)) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// ... throw InvalidEmailException...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!PasswordValidation.validate(password)) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// ... throw InvalidPasswordException...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">User</span> <span class=\"variable\">user</span> <span class=\"operator\">=</span> userRepo.getUserByEmail(email);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (user == <span class=\"literal\">null</span> || !password.equals(user.getPassword()) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// ... throw AuthenticationFailureException...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> user;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">UserRepo</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">checkIfUserExisted</span><span class=\"params\">(String email, String password)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//...query db to check if email&amp;password exists</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> User <span class=\"title function_\">getUserByEmail</span><span class=\"params\">(String email)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//...query db to get user by email...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"代码复用性（Code-Reusability）\"><a href=\"#代码复用性（Code-Reusability）\" class=\"headerlink\" title=\"代码复用性（Code Reusability）\"></a>代码复用性（Code Reusability）</h3><ol>\n<li><p>我们首先来区分三个概念：代码复用性（Code Reusability）、代码复用（Code Resue）和 DRY 原则。代码复用表示一种行为：我们在开发新功能的时候，尽量复用已经存在的代码。代码的可复用性表示一段代码可被复用的特性或能力：我们在编写代码的时候，让代码尽量可复用。DRY 原则是一条原则：不要写重复的代码。从定义描述上，它们好像有点类似，但深究起来，三者的区别还是蛮大的。</p>\n</li>\n<li><p>首先，“不重复”并不代表“可复用”。在一个项目代码中，可能不存在任何重复的代码，但也并不表示里面有可复用的代码，不重复和可复用完全是两个概念。所以，从这个角度来说，DRY 原则跟代码的可复用性讲的是两回事。</p>\n</li>\n<li><p>其次，“复用”和“可复用性”关注角度不同。代码“可复用性”是从代码开发者的角度来讲的，“复用”是从代码使用者的角度来讲的。比如，A 同事编写了一个 UrlUtils 类，代码的“可复用性”很好。B 同事在开发新功能的时候，直接“复用”A 同事编写的 UrlUtils 类。尽管复用、可复用性、DRY 原则这三者从理解上有所区别，但实际上要达到的目的都是类似的，都是为了减少代码量，提高代码的可读性、可维护性。除此之外，复用已经经过测试的老代码，bug 会比从零重新开发要少。</p>\n</li>\n<li><p>“复用”这个概念不仅可以指导细粒度的模块、类、函数的设计开发，实际上，一些框架、类库、组件等的产生也都是为了达到复用的目的。比如，Spring 框架、Google Guava 类库、UI 组件等等。</p>\n</li>\n</ol>\n<h3 id=\"怎么提高代码复用性？\"><a href=\"#怎么提高代码复用性？\" class=\"headerlink\" title=\"怎么提高代码复用性？\"></a>怎么提高代码复用性？</h3><p>实际上，我们前面已经讲到过很多提高代码可复用性的手段，今天算是集中总结一下，我总结了 7 条，具体如下。</p>\n<blockquote>\n<p>减少代码耦合</p>\n</blockquote>\n<p>对于高度耦合的代码，当我们希望复用其中的一个功能，想把这个功能的代码抽取出来成为一个独立的模块、类或者函数的时候，往往会发现牵一发而动全身。移动一点代码，就要牵连到很多其他相关的代码。所以，高度耦合的代码会影响到代码的复用性，我们要尽量减少代码耦合。</p>\n<blockquote>\n<p>满足单一职责原则</p>\n</blockquote>\n<p>我们前面讲过，如果职责不够单一，模块、类设计得大而全，那依赖它的代码或者它依赖的代码就会比较多，进而增加了代码的耦合。根据上一点，也就会影响到代码的复用性。相反，越细粒度的代码，代码的通用性会越好，越容易被复用。</p>\n<blockquote>\n<p>模块化</p>\n</blockquote>\n<p>这里的“模块”，不单单指一组类构成的模块，还可以理解为单个类、函数。我们要善于将功能独立的代码，封装成模块。独立的模块就像一块一块的积木，更加容易复用，可以直接拿来搭建更加复杂的系统。</p>\n<blockquote>\n<p>业务与非业务逻辑分离</p>\n</blockquote>\n<p>越是跟业务无关的代码越是容易复用，越是针对特定业务的代码越难复用。所以，为了复用跟业务无关的代码，我们将业务和非业务逻辑代码分离，抽取成一些通用的框架、类库、组件等。</p>\n<blockquote>\n<p>通用代码下沉</p>\n</blockquote>\n<p>从分层的角度来看，越底层的代码越通用、会被越多的模块调用，越应该设计得足够可复用。一般情况下，在代码分层之后，为了避免交叉调用导致调用关系混乱，我们只允许上层代码调用下层代码及同层代码之间的调用，杜绝下层代码调用上层代码。所以，通用的代码我们尽量下沉到更下层。</p>\n<blockquote>\n<p>继承、多态、抽象、封装</p>\n</blockquote>\n<p>在讲面向对象特性的时候，利用继承，可以将公共的代码抽取到父类，子类复用父类的属性和方法。利用多态，我们可以动态地替换一段代码的部分逻辑，让这段代码可复用。除此之外，抽象和封装，从更加广义的层面、而非狭义的面向对象特性的层面来理解的话，越抽象、越不依赖具体的实现，越容易复用。代码封装成模块，隐藏可变的细节、暴露不变的接口，就越容易复用。</p>\n<blockquote>\n<p>应用模板等设计模式</p>\n</blockquote>\n<p>一些设计模式，也能提高代码的复用性。比如，模板模式利用了多态来实现，可以灵活地替换其中的部分代码，整个流程模板代码可复用。关于应用设计模式提高代码复用性这一部分，我们留在后面慢慢来讲解。除了刚刚我们讲到的几点，还有一些跟编程语言相关的特性，也能提高代码的复用性，比如泛型编程等。实际上，除了上面讲到的这些方法之外，复用意识也非常重要。在写代码的时候，我们要多去思考一下，这</p>\n<h2 id=\"迪米特法则\"><a href=\"#迪米特法则\" class=\"headerlink\" title=\"迪米特法则\"></a>迪米特法则</h2><p>我们讲最后一个设计原则：迪米特法则。尽管它不像 SOLID、KISS、DRY 原则那样，人尽皆知，但它却非常实用。利用这个原则，能够帮我们实现代码的“高内聚、松耦合”。今天，我们就围绕下面几个问题，并结合两个代码实战案例，来深入地学习这个法则。</p>\n<ul>\n<li>什么是“高内聚、松耦合”？</li>\n<li>如何利用迪米特法则来实现“高内聚、松耦合”？</li>\n<li>有哪些代码设计是明显违背迪米特法则的？对此又该如何重构？</li>\n</ul>\n<h3 id=\"何为“高内聚、松耦合”？\"><a href=\"#何为“高内聚、松耦合”？\" class=\"headerlink\" title=\"何为“高内聚、松耦合”？\"></a>何为“高内聚、松耦合”？</h3><ol>\n<li>“高内聚、松耦合”是一个非常重要的设计思想，能够有效地提高代码的可读性和可维护性，缩小功能改动导致的代码改动范围。</li>\n<li>实际上，在前面的章节中，我们已经多次提到过这个设计思想。很多设计原则都以实现代码的“高内聚、松耦合”为目的，比如单一职责原则、基于接口而非实现编程等。实际上，“高内聚、松耦合”是一个比较通用的设计思想，可以用来指导不同粒度代码的设计与开发，比如系统、模块、类，甚至是函数，也可以应用到不同的开发场景中，比如微服务、框架、组件、类库等。为了方便我讲解，接下来我以“类”作为这个设计思想的应用对象来展开讲解，其他应用场景你可以自行类比。</li>\n<li>在这个设计思想中，“高内聚”用来指导类本身的设计，“松耦合”用来指导类与类之间依赖关系的设计。不过，这两者并非完全独立不相干。高内聚有助于松耦合，松耦合又需要高内聚的支持。</li>\n</ol>\n<blockquote>\n<p>那到底什么是“高内聚”呢？</p>\n</blockquote>\n<p>所谓高内聚，就是指相近的功能应该放到同一个类中，不相近的功能不要放到同一个类中。相近的功能往往会被同时修改，放到同一个类中，修改会比较集中，代码容易维护。实际上，我们前面讲过的单一职责原则是实现代码高内聚非常有效的设计原则。</p>\n<blockquote>\n<p>我们再来看一下，什么是“松耦合”？</p>\n</blockquote>\n<p>所谓松耦合是说，在代码中，类与类之间的依赖关系简单清晰。即使两个类有依赖关系，一个类的代码改动不会或者很少导致依赖类的代码改动。实际上，我们前面讲的依赖注入、接口隔离、基于接口而非实现编程，以及今天讲的迪米特法则，都是为了实现代码的松耦合</p>\n<blockquote>\n<p>最后，我们来看一下，“内聚”和“耦合”之间的关系</p>\n</blockquote>\n<p>前面也提到，“高内聚”有助于“松耦合”，同理，“低内聚”也会导致“紧耦合”。关于这一点，我画了一张对比图来解释。图中左边部分的代码结构是“高内聚、松耦合”；右边部分正好相反，是“低内聚、紧耦合”。</p>\n<img src=\"https://npm.elemecdn.com/youthlql@1.0.0/design_patterns/design_principles/0001.png\" />\n\n\n\n\n\n<ol>\n<li>图中左边部分的代码设计中，类的粒度比较小，每个类的职责都比较单一。相近的功能都放到了一个类中，不相近的功能被分割到了多个类中。这样类更加独立，代码的内聚性更好。因为职责单一，所以每个类被依赖的类就会比较少，代码低耦合。一个类的修改，只会影响到一个依赖类的代码改动。我们只需要测试这一个依赖类是否还能正常工作就行了。</li>\n<li>图中右边部分的代码设计中，类粒度比较大，低内聚，功能大而全，不相近的功能放到了一个类中。这就导致很多其他类都依赖这个类。当我们修改这个类的某一个功能代码的时候，会影响依赖它的多个类。我们需要测试这三个依赖类，是否还能正常工作。这也就是所谓的“牵一发而动全身”。</li>\n<li>除此之外，从图中我们也可以看出，高内聚、低耦合的代码结构更加简单、清晰，相应地，在可维护性和可读性上确实要好很多。</li>\n</ol>\n<h3 id=\"“迪米特法则”理论描述\"><a href=\"#“迪米特法则”理论描述\" class=\"headerlink\" title=\"“迪米特法则”理论描述\"></a>“迪米特法则”理论描述</h3><ol>\n<li><p>迪米特法则的英文翻译是：Law of Demeter，缩写是 LOD。单从这个名字上来看，我们完全猜不出这个原则讲的是什么。不过，它还有另外一个更加达意的名字，叫作最小知识原则，英文翻译为：The Least Knowledge Principle。</p>\n</li>\n<li><p>关于这个设计原则，我们先来看一下它最原汁原味的英文定义：</p>\n<blockquote>\n<p>Each unit should have only limited knowledge about other units: only units “closely” related to the current unit. Or: Each unit should only talk to its friends; Don’t talk to strangers.</p>\n</blockquote>\n<p>我们把它直译成中文，就是下面这个样子：</p>\n<blockquote>\n<p>每个模块（unit）只应该了解那些与它关系密切的模块（units: only units “closely” related to the current unit）的有限知识（knowledge）。或者说，每个模块只和自己的朋友“说话”（talk），不和陌生人“说话”（talk）。</p>\n</blockquote>\n<p>我们之前讲过，大部分设计原则和思想都非常抽象，有各种各样的解读，要想灵活地应用到实际的开发中，需要有实战经验的积累。迪米特法则也不例外。所以，我结合我自己的理解和经验，对刚刚的定义重新描述一下。注意，为了统一讲解，我把定义描述中的“模块”替换成了“类”。</p>\n<blockquote>\n<p>不该有直接依赖关系的类之间，不要有依赖；有依赖关系的类之间，尽量只依赖必要的接口（也就是定义中的“有限知识”）。从上面的描述中，我们可以看出，迪米特法则包含前后两部分，这两部分讲的是两件事情，我用两个实战案例分别来解读一下。</p>\n</blockquote>\n</li>\n</ol>\n<h3 id=\"理论解读与代码实战一\"><a href=\"#理论解读与代码实战一\" class=\"headerlink\" title=\"理论解读与代码实战一\"></a>理论解读与代码实战一</h3><ol>\n<li>我们先来看这条原则中的前半部分，<strong>“不该有直接依赖关系的类之间，不要有依赖”</strong>。我举个例子解释一下。</li>\n<li>这个例子实现了简化版的搜索引擎爬取网页的功能。代码中包含三个主要的类。其中，NetworkTransporter 类负责底层网络通信，根据请求获取数据；HtmlDownloader 类用来通过 URL 获取网页；Document 表示网页文档，后续的网页内容抽取、分词、索引都是以此为处理对象。具体的代码实现如下所示：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">NetworkTransporter</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 省略属性和其他方法...</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Byte[] send(HtmlRequest htmlRequest) &#123;</span><br><span class=\"line\">      <span class=\"comment\">//...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">HtmlDownloader</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> NetworkTransporter transporter;<span class=\"comment\">//通过构造函数或IOC注入</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">public</span> Html <span class=\"title function_\">downloadHtml</span><span class=\"params\">(String url)</span> &#123;</span><br><span class=\"line\">    Byte[] rawHtml = transporter.send(<span class=\"keyword\">new</span> <span class=\"title class_\">HtmlRequest</span>(url));</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Html</span>(rawHtml);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Document</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> Html html;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> String url;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"title function_\">Document</span><span class=\"params\">(String url)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.url = url;</span><br><span class=\"line\">    <span class=\"type\">HtmlDownloader</span> <span class=\"variable\">downloader</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">HtmlDownloader</span>();</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.html = downloader.downloadHtml(url);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>这段代码虽然“能用”，能实现我们想要的功能，但是它不够“好用”，有比较多的设计缺陷。你可以先试着思考一下，看看都有哪些缺陷，然后再来看我下面的讲解。</li>\n<li>首先，我们来看 NetworkTransporter 类。作为一个底层网络通信类，我们希望它的功能尽可能通用，而不只是服务于下载 HTML，所以，我们不应该直接依赖太具体的发送对象 HtmlRequest。从这一点上讲，NetworkTransporter 类的设计违背迪米特法则，依赖了不该有直接依赖关系的 HtmlRequest 类。</li>\n<li>我们应该如何进行重构，让 NetworkTransporter 类满足迪米特法则呢？我这里有个形象的比喻。假如你现在要去商店买东西，你肯定不会直接把钱包给收银员，让收银员自己从里面拿钱，而是你从钱包里把钱拿出来交给收银员。这里的 HtmlRequest 对象就相当于钱包，HtmlRequest 里的 address 和 content 对象就相当于钱。我们应该把 address 和 content 交给 NetworkTransporter，而非是直接把 HtmlRequest 交给 NetworkTransporter。根据这个思路，NetworkTransporter 重构之后的代码如下所示：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">NetworkTransporter</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 省略属性和其他方法...</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Byte[] send(String address, Byte[] data) &#123;</span><br><span class=\"line\">      <span class=\"comment\">//...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>我们再来看 HtmlDownloader 类。这个类的设计没有问题。不过，我们修改了 NetworkTransporter 的 send() 函数的定义，而这个类用到了 send() 函数，所以我们需要对它做相应的修改，修改后的代码如下所示</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">HtmlDownloader</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> NetworkTransporter transporter;<span class=\"comment\">//通过构造函数或IOC注入</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">// HtmlDownloader这里也要有相应的修改</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> Html <span class=\"title function_\">downloadHtml</span><span class=\"params\">(String url)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">HtmlRequest</span> <span class=\"variable\">htmlRequest</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">HtmlRequest</span>(url);</span><br><span class=\"line\">    Byte[] rawHtml = transporter.send(</span><br><span class=\"line\">      htmlRequest.getAddress(), htmlRequest.getContent().getBytes());</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Html</span>(rawHtml);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>最后，我们来看下 Document 类。这个类的问题比较多，主要有三点。第一，构造函数中的 downloader.downloadHtml() 逻辑复杂，耗时长，不应该放到构造函数中，会影响代码的可测试性。代码的可测试性我们后面会讲到，这里你先知道有这回事就可以了。第二，HtmlDownloader 对象在构造函数中通过 new 来创建，违反了基于接口而非实现编程的设计思想，也会影响到代码的可测试性。第三，从业务含义上来讲，Document 网页文档没必要依赖 HtmlDownloader 类，违背了迪米特法则。</p>\n<p>虽然 Document 类的问题很多，但修改起来比较简单，只要一处改动就可以解决所有问题。修改之后的代码如下所示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Document</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> Html html;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> String url;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"title function_\">Document</span><span class=\"params\">(String url, Html html)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.html = html;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.url = url;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 通过一个工厂方法来创建Document</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">DocumentFactory</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> HtmlDownloader downloader;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"title function_\">DocumentFactory</span><span class=\"params\">(HtmlDownloader downloader)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.downloader = downloader;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">public</span> Document <span class=\"title function_\">createDocument</span><span class=\"params\">(String url)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">Html</span> <span class=\"variable\">html</span> <span class=\"operator\">=</span> downloader.downloadHtml(url);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Document</span>(url, html);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h3 id=\"理论解读与代码实战二\"><a href=\"#理论解读与代码实战二\" class=\"headerlink\" title=\"理论解读与代码实战二\"></a>理论解读与代码实战二</h3><p>现在，我们再来看一下这条原则中的后半部分：“有依赖关系的类之间，尽量只依赖必要的接口”。我们还是结合一个例子来讲解。下面这段代码非常简单，Serialization 类负责对象的序列化和反序列化</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Serialization</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> String <span class=\"title function_\">serialize</span><span class=\"params\">(Object object)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">serializedResult</span> <span class=\"operator\">=</span> ...;</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> serializedResult;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">public</span> Object <span class=\"title function_\">deserialize</span><span class=\"params\">(String str)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">Object</span> <span class=\"variable\">deserializedResult</span> <span class=\"operator\">=</span> ...;</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> deserializedResult;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<ol>\n<li>单看这个类的设计，没有一点问题。不过，如果我们把它放到一定的应用场景里，那就还有继续优化的空间。假设在我们的项目中，有些类只用到了序列化操作，而另一些类只用到反序列化操作。那基于迪米特法则后半部分“有依赖关系的类之间，尽量只依赖必要的接口”，只用到序列化操作的那部分类不应该依赖反序列化接口。同理，只用到反序列化操作的那部分类不应该依赖序列化接口。</li>\n<li>根据这个思路，我们应该将 Serialization 类拆分为两个更小粒度的类，一个只负责序列化（Serializer 类），一个只负责反序列化（Deserializer 类）。拆分之后，使用序列化操作的类只需要依赖 Serializer 类，使用反序列化操作的类只需要依赖 Deserializer 类。拆分之后的代码如下所示：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Serializer</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> String <span class=\"title function_\">serialize</span><span class=\"params\">(Object object)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">serializedResult</span> <span class=\"operator\">=</span> ...;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">return</span> serializedResult;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Deserializer</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> Object <span class=\"title function_\">deserialize</span><span class=\"params\">(String str)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">Object</span> <span class=\"variable\">deserializedResult</span> <span class=\"operator\">=</span> ...;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">return</span> deserializedResult;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<ol>\n<li>不知道你有没有看出来，尽管拆分之后的代码更能满足迪米特法则，但却违背了高内聚的设计思想。高内聚要求相近的功能要放到同一个类中，这样可以方便功能修改的时候，修改的地方不至于过于分散。对于刚刚这个例子来说，如果我们修改了序列化的实现方式，比如从 JSON 换成了 XML，那反序列化的实现逻辑也需要一并修改。在未拆分的情况下，我们只需要修改一个类即可。在拆分之后，我们需要修改两个类。显然，这种设计思路的代码改动范围变大了。</li>\n<li>如果我们既不想违背高内聚的设计思想，也不想违背迪米特法则，那我们该如何解决这个问题呢？实际上，通过引入两个接口就能轻松解决这个问题，具体的代码如下所示。实际上，我们在讲到“接口隔离原则”的时候，第三个例子就使用了类似的实现思路，你可以结合着一块儿来看。</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">Serializable</span> &#123;</span><br><span class=\"line\">  String <span class=\"title function_\">serialize</span><span class=\"params\">(Object object)</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">Deserializable</span> &#123;</span><br><span class=\"line\">  Object <span class=\"title function_\">deserialize</span><span class=\"params\">(String text)</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Serialization</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Serializable</span>, Deserializable &#123;</span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> String <span class=\"title function_\">serialize</span><span class=\"params\">(Object object)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">serializedResult</span> <span class=\"operator\">=</span> ...;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">return</span> serializedResult;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> Object <span class=\"title function_\">deserialize</span><span class=\"params\">(String str)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">Object</span> <span class=\"variable\">deserializedResult</span> <span class=\"operator\">=</span> ...;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">return</span> deserializedResult;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">DemoClass_1</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> Serializable serializer;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"title function_\">Demo</span><span class=\"params\">(Serializable serializer)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.serializer = serializer;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">DemoClass_2</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> Deserializable deserializer;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"title function_\">Demo</span><span class=\"params\">(Deserializable deserializer)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.deserializer = deserializer;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>尽管我们还是要往 DemoClass_1 的构造函数中，传入包含序列化和反序列化的 Serialization 实现类，但是，我们依赖的 Serializable 接口只包含序列化操作，DemoClass_1 无法使用 Serialization 类中的反序列化接口，对反序列化操作无感知，这也就符合了迪米特法则后半部分所说的“依赖有限接口”的要求。</li>\n<li>实际上，上面的的代码实现思路，也体现了“基于接口而非实现编程”的设计原则，结合迪米特法则，我们可以总结出一条新的设计原则，那就是“基于最小接口而非最大实现编程”。有些同学之前问，新的设计模式和设计原则是怎么创造出来的，实际上，就是在大量的实践中，针对开发痛点总结归纳出来的套路。</li>\n</ol>\n<h3 id=\"辩证思考与灵活应用\"><a href=\"#辩证思考与灵活应用\" class=\"headerlink\" title=\"辩证思考与灵活应用\"></a>辩证思考与灵活应用</h3><ol>\n<li>对于实战二最终的设计思路，你有没有什么不同的观点呢？</li>\n<li>整个类只包含序列化和反序列化两个操作，只用到序列化操作的使用者，即便能够感知到仅有的一个反序列化函数，问题也不大。那为了满足迪米特法则，我们将一个非常简单的类，拆分出两个接口，是否有点过度设计的意思呢？</li>\n<li>设计原则本身没有对错，只有能否用对之说。不要为了应用设计原则而应用设计原则，我们在应用设计原则的时候，一定要具体问题具体分析。</li>\n<li>对于刚刚这个 Serialization 类来说，只包含两个操作，确实没有太大必要拆分成两个接口。但是，如果我们对 Serialization 类添加更多的功能，实现更多更好用的序列化、反序列化函数，我们来重新考虑一下这个问题。修改之后的具体的代码如下</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Serializer</span> &#123; <span class=\"comment\">// 参看JSON的接口定义</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> String <span class=\"title function_\">serialize</span><span class=\"params\">(Object object)</span> &#123; <span class=\"comment\">//... &#125;</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> String <span class=\"title function_\">serializeMap</span><span class=\"params\">(Map map)</span> &#123; <span class=\"comment\">//... &#125;</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> String <span class=\"title function_\">serializeList</span><span class=\"params\">(List list)</span> &#123; <span class=\"comment\">//... &#125;</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">public</span> Object <span class=\"title function_\">deserialize</span><span class=\"params\">(String objectString)</span> &#123; <span class=\"comment\">//... &#125;</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> Map <span class=\"title function_\">deserializeMap</span><span class=\"params\">(String mapString)</span> &#123; <span class=\"comment\">//... &#125;</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> List <span class=\"title function_\">deserializeList</span><span class=\"params\">(String listString)</span> &#123; <span class=\"comment\">//... &#125;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在这种场景下，第二种设计思路要更好些。因为基于之前的应用场景来说，大部分代码只需要用到序列化的功能。对于这部分使用者，没必要了解反序列化的“知识”，而修改之后的 Serialization 类，反序列化的“知识”，从一个函数变成了三个。一旦任一反序列化操作有代码改动，我们都需要检查、测试所有依赖 Serialization 类的代码是否还能正常工作。为了减少耦合和测试工作量，我们应该按照迪米特法则，将反序列化和序列化的功能隔离开来。</p>\n"},{"title":"设计模式-03.02-创建型-工厂&建造者&原型","keywords":"设计模式，工厂，建造者，原型","description":"详解常用的工厂模式和建造者模式，以及不常用的原型模式","cover":"https://npm.elemecdn.com/lql_static@latest/logo/design_patterns.jpg","abbrlink":"ba432704","date":"2024-06-18T05:21:58.000Z","_content":"\n\n# 声明\n\n> 1. 此系列文章非本人原创，是学习笔记。\n> 2. 设计模式系列以后会持续更新，包括已经发布的设计模式文章，因为后续还要再多看一下书，教程和开源项目等，继续润色文章。\n\n\n\n# 工厂模式【常用】\n\n> 工厂模式很重要，后面的很多架构设计，都是工厂模式联合着其它设计模式使用。\n\n1. 一般情况下，工厂模式分为三种更加细分的类型：简单工厂、工厂方法和抽象工厂。不过，在 GoF 的《设计模式》一书中，它将简单工厂模式看作是工厂方法模式的一种特例，所以工厂模式只被分成了工厂方法和抽象工厂两类。实际上，前面一种分类方法更加常见，所以，在今天的讲解中，我们沿用第一种分类方法。\n\n2. 在这三种细分的工厂模式中，简单工厂、工厂方法原理比较简单，在实际的项目中也比较常用。而抽象工厂的原理稍微复杂点，在实际的项目中相对也不常用。所以，我们今天讲解的重点是前两种工厂模式。对于抽象工厂，稍微了解一下即可。\n\n3. 除此之外，我们讲解的重点也不是原理和实现，因为这些都很简单，重点还是带你搞清楚应用场景：什么时候该用工厂模式？相对于直接 new 来创建对象，用工厂模式来创建究竟有什么好处呢？\n\n## 简单工厂（Simple Factory）\n\n首先，我们来看，什么是简单工厂模式。我们通过一个例子来解释一下。\n\n在下面这段代码中，我们根据配置文件的后缀（json、xml、yaml、properties），选择不同的解析器（JsonRuleConfigParser、XmlRuleConfigParser……），将存储在文件中的配置解析成内存对象 RuleConfig。\n\n```java\npublic class RuleConfigSource {\n  public RuleConfig load(String ruleConfigFilePath) {\n    String ruleConfigFileExtension = getFileExtension(ruleConfigFilePath);\n    IRuleConfigParser parser = null;\n    if (\"json\".equalsIgnoreCase(ruleConfigFileExtension)) {\n      parser = new JsonRuleConfigParser();\n    } else if (\"xml\".equalsIgnoreCase(ruleConfigFileExtension)) {\n      parser = new XmlRuleConfigParser();\n    } else if (\"yaml\".equalsIgnoreCase(ruleConfigFileExtension)) {\n      parser = new YamlRuleConfigParser();\n    } else if (\"properties\".equalsIgnoreCase(ruleConfigFileExtension)) {\n      parser = new PropertiesRuleConfigParser();\n    } else {\n      throw new InvalidRuleConfigException(\n             \"Rule config file format is not supported: \" + ruleConfigFilePath);\n    }\n\n    String configText = \"\";\n    //从ruleConfigFilePath文件中读取配置文本到configText中\n    RuleConfig ruleConfig = parser.parse(configText);\n    return ruleConfig;\n  }\n\n  private String getFileExtension(String filePath) {\n    //...解析文件名获取扩展名，比如rule.json，返回json\n    return \"json\";\n  }\n}\n```\n\n为了让代码逻辑更加清晰，可读性更好，我们要善于将功能独立的代码块封装成函数。按照这个设计思路，我们可以将代码中涉及 parser 创建的部分逻辑剥离出来，抽象成 createParser() 函数。重构之后的代码如下所示：\n\n\n\n```java\n  public RuleConfig load(String ruleConfigFilePath) {\n    String ruleConfigFileExtension = getFileExtension(ruleConfigFilePath);\n    IRuleConfigParser parser = createParser(ruleConfigFileExtension);\n    if (parser == null) {\n      throw new InvalidRuleConfigException(\n              \"Rule config file format is not supported: \" + ruleConfigFilePath);\n    }\n\n    String configText = \"\";\n    //从ruleConfigFilePath文件中读取配置文本到configText中\n    RuleConfig ruleConfig = parser.parse(configText);\n    return ruleConfig;\n  }\n\n  private String getFileExtension(String filePath) {\n    //...解析文件名获取扩展名，比如rule.json，返回json\n    return \"json\";\n  }\n\n  private IRuleConfigParser createParser(String configFormat) {\n    IRuleConfigParser parser = null;\n    if (\"json\".equalsIgnoreCase(configFormat)) {\n      parser = new JsonRuleConfigParser();\n    } else if (\"xml\".equalsIgnoreCase(configFormat)) {\n      parser = new XmlRuleConfigParser();\n    } else if (\"yaml\".equalsIgnoreCase(configFormat)) {\n      parser = new YamlRuleConfigParser();\n    } else if (\"properties\".equalsIgnoreCase(configFormat)) {\n      parser = new PropertiesRuleConfigParser();\n    }\n    return parser;\n  }\n}\n```\n\n\n\n为了让类的职责更加单一(**设计模式原则中的单一职责**，)、代码更加清晰，我们还可以进一步将 createParser() 函数剥离到一个独立的类中，让这个类只负责对象的创建。而这个类就是我们现在要讲的简单工厂模式类。具体的代码如下所示：\n\n```java\npublic class RuleConfigSource {\n  public RuleConfig load(String ruleConfigFilePath) {\n    String ruleConfigFileExtension = getFileExtension(ruleConfigFilePath);\n    IRuleConfigParser parser = RuleConfigParserFactory.createParser(ruleConfigFileExtension);\n    if (parser == null) {\n      throw new InvalidRuleConfigException(\n              \"Rule config file format is not supported: \" + ruleConfigFilePath);\n    }\n\n    String configText = \"\";\n    //从ruleConfigFilePath文件中读取配置文本到configText中\n    RuleConfig ruleConfig = parser.parse(configText);\n    return ruleConfig;\n  }\n\n  private String getFileExtension(String filePath) {\n    //...解析文件名获取扩展名，比如rule.json，返回json\n    return \"json\";\n  }\n}\n\npublic class RuleConfigParserFactory {\n  public static IRuleConfigParser createParser(String configFormat) {\n    IRuleConfigParser parser = null;\n    if (\"json\".equalsIgnoreCase(configFormat)) {\n      parser = new JsonRuleConfigParser();\n    } else if (\"xml\".equalsIgnoreCase(configFormat)) {\n      parser = new XmlRuleConfigParser();\n    } else if (\"yaml\".equalsIgnoreCase(configFormat)) {\n      parser = new YamlRuleConfigParser();\n    } else if (\"properties\".equalsIgnoreCase(configFormat)) {\n      parser = new PropertiesRuleConfigParser();\n    }\n    return parser;\n  }\n}\n```\n\n\n\n1. 在上面的代码实现中，我们每次调用 RuleConfigParserFactory 的 createParser() 的时候，都要创建一个新的 parser。\n2. 实际上，如果 parser 可以复用，为了节省内存和对象创建的时间，我们可以将 parser 事先创建好缓存起来。当调用 createParser() 函数的时候，我们从缓存中取出 parser 对象直接使用。这有点类似单例模式和简单工厂模式的结合，具体的代码实现如下所示。在接下来的讲解中，我们把上一种实现方法叫作简单工厂模式的第一种实现方法，把下面这种实现方法叫作简单工厂模式的第二种实现方法。\n\n\n\n```java\npublic class RuleConfigParserFactory {\n  private static final Map<String, RuleConfigParser> cachedParsers = new HashMap<>();\n\n  static {\n    cachedParsers.put(\"json\", new JsonRuleConfigParser());\n    cachedParsers.put(\"xml\", new XmlRuleConfigParser());\n    cachedParsers.put(\"yaml\", new YamlRuleConfigParser());\n    cachedParsers.put(\"properties\", new PropertiesRuleConfigParser());\n  }\n\n  public static IRuleConfigParser createParser(String configFormat) {\n    if (configFormat == null || configFormat.isEmpty()) {\n      return null;//返回null还是IllegalArgumentException全凭你自己说了算\n    }\n    IRuleConfigParser parser = cachedParsers.get(configFormat.toLowerCase());\n    return parser;\n  }\n}\n```\n\n\n\n1. 对于上面两种简单工厂模式的实现方法，如果我们要添加新的 parser，那势必要改动到 RuleConfigParserFactory 的代码，那这是不是违反开闭原则呢？实际上，如果不是需要频繁地添加新的 parser，只是偶尔修改一下 RuleConfigParserFactory 代码，稍微不符合开闭原则，也是完全可以接受的。\n2. 除此之外，在 RuleConfigParserFactory 的第一种代码实现中，有一组 if 分支判断逻辑，是不是应该用多态或其他设计模式来替代呢？实际上，如果 if 分支并不是很多，代码中有 if 分支也是完全可以接受的。应用多态或设计模式来替代 if 分支判断逻辑，也并不是没有任何缺点的，它虽然提高了代码的扩展性，更加符合**开闭原则**，但也增加了类的个数，牺牲了代码的可读性。关于这一点，我们在后面章节中会详细讲到。\n3. 总结一下，尽管简单工厂模式的代码实现中，有多处 if 分支判断逻辑，违背开闭原则，但权衡扩展性和可读性，这样的代码实现在大多数情况下（比如，不需要频繁地添加 parser，也没有太多的 parser）是没有问题的。\n\n\n\n## 工厂方法（Factory Method）\n\n如果我们非得要将 if 分支逻辑去掉，那该怎么办呢？比较经典处理方法就是利用多态。按照多态的实现思路，对上面的代码进行重构。重构之后的代码如下所示：\n\n```java\npublic interface IRuleConfigParserFactory {\n  IRuleConfigParser createParser();\n}\n\npublic class JsonRuleConfigParserFactory implements IRuleConfigParserFactory {\n  @Override\n  public IRuleConfigParser createParser() {\n    return new JsonRuleConfigParser();\n  }\n}\n\npublic class XmlRuleConfigParserFactory implements IRuleConfigParserFactory {\n  @Override\n  public IRuleConfigParser createParser() {\n    return new XmlRuleConfigParser();\n  }\n}\n\npublic class YamlRuleConfigParserFactory implements IRuleConfigParserFactory {\n  @Override\n  public IRuleConfigParser createParser() {\n    return new YamlRuleConfigParser();\n  }\n}\n\npublic class PropertiesRuleConfigParserFactory implements IRuleConfigParserFactory {\n  @Override\n  public IRuleConfigParser createParser() {\n    return new PropertiesRuleConfigParser();\n  }\n}\n```\n\n\n\n实际上，这就是工厂方法模式的典型代码实现。这样当我们新增一种 parser 的时候，只需要新增一个实现了 IRuleConfigParserFactory 接口的 Factory 类即可。所以，工厂方法模式比起简单工厂模式更加符合开闭原则。\n\n\n\n从上面的工厂方法的实现来看，一切都很完美，但是实际上存在挺大的问题。问题存在于这些工厂类的使用上。接下来，我们看一下，如何用这些工厂类来实现 RuleConfigSource 的 load() 函数。具体的代码如下所示：\n\n\n\n```java\npublic class RuleConfigSource {\n  public RuleConfig load(String ruleConfigFilePath) {\n    String ruleConfigFileExtension = getFileExtension(ruleConfigFilePath);\n\n    IRuleConfigParserFactory parserFactory = null;\n    if (\"json\".equalsIgnoreCase(ruleConfigFileExtension)) {\n      parserFactory = new JsonRuleConfigParserFactory();\n    } else if (\"xml\".equalsIgnoreCase(ruleConfigFileExtension)) {\n      parserFactory = new XmlRuleConfigParserFactory();\n    } else if (\"yaml\".equalsIgnoreCase(ruleConfigFileExtension)) {\n      parserFactory = new YamlRuleConfigParserFactory();\n    } else if (\"properties\".equalsIgnoreCase(ruleConfigFileExtension)) {\n      parserFactory = new PropertiesRuleConfigParserFactory();\n    } else {\n      throw new InvalidRuleConfigException(\"Rule config file format is not supported: \" + ruleConfigFilePath);\n    }\n    IRuleConfigParser parser = parserFactory.createParser();\n\n    String configText = \"\";\n    //从ruleConfigFilePath文件中读取配置文本到configText中\n    RuleConfig ruleConfig = parser.parse(configText);\n    return ruleConfig;\n  }\n\n  private String getFileExtension(String filePath) {\n    //...解析文件名获取扩展名，比如rule.json，返回json\n    return \"json\";\n  }\n}\n```\n\n\n\n1. 从上面的代码实现来看，工厂类对象的创建逻辑又耦合进了 load() 函数中，跟我们最初的代码版本非常相似，引入工厂方法非但没有解决问题，反倒让设计变得更加复杂了。那怎么来解决这个问题呢？\n2. 我们可以为工厂类再创建一个简单工厂，也就是工厂的工厂，用来创建工厂类对象。这段话听起来有点绕，我把代码实现出来了，你一看就能明白了。其中，RuleConfigParserFactoryMap 类是创建工厂对象的工厂类，getParserFactory() 返回的是缓存好的单例工厂对象。\n\n```java\npublic class RuleConfigSource {\n  public RuleConfig load(String ruleConfigFilePath) {\n    String ruleConfigFileExtension = getFileExtension(ruleConfigFilePath);\n\n    IRuleConfigParserFactory parserFactory = RuleConfigParserFactoryMap.getParserFactory(ruleConfigFileExtension);\n    if (parserFactory == null) {\n      throw new InvalidRuleConfigException(\"Rule config file format is not supported: \" + ruleConfigFilePath);\n    }\n    IRuleConfigParser parser = parserFactory.createParser();\n\n    String configText = \"\";\n    //从ruleConfigFilePath文件中读取配置文本到configText中\n    RuleConfig ruleConfig = parser.parse(configText);\n    return ruleConfig;\n  }\n\n  private String getFileExtension(String filePath) {\n    //...解析文件名获取扩展名，比如rule.json，返回json\n    return \"json\";\n  }\n}\n\n//因为工厂类只包含方法，不包含成员变量，完全可以复用，\n//不需要每次都创建新的工厂类对象，所以，简单工厂模式的第二种实现思路更加合适。\npublic class RuleConfigParserFactoryMap { //工厂的工厂\n  private static final Map<String, IRuleConfigParserFactory> cachedFactories = new HashMap<>();\n\n  static {\n    cachedFactories.put(\"json\", new JsonRuleConfigParserFactory());\n    cachedFactories.put(\"xml\", new XmlRuleConfigParserFactory());\n    cachedFactories.put(\"yaml\", new YamlRuleConfigParserFactory());\n    cachedFactories.put(\"properties\", new PropertiesRuleConfigParserFactory());\n  }\n\n  public static IRuleConfigParserFactory getParserFactory(String type) {\n    if (type == null || type.isEmpty()) {\n      return null;\n    }\n    IRuleConfigParserFactory parserFactory = cachedFactories.get(type.toLowerCase());\n    return parserFactory;\n  }\n}\n```\n\n\n\n1. 当我们需要添加新的规则配置解析器的时候，我们只需要创建新的 parser 类和 parser factory 类，并且在 RuleConfigParserFactoryMap 类中，将新的 parser factory 对象添加到 cachedFactories 中即可。代码的改动非常少，基本上符合开闭原则。\n2. 实际上，对于规则配置文件解析这个应用场景来说，工厂模式需要额外创建诸多 Factory 类，也会增加代码的复杂性，而且，每个 Factory 类只是做简单的 new 操作，功能非常单薄（只有一行代码），也没必要设计成独立的类，所以，在这个应用场景下，简单工厂模式简单好用，比工厂方法模式更加合适。\n\n\n\n### 那什么时候该用工厂方法模式，而非简单工厂模式呢？\n\n1. 我们前面提到，之所以将某个代码块剥离出来，独立为函数或者类，原因是这个代码块的逻辑过于复杂，剥离之后能让代码更加清晰，更加可读、可维护。但是，如果代码块本身并不复杂，就几行代码而已，我们完全没必要将它拆分成单独的函数或者类。\n2. 基于这个设计思想，当对象的创建逻辑比较复杂，不只是简单的 new 一下就可以，而是要组合其他类对象，做各种初始化操作的时候，我们推荐使用工厂方法模式，将复杂的创建逻辑拆分到多个工厂类中，让每个工厂类都不至于过于复杂。而使用简单工厂模式，将所有的创建逻辑都放到一个工厂类中，会导致这个工厂类变得很复杂。\n3. 除此之外，在某些场景下，如果对象不可复用，那工厂类每次都要返回不同的对象。如果我们使用简单工厂模式来实现，就只能选择第一种包含 if 分支逻辑的实现方式。如果我们还想避免烦人的 if-else 分支逻辑，这个时候，我们就推荐使用工厂方法模式。\n\n\n\n## 抽象工厂（Abstract Factory）\n\n1. 讲完了简单工厂、工厂方法，我们再来看抽象工厂模式。抽象工厂模式的应用场景比较特殊，没有前两种常用，所以不是我们学习的重点，你简单了解一下就可以了。\n2. 在简单工厂和工厂方法中，类只有一种分类方式。比如，在规则配置解析那个例子中，解析器类只会根据配置文件格式（Json、Xml、Yaml……）来分类。但是，如果类有两种分类方式，比如，我们既可以按照配置文件格式来分类，也可以按照解析的对象（Rule 规则配置还是 System 系统配置）来分类，那就会对应下面这 8 个 parser 类。\n\n```java\n针对规则配置的解析器：基于接口IRuleConfigParser\nJsonRuleConfigParser\nXmlRuleConfigParser\nYamlRuleConfigParser\nPropertiesRuleConfigParser\n\n针对系统配置的解析器：基于接口ISystemConfigParser\nJsonSystemConfigParser\nXmlSystemConfigParser\nYamlSystemConfigParser\nPropertiesSystemConfigParser\n```\n\n\n\n1. 针对这种特殊的场景，如果还是继续用工厂方法来实现的话，我们要针对每个 parser 都编写一个工厂类，也就是要编写 8 个工厂类。如果我们未来还需要增加针对业务配置的解析器（比如 IBizConfigParser），那就要再对应地增加 4 个工厂类。而我们知道，过多的类也会让系统难维护。这个问题该怎么解决呢？\n2. 抽象工厂就是针对这种非常特殊的场景而诞生的。我们可以让一个工厂负责创建多个不同类型的对象（IRuleConfigParser、ISystemConfigParser 等），而不是只创建一种 parser 对象。这样就可以有效地减少工厂类的个数。具体的代码实现如下所示：\n\n```java\npublic interface IConfigParserFactory {\n  IRuleConfigParser createRuleParser();\n  ISystemConfigParser createSystemParser();\n  //此处可以扩展新的parser类型，比如IBizConfigParser\n}\n\npublic class JsonConfigParserFactory implements IConfigParserFactory {\n  @Override\n  public IRuleConfigParser createRuleParser() {\n    return new JsonRuleConfigParser();\n  }\n\n  @Override\n  public ISystemConfigParser createSystemParser() {\n    return new JsonSystemConfigParser();\n  }\n}\n\npublic class XmlConfigParserFactory implements IConfigParserFactory {\n  @Override\n  public IRuleConfigParser createRuleParser() {\n    return new XmlRuleConfigParser();\n  }\n\n  @Override\n  public ISystemConfigParser createSystemParser() {\n    return new XmlSystemConfigParser();\n  }\n}\n\n// 省略YamlConfigParserFactory和PropertiesConfigParserFactory代码\n```\n\n\n\n## 如何设计实现一个Dependency Injection框架？\n\n\n\n当创建对象是一个“大工程”的时候，我们一般会选择使用工厂模式，来封装对象复杂的创建过程，将对象的创建和使用分离，让代码更加清晰。那何为“大工程”呢？上面我们讲了两种情况，一种是创建过程涉及复杂的 if-else 分支判断，另一种是对象创建需要组装多个其他类对象或者需要复杂的初始化过程。\n\n\n\n今天，我们再来讲一个创建对象的“大工程”，依赖注入框架，或者叫依赖注入容器（Dependency Injection Container），简称 DI 容器。在今天的讲解中，我会带你一块搞清楚这样几个问题：DI 容器跟我们讲的工厂模式又有何区别和联系？DI 容器的核心功能有哪些，以及如何实现一个简单的 DI 容器？\n\n\n\n\n\n### 工厂模式和 DI 容器有何区别？\n\n1. 实际上，DI 容器底层最基本的设计思路就是基于工厂模式的。DI 容器相当于一个大的工厂类，负责在程序启动的时候，根据配置（要创建哪些类对象，每个类对象的创建需要依赖哪些其他类对象）事先创建好对象。当应用程序需要使用某个类对象的时候，直接从容器中获取即可。正是因为它持有一堆对象，所以这个框架才被称为“容器”。\n2. DI 容器相对于我们上面讲的工厂模式的例子来说，它处理的是更大的对象创建工程。上面讲的工厂模式中，一个工厂类只负责某个类对象或者某一组相关类对象（继承自同一抽象类或者接口的子类）的创建，而 DI 容器负责的是整个应用中所有类对象的创建。\n3. 除此之外，DI 容器负责的事情要比单纯的工厂模式要多。比如，它还包括配置的解析、对象生命周期的管理。接下来，我们就详细讲讲，一个简单的 DI 容器应该包含哪些核心功能。\n\n\n\n### DI 容器的核心功能有哪些？\n\n总结一下，一个简单的 DI 容器的核心功能一般有三个：配置解析、对象创建和对象生命周期管理。\n\n\n\n> 首先，我们来看配置解析。\n\n1. 在上面讲的工厂模式中，工厂类要创建哪个类对象是事先确定好的，并且是写死在工厂类代码中的。作为一个通用的框架来说，框架代码跟应用代码应该是高度解耦的，DI 容器事先并不知道应用会创建哪些对象，不可能把某个应用要创建的对象写死在框架代码中。所以，我们需要通过一种形式，让应用告知 DI 容器要创建哪些对象。这种形式就是我们要讲的配置。\n2. 我们将需要由 DI 容器来创建的类对象和创建类对象的必要信息（使用哪个构造函数以及对应的构造函数参数都是什么等等），放到配置文件中。容器读取配置文件，根据配置文件提供的信息来创建对象。\n3. 下面是一个典型的 Spring 容器的配置文件。Spring 容器读取这个配置文件，解析出要创建的两个对象：rateLimiter 和 redisCounter，并且得到两者的依赖关系：rateLimiter 依赖 redisCounter。\n\n\n\n```java\npublic class RateLimiter {\n  private RedisCounter redisCounter;\n  public RateLimiter(RedisCounter redisCounter) {\n    this.redisCounter = redisCounter;\n  }\n  public void test() {\n    System.out.println(\"Hello World!\");\n  }\n  //...\n}\n\npublic class RedisCounter {\n  private String ipAddress;\n  private int port;\n  public RedisCounter(String ipAddress, int port) {\n    this.ipAddress = ipAddress;\n    this.port = port;\n  }\n  //...\n}\n\n配置文件beans.xml：\n<beans>\n   <bean id=\"rateLimiter\" class=\"com.xzg.RateLimiter\">\n      <constructor-arg ref=\"redisCounter\"/>\n   </bean>\n \n   <bean id=\"redisCounter\" class=\"com.xzg.redisCounter\">\n     <constructor-arg type=\"String\" value=\"127.0.0.1\">\n     <constructor-arg type=\"int\" value=1234>\n   </bean>\n</beans>\n```\n\n\n\n> 其次，我们再来看对象创建。\n\n1. 在 DI 容器中，如果我们给每个类都对应创建一个工厂类，那项目中类的个数会成倍增加，这会增加代码的维护成本。要解决这个问题并不难。我们只需要将所有类对象的创建都放到一个工厂类中完成就可以了，比如 BeansFactory。\n2. 你可能会说，如果要创建的类对象非常多，BeansFactory 中的代码会不会线性膨胀（代码量跟创建对象的个数成正比）呢？实际上并不会。待会讲到 DI 容器的具体实现的时候，我们会讲“反射”这种机制，它能在程序运行的过程中，动态地加载类、创建对象，不需要事先在代码中写死要创建哪些对象。所以，不管是创建一个对象还是十个对象，BeansFactory 工厂类代码都是一样的。\n\n\n\n> 最后，我们来看对象的生命周期管理。\n\n1. 上面我们讲到，简单工厂模式有两种实现方式，一种是每次都返回新创建的对象，另一种是每次都返回同一个事先创建好的对象，也就是所谓的单例对象。在 Spring 框架中，我们可以通过配置 scope 属性，来区分这两种不同类型的对象。scope=prototype 表示返回新创建的对象，scope=singleton 表示返回单例对象。\n2. 除此之外，我们还可以配置对象是否支持懒加载。如果 lazy-init=true，对象在真正被使用到的时候（比如：BeansFactory.getBean(“userService”)）才被被创建；如果 lazy-init=false，对象在应用启动的时候就事先创建好。\n3. 不仅如此，我们还可以配置对象的 init-method 和 destroy-method 方法，比如 init-method=loadProperties()，destroy-method=updateConfigFile()。DI 容器在创建好对象之后，会主动调用 init-method 属性指定的方法来初始化对象。在对象被最终销毁之前，DI 容器会主动调用 destroy-method 属性指定的方法来做一些清理工作，比如释放数据库连接池、关闭文件。\n\n\n\n## 如何实现一个简单的 DI 容器？\n\n用 Java 语言来实现一个简单的 DI 容器，核心逻辑只需要包括这样两个部分：配置文件解析、根据配置文件通过“反射”语法来创建对象。\n\n\n\n### 最小原型设计\n\n因为我们主要是讲解设计模式，所以，在今天的讲解中，我们只实现一个 DI 容器的最小原型。像 Spring 框架这样的 DI 容器，它支持的配置格式非常灵活和复杂。为了简化代码实现，重点讲解原理，在最小原型中，我们只支持下面配置文件中涉及的配置语法。\n\n```java\n配置文件beans.xml\n<beans>\n   <bean id=\"rateLimiter\" class=\"com.xzg.RateLimiter\">\n      <constructor-arg ref=\"redisCounter\"/>\n   </bean>\n \n   <bean id=\"redisCounter\" class=\"com.xzg.redisCounter\" scope=\"singleton\" lazy-init=\"true\">\n     <constructor-arg type=\"String\" value=\"127.0.0.1\">\n     <constructor-arg type=\"int\" value=1234>\n   </bean>\n</bean\n```\n\n\n\n最小原型的使用方式跟 Spring 框架非常类似，示例代码如下所示：\n\n```java\npublic class Demo {\n  public static void main(String[] args) {\n    ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\n            \"beans.xml\");\n    RateLimiter rateLimiter = (RateLimiter) applicationContext.getBean(\"rateLimiter\");\n    rateLimiter.test();\n    //...\n  }\n}\n```\n\n\n\n### 提供执行入口\n\n面向对象设计的最后一步是：组装类并提供执行入口。在这里，执行入口就是一组暴露给外部使用的接口和类。通过刚刚的最小原型使用示例代码，我们可以看出，执行入口主要包含两部分：ApplicationContext 和 ClassPathXmlApplicationContext。其中，ApplicationContext 是接口，ClassPathXmlApplicationContext 是接口的实现类。两个类具体实现如下所示：\n\n\n\n```java\npublic interface ApplicationContext {\n  Object getBean(String beanId);\n}\n\npublic class ClassPathXmlApplicationContext implements ApplicationContext {\n  private BeansFactory beansFactory;\n  private BeanConfigParser beanConfigParser;\n\n  public ClassPathXmlApplicationContext(String configLocation) {\n    this.beansFactory = new BeansFactory();\n    this.beanConfigParser = new XmlBeanConfigParser();\n    loadBeanDefinitions(configLocation);\n  }\n\n  private void loadBeanDefinitions(String configLocation) {\n    InputStream in = null;\n    try {\n      in = this.getClass().getResourceAsStream(\"/\" + configLocation);\n      if (in == null) {\n        throw new RuntimeException(\"Can not find config file: \" + configLocation);\n      }\n      List<BeanDefinition> beanDefinitions = beanConfigParser.parse(in);\n      beansFactory.addBeanDefinitions(beanDefinitions);\n    } finally {\n      if (in != null) {\n        try {\n          in.close();\n        } catch (IOException e) {\n          // TODO: log error\n        }\n      }\n    }\n  }\n\n  @Override\n  public Object getBean(String beanId) {\n    return beansFactory.getBean(beanId);\n  }\n}\n```\n\n从上面的代码中，我们可以看出，ClassPathXmlApplicationContext 负责组装 BeansFactory 和 BeanConfigParser 两个类，串联执行流程：从 classpath 中加载 XML 格式的配置文件，通过 BeanConfigParser 解析为统一的 BeanDefinition 格式，然后，BeansFactory 根据 BeanDefinition 来创建对象。\n\n\n\n### 配置文件解析\n\n配置文件解析主要包含 BeanConfigParser 接口和 XmlBeanConfigParser 实现类，负责将配置文件解析为 BeanDefinition 结构，以便 BeansFactory 根据这个结构来创建对象。配置文件的解析比较繁琐，不涉及我们要讲的理论知识，不是我们讲解的重点，所以这里我只给出两个类的大致设计思路，并未给出具体的实现代码。如果感兴趣的话，你可以自行补充完整。具体的代码框架如下所示：\n\n```java\npublic interface BeanConfigParser {\n  List<BeanDefinition> parse(InputStream inputStream);\n  List<BeanDefinition> parse(String configContent);\n}\n\npublic class XmlBeanConfigParser implements BeanConfigParser {\n\n  @Override\n  public List<BeanDefinition> parse(InputStream inputStream) {\n    String content = null;\n    // TODO:...\n    return parse(content);\n  }\n\n  @Override\n  public List<BeanDefinition> parse(String configContent) {\n    List<BeanDefinition> beanDefinitions = new ArrayList<>();\n    // TODO:...\n    return beanDefinitions;\n  }\n\n}\n\npublic class BeanDefinition {\n  private String id;\n  private String className;\n  private List<ConstructorArg> constructorArgs = new ArrayList<>();\n  private Scope scope = Scope.SINGLETON;\n  private boolean lazyInit = false;\n  // 省略必要的getter/setter/constructors\n \n  public boolean isSingleton() {\n    return scope.equals(Scope.SINGLETON);\n  }\n\n\n  public static enum Scope {\n    SINGLETON,\n    PROTOTYPE\n  }\n  \n  public static class ConstructorArg {\n    private boolean isRef;\n    private Class type;\n    private Object arg;\n    // 省略必要的getter/setter/constructors\n  }\n}\n```\n\n\n\n### 核心工厂类设计\n\n1. 最后，我们来看，BeansFactory 是如何设计和实现的。这也是我们这个 DI 容器最核心的一个类了。它负责根据从配置文件解析得到的 BeanDefinition 来创建对象。\n2. 如果对象的 scope 属性是 singleton，那对象创建之后会缓存在 singletonObjects 这样一个 map 中，下次再请求此对象的时候，直接从 map 中取出返回，不需要重新创建。如果对象的 scope 属性是 prototype，那每次请求对象，BeansFactory 都会创建一个新的对象返回。\n3. 实际上，BeansFactory 创建对象用到的主要技术点就是 Java 中的反射语法：一种动态加载类和创建对象的机制。我们知道，JVM 在启动的时候会根据代码自动地加载类、创建对象。至于都要加载哪些类、创建哪些对象，这些都是在代码中写死的，或者说提前写好的。但是，如果某个对象的创建并不是写死在代码中，而是放到配置文件中，我们需要在程序运行期间，动态地根据配置文件来加载类、创建对象，那这部分工作就没法让 JVM 帮我们自动完成了，我们需要利用 Java 提供的反射语法自己去编写代码。\n4. 搞清楚了反射的原理，BeansFactory 的代码就不难看懂了。具体代码实现如下所示：\n\n\n\n```java\npublic class BeansFactory {\n  private ConcurrentHashMap<String, Object> singletonObjects = new ConcurrentHashMap<>();\n  private ConcurrentHashMap<String, BeanDefinition> beanDefinitions = new ConcurrentHashMap<>();\n\n  public void addBeanDefinitions(List<BeanDefinition> beanDefinitionList) {\n    for (BeanDefinition beanDefinition : beanDefinitionList) {\n      this.beanDefinitions.putIfAbsent(beanDefinition.getId(), beanDefinition);\n    }\n\n    for (BeanDefinition beanDefinition : beanDefinitionList) {\n      if (beanDefinition.isLazyInit() == false && beanDefinition.isSingleton()) {\n        createBean(beanDefinition);\n      }\n    }\n  }\n\n  public Object getBean(String beanId) {\n    BeanDefinition beanDefinition = beanDefinitions.get(beanId);\n    if (beanDefinition == null) {\n      throw new NoSuchBeanDefinitionException(\"Bean is not defined: \" + beanId);\n    }\n    return createBean(beanDefinition);\n  }\n\n  @VisibleForTesting\n  protected Object createBean(BeanDefinition beanDefinition) {\n    if (beanDefinition.isSingleton() && singletonObjects.contains(beanDefinition.getId())) {\n      return singletonObjects.get(beanDefinition.getId());\n    }\n\n    Object bean = null;\n    try {\n      Class beanClass = Class.forName(beanDefinition.getClassName());\n      List<BeanDefinition.ConstructorArg> args = beanDefinition.getConstructorArgs();\n      if (args.isEmpty()) {\n        bean = beanClass.newInstance();\n      } else {\n        Class[] argClasses = new Class[args.size()];\n        Object[] argObjects = new Object[args.size()];\n        for (int i = 0; i < args.size(); ++i) {\n          BeanDefinition.ConstructorArg arg = args.get(i);\n          if (!arg.getIsRef()) {\n            argClasses[i] = arg.getType();\n            argObjects[i] = arg.getArg();\n          } else {\n            BeanDefinition refBeanDefinition = beanDefinitions.get(arg.getArg());\n            if (refBeanDefinition == null) {\n              throw new NoSuchBeanDefinitionException(\"Bean is not defined: \" + arg.getArg());\n            }\n            argClasses[i] = Class.forName(refBeanDefinition.getClassName());\n            argObjects[i] = createBean(refBeanDefinition);\n          }\n        }\n        bean = beanClass.getConstructor(argClasses).newInstance(argObjects);\n      }\n    } catch (ClassNotFoundException | IllegalAccessException\n            | InstantiationException | NoSuchMethodException | InvocationTargetException e) {\n      throw new BeanCreationFailureException(\"\", e);\n    }\n\n    if (bean != null && beanDefinition.isSingleton()) {\n      singletonObjects.putIfAbsent(beanDefinition.getId(), bean);\n      return singletonObjects.get(beanDefinition.getId());\n    }\n    return bean;\n  }\n}\n```\n\n1. 执行入口那里调用`addBeanDefinitions`\n2. 然后`addBeanDefinitions`再调用createBean利用反射创建对象，如果对象的 scope 属性是 singleton，那对象创建之后会缓存在 singletonObjects 这样一个 map 中\n3. 最后最小原型设计那里再调用getBean从singletonObjects 获取对象。\n\n\n\n\n\n# 建造者模式【常用】\n\n> 只要是标注常用的，基本上用的都比较多，无论篇幅长短，都不要忽视。\n\n建造者模式的原理和代码实现非常简单，掌握起来并不难，难点在于应用场景。比如，你有没有考虑过这样几个问题：直接使用构造函数或者配合 set 方法就能创建对象，为什么还需要建造者模式来创建呢？建造者模式和工厂模式都可以创建对象，那它们两个的区别在哪里呢？\n\n## 为什么需要建造者模式？\n\n\n\n1. 在平时的开发中，创建一个对象最常用的方式是，使用 new 关键字调用类的构造函数来完成。我的问题是，什么情况下这种方式就不适用了，就需要采用建造者模式来创建对象呢？你可以先思考一下，下面我通过一个例子来带你看一下。\n2. 假设有这样一道设计面试题：我们需要定义一个资源池配置类 ResourcePoolConfig。这里的资源池，你可以简单理解为线程池、连接池、对象池等。在这个资源池配置类中，有以下几个成员变量，也就是可配置项。现在，请你编写代码实现这个 ResourcePoolConfig 类。\n\n<img src=\"https://npm.elemecdn.com/youthlql@1.0.0/design_patterns/creational/03.02/0001.png\" />\n\n\n\n只要你稍微有点开发经验，那实现这样一个类对你来说并不是件难事。最常见、最容易想到的实现思路如下代码所示。因为 maxTotal、maxIdle、minIdle 不是必填变量，所以在创建 ResourcePoolConfig 对象的时候，我们通过往构造函数中，给这几个参数传递 null 值，来表示使用默认值。\n\n```java\npublic class ResourcePoolConfig {\n  private static final int DEFAULT_MAX_TOTAL = 8;\n  private static final int DEFAULT_MAX_IDLE = 8;\n  private static final int DEFAULT_MIN_IDLE = 0;\n\n  private String name;\n  private int maxTotal = DEFAULT_MAX_TOTAL;\n  private int maxIdle = DEFAULT_MAX_IDLE;\n  private int minIdle = DEFAULT_MIN_IDLE;\n\n  public ResourcePoolConfig(String name, Integer maxTotal, Integer maxIdle, Integer minIdle) {\n    if (StringUtils.isBlank(name)) {\n      throw new IllegalArgumentException(\"name should not be empty.\");\n    }\n    this.name = name;\n\n    if (maxTotal != null) {\n      if (maxTotal <= 0) {\n        throw new IllegalArgumentException(\"maxTotal should be positive.\");\n      }\n      this.maxTotal = maxTotal;\n    }\n\n    if (maxIdle != null) {\n      if (maxIdle < 0) {\n        throw new IllegalArgumentException(\"maxIdle should not be negative.\");\n      }\n      this.maxIdle = maxIdle;\n    }\n\n    if (minIdle != null) {\n      if (minIdle < 0) {\n        throw new IllegalArgumentException(\"minIdle should not be negative.\");\n      }\n      this.minIdle = minIdle;\n    }\n  }\n  //...省略getter方法...\n}\n```\n\n现在，ResourcePoolConfig 只有 4 个可配置项，对应到构造函数中，也只有 4 个参数，参数的个数不多。但是，如果可配置项逐渐增多，变成了 8 个、10 个，甚至更多，那继续沿用现在的设计思路，构造函数的参数列表会变得很长，代码在可读性和易用性上都会变差。在使用构造函数的时候，我们就容易搞错各参数的顺序，传递进错误的参数值，导致非常隐蔽的 bug。\n\n```java\n// 参数太多，导致可读性差、参数可能传递错误\nResourcePoolConfig config = new ResourcePoolConfig(\"dbconnectionpool\", 16, null, 8, null, false , true, 10, 20，false， true);\n```\n\n\n\n解决这个问题的办法你应该也已经想到了，那就是用 set() 函数来给成员变量赋值，以替代冗长的构造函数。我们直接看代码，具体如下所示。其中，配置项 name 是必填的，所以我们把它放到构造函数中设置，强制创建类对象的时候就要填写。其他配置项 maxTotal、maxIdle、minIdle 都不是必填的，所以我们通过 set() 函数来设置，让使用者自主选择填写或者不填写。\n\n\n\n```java\npublic class ResourcePoolConfig {\n  private static final int DEFAULT_MAX_TOTAL = 8;\n  private static final int DEFAULT_MAX_IDLE = 8;\n  private static final int DEFAULT_MIN_IDLE = 0;\n\n  private String name;\n  private int maxTotal = DEFAULT_MAX_TOTAL;\n  private int maxIdle = DEFAULT_MAX_IDLE;\n  private int minIdle = DEFAULT_MIN_IDLE;\n  \n  public ResourcePoolConfig(String name) {\n    if (StringUtils.isBlank(name)) {\n      throw new IllegalArgumentException(\"name should not be empty.\");\n    }\n    this.name = name;\n  }\n\n  public void setMaxTotal(int maxTotal) {\n    if (maxTotal <= 0) {\n      throw new IllegalArgumentException(\"maxTotal should be positive.\");\n    }\n    this.maxTotal = maxTotal;\n  }\n\n  public void setMaxIdle(int maxIdle) {\n    if (maxIdle < 0) {\n      throw new IllegalArgumentException(\"maxIdle should not be negative.\");\n    }\n    this.maxIdle = maxIdle;\n  }\n\n  public void setMinIdle(int minIdle) {\n    if (minIdle < 0) {\n      throw new IllegalArgumentException(\"minIdle should not be negative.\");\n    }\n    this.minIdle = minIdle;\n  }\n  //...省略getter方法...\n}\n```\n\n\n\n接下来，我们来看新的 ResourcePoolConfig 类该如何使用。我写了一个示例代码，如下所示。没有了冗长的函数调用和参数列表，代码在可读性和易用性上提高了很多。\n\n```java\n// ResourcePoolConfig使用举例\nResourcePoolConfig config = new ResourcePoolConfig(\"dbconnectionpool\");\nconfig.setMaxTotal(16);\nconfig.setMaxIdle(8);\n```\n\n\n\n至此，我们仍然没有用到建造者模式，通过构造函数设置必填项，通过 set() 方法设置可选配置项，就能实现我们的设计需求。如果我们把问题的难度再加大点，比如，还需要解决下面这三个问题，那现在的设计思路就不能满足了。\n\n- 我们刚刚讲到，name 是必填的，所以，我们把它放到构造函数中，强制创建对象的时候就设置。如果必填的配置项有很多，把这些必填配置项都放到构造函数中设置，那构造函数就又会出现参数列表很长的问题。如果我们把必填项也通过 set() 方法设置，那校验这些必填项是否已经填写的逻辑就无处安放了。\n- 除此之外，假设配置项之间有一定的依赖关系，比如，如果用户设置了 maxTotal、maxIdle、minIdle 其中一个，就必须显式地设置另外两个；或者配置项之间有一定的约束条件，比如，maxIdle 和 minIdle 要小于等于 maxTotal。如果我们继续使用现在的设计思路，那这些配置项之间的依赖关系或者约束条件的校验逻辑就无处安放了。\n- 如果我们希望 ResourcePoolConfig 类对象是不可变对象，也就是说，对象在创建好之后，就不能再修改内部的属性值。要实现这个功能，我们就不能在 ResourcePoolConfig 类中暴露 set() 方法。\n\n为了解决这些问题，建造者模式就派上用场了。我们可以把校验逻辑放置到 Builder 类中，先创建建造者，并且通过 set() 方法设置建造者的变量值，然后在使用 build() 方法真正创建对象之前，做集中的校验，校验通过之后才会创建对象。除此之外，我们把 ResourcePoolConfig 的构造函数改为 private 私有权限。这样我们就只能通过建造者来创建 ResourcePoolConfig 类对象。并且，ResourcePoolConfig 没有提供任何 set() 方法，这样我们创建出来的对象就是不可变对象了。我们用建造者模式重新实现了上面的需求，具体的代码如下所示：\n\n```java\npublic class ResourcePoolConfig {\n  private String name;\n  private int maxTotal;\n  private int maxIdle;\n  private int minIdle;\n\n  private ResourcePoolConfig(Builder builder) {\n    this.name = builder.name;\n    this.maxTotal = builder.maxTotal;\n    this.maxIdle = builder.maxIdle;\n    this.minIdle = builder.minIdle;\n  }\n  //...省略getter方法...\n\n  //我们将Builder类设计成了ResourcePoolConfig的内部类。\n  //我们也可以将Builder类设计成独立的非内部类ResourcePoolConfigBuilder。\n  public static class Builder {\n    private static final int DEFAULT_MAX_TOTAL = 8;\n    private static final int DEFAULT_MAX_IDLE = 8;\n    private static final int DEFAULT_MIN_IDLE = 0;\n\n    private String name;\n    private int maxTotal = DEFAULT_MAX_TOTAL;\n    private int maxIdle = DEFAULT_MAX_IDLE;\n    private int minIdle = DEFAULT_MIN_IDLE;\n\n    public ResourcePoolConfig build() {\n      // 校验逻辑放到这里来做，包括必填项校验、依赖关系校验、约束条件校验等\n      if (StringUtils.isBlank(name)) {\n        throw new IllegalArgumentException(\"...\");\n      }\n      if (maxIdle > maxTotal) {\n        throw new IllegalArgumentException(\"...\");\n      }\n      if (minIdle > maxTotal || minIdle > maxIdle) {\n        throw new IllegalArgumentException(\"...\");\n      }\n\n      return new ResourcePoolConfig(this);\n    }\n\n    public Builder setName(String name) {\n      if (StringUtils.isBlank(name)) {\n        throw new IllegalArgumentException(\"...\");\n      }\n      this.name = name;\n      return this;\n    }\n\n    public Builder setMaxTotal(int maxTotal) {\n      if (maxTotal <= 0) {\n        throw new IllegalArgumentException(\"...\");\n      }\n      this.maxTotal = maxTotal;\n      return this;\n    }\n\n    public Builder setMaxIdle(int maxIdle) {\n      if (maxIdle < 0) {\n        throw new IllegalArgumentException(\"...\");\n      }\n      this.maxIdle = maxIdle;\n      return this;\n    }\n\n    public Builder setMinIdle(int minIdle) {\n      if (minIdle < 0) {\n        throw new IllegalArgumentException(\"...\");\n      }\n      this.minIdle = minIdle;\n      return this;\n    }\n  }\n}\n\n// 这段代码会抛出IllegalArgumentException，因为minIdle>maxIdle\nResourcePoolConfig config = new ResourcePoolConfig.Builder()\n        .setName(\"dbconnectionpool\")\n        .setMaxTotal(16)\n        .setMaxIdle(10)\n        .setMinIdle(12)\n        .build();\n```\n\n\n\n实际上，使用建造者模式创建对象，还能避免对象存在无效状态。我再举个例子解释一下。比如我们定义了一个长方形类，如果不使用建造者模式，采用先创建后 set 的方式，那就会导致在第一个 set 之后，对象处于无效状态。具体代码如下所示\n\n```java\nRectangle r = new Rectange(); // r is invalid\nr.setWidth(2); // r is invalid\nr.setHeight(3); // r is valid\n```\n\n> 这里是说，长方形必须同时具备宽、高两个属性才是一个有效的长方形。只有其中一个属性，这个长方形对象就没有意义，是无效的。\n\n1. 为了避免这种无效状态的存在，我们就需要使用构造函数一次性初始化好所有的成员变量。如果构造函数参数过多，我们就需要考虑使用建造者模式，先设置建造者的变量，然后再一次性地创建对象，让对象一直处于有效状态。(建造者主要解决参数过多、参数检验、控制对象创建后不可变的问题)\n2. 实际上，如果我们并不是很关心对象是否有短暂的无效状态，也不是太在意对象是否是可变的。比如，对象只是用来映射数据库读出来的数据，那我们直接暴露 set() 方法来设置类的成员变量值是完全没问题的。而且，使用建造者模式来构建对象，代码实际上是有点重复的，ResourcePoolConfig 类中的成员变量，要在 Builder 类中重新再定义一遍。\n\n\n\n\n\n## 与工厂模式有何区别？\n\n\n\n1. 从上面的讲解中，我们可以看出，建造者模式是让建造者类来负责对象的创建工作。上面讲到的工厂模式，是由工厂类来负责对象创建的工作。那它们之间有什么区别呢？\n2. 实际上，工厂模式是用来创建不同但是相关类型的对象（继承同一父类或者接口的一组子类），由给定的参数来决定创建哪种类型的对象。建造者模式是用来创建一种类型的复杂对象，通过设置不同的可选参数，“定制化”地创建不同的对象。\n\n\n\n网上有一个经典的例子很好地解释了两者的区别:\n\n> 顾客走进一家餐馆点餐，我们利用工厂模式，根据用户不同的选择，来制作不同的食物，比如披萨、汉堡、沙拉。对于披萨来说，用户又有各种配料可以定制，比如奶酪、西红柿、起司，我们通过建造者模式根据用户选择的不同配料来制作披萨。\n\n实际上，我们也不要太学院派，非得把工厂模式、建造者模式分得那么清楚，我们需要知道的是，每个模式为什么这么设计，能解决什么问题。只有了解了这些最本质的东西，我们才能不生搬硬套，才能灵活应用，甚至可以混用各种模式创造出新的模式，来解决特定场景的问题。\n\n\n\n\n\n\n\n# 原型模式【不常用】\n\n今天的讲解跟具体某一语言的语法机制无关，而是通过一个 clone 散列表的例子带你搞清楚：原型模式的应用场景，以及它的两种实现方式：深拷贝和浅拷贝。虽然原型模式的原理和代码实现非常简单，但今天举的例子还是稍微有点复杂的\n\n\n\n## 原型模式的原理与应用\n\n如果对象的创建成本比较大，而同一个类的不同对象之间差别不大（大部分字段都相同），在这种情况下，我们可以利用对已有对象（原型）进行复制（或者叫拷贝）的方式来创建新对象，以达到节省创建时间的目的。这种基于原型来创建对象的方式就叫作原型设计模式（Prototype Design Pattern），简称原型模式。\n\n\n\n> 那何为“对象的创建成本比较大”？\n\n1. 实际上，创建对象包含的申请内存、给成员变量赋值这一过程，本身并不会花费太多时间，或者说对于大部分业务系统来说，这点时间完全是可以忽略的。应用一个复杂的模式，只得到一点点的性能提升，这就是所谓的过度设计，得不偿失。\n2. 但是，如果对象中的数据需要经过复杂的计算才能得到（比如排序、计算哈希值），或者需要从 RPC、网络、数据库、文件系统等非常慢速的 IO 中读取，这种情况下，我们就可以利用原型模式，从其他已有对象中直接拷贝得到，而不用每次在创建新对象的时候，都重复执行这些耗时的操作。\n\n\n\n> 这么说还是比较理论，接下来，我们通过一个例子来解释一下刚刚这段话。\n\n\n\n1. 假设数据库中存储了大约 10 万条“搜索关键词”信息，每条信息包含关键词、关键词被搜索的次数、信息最近被更新的时间等。系统 A 在启动的时候会加载这份数据到内存中，用于处理某些其他的业务需求。为了方便快速地查找某个关键词对应的信息，我们给关键词建立一个散列表索引。\n2. 如果你熟悉的是 Java 语言，可以直接使用语言中提供的 HashMap 容器来实现。其中，HashMap 的 key 为搜索关键词，value 为关键词详细信息（比如搜索次数）。我们只需要将数据从数据库中读取出来，放入 HashMap 就可以了。\n3. 不过，我们还有另外一个系统 B，专门用来分析搜索日志，定期（比如间隔 10 分钟）批量地更新数据库中的数据，并且标记为新的数据版本。比如，在下面的示例图中，我们对 v2 版本的数据进行更新，得到 v3 版本的数据。这里我们假设只有更新和新添关键词，没有删除关键词的行为。\n\n<img src=\"https://npm.elemecdn.com/youthlql@1.0.0/design_patterns/creational/03.02/0002.png\"/>\n\n\n\n1. 为了保证系统 A 中数据的实时性（不一定非常实时，但数据也不能太旧），系统 A 需要定期根据数据库中的数据，更新内存中的索引和数据。\n2. 我们该如何实现这个需求呢？实际上，也不难。我们只需要在系统 A 中，记录当前数据的版本 Va 对应的更新时间 Ta，从数据库中捞出更新时间大于 Ta 的所有搜索关键词，也就是找出 Va 版本与最新版本数据的“差集”，然后针对差集中的每个关键词进行处理。如果它已经在散列表中存在了，我们就更新相应的搜索次数、更新时间等信息；如果它在散列表中不存在，我们就将它插入到散列表中。\n3. 按照这个设计思路，我给出的示例代码如下所示：\n\n```java\npublic class Demo {\n  private ConcurrentHashMap<String, SearchWord> currentKeywords = new ConcurrentHashMap<>();\n  private long lastUpdateTime = -1;\n\n  public void refresh() {\n    // 从数据库中取出更新时间>lastUpdateTime的数据，放入到currentKeywords中\n    List<SearchWord> toBeUpdatedSearchWords = getSearchWords(lastUpdateTime);\n    long maxNewUpdatedTime = lastUpdateTime;\n    for (SearchWord searchWord : toBeUpdatedSearchWords) {\n      if (searchWord.getLastUpdateTime() > maxNewUpdatedTime) {\n        maxNewUpdatedTime = searchWord.getLastUpdateTime();\n      }\n      if (currentKeywords.containsKey(searchWord.getKeyword())) {\n        currentKeywords.replace(searchWord.getKeyword(), searchWord);\n      } else {\n        currentKeywords.put(searchWord.getKeyword(), searchWord);\n      }\n    }\n\n    lastUpdateTime = maxNewUpdatedTime;\n  }\n\n  private List<SearchWord> getSearchWords(long lastUpdateTime) {\n    // TODO: 从数据库中取出更新时间>lastUpdateTime的数据\n    return null;\n  }\n}\n```\n\n\n\n不过，现在，我们有一个特殊的要求：任何时刻，系统 A 中的所有数据都必须是同一个版本的，要么都是版本 a，要么都是版本 b，不能有的是版本 a，有的是版本 b。那刚刚的更新方式就不能满足这个要求了（因为数据很多，一个一个的for循环肯定会出现不同数据版本的问题）。除此之外，我们还要求：在更新内存数据的时候，系统 A 不能处于不可用状态，也就是不能停机更新数据。\n\n\n\n1. 那我们该如何实现现在这个需求呢？\n\n2. 实际上，也不难。我们把正在使用的数据的版本定义为“服务版本”，当我们要更新内存中的数据的时候，我们并不是直接在服务版本（假设是版本 a 数据）上更新，而是重新创建另一个版本数据（假设是版本 b 数据），等新的版本数据建好之后，再一次性地将服务版本从版本 a 切换到版本 b。这样既保证了数据一直可用，又避免了中间状态的存在。\n3. 按照这个设计思路，我给出的示例代码如下所示：\n\n```java\npublic class Demo {\n  private HashMap<String, SearchWord> currentKeywords=new HashMap<>();\n\n  public void refresh() {\n    HashMap<String, SearchWord> newKeywords = new LinkedHashMap<>();\n\n    // 从数据库中取出所有的数据，放入到newKeywords中\n    List<SearchWord> toBeUpdatedSearchWords = getSearchWords();\n    for (SearchWord searchWord : toBeUpdatedSearchWords) {\n      newKeywords.put(searchWord.getKeyword(), searchWord);\n    }\n\n    currentKeywords = newKeywords;\n  }\n\n  private List<SearchWord> getSearchWords() {\n    // TODO: 从数据库中取出所有的数据\n    return null;\n  }\n}\n```\n\n\n\n1. 不过，在上面的代码实现中，newKeywords 构建的成本比较高。我们需要将这 10 万条数据从数据库中读出，然后计算哈希值，构建 newKeywords。这个过程显然是比较耗时。为了提高效率，原型模式就派上用场了。\n2. 我们拷贝 currentKeywords 数据到 newKeywords 中，然后从数据库中只捞出新增或者有更新的关键词，更新到 newKeywords 中。而相对于 10 万条数据来说，每次新增或者更新的关键词个数是比较少的，所以，这种策略大大提高了数据更新的效率。\n3. 按照这个设计思路，我给出的示例代码如下所示：\n\n```java\npublic class Demo {\n  private HashMap<String, SearchWord> currentKeywords=new HashMap<>();\n  private long lastUpdateTime = -1;\n\n  public void refresh() {\n    // 原型模式就这么简单，拷贝已有对象的数据，更新少量差值\n    HashMap<String, SearchWord> newKeywords = (HashMap<String, SearchWord>) currentKeywords.clone();\n\n    // 从数据库中取出更新时间>lastUpdateTime的数据，放入到newKeywords中\n    List<SearchWord> toBeUpdatedSearchWords = getSearchWords(lastUpdateTime);\n    long maxNewUpdatedTime = lastUpdateTime;\n    for (SearchWord searchWord : toBeUpdatedSearchWords) {\n      if (searchWord.getLastUpdateTime() > maxNewUpdatedTime) {\n        maxNewUpdatedTime = searchWord.getLastUpdateTime();\n      }\n      if (newKeywords.containsKey(searchWord.getKeyword())) {\n        SearchWord oldSearchWord = newKeywords.get(searchWord.getKeyword());\n        oldSearchWord.setCount(searchWord.getCount());\n        oldSearchWord.setLastUpdateTime(searchWord.getLastUpdateTime());\n      } else {\n        newKeywords.put(searchWord.getKeyword(), searchWord);\n      }\n    }\n\n    lastUpdateTime = maxNewUpdatedTime;\n    currentKeywords = newKeywords;\n  }\n\n  private List<SearchWord> getSearchWords(long lastUpdateTime) {\n    // TODO: 从数据库中取出更新时间>lastUpdateTime的数据\n    return null;\n  }\n}\n```\n\n1. 这里我们利用了 Java 中的 clone() 语法来复制一个对象。如果你熟悉的语言没有这个语法，那把数据从 currentKeywords 中一个个取出来，然后再重新计算哈希值，放入到 newKeywords 中也是可以接受的。毕竟，最耗时的还是从数据库中取数据的操作。相对于数据库的 IO 操作来说，内存操作和 CPU 计算的耗时都是可以忽略的。\n2. 不过，不知道你有没有发现，实际上，刚刚的代码实现是有问题的。要弄明白到底有什么问题，我们需要先了解另外两个概念：深拷贝（Deep Copy）和浅拷贝（Shallow Copy）。\n\n\n\n\n\n## 原型模式的实现方式：深拷贝和浅拷贝\n\n> 1、关于深拷贝浅拷贝，我觉得这篇文章讲的不错：https://blog.csdn.net/baiye_xing/article/details/71788741\n\n\n\n> 我自己的总结：\n>\n> **浅拷贝**：对一个对象进行拷贝时，这个对象对应的类里的成员变量。\n>\n> - 对于数据类型是基本数据类型的成员变量，浅拷贝会直接进行值拷贝，也就是将该属性值复制一份给新的对象。因为是两份不同的数据，所以对其中一个对象的该成员变量值进行修改，不会影响另一个对象拷贝得到的数据\n> - 对于数据类型是引用数据类型的成员变量(也就是子对象，或者数组啥的)，也就是只是将该成员变量的引用值（引用拷贝【并发引用传递，Java本质还是值传递】）复制一份给新的对象。因为实际上两个对象的该成员变量都指向同一个实例。在这种情况下，在一个对象中修改该成员变量会影响到另一个对象的该成员变量值。\n>\n> 1. **深拷贝**：对基本数据类型进行值传递，对引用数据类型，创建一个新的对象，并复制其内容，此为深拷贝。\n> 2. 也就是说浅拷贝对于子对象只是拷贝了引用值，并没有真正的拷贝整个对象。\n>\n> **深拷贝实现思路：**\n>\n> 1. 对于每个子对象都实现Cloneable 接口，并重写clone方法。最后在最顶层的类的重写的 clone 方法中调用所有子对象的 clone 方法即可实现深拷贝。【简单的说就是：每一层的每个子对象都进行浅拷贝=深拷贝】\n>\n> 2. 利用序列化。【先对对象进行序列化，紧接着马上反序列化出 】\n\n\n\n我们来看，在内存中，用散列表组织的搜索关键词信息是如何存储的。我画了一张示意图，大致结构如下所示。从图中我们可以发现，散列表索引中，每个结点存储的 key 是搜索关键词，value 是 SearchWord 对象的内存地址。SearchWord 对象本身存储在散列表之外的内存空间中。\n\n<img src=\"https://npm.elemecdn.com/youthlql@1.0.0/design_patterns/creational/03.02/0003.png\"  />\n\n浅拷贝和深拷贝的区别在于，浅拷贝只会复制图中的索引（散列表），不会复制数据（SearchWord 对象）本身。相反，深拷贝不仅仅会复制索引，还会复制数据本身。浅拷贝得到的对象（newKeywords）跟原始对象（currentKeywords）共享数据（SearchWord 对象），而深拷贝得到的是一份完完全全独立的对象。具体的对比如下图所示：\n\n<img src=\"https://npm.elemecdn.com/youthlql@1.0.0/design_patterns/creational/03.02/0004.png\"/>\n\n\n\n<img src=\"https://npm.elemecdn.com/youthlql@1.0.0/design_patterns/creational/03.02/0005.png\" />\n\n\n\n1. 在 Java 语言中，Object 类的 clone() 方法执行的就是我们刚刚说的浅拷贝。它只会拷贝对象中的基本数据类型的数据（比如，int、long），以及引用对象（SearchWord）的内存地址，不会递归地拷贝引用对象本身。\n2. 在上面的代码中，我们通过调用 HashMap 上的 clone() 浅拷贝方法来实现原型模式。当我们通过 newKeywords 更新 SearchWord 对象的时候（比如，更新“设计模式”这个搜索关键词的访问次数），newKeywords 和 currentKeywords 因为指向相同的一组 SearchWord 对象，就会导致 currentKeywords 中指向的 SearchWord，有的是老版本的，有的是新版本的，就没法满足我们之前的需求：currentKeywords 中的数据在任何时刻都是同一个版本的，不存在介于老版本与新版本之间的中间状态。\n\n3. 现在，我们又该如何来解决这个问题呢？\n\n4. 我们可以将浅拷贝替换为深拷贝。newKeywords 不仅仅复制 currentKeywords 的索引，还把 SearchWord 对象也复制一份出来，这样 newKeywords 和 currentKeywords 就指向不同的 SearchWord 对象，也就不存在更新 newKeywords 的数据会导致 currentKeywords 的数据也被更新的问题了。\n5. 那如何实现深拷贝呢？总结一下的话，有下面两种方法。\n\n\n\n第一种方法：递归拷贝对象、对象的引用对象以及引用对象的引用对象……直到要拷贝的对象只包含基本数据类型数据，没有引用对象为止。根据这个思路对之前的代码进行重构。重构之后的代码如下所示：\n\n```java\npublic class Demo {\n  private HashMap<String, SearchWord> currentKeywords=new HashMap<>();\n  private long lastUpdateTime = -1;\n\n  public void refresh() {\n    // Deep copy\n    HashMap<String, SearchWord> newKeywords = new HashMap<>();\n    for (HashMap.Entry<String, SearchWord> e : currentKeywords.entrySet()) {\n      SearchWord searchWord = e.getValue();\n      SearchWord newSearchWord = new SearchWord(\n              searchWord.getKeyword(), searchWord.getCount(), searchWord.getLastUpdateTime());\n      newKeywords.put(e.getKey(), newSearchWord);\n    }\n\n    // 从数据库中取出更新时间>lastUpdateTime的数据，放入到newKeywords中\n    List<SearchWord> toBeUpdatedSearchWords = getSearchWords(lastUpdateTime);\n    long maxNewUpdatedTime = lastUpdateTime;\n    for (SearchWord searchWord : toBeUpdatedSearchWords) {\n      if (searchWord.getLastUpdateTime() > maxNewUpdatedTime) {\n        maxNewUpdatedTime = searchWord.getLastUpdateTime();\n      }\n      if (newKeywords.containsKey(searchWord.getKeyword())) {\n        SearchWord oldSearchWord = newKeywords.get(searchWord.getKeyword());\n        oldSearchWord.setCount(searchWord.getCount());\n        oldSearchWord.setLastUpdateTime(searchWord.getLastUpdateTime());\n      } else {\n        newKeywords.put(searchWord.getKeyword(), searchWord);\n      }\n    }\n\n    lastUpdateTime = maxNewUpdatedTime;\n    currentKeywords = newKeywords;\n  }\n\n  private List<SearchWord> getSearchWords(long lastUpdateTime) {\n    // TODO: 从数据库中取出更新时间>lastUpdateTime的数据\n    return null;\n  }\n\n}\n```\n\n\n\n第二种方法：先将对象序列化，然后再反序列化成新的对象。具体的示例代码如下所示：\n\n```java\npublic Object deepCopy(Object object) {\n  ByteArrayOutputStream bo = new ByteArrayOutputStream();\n  ObjectOutputStream oo = new ObjectOutputStream(bo);\n  oo.writeObject(object);\n  \n  ByteArrayInputStream bi = new ByteArrayInputStream(bo.toByteArray());\n  ObjectInputStream oi = new ObjectInputStream(bi);\n  \n  return oi.readObject();\n}\n```\n\n1. 刚刚的两种实现方法，不管采用哪种，深拷贝都要比浅拷贝耗时、耗内存空间。针对我们这个应用场景，有没有更快、更省内存的实现方式呢？\n2. 我们可以先采用浅拷贝的方式创建 newKeywords。对于需要更新的 SearchWord 对象，我们再使用深度拷贝的方式创建一份新的对象，替换 newKeywords 中的老对象。毕竟需要更新的数据是很少的。这种方式即利用了浅拷贝节省时间、空间的优点，又能保证 currentKeywords 中的中数据都是老版本的数据。具体的代码实现如下所示。这也是标题中讲到的，在我们这个应用场景下，最快速 clone 散列表的方式。\n\n\n\n```java\npublic class Demo {\n  private HashMap<String, SearchWord> currentKeywords=new HashMap<>();\n  private long lastUpdateTime = -1;\n\n  public void refresh() {\n    // Shallow copy\n    HashMap<String, SearchWord> newKeywords = (HashMap<String, SearchWord>) currentKeywords.clone();\n\n    // 从数据库中取出更新时间>lastUpdateTime的数据，放入到newKeywords中\n    List<SearchWord> toBeUpdatedSearchWords = getSearchWords(lastUpdateTime);\n    long maxNewUpdatedTime = lastUpdateTime;\n    for (SearchWord searchWord : toBeUpdatedSearchWords) {\n      if (searchWord.getLastUpdateTime() > maxNewUpdatedTime) {\n        maxNewUpdatedTime = searchWord.getLastUpdateTime();\n      }\n      if (newKeywords.containsKey(searchWord.getKeyword())) {\n        newKeywords.remove(searchWord.getKeyword());\n      }\n      newKeywords.put(searchWord.getKeyword(), searchWord);\n    }\n\n    lastUpdateTime = maxNewUpdatedTime;\n    currentKeywords = newKeywords;\n  }\n\n  private List<SearchWord> getSearchWords(long lastUpdateTime) {\n    // TODO: 从数据库中取出更新时间>lastUpdateTime的数据\n    return null;\n  }\n}\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/2024-06-18-设计模式-03.02-创建型-工厂&建造者&原型.md","raw":"---\ntitle: 设计模式-03.02-创建型-工厂&建造者&原型\ntags:\n  - 设计模式\n  - 工厂\n  - 建造者\n  - 原型\ncategories:\n  - 设计模式\n  - 03.创建型\nkeywords: 设计模式，工厂，建造者，原型\ndescription: 详解常用的工厂模式和建造者模式，以及不常用的原型模式\ncover: 'https://npm.elemecdn.com/lql_static@latest/logo/design_patterns.jpg'\nabbrlink: ba432704\ndate: 2024-06-18 13:21:58\n---\n\n\n# 声明\n\n> 1. 此系列文章非本人原创，是学习笔记。\n> 2. 设计模式系列以后会持续更新，包括已经发布的设计模式文章，因为后续还要再多看一下书，教程和开源项目等，继续润色文章。\n\n\n\n# 工厂模式【常用】\n\n> 工厂模式很重要，后面的很多架构设计，都是工厂模式联合着其它设计模式使用。\n\n1. 一般情况下，工厂模式分为三种更加细分的类型：简单工厂、工厂方法和抽象工厂。不过，在 GoF 的《设计模式》一书中，它将简单工厂模式看作是工厂方法模式的一种特例，所以工厂模式只被分成了工厂方法和抽象工厂两类。实际上，前面一种分类方法更加常见，所以，在今天的讲解中，我们沿用第一种分类方法。\n\n2. 在这三种细分的工厂模式中，简单工厂、工厂方法原理比较简单，在实际的项目中也比较常用。而抽象工厂的原理稍微复杂点，在实际的项目中相对也不常用。所以，我们今天讲解的重点是前两种工厂模式。对于抽象工厂，稍微了解一下即可。\n\n3. 除此之外，我们讲解的重点也不是原理和实现，因为这些都很简单，重点还是带你搞清楚应用场景：什么时候该用工厂模式？相对于直接 new 来创建对象，用工厂模式来创建究竟有什么好处呢？\n\n## 简单工厂（Simple Factory）\n\n首先，我们来看，什么是简单工厂模式。我们通过一个例子来解释一下。\n\n在下面这段代码中，我们根据配置文件的后缀（json、xml、yaml、properties），选择不同的解析器（JsonRuleConfigParser、XmlRuleConfigParser……），将存储在文件中的配置解析成内存对象 RuleConfig。\n\n```java\npublic class RuleConfigSource {\n  public RuleConfig load(String ruleConfigFilePath) {\n    String ruleConfigFileExtension = getFileExtension(ruleConfigFilePath);\n    IRuleConfigParser parser = null;\n    if (\"json\".equalsIgnoreCase(ruleConfigFileExtension)) {\n      parser = new JsonRuleConfigParser();\n    } else if (\"xml\".equalsIgnoreCase(ruleConfigFileExtension)) {\n      parser = new XmlRuleConfigParser();\n    } else if (\"yaml\".equalsIgnoreCase(ruleConfigFileExtension)) {\n      parser = new YamlRuleConfigParser();\n    } else if (\"properties\".equalsIgnoreCase(ruleConfigFileExtension)) {\n      parser = new PropertiesRuleConfigParser();\n    } else {\n      throw new InvalidRuleConfigException(\n             \"Rule config file format is not supported: \" + ruleConfigFilePath);\n    }\n\n    String configText = \"\";\n    //从ruleConfigFilePath文件中读取配置文本到configText中\n    RuleConfig ruleConfig = parser.parse(configText);\n    return ruleConfig;\n  }\n\n  private String getFileExtension(String filePath) {\n    //...解析文件名获取扩展名，比如rule.json，返回json\n    return \"json\";\n  }\n}\n```\n\n为了让代码逻辑更加清晰，可读性更好，我们要善于将功能独立的代码块封装成函数。按照这个设计思路，我们可以将代码中涉及 parser 创建的部分逻辑剥离出来，抽象成 createParser() 函数。重构之后的代码如下所示：\n\n\n\n```java\n  public RuleConfig load(String ruleConfigFilePath) {\n    String ruleConfigFileExtension = getFileExtension(ruleConfigFilePath);\n    IRuleConfigParser parser = createParser(ruleConfigFileExtension);\n    if (parser == null) {\n      throw new InvalidRuleConfigException(\n              \"Rule config file format is not supported: \" + ruleConfigFilePath);\n    }\n\n    String configText = \"\";\n    //从ruleConfigFilePath文件中读取配置文本到configText中\n    RuleConfig ruleConfig = parser.parse(configText);\n    return ruleConfig;\n  }\n\n  private String getFileExtension(String filePath) {\n    //...解析文件名获取扩展名，比如rule.json，返回json\n    return \"json\";\n  }\n\n  private IRuleConfigParser createParser(String configFormat) {\n    IRuleConfigParser parser = null;\n    if (\"json\".equalsIgnoreCase(configFormat)) {\n      parser = new JsonRuleConfigParser();\n    } else if (\"xml\".equalsIgnoreCase(configFormat)) {\n      parser = new XmlRuleConfigParser();\n    } else if (\"yaml\".equalsIgnoreCase(configFormat)) {\n      parser = new YamlRuleConfigParser();\n    } else if (\"properties\".equalsIgnoreCase(configFormat)) {\n      parser = new PropertiesRuleConfigParser();\n    }\n    return parser;\n  }\n}\n```\n\n\n\n为了让类的职责更加单一(**设计模式原则中的单一职责**，)、代码更加清晰，我们还可以进一步将 createParser() 函数剥离到一个独立的类中，让这个类只负责对象的创建。而这个类就是我们现在要讲的简单工厂模式类。具体的代码如下所示：\n\n```java\npublic class RuleConfigSource {\n  public RuleConfig load(String ruleConfigFilePath) {\n    String ruleConfigFileExtension = getFileExtension(ruleConfigFilePath);\n    IRuleConfigParser parser = RuleConfigParserFactory.createParser(ruleConfigFileExtension);\n    if (parser == null) {\n      throw new InvalidRuleConfigException(\n              \"Rule config file format is not supported: \" + ruleConfigFilePath);\n    }\n\n    String configText = \"\";\n    //从ruleConfigFilePath文件中读取配置文本到configText中\n    RuleConfig ruleConfig = parser.parse(configText);\n    return ruleConfig;\n  }\n\n  private String getFileExtension(String filePath) {\n    //...解析文件名获取扩展名，比如rule.json，返回json\n    return \"json\";\n  }\n}\n\npublic class RuleConfigParserFactory {\n  public static IRuleConfigParser createParser(String configFormat) {\n    IRuleConfigParser parser = null;\n    if (\"json\".equalsIgnoreCase(configFormat)) {\n      parser = new JsonRuleConfigParser();\n    } else if (\"xml\".equalsIgnoreCase(configFormat)) {\n      parser = new XmlRuleConfigParser();\n    } else if (\"yaml\".equalsIgnoreCase(configFormat)) {\n      parser = new YamlRuleConfigParser();\n    } else if (\"properties\".equalsIgnoreCase(configFormat)) {\n      parser = new PropertiesRuleConfigParser();\n    }\n    return parser;\n  }\n}\n```\n\n\n\n1. 在上面的代码实现中，我们每次调用 RuleConfigParserFactory 的 createParser() 的时候，都要创建一个新的 parser。\n2. 实际上，如果 parser 可以复用，为了节省内存和对象创建的时间，我们可以将 parser 事先创建好缓存起来。当调用 createParser() 函数的时候，我们从缓存中取出 parser 对象直接使用。这有点类似单例模式和简单工厂模式的结合，具体的代码实现如下所示。在接下来的讲解中，我们把上一种实现方法叫作简单工厂模式的第一种实现方法，把下面这种实现方法叫作简单工厂模式的第二种实现方法。\n\n\n\n```java\npublic class RuleConfigParserFactory {\n  private static final Map<String, RuleConfigParser> cachedParsers = new HashMap<>();\n\n  static {\n    cachedParsers.put(\"json\", new JsonRuleConfigParser());\n    cachedParsers.put(\"xml\", new XmlRuleConfigParser());\n    cachedParsers.put(\"yaml\", new YamlRuleConfigParser());\n    cachedParsers.put(\"properties\", new PropertiesRuleConfigParser());\n  }\n\n  public static IRuleConfigParser createParser(String configFormat) {\n    if (configFormat == null || configFormat.isEmpty()) {\n      return null;//返回null还是IllegalArgumentException全凭你自己说了算\n    }\n    IRuleConfigParser parser = cachedParsers.get(configFormat.toLowerCase());\n    return parser;\n  }\n}\n```\n\n\n\n1. 对于上面两种简单工厂模式的实现方法，如果我们要添加新的 parser，那势必要改动到 RuleConfigParserFactory 的代码，那这是不是违反开闭原则呢？实际上，如果不是需要频繁地添加新的 parser，只是偶尔修改一下 RuleConfigParserFactory 代码，稍微不符合开闭原则，也是完全可以接受的。\n2. 除此之外，在 RuleConfigParserFactory 的第一种代码实现中，有一组 if 分支判断逻辑，是不是应该用多态或其他设计模式来替代呢？实际上，如果 if 分支并不是很多，代码中有 if 分支也是完全可以接受的。应用多态或设计模式来替代 if 分支判断逻辑，也并不是没有任何缺点的，它虽然提高了代码的扩展性，更加符合**开闭原则**，但也增加了类的个数，牺牲了代码的可读性。关于这一点，我们在后面章节中会详细讲到。\n3. 总结一下，尽管简单工厂模式的代码实现中，有多处 if 分支判断逻辑，违背开闭原则，但权衡扩展性和可读性，这样的代码实现在大多数情况下（比如，不需要频繁地添加 parser，也没有太多的 parser）是没有问题的。\n\n\n\n## 工厂方法（Factory Method）\n\n如果我们非得要将 if 分支逻辑去掉，那该怎么办呢？比较经典处理方法就是利用多态。按照多态的实现思路，对上面的代码进行重构。重构之后的代码如下所示：\n\n```java\npublic interface IRuleConfigParserFactory {\n  IRuleConfigParser createParser();\n}\n\npublic class JsonRuleConfigParserFactory implements IRuleConfigParserFactory {\n  @Override\n  public IRuleConfigParser createParser() {\n    return new JsonRuleConfigParser();\n  }\n}\n\npublic class XmlRuleConfigParserFactory implements IRuleConfigParserFactory {\n  @Override\n  public IRuleConfigParser createParser() {\n    return new XmlRuleConfigParser();\n  }\n}\n\npublic class YamlRuleConfigParserFactory implements IRuleConfigParserFactory {\n  @Override\n  public IRuleConfigParser createParser() {\n    return new YamlRuleConfigParser();\n  }\n}\n\npublic class PropertiesRuleConfigParserFactory implements IRuleConfigParserFactory {\n  @Override\n  public IRuleConfigParser createParser() {\n    return new PropertiesRuleConfigParser();\n  }\n}\n```\n\n\n\n实际上，这就是工厂方法模式的典型代码实现。这样当我们新增一种 parser 的时候，只需要新增一个实现了 IRuleConfigParserFactory 接口的 Factory 类即可。所以，工厂方法模式比起简单工厂模式更加符合开闭原则。\n\n\n\n从上面的工厂方法的实现来看，一切都很完美，但是实际上存在挺大的问题。问题存在于这些工厂类的使用上。接下来，我们看一下，如何用这些工厂类来实现 RuleConfigSource 的 load() 函数。具体的代码如下所示：\n\n\n\n```java\npublic class RuleConfigSource {\n  public RuleConfig load(String ruleConfigFilePath) {\n    String ruleConfigFileExtension = getFileExtension(ruleConfigFilePath);\n\n    IRuleConfigParserFactory parserFactory = null;\n    if (\"json\".equalsIgnoreCase(ruleConfigFileExtension)) {\n      parserFactory = new JsonRuleConfigParserFactory();\n    } else if (\"xml\".equalsIgnoreCase(ruleConfigFileExtension)) {\n      parserFactory = new XmlRuleConfigParserFactory();\n    } else if (\"yaml\".equalsIgnoreCase(ruleConfigFileExtension)) {\n      parserFactory = new YamlRuleConfigParserFactory();\n    } else if (\"properties\".equalsIgnoreCase(ruleConfigFileExtension)) {\n      parserFactory = new PropertiesRuleConfigParserFactory();\n    } else {\n      throw new InvalidRuleConfigException(\"Rule config file format is not supported: \" + ruleConfigFilePath);\n    }\n    IRuleConfigParser parser = parserFactory.createParser();\n\n    String configText = \"\";\n    //从ruleConfigFilePath文件中读取配置文本到configText中\n    RuleConfig ruleConfig = parser.parse(configText);\n    return ruleConfig;\n  }\n\n  private String getFileExtension(String filePath) {\n    //...解析文件名获取扩展名，比如rule.json，返回json\n    return \"json\";\n  }\n}\n```\n\n\n\n1. 从上面的代码实现来看，工厂类对象的创建逻辑又耦合进了 load() 函数中，跟我们最初的代码版本非常相似，引入工厂方法非但没有解决问题，反倒让设计变得更加复杂了。那怎么来解决这个问题呢？\n2. 我们可以为工厂类再创建一个简单工厂，也就是工厂的工厂，用来创建工厂类对象。这段话听起来有点绕，我把代码实现出来了，你一看就能明白了。其中，RuleConfigParserFactoryMap 类是创建工厂对象的工厂类，getParserFactory() 返回的是缓存好的单例工厂对象。\n\n```java\npublic class RuleConfigSource {\n  public RuleConfig load(String ruleConfigFilePath) {\n    String ruleConfigFileExtension = getFileExtension(ruleConfigFilePath);\n\n    IRuleConfigParserFactory parserFactory = RuleConfigParserFactoryMap.getParserFactory(ruleConfigFileExtension);\n    if (parserFactory == null) {\n      throw new InvalidRuleConfigException(\"Rule config file format is not supported: \" + ruleConfigFilePath);\n    }\n    IRuleConfigParser parser = parserFactory.createParser();\n\n    String configText = \"\";\n    //从ruleConfigFilePath文件中读取配置文本到configText中\n    RuleConfig ruleConfig = parser.parse(configText);\n    return ruleConfig;\n  }\n\n  private String getFileExtension(String filePath) {\n    //...解析文件名获取扩展名，比如rule.json，返回json\n    return \"json\";\n  }\n}\n\n//因为工厂类只包含方法，不包含成员变量，完全可以复用，\n//不需要每次都创建新的工厂类对象，所以，简单工厂模式的第二种实现思路更加合适。\npublic class RuleConfigParserFactoryMap { //工厂的工厂\n  private static final Map<String, IRuleConfigParserFactory> cachedFactories = new HashMap<>();\n\n  static {\n    cachedFactories.put(\"json\", new JsonRuleConfigParserFactory());\n    cachedFactories.put(\"xml\", new XmlRuleConfigParserFactory());\n    cachedFactories.put(\"yaml\", new YamlRuleConfigParserFactory());\n    cachedFactories.put(\"properties\", new PropertiesRuleConfigParserFactory());\n  }\n\n  public static IRuleConfigParserFactory getParserFactory(String type) {\n    if (type == null || type.isEmpty()) {\n      return null;\n    }\n    IRuleConfigParserFactory parserFactory = cachedFactories.get(type.toLowerCase());\n    return parserFactory;\n  }\n}\n```\n\n\n\n1. 当我们需要添加新的规则配置解析器的时候，我们只需要创建新的 parser 类和 parser factory 类，并且在 RuleConfigParserFactoryMap 类中，将新的 parser factory 对象添加到 cachedFactories 中即可。代码的改动非常少，基本上符合开闭原则。\n2. 实际上，对于规则配置文件解析这个应用场景来说，工厂模式需要额外创建诸多 Factory 类，也会增加代码的复杂性，而且，每个 Factory 类只是做简单的 new 操作，功能非常单薄（只有一行代码），也没必要设计成独立的类，所以，在这个应用场景下，简单工厂模式简单好用，比工厂方法模式更加合适。\n\n\n\n### 那什么时候该用工厂方法模式，而非简单工厂模式呢？\n\n1. 我们前面提到，之所以将某个代码块剥离出来，独立为函数或者类，原因是这个代码块的逻辑过于复杂，剥离之后能让代码更加清晰，更加可读、可维护。但是，如果代码块本身并不复杂，就几行代码而已，我们完全没必要将它拆分成单独的函数或者类。\n2. 基于这个设计思想，当对象的创建逻辑比较复杂，不只是简单的 new 一下就可以，而是要组合其他类对象，做各种初始化操作的时候，我们推荐使用工厂方法模式，将复杂的创建逻辑拆分到多个工厂类中，让每个工厂类都不至于过于复杂。而使用简单工厂模式，将所有的创建逻辑都放到一个工厂类中，会导致这个工厂类变得很复杂。\n3. 除此之外，在某些场景下，如果对象不可复用，那工厂类每次都要返回不同的对象。如果我们使用简单工厂模式来实现，就只能选择第一种包含 if 分支逻辑的实现方式。如果我们还想避免烦人的 if-else 分支逻辑，这个时候，我们就推荐使用工厂方法模式。\n\n\n\n## 抽象工厂（Abstract Factory）\n\n1. 讲完了简单工厂、工厂方法，我们再来看抽象工厂模式。抽象工厂模式的应用场景比较特殊，没有前两种常用，所以不是我们学习的重点，你简单了解一下就可以了。\n2. 在简单工厂和工厂方法中，类只有一种分类方式。比如，在规则配置解析那个例子中，解析器类只会根据配置文件格式（Json、Xml、Yaml……）来分类。但是，如果类有两种分类方式，比如，我们既可以按照配置文件格式来分类，也可以按照解析的对象（Rule 规则配置还是 System 系统配置）来分类，那就会对应下面这 8 个 parser 类。\n\n```java\n针对规则配置的解析器：基于接口IRuleConfigParser\nJsonRuleConfigParser\nXmlRuleConfigParser\nYamlRuleConfigParser\nPropertiesRuleConfigParser\n\n针对系统配置的解析器：基于接口ISystemConfigParser\nJsonSystemConfigParser\nXmlSystemConfigParser\nYamlSystemConfigParser\nPropertiesSystemConfigParser\n```\n\n\n\n1. 针对这种特殊的场景，如果还是继续用工厂方法来实现的话，我们要针对每个 parser 都编写一个工厂类，也就是要编写 8 个工厂类。如果我们未来还需要增加针对业务配置的解析器（比如 IBizConfigParser），那就要再对应地增加 4 个工厂类。而我们知道，过多的类也会让系统难维护。这个问题该怎么解决呢？\n2. 抽象工厂就是针对这种非常特殊的场景而诞生的。我们可以让一个工厂负责创建多个不同类型的对象（IRuleConfigParser、ISystemConfigParser 等），而不是只创建一种 parser 对象。这样就可以有效地减少工厂类的个数。具体的代码实现如下所示：\n\n```java\npublic interface IConfigParserFactory {\n  IRuleConfigParser createRuleParser();\n  ISystemConfigParser createSystemParser();\n  //此处可以扩展新的parser类型，比如IBizConfigParser\n}\n\npublic class JsonConfigParserFactory implements IConfigParserFactory {\n  @Override\n  public IRuleConfigParser createRuleParser() {\n    return new JsonRuleConfigParser();\n  }\n\n  @Override\n  public ISystemConfigParser createSystemParser() {\n    return new JsonSystemConfigParser();\n  }\n}\n\npublic class XmlConfigParserFactory implements IConfigParserFactory {\n  @Override\n  public IRuleConfigParser createRuleParser() {\n    return new XmlRuleConfigParser();\n  }\n\n  @Override\n  public ISystemConfigParser createSystemParser() {\n    return new XmlSystemConfigParser();\n  }\n}\n\n// 省略YamlConfigParserFactory和PropertiesConfigParserFactory代码\n```\n\n\n\n## 如何设计实现一个Dependency Injection框架？\n\n\n\n当创建对象是一个“大工程”的时候，我们一般会选择使用工厂模式，来封装对象复杂的创建过程，将对象的创建和使用分离，让代码更加清晰。那何为“大工程”呢？上面我们讲了两种情况，一种是创建过程涉及复杂的 if-else 分支判断，另一种是对象创建需要组装多个其他类对象或者需要复杂的初始化过程。\n\n\n\n今天，我们再来讲一个创建对象的“大工程”，依赖注入框架，或者叫依赖注入容器（Dependency Injection Container），简称 DI 容器。在今天的讲解中，我会带你一块搞清楚这样几个问题：DI 容器跟我们讲的工厂模式又有何区别和联系？DI 容器的核心功能有哪些，以及如何实现一个简单的 DI 容器？\n\n\n\n\n\n### 工厂模式和 DI 容器有何区别？\n\n1. 实际上，DI 容器底层最基本的设计思路就是基于工厂模式的。DI 容器相当于一个大的工厂类，负责在程序启动的时候，根据配置（要创建哪些类对象，每个类对象的创建需要依赖哪些其他类对象）事先创建好对象。当应用程序需要使用某个类对象的时候，直接从容器中获取即可。正是因为它持有一堆对象，所以这个框架才被称为“容器”。\n2. DI 容器相对于我们上面讲的工厂模式的例子来说，它处理的是更大的对象创建工程。上面讲的工厂模式中，一个工厂类只负责某个类对象或者某一组相关类对象（继承自同一抽象类或者接口的子类）的创建，而 DI 容器负责的是整个应用中所有类对象的创建。\n3. 除此之外，DI 容器负责的事情要比单纯的工厂模式要多。比如，它还包括配置的解析、对象生命周期的管理。接下来，我们就详细讲讲，一个简单的 DI 容器应该包含哪些核心功能。\n\n\n\n### DI 容器的核心功能有哪些？\n\n总结一下，一个简单的 DI 容器的核心功能一般有三个：配置解析、对象创建和对象生命周期管理。\n\n\n\n> 首先，我们来看配置解析。\n\n1. 在上面讲的工厂模式中，工厂类要创建哪个类对象是事先确定好的，并且是写死在工厂类代码中的。作为一个通用的框架来说，框架代码跟应用代码应该是高度解耦的，DI 容器事先并不知道应用会创建哪些对象，不可能把某个应用要创建的对象写死在框架代码中。所以，我们需要通过一种形式，让应用告知 DI 容器要创建哪些对象。这种形式就是我们要讲的配置。\n2. 我们将需要由 DI 容器来创建的类对象和创建类对象的必要信息（使用哪个构造函数以及对应的构造函数参数都是什么等等），放到配置文件中。容器读取配置文件，根据配置文件提供的信息来创建对象。\n3. 下面是一个典型的 Spring 容器的配置文件。Spring 容器读取这个配置文件，解析出要创建的两个对象：rateLimiter 和 redisCounter，并且得到两者的依赖关系：rateLimiter 依赖 redisCounter。\n\n\n\n```java\npublic class RateLimiter {\n  private RedisCounter redisCounter;\n  public RateLimiter(RedisCounter redisCounter) {\n    this.redisCounter = redisCounter;\n  }\n  public void test() {\n    System.out.println(\"Hello World!\");\n  }\n  //...\n}\n\npublic class RedisCounter {\n  private String ipAddress;\n  private int port;\n  public RedisCounter(String ipAddress, int port) {\n    this.ipAddress = ipAddress;\n    this.port = port;\n  }\n  //...\n}\n\n配置文件beans.xml：\n<beans>\n   <bean id=\"rateLimiter\" class=\"com.xzg.RateLimiter\">\n      <constructor-arg ref=\"redisCounter\"/>\n   </bean>\n \n   <bean id=\"redisCounter\" class=\"com.xzg.redisCounter\">\n     <constructor-arg type=\"String\" value=\"127.0.0.1\">\n     <constructor-arg type=\"int\" value=1234>\n   </bean>\n</beans>\n```\n\n\n\n> 其次，我们再来看对象创建。\n\n1. 在 DI 容器中，如果我们给每个类都对应创建一个工厂类，那项目中类的个数会成倍增加，这会增加代码的维护成本。要解决这个问题并不难。我们只需要将所有类对象的创建都放到一个工厂类中完成就可以了，比如 BeansFactory。\n2. 你可能会说，如果要创建的类对象非常多，BeansFactory 中的代码会不会线性膨胀（代码量跟创建对象的个数成正比）呢？实际上并不会。待会讲到 DI 容器的具体实现的时候，我们会讲“反射”这种机制，它能在程序运行的过程中，动态地加载类、创建对象，不需要事先在代码中写死要创建哪些对象。所以，不管是创建一个对象还是十个对象，BeansFactory 工厂类代码都是一样的。\n\n\n\n> 最后，我们来看对象的生命周期管理。\n\n1. 上面我们讲到，简单工厂模式有两种实现方式，一种是每次都返回新创建的对象，另一种是每次都返回同一个事先创建好的对象，也就是所谓的单例对象。在 Spring 框架中，我们可以通过配置 scope 属性，来区分这两种不同类型的对象。scope=prototype 表示返回新创建的对象，scope=singleton 表示返回单例对象。\n2. 除此之外，我们还可以配置对象是否支持懒加载。如果 lazy-init=true，对象在真正被使用到的时候（比如：BeansFactory.getBean(“userService”)）才被被创建；如果 lazy-init=false，对象在应用启动的时候就事先创建好。\n3. 不仅如此，我们还可以配置对象的 init-method 和 destroy-method 方法，比如 init-method=loadProperties()，destroy-method=updateConfigFile()。DI 容器在创建好对象之后，会主动调用 init-method 属性指定的方法来初始化对象。在对象被最终销毁之前，DI 容器会主动调用 destroy-method 属性指定的方法来做一些清理工作，比如释放数据库连接池、关闭文件。\n\n\n\n## 如何实现一个简单的 DI 容器？\n\n用 Java 语言来实现一个简单的 DI 容器，核心逻辑只需要包括这样两个部分：配置文件解析、根据配置文件通过“反射”语法来创建对象。\n\n\n\n### 最小原型设计\n\n因为我们主要是讲解设计模式，所以，在今天的讲解中，我们只实现一个 DI 容器的最小原型。像 Spring 框架这样的 DI 容器，它支持的配置格式非常灵活和复杂。为了简化代码实现，重点讲解原理，在最小原型中，我们只支持下面配置文件中涉及的配置语法。\n\n```java\n配置文件beans.xml\n<beans>\n   <bean id=\"rateLimiter\" class=\"com.xzg.RateLimiter\">\n      <constructor-arg ref=\"redisCounter\"/>\n   </bean>\n \n   <bean id=\"redisCounter\" class=\"com.xzg.redisCounter\" scope=\"singleton\" lazy-init=\"true\">\n     <constructor-arg type=\"String\" value=\"127.0.0.1\">\n     <constructor-arg type=\"int\" value=1234>\n   </bean>\n</bean\n```\n\n\n\n最小原型的使用方式跟 Spring 框架非常类似，示例代码如下所示：\n\n```java\npublic class Demo {\n  public static void main(String[] args) {\n    ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\n            \"beans.xml\");\n    RateLimiter rateLimiter = (RateLimiter) applicationContext.getBean(\"rateLimiter\");\n    rateLimiter.test();\n    //...\n  }\n}\n```\n\n\n\n### 提供执行入口\n\n面向对象设计的最后一步是：组装类并提供执行入口。在这里，执行入口就是一组暴露给外部使用的接口和类。通过刚刚的最小原型使用示例代码，我们可以看出，执行入口主要包含两部分：ApplicationContext 和 ClassPathXmlApplicationContext。其中，ApplicationContext 是接口，ClassPathXmlApplicationContext 是接口的实现类。两个类具体实现如下所示：\n\n\n\n```java\npublic interface ApplicationContext {\n  Object getBean(String beanId);\n}\n\npublic class ClassPathXmlApplicationContext implements ApplicationContext {\n  private BeansFactory beansFactory;\n  private BeanConfigParser beanConfigParser;\n\n  public ClassPathXmlApplicationContext(String configLocation) {\n    this.beansFactory = new BeansFactory();\n    this.beanConfigParser = new XmlBeanConfigParser();\n    loadBeanDefinitions(configLocation);\n  }\n\n  private void loadBeanDefinitions(String configLocation) {\n    InputStream in = null;\n    try {\n      in = this.getClass().getResourceAsStream(\"/\" + configLocation);\n      if (in == null) {\n        throw new RuntimeException(\"Can not find config file: \" + configLocation);\n      }\n      List<BeanDefinition> beanDefinitions = beanConfigParser.parse(in);\n      beansFactory.addBeanDefinitions(beanDefinitions);\n    } finally {\n      if (in != null) {\n        try {\n          in.close();\n        } catch (IOException e) {\n          // TODO: log error\n        }\n      }\n    }\n  }\n\n  @Override\n  public Object getBean(String beanId) {\n    return beansFactory.getBean(beanId);\n  }\n}\n```\n\n从上面的代码中，我们可以看出，ClassPathXmlApplicationContext 负责组装 BeansFactory 和 BeanConfigParser 两个类，串联执行流程：从 classpath 中加载 XML 格式的配置文件，通过 BeanConfigParser 解析为统一的 BeanDefinition 格式，然后，BeansFactory 根据 BeanDefinition 来创建对象。\n\n\n\n### 配置文件解析\n\n配置文件解析主要包含 BeanConfigParser 接口和 XmlBeanConfigParser 实现类，负责将配置文件解析为 BeanDefinition 结构，以便 BeansFactory 根据这个结构来创建对象。配置文件的解析比较繁琐，不涉及我们要讲的理论知识，不是我们讲解的重点，所以这里我只给出两个类的大致设计思路，并未给出具体的实现代码。如果感兴趣的话，你可以自行补充完整。具体的代码框架如下所示：\n\n```java\npublic interface BeanConfigParser {\n  List<BeanDefinition> parse(InputStream inputStream);\n  List<BeanDefinition> parse(String configContent);\n}\n\npublic class XmlBeanConfigParser implements BeanConfigParser {\n\n  @Override\n  public List<BeanDefinition> parse(InputStream inputStream) {\n    String content = null;\n    // TODO:...\n    return parse(content);\n  }\n\n  @Override\n  public List<BeanDefinition> parse(String configContent) {\n    List<BeanDefinition> beanDefinitions = new ArrayList<>();\n    // TODO:...\n    return beanDefinitions;\n  }\n\n}\n\npublic class BeanDefinition {\n  private String id;\n  private String className;\n  private List<ConstructorArg> constructorArgs = new ArrayList<>();\n  private Scope scope = Scope.SINGLETON;\n  private boolean lazyInit = false;\n  // 省略必要的getter/setter/constructors\n \n  public boolean isSingleton() {\n    return scope.equals(Scope.SINGLETON);\n  }\n\n\n  public static enum Scope {\n    SINGLETON,\n    PROTOTYPE\n  }\n  \n  public static class ConstructorArg {\n    private boolean isRef;\n    private Class type;\n    private Object arg;\n    // 省略必要的getter/setter/constructors\n  }\n}\n```\n\n\n\n### 核心工厂类设计\n\n1. 最后，我们来看，BeansFactory 是如何设计和实现的。这也是我们这个 DI 容器最核心的一个类了。它负责根据从配置文件解析得到的 BeanDefinition 来创建对象。\n2. 如果对象的 scope 属性是 singleton，那对象创建之后会缓存在 singletonObjects 这样一个 map 中，下次再请求此对象的时候，直接从 map 中取出返回，不需要重新创建。如果对象的 scope 属性是 prototype，那每次请求对象，BeansFactory 都会创建一个新的对象返回。\n3. 实际上，BeansFactory 创建对象用到的主要技术点就是 Java 中的反射语法：一种动态加载类和创建对象的机制。我们知道，JVM 在启动的时候会根据代码自动地加载类、创建对象。至于都要加载哪些类、创建哪些对象，这些都是在代码中写死的，或者说提前写好的。但是，如果某个对象的创建并不是写死在代码中，而是放到配置文件中，我们需要在程序运行期间，动态地根据配置文件来加载类、创建对象，那这部分工作就没法让 JVM 帮我们自动完成了，我们需要利用 Java 提供的反射语法自己去编写代码。\n4. 搞清楚了反射的原理，BeansFactory 的代码就不难看懂了。具体代码实现如下所示：\n\n\n\n```java\npublic class BeansFactory {\n  private ConcurrentHashMap<String, Object> singletonObjects = new ConcurrentHashMap<>();\n  private ConcurrentHashMap<String, BeanDefinition> beanDefinitions = new ConcurrentHashMap<>();\n\n  public void addBeanDefinitions(List<BeanDefinition> beanDefinitionList) {\n    for (BeanDefinition beanDefinition : beanDefinitionList) {\n      this.beanDefinitions.putIfAbsent(beanDefinition.getId(), beanDefinition);\n    }\n\n    for (BeanDefinition beanDefinition : beanDefinitionList) {\n      if (beanDefinition.isLazyInit() == false && beanDefinition.isSingleton()) {\n        createBean(beanDefinition);\n      }\n    }\n  }\n\n  public Object getBean(String beanId) {\n    BeanDefinition beanDefinition = beanDefinitions.get(beanId);\n    if (beanDefinition == null) {\n      throw new NoSuchBeanDefinitionException(\"Bean is not defined: \" + beanId);\n    }\n    return createBean(beanDefinition);\n  }\n\n  @VisibleForTesting\n  protected Object createBean(BeanDefinition beanDefinition) {\n    if (beanDefinition.isSingleton() && singletonObjects.contains(beanDefinition.getId())) {\n      return singletonObjects.get(beanDefinition.getId());\n    }\n\n    Object bean = null;\n    try {\n      Class beanClass = Class.forName(beanDefinition.getClassName());\n      List<BeanDefinition.ConstructorArg> args = beanDefinition.getConstructorArgs();\n      if (args.isEmpty()) {\n        bean = beanClass.newInstance();\n      } else {\n        Class[] argClasses = new Class[args.size()];\n        Object[] argObjects = new Object[args.size()];\n        for (int i = 0; i < args.size(); ++i) {\n          BeanDefinition.ConstructorArg arg = args.get(i);\n          if (!arg.getIsRef()) {\n            argClasses[i] = arg.getType();\n            argObjects[i] = arg.getArg();\n          } else {\n            BeanDefinition refBeanDefinition = beanDefinitions.get(arg.getArg());\n            if (refBeanDefinition == null) {\n              throw new NoSuchBeanDefinitionException(\"Bean is not defined: \" + arg.getArg());\n            }\n            argClasses[i] = Class.forName(refBeanDefinition.getClassName());\n            argObjects[i] = createBean(refBeanDefinition);\n          }\n        }\n        bean = beanClass.getConstructor(argClasses).newInstance(argObjects);\n      }\n    } catch (ClassNotFoundException | IllegalAccessException\n            | InstantiationException | NoSuchMethodException | InvocationTargetException e) {\n      throw new BeanCreationFailureException(\"\", e);\n    }\n\n    if (bean != null && beanDefinition.isSingleton()) {\n      singletonObjects.putIfAbsent(beanDefinition.getId(), bean);\n      return singletonObjects.get(beanDefinition.getId());\n    }\n    return bean;\n  }\n}\n```\n\n1. 执行入口那里调用`addBeanDefinitions`\n2. 然后`addBeanDefinitions`再调用createBean利用反射创建对象，如果对象的 scope 属性是 singleton，那对象创建之后会缓存在 singletonObjects 这样一个 map 中\n3. 最后最小原型设计那里再调用getBean从singletonObjects 获取对象。\n\n\n\n\n\n# 建造者模式【常用】\n\n> 只要是标注常用的，基本上用的都比较多，无论篇幅长短，都不要忽视。\n\n建造者模式的原理和代码实现非常简单，掌握起来并不难，难点在于应用场景。比如，你有没有考虑过这样几个问题：直接使用构造函数或者配合 set 方法就能创建对象，为什么还需要建造者模式来创建呢？建造者模式和工厂模式都可以创建对象，那它们两个的区别在哪里呢？\n\n## 为什么需要建造者模式？\n\n\n\n1. 在平时的开发中，创建一个对象最常用的方式是，使用 new 关键字调用类的构造函数来完成。我的问题是，什么情况下这种方式就不适用了，就需要采用建造者模式来创建对象呢？你可以先思考一下，下面我通过一个例子来带你看一下。\n2. 假设有这样一道设计面试题：我们需要定义一个资源池配置类 ResourcePoolConfig。这里的资源池，你可以简单理解为线程池、连接池、对象池等。在这个资源池配置类中，有以下几个成员变量，也就是可配置项。现在，请你编写代码实现这个 ResourcePoolConfig 类。\n\n<img src=\"https://npm.elemecdn.com/youthlql@1.0.0/design_patterns/creational/03.02/0001.png\" />\n\n\n\n只要你稍微有点开发经验，那实现这样一个类对你来说并不是件难事。最常见、最容易想到的实现思路如下代码所示。因为 maxTotal、maxIdle、minIdle 不是必填变量，所以在创建 ResourcePoolConfig 对象的时候，我们通过往构造函数中，给这几个参数传递 null 值，来表示使用默认值。\n\n```java\npublic class ResourcePoolConfig {\n  private static final int DEFAULT_MAX_TOTAL = 8;\n  private static final int DEFAULT_MAX_IDLE = 8;\n  private static final int DEFAULT_MIN_IDLE = 0;\n\n  private String name;\n  private int maxTotal = DEFAULT_MAX_TOTAL;\n  private int maxIdle = DEFAULT_MAX_IDLE;\n  private int minIdle = DEFAULT_MIN_IDLE;\n\n  public ResourcePoolConfig(String name, Integer maxTotal, Integer maxIdle, Integer minIdle) {\n    if (StringUtils.isBlank(name)) {\n      throw new IllegalArgumentException(\"name should not be empty.\");\n    }\n    this.name = name;\n\n    if (maxTotal != null) {\n      if (maxTotal <= 0) {\n        throw new IllegalArgumentException(\"maxTotal should be positive.\");\n      }\n      this.maxTotal = maxTotal;\n    }\n\n    if (maxIdle != null) {\n      if (maxIdle < 0) {\n        throw new IllegalArgumentException(\"maxIdle should not be negative.\");\n      }\n      this.maxIdle = maxIdle;\n    }\n\n    if (minIdle != null) {\n      if (minIdle < 0) {\n        throw new IllegalArgumentException(\"minIdle should not be negative.\");\n      }\n      this.minIdle = minIdle;\n    }\n  }\n  //...省略getter方法...\n}\n```\n\n现在，ResourcePoolConfig 只有 4 个可配置项，对应到构造函数中，也只有 4 个参数，参数的个数不多。但是，如果可配置项逐渐增多，变成了 8 个、10 个，甚至更多，那继续沿用现在的设计思路，构造函数的参数列表会变得很长，代码在可读性和易用性上都会变差。在使用构造函数的时候，我们就容易搞错各参数的顺序，传递进错误的参数值，导致非常隐蔽的 bug。\n\n```java\n// 参数太多，导致可读性差、参数可能传递错误\nResourcePoolConfig config = new ResourcePoolConfig(\"dbconnectionpool\", 16, null, 8, null, false , true, 10, 20，false， true);\n```\n\n\n\n解决这个问题的办法你应该也已经想到了，那就是用 set() 函数来给成员变量赋值，以替代冗长的构造函数。我们直接看代码，具体如下所示。其中，配置项 name 是必填的，所以我们把它放到构造函数中设置，强制创建类对象的时候就要填写。其他配置项 maxTotal、maxIdle、minIdle 都不是必填的，所以我们通过 set() 函数来设置，让使用者自主选择填写或者不填写。\n\n\n\n```java\npublic class ResourcePoolConfig {\n  private static final int DEFAULT_MAX_TOTAL = 8;\n  private static final int DEFAULT_MAX_IDLE = 8;\n  private static final int DEFAULT_MIN_IDLE = 0;\n\n  private String name;\n  private int maxTotal = DEFAULT_MAX_TOTAL;\n  private int maxIdle = DEFAULT_MAX_IDLE;\n  private int minIdle = DEFAULT_MIN_IDLE;\n  \n  public ResourcePoolConfig(String name) {\n    if (StringUtils.isBlank(name)) {\n      throw new IllegalArgumentException(\"name should not be empty.\");\n    }\n    this.name = name;\n  }\n\n  public void setMaxTotal(int maxTotal) {\n    if (maxTotal <= 0) {\n      throw new IllegalArgumentException(\"maxTotal should be positive.\");\n    }\n    this.maxTotal = maxTotal;\n  }\n\n  public void setMaxIdle(int maxIdle) {\n    if (maxIdle < 0) {\n      throw new IllegalArgumentException(\"maxIdle should not be negative.\");\n    }\n    this.maxIdle = maxIdle;\n  }\n\n  public void setMinIdle(int minIdle) {\n    if (minIdle < 0) {\n      throw new IllegalArgumentException(\"minIdle should not be negative.\");\n    }\n    this.minIdle = minIdle;\n  }\n  //...省略getter方法...\n}\n```\n\n\n\n接下来，我们来看新的 ResourcePoolConfig 类该如何使用。我写了一个示例代码，如下所示。没有了冗长的函数调用和参数列表，代码在可读性和易用性上提高了很多。\n\n```java\n// ResourcePoolConfig使用举例\nResourcePoolConfig config = new ResourcePoolConfig(\"dbconnectionpool\");\nconfig.setMaxTotal(16);\nconfig.setMaxIdle(8);\n```\n\n\n\n至此，我们仍然没有用到建造者模式，通过构造函数设置必填项，通过 set() 方法设置可选配置项，就能实现我们的设计需求。如果我们把问题的难度再加大点，比如，还需要解决下面这三个问题，那现在的设计思路就不能满足了。\n\n- 我们刚刚讲到，name 是必填的，所以，我们把它放到构造函数中，强制创建对象的时候就设置。如果必填的配置项有很多，把这些必填配置项都放到构造函数中设置，那构造函数就又会出现参数列表很长的问题。如果我们把必填项也通过 set() 方法设置，那校验这些必填项是否已经填写的逻辑就无处安放了。\n- 除此之外，假设配置项之间有一定的依赖关系，比如，如果用户设置了 maxTotal、maxIdle、minIdle 其中一个，就必须显式地设置另外两个；或者配置项之间有一定的约束条件，比如，maxIdle 和 minIdle 要小于等于 maxTotal。如果我们继续使用现在的设计思路，那这些配置项之间的依赖关系或者约束条件的校验逻辑就无处安放了。\n- 如果我们希望 ResourcePoolConfig 类对象是不可变对象，也就是说，对象在创建好之后，就不能再修改内部的属性值。要实现这个功能，我们就不能在 ResourcePoolConfig 类中暴露 set() 方法。\n\n为了解决这些问题，建造者模式就派上用场了。我们可以把校验逻辑放置到 Builder 类中，先创建建造者，并且通过 set() 方法设置建造者的变量值，然后在使用 build() 方法真正创建对象之前，做集中的校验，校验通过之后才会创建对象。除此之外，我们把 ResourcePoolConfig 的构造函数改为 private 私有权限。这样我们就只能通过建造者来创建 ResourcePoolConfig 类对象。并且，ResourcePoolConfig 没有提供任何 set() 方法，这样我们创建出来的对象就是不可变对象了。我们用建造者模式重新实现了上面的需求，具体的代码如下所示：\n\n```java\npublic class ResourcePoolConfig {\n  private String name;\n  private int maxTotal;\n  private int maxIdle;\n  private int minIdle;\n\n  private ResourcePoolConfig(Builder builder) {\n    this.name = builder.name;\n    this.maxTotal = builder.maxTotal;\n    this.maxIdle = builder.maxIdle;\n    this.minIdle = builder.minIdle;\n  }\n  //...省略getter方法...\n\n  //我们将Builder类设计成了ResourcePoolConfig的内部类。\n  //我们也可以将Builder类设计成独立的非内部类ResourcePoolConfigBuilder。\n  public static class Builder {\n    private static final int DEFAULT_MAX_TOTAL = 8;\n    private static final int DEFAULT_MAX_IDLE = 8;\n    private static final int DEFAULT_MIN_IDLE = 0;\n\n    private String name;\n    private int maxTotal = DEFAULT_MAX_TOTAL;\n    private int maxIdle = DEFAULT_MAX_IDLE;\n    private int minIdle = DEFAULT_MIN_IDLE;\n\n    public ResourcePoolConfig build() {\n      // 校验逻辑放到这里来做，包括必填项校验、依赖关系校验、约束条件校验等\n      if (StringUtils.isBlank(name)) {\n        throw new IllegalArgumentException(\"...\");\n      }\n      if (maxIdle > maxTotal) {\n        throw new IllegalArgumentException(\"...\");\n      }\n      if (minIdle > maxTotal || minIdle > maxIdle) {\n        throw new IllegalArgumentException(\"...\");\n      }\n\n      return new ResourcePoolConfig(this);\n    }\n\n    public Builder setName(String name) {\n      if (StringUtils.isBlank(name)) {\n        throw new IllegalArgumentException(\"...\");\n      }\n      this.name = name;\n      return this;\n    }\n\n    public Builder setMaxTotal(int maxTotal) {\n      if (maxTotal <= 0) {\n        throw new IllegalArgumentException(\"...\");\n      }\n      this.maxTotal = maxTotal;\n      return this;\n    }\n\n    public Builder setMaxIdle(int maxIdle) {\n      if (maxIdle < 0) {\n        throw new IllegalArgumentException(\"...\");\n      }\n      this.maxIdle = maxIdle;\n      return this;\n    }\n\n    public Builder setMinIdle(int minIdle) {\n      if (minIdle < 0) {\n        throw new IllegalArgumentException(\"...\");\n      }\n      this.minIdle = minIdle;\n      return this;\n    }\n  }\n}\n\n// 这段代码会抛出IllegalArgumentException，因为minIdle>maxIdle\nResourcePoolConfig config = new ResourcePoolConfig.Builder()\n        .setName(\"dbconnectionpool\")\n        .setMaxTotal(16)\n        .setMaxIdle(10)\n        .setMinIdle(12)\n        .build();\n```\n\n\n\n实际上，使用建造者模式创建对象，还能避免对象存在无效状态。我再举个例子解释一下。比如我们定义了一个长方形类，如果不使用建造者模式，采用先创建后 set 的方式，那就会导致在第一个 set 之后，对象处于无效状态。具体代码如下所示\n\n```java\nRectangle r = new Rectange(); // r is invalid\nr.setWidth(2); // r is invalid\nr.setHeight(3); // r is valid\n```\n\n> 这里是说，长方形必须同时具备宽、高两个属性才是一个有效的长方形。只有其中一个属性，这个长方形对象就没有意义，是无效的。\n\n1. 为了避免这种无效状态的存在，我们就需要使用构造函数一次性初始化好所有的成员变量。如果构造函数参数过多，我们就需要考虑使用建造者模式，先设置建造者的变量，然后再一次性地创建对象，让对象一直处于有效状态。(建造者主要解决参数过多、参数检验、控制对象创建后不可变的问题)\n2. 实际上，如果我们并不是很关心对象是否有短暂的无效状态，也不是太在意对象是否是可变的。比如，对象只是用来映射数据库读出来的数据，那我们直接暴露 set() 方法来设置类的成员变量值是完全没问题的。而且，使用建造者模式来构建对象，代码实际上是有点重复的，ResourcePoolConfig 类中的成员变量，要在 Builder 类中重新再定义一遍。\n\n\n\n\n\n## 与工厂模式有何区别？\n\n\n\n1. 从上面的讲解中，我们可以看出，建造者模式是让建造者类来负责对象的创建工作。上面讲到的工厂模式，是由工厂类来负责对象创建的工作。那它们之间有什么区别呢？\n2. 实际上，工厂模式是用来创建不同但是相关类型的对象（继承同一父类或者接口的一组子类），由给定的参数来决定创建哪种类型的对象。建造者模式是用来创建一种类型的复杂对象，通过设置不同的可选参数，“定制化”地创建不同的对象。\n\n\n\n网上有一个经典的例子很好地解释了两者的区别:\n\n> 顾客走进一家餐馆点餐，我们利用工厂模式，根据用户不同的选择，来制作不同的食物，比如披萨、汉堡、沙拉。对于披萨来说，用户又有各种配料可以定制，比如奶酪、西红柿、起司，我们通过建造者模式根据用户选择的不同配料来制作披萨。\n\n实际上，我们也不要太学院派，非得把工厂模式、建造者模式分得那么清楚，我们需要知道的是，每个模式为什么这么设计，能解决什么问题。只有了解了这些最本质的东西，我们才能不生搬硬套，才能灵活应用，甚至可以混用各种模式创造出新的模式，来解决特定场景的问题。\n\n\n\n\n\n\n\n# 原型模式【不常用】\n\n今天的讲解跟具体某一语言的语法机制无关，而是通过一个 clone 散列表的例子带你搞清楚：原型模式的应用场景，以及它的两种实现方式：深拷贝和浅拷贝。虽然原型模式的原理和代码实现非常简单，但今天举的例子还是稍微有点复杂的\n\n\n\n## 原型模式的原理与应用\n\n如果对象的创建成本比较大，而同一个类的不同对象之间差别不大（大部分字段都相同），在这种情况下，我们可以利用对已有对象（原型）进行复制（或者叫拷贝）的方式来创建新对象，以达到节省创建时间的目的。这种基于原型来创建对象的方式就叫作原型设计模式（Prototype Design Pattern），简称原型模式。\n\n\n\n> 那何为“对象的创建成本比较大”？\n\n1. 实际上，创建对象包含的申请内存、给成员变量赋值这一过程，本身并不会花费太多时间，或者说对于大部分业务系统来说，这点时间完全是可以忽略的。应用一个复杂的模式，只得到一点点的性能提升，这就是所谓的过度设计，得不偿失。\n2. 但是，如果对象中的数据需要经过复杂的计算才能得到（比如排序、计算哈希值），或者需要从 RPC、网络、数据库、文件系统等非常慢速的 IO 中读取，这种情况下，我们就可以利用原型模式，从其他已有对象中直接拷贝得到，而不用每次在创建新对象的时候，都重复执行这些耗时的操作。\n\n\n\n> 这么说还是比较理论，接下来，我们通过一个例子来解释一下刚刚这段话。\n\n\n\n1. 假设数据库中存储了大约 10 万条“搜索关键词”信息，每条信息包含关键词、关键词被搜索的次数、信息最近被更新的时间等。系统 A 在启动的时候会加载这份数据到内存中，用于处理某些其他的业务需求。为了方便快速地查找某个关键词对应的信息，我们给关键词建立一个散列表索引。\n2. 如果你熟悉的是 Java 语言，可以直接使用语言中提供的 HashMap 容器来实现。其中，HashMap 的 key 为搜索关键词，value 为关键词详细信息（比如搜索次数）。我们只需要将数据从数据库中读取出来，放入 HashMap 就可以了。\n3. 不过，我们还有另外一个系统 B，专门用来分析搜索日志，定期（比如间隔 10 分钟）批量地更新数据库中的数据，并且标记为新的数据版本。比如，在下面的示例图中，我们对 v2 版本的数据进行更新，得到 v3 版本的数据。这里我们假设只有更新和新添关键词，没有删除关键词的行为。\n\n<img src=\"https://npm.elemecdn.com/youthlql@1.0.0/design_patterns/creational/03.02/0002.png\"/>\n\n\n\n1. 为了保证系统 A 中数据的实时性（不一定非常实时，但数据也不能太旧），系统 A 需要定期根据数据库中的数据，更新内存中的索引和数据。\n2. 我们该如何实现这个需求呢？实际上，也不难。我们只需要在系统 A 中，记录当前数据的版本 Va 对应的更新时间 Ta，从数据库中捞出更新时间大于 Ta 的所有搜索关键词，也就是找出 Va 版本与最新版本数据的“差集”，然后针对差集中的每个关键词进行处理。如果它已经在散列表中存在了，我们就更新相应的搜索次数、更新时间等信息；如果它在散列表中不存在，我们就将它插入到散列表中。\n3. 按照这个设计思路，我给出的示例代码如下所示：\n\n```java\npublic class Demo {\n  private ConcurrentHashMap<String, SearchWord> currentKeywords = new ConcurrentHashMap<>();\n  private long lastUpdateTime = -1;\n\n  public void refresh() {\n    // 从数据库中取出更新时间>lastUpdateTime的数据，放入到currentKeywords中\n    List<SearchWord> toBeUpdatedSearchWords = getSearchWords(lastUpdateTime);\n    long maxNewUpdatedTime = lastUpdateTime;\n    for (SearchWord searchWord : toBeUpdatedSearchWords) {\n      if (searchWord.getLastUpdateTime() > maxNewUpdatedTime) {\n        maxNewUpdatedTime = searchWord.getLastUpdateTime();\n      }\n      if (currentKeywords.containsKey(searchWord.getKeyword())) {\n        currentKeywords.replace(searchWord.getKeyword(), searchWord);\n      } else {\n        currentKeywords.put(searchWord.getKeyword(), searchWord);\n      }\n    }\n\n    lastUpdateTime = maxNewUpdatedTime;\n  }\n\n  private List<SearchWord> getSearchWords(long lastUpdateTime) {\n    // TODO: 从数据库中取出更新时间>lastUpdateTime的数据\n    return null;\n  }\n}\n```\n\n\n\n不过，现在，我们有一个特殊的要求：任何时刻，系统 A 中的所有数据都必须是同一个版本的，要么都是版本 a，要么都是版本 b，不能有的是版本 a，有的是版本 b。那刚刚的更新方式就不能满足这个要求了（因为数据很多，一个一个的for循环肯定会出现不同数据版本的问题）。除此之外，我们还要求：在更新内存数据的时候，系统 A 不能处于不可用状态，也就是不能停机更新数据。\n\n\n\n1. 那我们该如何实现现在这个需求呢？\n\n2. 实际上，也不难。我们把正在使用的数据的版本定义为“服务版本”，当我们要更新内存中的数据的时候，我们并不是直接在服务版本（假设是版本 a 数据）上更新，而是重新创建另一个版本数据（假设是版本 b 数据），等新的版本数据建好之后，再一次性地将服务版本从版本 a 切换到版本 b。这样既保证了数据一直可用，又避免了中间状态的存在。\n3. 按照这个设计思路，我给出的示例代码如下所示：\n\n```java\npublic class Demo {\n  private HashMap<String, SearchWord> currentKeywords=new HashMap<>();\n\n  public void refresh() {\n    HashMap<String, SearchWord> newKeywords = new LinkedHashMap<>();\n\n    // 从数据库中取出所有的数据，放入到newKeywords中\n    List<SearchWord> toBeUpdatedSearchWords = getSearchWords();\n    for (SearchWord searchWord : toBeUpdatedSearchWords) {\n      newKeywords.put(searchWord.getKeyword(), searchWord);\n    }\n\n    currentKeywords = newKeywords;\n  }\n\n  private List<SearchWord> getSearchWords() {\n    // TODO: 从数据库中取出所有的数据\n    return null;\n  }\n}\n```\n\n\n\n1. 不过，在上面的代码实现中，newKeywords 构建的成本比较高。我们需要将这 10 万条数据从数据库中读出，然后计算哈希值，构建 newKeywords。这个过程显然是比较耗时。为了提高效率，原型模式就派上用场了。\n2. 我们拷贝 currentKeywords 数据到 newKeywords 中，然后从数据库中只捞出新增或者有更新的关键词，更新到 newKeywords 中。而相对于 10 万条数据来说，每次新增或者更新的关键词个数是比较少的，所以，这种策略大大提高了数据更新的效率。\n3. 按照这个设计思路，我给出的示例代码如下所示：\n\n```java\npublic class Demo {\n  private HashMap<String, SearchWord> currentKeywords=new HashMap<>();\n  private long lastUpdateTime = -1;\n\n  public void refresh() {\n    // 原型模式就这么简单，拷贝已有对象的数据，更新少量差值\n    HashMap<String, SearchWord> newKeywords = (HashMap<String, SearchWord>) currentKeywords.clone();\n\n    // 从数据库中取出更新时间>lastUpdateTime的数据，放入到newKeywords中\n    List<SearchWord> toBeUpdatedSearchWords = getSearchWords(lastUpdateTime);\n    long maxNewUpdatedTime = lastUpdateTime;\n    for (SearchWord searchWord : toBeUpdatedSearchWords) {\n      if (searchWord.getLastUpdateTime() > maxNewUpdatedTime) {\n        maxNewUpdatedTime = searchWord.getLastUpdateTime();\n      }\n      if (newKeywords.containsKey(searchWord.getKeyword())) {\n        SearchWord oldSearchWord = newKeywords.get(searchWord.getKeyword());\n        oldSearchWord.setCount(searchWord.getCount());\n        oldSearchWord.setLastUpdateTime(searchWord.getLastUpdateTime());\n      } else {\n        newKeywords.put(searchWord.getKeyword(), searchWord);\n      }\n    }\n\n    lastUpdateTime = maxNewUpdatedTime;\n    currentKeywords = newKeywords;\n  }\n\n  private List<SearchWord> getSearchWords(long lastUpdateTime) {\n    // TODO: 从数据库中取出更新时间>lastUpdateTime的数据\n    return null;\n  }\n}\n```\n\n1. 这里我们利用了 Java 中的 clone() 语法来复制一个对象。如果你熟悉的语言没有这个语法，那把数据从 currentKeywords 中一个个取出来，然后再重新计算哈希值，放入到 newKeywords 中也是可以接受的。毕竟，最耗时的还是从数据库中取数据的操作。相对于数据库的 IO 操作来说，内存操作和 CPU 计算的耗时都是可以忽略的。\n2. 不过，不知道你有没有发现，实际上，刚刚的代码实现是有问题的。要弄明白到底有什么问题，我们需要先了解另外两个概念：深拷贝（Deep Copy）和浅拷贝（Shallow Copy）。\n\n\n\n\n\n## 原型模式的实现方式：深拷贝和浅拷贝\n\n> 1、关于深拷贝浅拷贝，我觉得这篇文章讲的不错：https://blog.csdn.net/baiye_xing/article/details/71788741\n\n\n\n> 我自己的总结：\n>\n> **浅拷贝**：对一个对象进行拷贝时，这个对象对应的类里的成员变量。\n>\n> - 对于数据类型是基本数据类型的成员变量，浅拷贝会直接进行值拷贝，也就是将该属性值复制一份给新的对象。因为是两份不同的数据，所以对其中一个对象的该成员变量值进行修改，不会影响另一个对象拷贝得到的数据\n> - 对于数据类型是引用数据类型的成员变量(也就是子对象，或者数组啥的)，也就是只是将该成员变量的引用值（引用拷贝【并发引用传递，Java本质还是值传递】）复制一份给新的对象。因为实际上两个对象的该成员变量都指向同一个实例。在这种情况下，在一个对象中修改该成员变量会影响到另一个对象的该成员变量值。\n>\n> 1. **深拷贝**：对基本数据类型进行值传递，对引用数据类型，创建一个新的对象，并复制其内容，此为深拷贝。\n> 2. 也就是说浅拷贝对于子对象只是拷贝了引用值，并没有真正的拷贝整个对象。\n>\n> **深拷贝实现思路：**\n>\n> 1. 对于每个子对象都实现Cloneable 接口，并重写clone方法。最后在最顶层的类的重写的 clone 方法中调用所有子对象的 clone 方法即可实现深拷贝。【简单的说就是：每一层的每个子对象都进行浅拷贝=深拷贝】\n>\n> 2. 利用序列化。【先对对象进行序列化，紧接着马上反序列化出 】\n\n\n\n我们来看，在内存中，用散列表组织的搜索关键词信息是如何存储的。我画了一张示意图，大致结构如下所示。从图中我们可以发现，散列表索引中，每个结点存储的 key 是搜索关键词，value 是 SearchWord 对象的内存地址。SearchWord 对象本身存储在散列表之外的内存空间中。\n\n<img src=\"https://npm.elemecdn.com/youthlql@1.0.0/design_patterns/creational/03.02/0003.png\"  />\n\n浅拷贝和深拷贝的区别在于，浅拷贝只会复制图中的索引（散列表），不会复制数据（SearchWord 对象）本身。相反，深拷贝不仅仅会复制索引，还会复制数据本身。浅拷贝得到的对象（newKeywords）跟原始对象（currentKeywords）共享数据（SearchWord 对象），而深拷贝得到的是一份完完全全独立的对象。具体的对比如下图所示：\n\n<img src=\"https://npm.elemecdn.com/youthlql@1.0.0/design_patterns/creational/03.02/0004.png\"/>\n\n\n\n<img src=\"https://npm.elemecdn.com/youthlql@1.0.0/design_patterns/creational/03.02/0005.png\" />\n\n\n\n1. 在 Java 语言中，Object 类的 clone() 方法执行的就是我们刚刚说的浅拷贝。它只会拷贝对象中的基本数据类型的数据（比如，int、long），以及引用对象（SearchWord）的内存地址，不会递归地拷贝引用对象本身。\n2. 在上面的代码中，我们通过调用 HashMap 上的 clone() 浅拷贝方法来实现原型模式。当我们通过 newKeywords 更新 SearchWord 对象的时候（比如，更新“设计模式”这个搜索关键词的访问次数），newKeywords 和 currentKeywords 因为指向相同的一组 SearchWord 对象，就会导致 currentKeywords 中指向的 SearchWord，有的是老版本的，有的是新版本的，就没法满足我们之前的需求：currentKeywords 中的数据在任何时刻都是同一个版本的，不存在介于老版本与新版本之间的中间状态。\n\n3. 现在，我们又该如何来解决这个问题呢？\n\n4. 我们可以将浅拷贝替换为深拷贝。newKeywords 不仅仅复制 currentKeywords 的索引，还把 SearchWord 对象也复制一份出来，这样 newKeywords 和 currentKeywords 就指向不同的 SearchWord 对象，也就不存在更新 newKeywords 的数据会导致 currentKeywords 的数据也被更新的问题了。\n5. 那如何实现深拷贝呢？总结一下的话，有下面两种方法。\n\n\n\n第一种方法：递归拷贝对象、对象的引用对象以及引用对象的引用对象……直到要拷贝的对象只包含基本数据类型数据，没有引用对象为止。根据这个思路对之前的代码进行重构。重构之后的代码如下所示：\n\n```java\npublic class Demo {\n  private HashMap<String, SearchWord> currentKeywords=new HashMap<>();\n  private long lastUpdateTime = -1;\n\n  public void refresh() {\n    // Deep copy\n    HashMap<String, SearchWord> newKeywords = new HashMap<>();\n    for (HashMap.Entry<String, SearchWord> e : currentKeywords.entrySet()) {\n      SearchWord searchWord = e.getValue();\n      SearchWord newSearchWord = new SearchWord(\n              searchWord.getKeyword(), searchWord.getCount(), searchWord.getLastUpdateTime());\n      newKeywords.put(e.getKey(), newSearchWord);\n    }\n\n    // 从数据库中取出更新时间>lastUpdateTime的数据，放入到newKeywords中\n    List<SearchWord> toBeUpdatedSearchWords = getSearchWords(lastUpdateTime);\n    long maxNewUpdatedTime = lastUpdateTime;\n    for (SearchWord searchWord : toBeUpdatedSearchWords) {\n      if (searchWord.getLastUpdateTime() > maxNewUpdatedTime) {\n        maxNewUpdatedTime = searchWord.getLastUpdateTime();\n      }\n      if (newKeywords.containsKey(searchWord.getKeyword())) {\n        SearchWord oldSearchWord = newKeywords.get(searchWord.getKeyword());\n        oldSearchWord.setCount(searchWord.getCount());\n        oldSearchWord.setLastUpdateTime(searchWord.getLastUpdateTime());\n      } else {\n        newKeywords.put(searchWord.getKeyword(), searchWord);\n      }\n    }\n\n    lastUpdateTime = maxNewUpdatedTime;\n    currentKeywords = newKeywords;\n  }\n\n  private List<SearchWord> getSearchWords(long lastUpdateTime) {\n    // TODO: 从数据库中取出更新时间>lastUpdateTime的数据\n    return null;\n  }\n\n}\n```\n\n\n\n第二种方法：先将对象序列化，然后再反序列化成新的对象。具体的示例代码如下所示：\n\n```java\npublic Object deepCopy(Object object) {\n  ByteArrayOutputStream bo = new ByteArrayOutputStream();\n  ObjectOutputStream oo = new ObjectOutputStream(bo);\n  oo.writeObject(object);\n  \n  ByteArrayInputStream bi = new ByteArrayInputStream(bo.toByteArray());\n  ObjectInputStream oi = new ObjectInputStream(bi);\n  \n  return oi.readObject();\n}\n```\n\n1. 刚刚的两种实现方法，不管采用哪种，深拷贝都要比浅拷贝耗时、耗内存空间。针对我们这个应用场景，有没有更快、更省内存的实现方式呢？\n2. 我们可以先采用浅拷贝的方式创建 newKeywords。对于需要更新的 SearchWord 对象，我们再使用深度拷贝的方式创建一份新的对象，替换 newKeywords 中的老对象。毕竟需要更新的数据是很少的。这种方式即利用了浅拷贝节省时间、空间的优点，又能保证 currentKeywords 中的中数据都是老版本的数据。具体的代码实现如下所示。这也是标题中讲到的，在我们这个应用场景下，最快速 clone 散列表的方式。\n\n\n\n```java\npublic class Demo {\n  private HashMap<String, SearchWord> currentKeywords=new HashMap<>();\n  private long lastUpdateTime = -1;\n\n  public void refresh() {\n    // Shallow copy\n    HashMap<String, SearchWord> newKeywords = (HashMap<String, SearchWord>) currentKeywords.clone();\n\n    // 从数据库中取出更新时间>lastUpdateTime的数据，放入到newKeywords中\n    List<SearchWord> toBeUpdatedSearchWords = getSearchWords(lastUpdateTime);\n    long maxNewUpdatedTime = lastUpdateTime;\n    for (SearchWord searchWord : toBeUpdatedSearchWords) {\n      if (searchWord.getLastUpdateTime() > maxNewUpdatedTime) {\n        maxNewUpdatedTime = searchWord.getLastUpdateTime();\n      }\n      if (newKeywords.containsKey(searchWord.getKeyword())) {\n        newKeywords.remove(searchWord.getKeyword());\n      }\n      newKeywords.put(searchWord.getKeyword(), searchWord);\n    }\n\n    lastUpdateTime = maxNewUpdatedTime;\n    currentKeywords = newKeywords;\n  }\n\n  private List<SearchWord> getSearchWords(long lastUpdateTime) {\n    // TODO: 从数据库中取出更新时间>lastUpdateTime的数据\n    return null;\n  }\n}\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"2024-06-18-设计模式-03.02-创建型-工厂&建造者&原型","published":1,"updated":"2024-06-18T05:25:21.165Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cly2c4k3u000xqsvd4tr9564x","content":"<h1 id=\"声明\"><a href=\"#声明\" class=\"headerlink\" title=\"声明\"></a>声明</h1><blockquote>\n<ol>\n<li>此系列文章非本人原创，是学习笔记。</li>\n<li>设计模式系列以后会持续更新，包括已经发布的设计模式文章，因为后续还要再多看一下书，教程和开源项目等，继续润色文章。</li>\n</ol>\n</blockquote>\n<h1 id=\"工厂模式【常用】\"><a href=\"#工厂模式【常用】\" class=\"headerlink\" title=\"工厂模式【常用】\"></a>工厂模式【常用】</h1><blockquote>\n<p>工厂模式很重要，后面的很多架构设计，都是工厂模式联合着其它设计模式使用。</p>\n</blockquote>\n<ol>\n<li><p>一般情况下，工厂模式分为三种更加细分的类型：简单工厂、工厂方法和抽象工厂。不过，在 GoF 的《设计模式》一书中，它将简单工厂模式看作是工厂方法模式的一种特例，所以工厂模式只被分成了工厂方法和抽象工厂两类。实际上，前面一种分类方法更加常见，所以，在今天的讲解中，我们沿用第一种分类方法。</p>\n</li>\n<li><p>在这三种细分的工厂模式中，简单工厂、工厂方法原理比较简单，在实际的项目中也比较常用。而抽象工厂的原理稍微复杂点，在实际的项目中相对也不常用。所以，我们今天讲解的重点是前两种工厂模式。对于抽象工厂，稍微了解一下即可。</p>\n</li>\n<li><p>除此之外，我们讲解的重点也不是原理和实现，因为这些都很简单，重点还是带你搞清楚应用场景：什么时候该用工厂模式？相对于直接 new 来创建对象，用工厂模式来创建究竟有什么好处呢？</p>\n</li>\n</ol>\n<h2 id=\"简单工厂（Simple-Factory）\"><a href=\"#简单工厂（Simple-Factory）\" class=\"headerlink\" title=\"简单工厂（Simple Factory）\"></a>简单工厂（Simple Factory）</h2><p>首先，我们来看，什么是简单工厂模式。我们通过一个例子来解释一下。</p>\n<p>在下面这段代码中，我们根据配置文件的后缀（json、xml、yaml、properties），选择不同的解析器（JsonRuleConfigParser、XmlRuleConfigParser……），将存储在文件中的配置解析成内存对象 RuleConfig。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">RuleConfigSource</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> RuleConfig <span class=\"title function_\">load</span><span class=\"params\">(String ruleConfigFilePath)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">ruleConfigFileExtension</span> <span class=\"operator\">=</span> getFileExtension(ruleConfigFilePath);</span><br><span class=\"line\">    <span class=\"type\">IRuleConfigParser</span> <span class=\"variable\">parser</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"string\">&quot;json&quot;</span>.equalsIgnoreCase(ruleConfigFileExtension)) &#123;</span><br><span class=\"line\">      parser = <span class=\"keyword\">new</span> <span class=\"title class_\">JsonRuleConfigParser</span>();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"string\">&quot;xml&quot;</span>.equalsIgnoreCase(ruleConfigFileExtension)) &#123;</span><br><span class=\"line\">      parser = <span class=\"keyword\">new</span> <span class=\"title class_\">XmlRuleConfigParser</span>();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"string\">&quot;yaml&quot;</span>.equalsIgnoreCase(ruleConfigFileExtension)) &#123;</span><br><span class=\"line\">      parser = <span class=\"keyword\">new</span> <span class=\"title class_\">YamlRuleConfigParser</span>();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"string\">&quot;properties&quot;</span>.equalsIgnoreCase(ruleConfigFileExtension)) &#123;</span><br><span class=\"line\">      parser = <span class=\"keyword\">new</span> <span class=\"title class_\">PropertiesRuleConfigParser</span>();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">InvalidRuleConfigException</span>(</span><br><span class=\"line\">             <span class=\"string\">&quot;Rule config file format is not supported: &quot;</span> + ruleConfigFilePath);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">configText</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">    <span class=\"comment\">//从ruleConfigFilePath文件中读取配置文本到configText中</span></span><br><span class=\"line\">    <span class=\"type\">RuleConfig</span> <span class=\"variable\">ruleConfig</span> <span class=\"operator\">=</span> parser.parse(configText);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ruleConfig;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> String <span class=\"title function_\">getFileExtension</span><span class=\"params\">(String filePath)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//...解析文件名获取扩展名，比如rule.json，返回json</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;json&quot;</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>为了让代码逻辑更加清晰，可读性更好，我们要善于将功能独立的代码块封装成函数。按照这个设计思路，我们可以将代码中涉及 parser 创建的部分逻辑剥离出来，抽象成 createParser() 函数。重构之后的代码如下所示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  <span class=\"keyword\">public</span> RuleConfig <span class=\"title function_\">load</span><span class=\"params\">(String ruleConfigFilePath)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">ruleConfigFileExtension</span> <span class=\"operator\">=</span> getFileExtension(ruleConfigFilePath);</span><br><span class=\"line\">    <span class=\"type\">IRuleConfigParser</span> <span class=\"variable\">parser</span> <span class=\"operator\">=</span> createParser(ruleConfigFileExtension);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (parser == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">InvalidRuleConfigException</span>(</span><br><span class=\"line\">              <span class=\"string\">&quot;Rule config file format is not supported: &quot;</span> + ruleConfigFilePath);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">configText</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">    <span class=\"comment\">//从ruleConfigFilePath文件中读取配置文本到configText中</span></span><br><span class=\"line\">    <span class=\"type\">RuleConfig</span> <span class=\"variable\">ruleConfig</span> <span class=\"operator\">=</span> parser.parse(configText);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ruleConfig;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> String <span class=\"title function_\">getFileExtension</span><span class=\"params\">(String filePath)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//...解析文件名获取扩展名，比如rule.json，返回json</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;json&quot;</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> IRuleConfigParser <span class=\"title function_\">createParser</span><span class=\"params\">(String configFormat)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">IRuleConfigParser</span> <span class=\"variable\">parser</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"string\">&quot;json&quot;</span>.equalsIgnoreCase(configFormat)) &#123;</span><br><span class=\"line\">      parser = <span class=\"keyword\">new</span> <span class=\"title class_\">JsonRuleConfigParser</span>();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"string\">&quot;xml&quot;</span>.equalsIgnoreCase(configFormat)) &#123;</span><br><span class=\"line\">      parser = <span class=\"keyword\">new</span> <span class=\"title class_\">XmlRuleConfigParser</span>();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"string\">&quot;yaml&quot;</span>.equalsIgnoreCase(configFormat)) &#123;</span><br><span class=\"line\">      parser = <span class=\"keyword\">new</span> <span class=\"title class_\">YamlRuleConfigParser</span>();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"string\">&quot;properties&quot;</span>.equalsIgnoreCase(configFormat)) &#123;</span><br><span class=\"line\">      parser = <span class=\"keyword\">new</span> <span class=\"title class_\">PropertiesRuleConfigParser</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> parser;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>为了让类的职责更加单一(<strong>设计模式原则中的单一职责</strong>，)、代码更加清晰，我们还可以进一步将 createParser() 函数剥离到一个独立的类中，让这个类只负责对象的创建。而这个类就是我们现在要讲的简单工厂模式类。具体的代码如下所示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">RuleConfigSource</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> RuleConfig <span class=\"title function_\">load</span><span class=\"params\">(String ruleConfigFilePath)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">ruleConfigFileExtension</span> <span class=\"operator\">=</span> getFileExtension(ruleConfigFilePath);</span><br><span class=\"line\">    <span class=\"type\">IRuleConfigParser</span> <span class=\"variable\">parser</span> <span class=\"operator\">=</span> RuleConfigParserFactory.createParser(ruleConfigFileExtension);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (parser == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">InvalidRuleConfigException</span>(</span><br><span class=\"line\">              <span class=\"string\">&quot;Rule config file format is not supported: &quot;</span> + ruleConfigFilePath);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">configText</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">    <span class=\"comment\">//从ruleConfigFilePath文件中读取配置文本到configText中</span></span><br><span class=\"line\">    <span class=\"type\">RuleConfig</span> <span class=\"variable\">ruleConfig</span> <span class=\"operator\">=</span> parser.parse(configText);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ruleConfig;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> String <span class=\"title function_\">getFileExtension</span><span class=\"params\">(String filePath)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//...解析文件名获取扩展名，比如rule.json，返回json</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;json&quot;</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">RuleConfigParserFactory</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> IRuleConfigParser <span class=\"title function_\">createParser</span><span class=\"params\">(String configFormat)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">IRuleConfigParser</span> <span class=\"variable\">parser</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"string\">&quot;json&quot;</span>.equalsIgnoreCase(configFormat)) &#123;</span><br><span class=\"line\">      parser = <span class=\"keyword\">new</span> <span class=\"title class_\">JsonRuleConfigParser</span>();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"string\">&quot;xml&quot;</span>.equalsIgnoreCase(configFormat)) &#123;</span><br><span class=\"line\">      parser = <span class=\"keyword\">new</span> <span class=\"title class_\">XmlRuleConfigParser</span>();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"string\">&quot;yaml&quot;</span>.equalsIgnoreCase(configFormat)) &#123;</span><br><span class=\"line\">      parser = <span class=\"keyword\">new</span> <span class=\"title class_\">YamlRuleConfigParser</span>();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"string\">&quot;properties&quot;</span>.equalsIgnoreCase(configFormat)) &#123;</span><br><span class=\"line\">      parser = <span class=\"keyword\">new</span> <span class=\"title class_\">PropertiesRuleConfigParser</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> parser;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<ol>\n<li>在上面的代码实现中，我们每次调用 RuleConfigParserFactory 的 createParser() 的时候，都要创建一个新的 parser。</li>\n<li>实际上，如果 parser 可以复用，为了节省内存和对象创建的时间，我们可以将 parser 事先创建好缓存起来。当调用 createParser() 函数的时候，我们从缓存中取出 parser 对象直接使用。这有点类似单例模式和简单工厂模式的结合，具体的代码实现如下所示。在接下来的讲解中，我们把上一种实现方法叫作简单工厂模式的第一种实现方法，把下面这种实现方法叫作简单工厂模式的第二种实现方法。</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">RuleConfigParserFactory</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Map&lt;String, RuleConfigParser&gt; cachedParsers = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">    cachedParsers.put(<span class=\"string\">&quot;json&quot;</span>, <span class=\"keyword\">new</span> <span class=\"title class_\">JsonRuleConfigParser</span>());</span><br><span class=\"line\">    cachedParsers.put(<span class=\"string\">&quot;xml&quot;</span>, <span class=\"keyword\">new</span> <span class=\"title class_\">XmlRuleConfigParser</span>());</span><br><span class=\"line\">    cachedParsers.put(<span class=\"string\">&quot;yaml&quot;</span>, <span class=\"keyword\">new</span> <span class=\"title class_\">YamlRuleConfigParser</span>());</span><br><span class=\"line\">    cachedParsers.put(<span class=\"string\">&quot;properties&quot;</span>, <span class=\"keyword\">new</span> <span class=\"title class_\">PropertiesRuleConfigParser</span>());</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> IRuleConfigParser <span class=\"title function_\">createParser</span><span class=\"params\">(String configFormat)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (configFormat == <span class=\"literal\">null</span> || configFormat.isEmpty()) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;<span class=\"comment\">//返回null还是IllegalArgumentException全凭你自己说了算</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">IRuleConfigParser</span> <span class=\"variable\">parser</span> <span class=\"operator\">=</span> cachedParsers.get(configFormat.toLowerCase());</span><br><span class=\"line\">    <span class=\"keyword\">return</span> parser;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<ol>\n<li>对于上面两种简单工厂模式的实现方法，如果我们要添加新的 parser，那势必要改动到 RuleConfigParserFactory 的代码，那这是不是违反开闭原则呢？实际上，如果不是需要频繁地添加新的 parser，只是偶尔修改一下 RuleConfigParserFactory 代码，稍微不符合开闭原则，也是完全可以接受的。</li>\n<li>除此之外，在 RuleConfigParserFactory 的第一种代码实现中，有一组 if 分支判断逻辑，是不是应该用多态或其他设计模式来替代呢？实际上，如果 if 分支并不是很多，代码中有 if 分支也是完全可以接受的。应用多态或设计模式来替代 if 分支判断逻辑，也并不是没有任何缺点的，它虽然提高了代码的扩展性，更加符合<strong>开闭原则</strong>，但也增加了类的个数，牺牲了代码的可读性。关于这一点，我们在后面章节中会详细讲到。</li>\n<li>总结一下，尽管简单工厂模式的代码实现中，有多处 if 分支判断逻辑，违背开闭原则，但权衡扩展性和可读性，这样的代码实现在大多数情况下（比如，不需要频繁地添加 parser，也没有太多的 parser）是没有问题的。</li>\n</ol>\n<h2 id=\"工厂方法（Factory-Method）\"><a href=\"#工厂方法（Factory-Method）\" class=\"headerlink\" title=\"工厂方法（Factory Method）\"></a>工厂方法（Factory Method）</h2><p>如果我们非得要将 if 分支逻辑去掉，那该怎么办呢？比较经典处理方法就是利用多态。按照多态的实现思路，对上面的代码进行重构。重构之后的代码如下所示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">IRuleConfigParserFactory</span> &#123;</span><br><span class=\"line\">  IRuleConfigParser <span class=\"title function_\">createParser</span><span class=\"params\">()</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">JsonRuleConfigParserFactory</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">IRuleConfigParserFactory</span> &#123;</span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> IRuleConfigParser <span class=\"title function_\">createParser</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">JsonRuleConfigParser</span>();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">XmlRuleConfigParserFactory</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">IRuleConfigParserFactory</span> &#123;</span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> IRuleConfigParser <span class=\"title function_\">createParser</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">XmlRuleConfigParser</span>();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">YamlRuleConfigParserFactory</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">IRuleConfigParserFactory</span> &#123;</span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> IRuleConfigParser <span class=\"title function_\">createParser</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">YamlRuleConfigParser</span>();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">PropertiesRuleConfigParserFactory</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">IRuleConfigParserFactory</span> &#123;</span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> IRuleConfigParser <span class=\"title function_\">createParser</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">PropertiesRuleConfigParser</span>();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>实际上，这就是工厂方法模式的典型代码实现。这样当我们新增一种 parser 的时候，只需要新增一个实现了 IRuleConfigParserFactory 接口的 Factory 类即可。所以，工厂方法模式比起简单工厂模式更加符合开闭原则。</p>\n<p>从上面的工厂方法的实现来看，一切都很完美，但是实际上存在挺大的问题。问题存在于这些工厂类的使用上。接下来，我们看一下，如何用这些工厂类来实现 RuleConfigSource 的 load() 函数。具体的代码如下所示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">RuleConfigSource</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> RuleConfig <span class=\"title function_\">load</span><span class=\"params\">(String ruleConfigFilePath)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">ruleConfigFileExtension</span> <span class=\"operator\">=</span> getFileExtension(ruleConfigFilePath);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">IRuleConfigParserFactory</span> <span class=\"variable\">parserFactory</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"string\">&quot;json&quot;</span>.equalsIgnoreCase(ruleConfigFileExtension)) &#123;</span><br><span class=\"line\">      parserFactory = <span class=\"keyword\">new</span> <span class=\"title class_\">JsonRuleConfigParserFactory</span>();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"string\">&quot;xml&quot;</span>.equalsIgnoreCase(ruleConfigFileExtension)) &#123;</span><br><span class=\"line\">      parserFactory = <span class=\"keyword\">new</span> <span class=\"title class_\">XmlRuleConfigParserFactory</span>();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"string\">&quot;yaml&quot;</span>.equalsIgnoreCase(ruleConfigFileExtension)) &#123;</span><br><span class=\"line\">      parserFactory = <span class=\"keyword\">new</span> <span class=\"title class_\">YamlRuleConfigParserFactory</span>();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"string\">&quot;properties&quot;</span>.equalsIgnoreCase(ruleConfigFileExtension)) &#123;</span><br><span class=\"line\">      parserFactory = <span class=\"keyword\">new</span> <span class=\"title class_\">PropertiesRuleConfigParserFactory</span>();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">InvalidRuleConfigException</span>(<span class=\"string\">&quot;Rule config file format is not supported: &quot;</span> + ruleConfigFilePath);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">IRuleConfigParser</span> <span class=\"variable\">parser</span> <span class=\"operator\">=</span> parserFactory.createParser();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">configText</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">    <span class=\"comment\">//从ruleConfigFilePath文件中读取配置文本到configText中</span></span><br><span class=\"line\">    <span class=\"type\">RuleConfig</span> <span class=\"variable\">ruleConfig</span> <span class=\"operator\">=</span> parser.parse(configText);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ruleConfig;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> String <span class=\"title function_\">getFileExtension</span><span class=\"params\">(String filePath)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//...解析文件名获取扩展名，比如rule.json，返回json</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;json&quot;</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<ol>\n<li>从上面的代码实现来看，工厂类对象的创建逻辑又耦合进了 load() 函数中，跟我们最初的代码版本非常相似，引入工厂方法非但没有解决问题，反倒让设计变得更加复杂了。那怎么来解决这个问题呢？</li>\n<li>我们可以为工厂类再创建一个简单工厂，也就是工厂的工厂，用来创建工厂类对象。这段话听起来有点绕，我把代码实现出来了，你一看就能明白了。其中，RuleConfigParserFactoryMap 类是创建工厂对象的工厂类，getParserFactory() 返回的是缓存好的单例工厂对象。</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">RuleConfigSource</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> RuleConfig <span class=\"title function_\">load</span><span class=\"params\">(String ruleConfigFilePath)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">ruleConfigFileExtension</span> <span class=\"operator\">=</span> getFileExtension(ruleConfigFilePath);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">IRuleConfigParserFactory</span> <span class=\"variable\">parserFactory</span> <span class=\"operator\">=</span> RuleConfigParserFactoryMap.getParserFactory(ruleConfigFileExtension);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (parserFactory == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">InvalidRuleConfigException</span>(<span class=\"string\">&quot;Rule config file format is not supported: &quot;</span> + ruleConfigFilePath);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">IRuleConfigParser</span> <span class=\"variable\">parser</span> <span class=\"operator\">=</span> parserFactory.createParser();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">configText</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">    <span class=\"comment\">//从ruleConfigFilePath文件中读取配置文本到configText中</span></span><br><span class=\"line\">    <span class=\"type\">RuleConfig</span> <span class=\"variable\">ruleConfig</span> <span class=\"operator\">=</span> parser.parse(configText);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ruleConfig;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> String <span class=\"title function_\">getFileExtension</span><span class=\"params\">(String filePath)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//...解析文件名获取扩展名，比如rule.json，返回json</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;json&quot;</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//因为工厂类只包含方法，不包含成员变量，完全可以复用，</span></span><br><span class=\"line\"><span class=\"comment\">//不需要每次都创建新的工厂类对象，所以，简单工厂模式的第二种实现思路更加合适。</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">RuleConfigParserFactoryMap</span> &#123; <span class=\"comment\">//工厂的工厂</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Map&lt;String, IRuleConfigParserFactory&gt; cachedFactories = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">    cachedFactories.put(<span class=\"string\">&quot;json&quot;</span>, <span class=\"keyword\">new</span> <span class=\"title class_\">JsonRuleConfigParserFactory</span>());</span><br><span class=\"line\">    cachedFactories.put(<span class=\"string\">&quot;xml&quot;</span>, <span class=\"keyword\">new</span> <span class=\"title class_\">XmlRuleConfigParserFactory</span>());</span><br><span class=\"line\">    cachedFactories.put(<span class=\"string\">&quot;yaml&quot;</span>, <span class=\"keyword\">new</span> <span class=\"title class_\">YamlRuleConfigParserFactory</span>());</span><br><span class=\"line\">    cachedFactories.put(<span class=\"string\">&quot;properties&quot;</span>, <span class=\"keyword\">new</span> <span class=\"title class_\">PropertiesRuleConfigParserFactory</span>());</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> IRuleConfigParserFactory <span class=\"title function_\">getParserFactory</span><span class=\"params\">(String type)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (type == <span class=\"literal\">null</span> || type.isEmpty()) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">IRuleConfigParserFactory</span> <span class=\"variable\">parserFactory</span> <span class=\"operator\">=</span> cachedFactories.get(type.toLowerCase());</span><br><span class=\"line\">    <span class=\"keyword\">return</span> parserFactory;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<ol>\n<li>当我们需要添加新的规则配置解析器的时候，我们只需要创建新的 parser 类和 parser factory 类，并且在 RuleConfigParserFactoryMap 类中，将新的 parser factory 对象添加到 cachedFactories 中即可。代码的改动非常少，基本上符合开闭原则。</li>\n<li>实际上，对于规则配置文件解析这个应用场景来说，工厂模式需要额外创建诸多 Factory 类，也会增加代码的复杂性，而且，每个 Factory 类只是做简单的 new 操作，功能非常单薄（只有一行代码），也没必要设计成独立的类，所以，在这个应用场景下，简单工厂模式简单好用，比工厂方法模式更加合适。</li>\n</ol>\n<h3 id=\"那什么时候该用工厂方法模式，而非简单工厂模式呢？\"><a href=\"#那什么时候该用工厂方法模式，而非简单工厂模式呢？\" class=\"headerlink\" title=\"那什么时候该用工厂方法模式，而非简单工厂模式呢？\"></a>那什么时候该用工厂方法模式，而非简单工厂模式呢？</h3><ol>\n<li>我们前面提到，之所以将某个代码块剥离出来，独立为函数或者类，原因是这个代码块的逻辑过于复杂，剥离之后能让代码更加清晰，更加可读、可维护。但是，如果代码块本身并不复杂，就几行代码而已，我们完全没必要将它拆分成单独的函数或者类。</li>\n<li>基于这个设计思想，当对象的创建逻辑比较复杂，不只是简单的 new 一下就可以，而是要组合其他类对象，做各种初始化操作的时候，我们推荐使用工厂方法模式，将复杂的创建逻辑拆分到多个工厂类中，让每个工厂类都不至于过于复杂。而使用简单工厂模式，将所有的创建逻辑都放到一个工厂类中，会导致这个工厂类变得很复杂。</li>\n<li>除此之外，在某些场景下，如果对象不可复用，那工厂类每次都要返回不同的对象。如果我们使用简单工厂模式来实现，就只能选择第一种包含 if 分支逻辑的实现方式。如果我们还想避免烦人的 if-else 分支逻辑，这个时候，我们就推荐使用工厂方法模式。</li>\n</ol>\n<h2 id=\"抽象工厂（Abstract-Factory）\"><a href=\"#抽象工厂（Abstract-Factory）\" class=\"headerlink\" title=\"抽象工厂（Abstract Factory）\"></a>抽象工厂（Abstract Factory）</h2><ol>\n<li>讲完了简单工厂、工厂方法，我们再来看抽象工厂模式。抽象工厂模式的应用场景比较特殊，没有前两种常用，所以不是我们学习的重点，你简单了解一下就可以了。</li>\n<li>在简单工厂和工厂方法中，类只有一种分类方式。比如，在规则配置解析那个例子中，解析器类只会根据配置文件格式（Json、Xml、Yaml……）来分类。但是，如果类有两种分类方式，比如，我们既可以按照配置文件格式来分类，也可以按照解析的对象（Rule 规则配置还是 System 系统配置）来分类，那就会对应下面这 8 个 parser 类。</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">针对规则配置的解析器：基于接口IRuleConfigParser</span><br><span class=\"line\">JsonRuleConfigParser</span><br><span class=\"line\">XmlRuleConfigParser</span><br><span class=\"line\">YamlRuleConfigParser</span><br><span class=\"line\">PropertiesRuleConfigParser</span><br><span class=\"line\"></span><br><span class=\"line\">针对系统配置的解析器：基于接口ISystemConfigParser</span><br><span class=\"line\">JsonSystemConfigParser</span><br><span class=\"line\">XmlSystemConfigParser</span><br><span class=\"line\">YamlSystemConfigParser</span><br><span class=\"line\">PropertiesSystemConfigParser</span><br></pre></td></tr></table></figure>\n\n\n\n<ol>\n<li>针对这种特殊的场景，如果还是继续用工厂方法来实现的话，我们要针对每个 parser 都编写一个工厂类，也就是要编写 8 个工厂类。如果我们未来还需要增加针对业务配置的解析器（比如 IBizConfigParser），那就要再对应地增加 4 个工厂类。而我们知道，过多的类也会让系统难维护。这个问题该怎么解决呢？</li>\n<li>抽象工厂就是针对这种非常特殊的场景而诞生的。我们可以让一个工厂负责创建多个不同类型的对象（IRuleConfigParser、ISystemConfigParser 等），而不是只创建一种 parser 对象。这样就可以有效地减少工厂类的个数。具体的代码实现如下所示：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">IConfigParserFactory</span> &#123;</span><br><span class=\"line\">  IRuleConfigParser <span class=\"title function_\">createRuleParser</span><span class=\"params\">()</span>;</span><br><span class=\"line\">  ISystemConfigParser <span class=\"title function_\">createSystemParser</span><span class=\"params\">()</span>;</span><br><span class=\"line\">  <span class=\"comment\">//此处可以扩展新的parser类型，比如IBizConfigParser</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">JsonConfigParserFactory</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">IConfigParserFactory</span> &#123;</span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> IRuleConfigParser <span class=\"title function_\">createRuleParser</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">JsonRuleConfigParser</span>();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> ISystemConfigParser <span class=\"title function_\">createSystemParser</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">JsonSystemConfigParser</span>();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">XmlConfigParserFactory</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">IConfigParserFactory</span> &#123;</span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> IRuleConfigParser <span class=\"title function_\">createRuleParser</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">XmlRuleConfigParser</span>();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> ISystemConfigParser <span class=\"title function_\">createSystemParser</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">XmlSystemConfigParser</span>();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 省略YamlConfigParserFactory和PropertiesConfigParserFactory代码</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"如何设计实现一个Dependency-Injection框架？\"><a href=\"#如何设计实现一个Dependency-Injection框架？\" class=\"headerlink\" title=\"如何设计实现一个Dependency Injection框架？\"></a>如何设计实现一个Dependency Injection框架？</h2><p>当创建对象是一个“大工程”的时候，我们一般会选择使用工厂模式，来封装对象复杂的创建过程，将对象的创建和使用分离，让代码更加清晰。那何为“大工程”呢？上面我们讲了两种情况，一种是创建过程涉及复杂的 if-else 分支判断，另一种是对象创建需要组装多个其他类对象或者需要复杂的初始化过程。</p>\n<p>今天，我们再来讲一个创建对象的“大工程”，依赖注入框架，或者叫依赖注入容器（Dependency Injection Container），简称 DI 容器。在今天的讲解中，我会带你一块搞清楚这样几个问题：DI 容器跟我们讲的工厂模式又有何区别和联系？DI 容器的核心功能有哪些，以及如何实现一个简单的 DI 容器？</p>\n<h3 id=\"工厂模式和-DI-容器有何区别？\"><a href=\"#工厂模式和-DI-容器有何区别？\" class=\"headerlink\" title=\"工厂模式和 DI 容器有何区别？\"></a>工厂模式和 DI 容器有何区别？</h3><ol>\n<li>实际上，DI 容器底层最基本的设计思路就是基于工厂模式的。DI 容器相当于一个大的工厂类，负责在程序启动的时候，根据配置（要创建哪些类对象，每个类对象的创建需要依赖哪些其他类对象）事先创建好对象。当应用程序需要使用某个类对象的时候，直接从容器中获取即可。正是因为它持有一堆对象，所以这个框架才被称为“容器”。</li>\n<li>DI 容器相对于我们上面讲的工厂模式的例子来说，它处理的是更大的对象创建工程。上面讲的工厂模式中，一个工厂类只负责某个类对象或者某一组相关类对象（继承自同一抽象类或者接口的子类）的创建，而 DI 容器负责的是整个应用中所有类对象的创建。</li>\n<li>除此之外，DI 容器负责的事情要比单纯的工厂模式要多。比如，它还包括配置的解析、对象生命周期的管理。接下来，我们就详细讲讲，一个简单的 DI 容器应该包含哪些核心功能。</li>\n</ol>\n<h3 id=\"DI-容器的核心功能有哪些？\"><a href=\"#DI-容器的核心功能有哪些？\" class=\"headerlink\" title=\"DI 容器的核心功能有哪些？\"></a>DI 容器的核心功能有哪些？</h3><p>总结一下，一个简单的 DI 容器的核心功能一般有三个：配置解析、对象创建和对象生命周期管理。</p>\n<blockquote>\n<p>首先，我们来看配置解析。</p>\n</blockquote>\n<ol>\n<li>在上面讲的工厂模式中，工厂类要创建哪个类对象是事先确定好的，并且是写死在工厂类代码中的。作为一个通用的框架来说，框架代码跟应用代码应该是高度解耦的，DI 容器事先并不知道应用会创建哪些对象，不可能把某个应用要创建的对象写死在框架代码中。所以，我们需要通过一种形式，让应用告知 DI 容器要创建哪些对象。这种形式就是我们要讲的配置。</li>\n<li>我们将需要由 DI 容器来创建的类对象和创建类对象的必要信息（使用哪个构造函数以及对应的构造函数参数都是什么等等），放到配置文件中。容器读取配置文件，根据配置文件提供的信息来创建对象。</li>\n<li>下面是一个典型的 Spring 容器的配置文件。Spring 容器读取这个配置文件，解析出要创建的两个对象：rateLimiter 和 redisCounter，并且得到两者的依赖关系：rateLimiter 依赖 redisCounter。</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">RateLimiter</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> RedisCounter redisCounter;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"title function_\">RateLimiter</span><span class=\"params\">(RedisCounter redisCounter)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.redisCounter = redisCounter;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;Hello World!&quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">RedisCounter</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> String ipAddress;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"type\">int</span> port;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"title function_\">RedisCounter</span><span class=\"params\">(String ipAddress, <span class=\"type\">int</span> port)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.ipAddress = ipAddress;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.port = port;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">配置文件beans.xml：</span><br><span class=\"line\">&lt;beans&gt;</span><br><span class=\"line\">   &lt;bean id=<span class=\"string\">&quot;rateLimiter&quot;</span> class=<span class=\"string\">&quot;com.xzg.RateLimiter&quot;</span>&gt;</span><br><span class=\"line\">      &lt;constructor-arg ref=<span class=\"string\">&quot;redisCounter&quot;</span>/&gt;</span><br><span class=\"line\">   &lt;/bean&gt;</span><br><span class=\"line\"> </span><br><span class=\"line\">   &lt;bean id=<span class=\"string\">&quot;redisCounter&quot;</span> class=<span class=\"string\">&quot;com.xzg.redisCounter&quot;</span>&gt;</span><br><span class=\"line\">     &lt;constructor-arg type=<span class=\"string\">&quot;String&quot;</span> value=<span class=\"string\">&quot;127.0.0.1&quot;</span>&gt;</span><br><span class=\"line\">     &lt;constructor-arg type=<span class=\"string\">&quot;int&quot;</span> value=<span class=\"number\">1234</span>&gt;</span><br><span class=\"line\">   &lt;/bean&gt;</span><br><span class=\"line\">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>\n\n\n\n<blockquote>\n<p>其次，我们再来看对象创建。</p>\n</blockquote>\n<ol>\n<li>在 DI 容器中，如果我们给每个类都对应创建一个工厂类，那项目中类的个数会成倍增加，这会增加代码的维护成本。要解决这个问题并不难。我们只需要将所有类对象的创建都放到一个工厂类中完成就可以了，比如 BeansFactory。</li>\n<li>你可能会说，如果要创建的类对象非常多，BeansFactory 中的代码会不会线性膨胀（代码量跟创建对象的个数成正比）呢？实际上并不会。待会讲到 DI 容器的具体实现的时候，我们会讲“反射”这种机制，它能在程序运行的过程中，动态地加载类、创建对象，不需要事先在代码中写死要创建哪些对象。所以，不管是创建一个对象还是十个对象，BeansFactory 工厂类代码都是一样的。</li>\n</ol>\n<blockquote>\n<p>最后，我们来看对象的生命周期管理。</p>\n</blockquote>\n<ol>\n<li>上面我们讲到，简单工厂模式有两种实现方式，一种是每次都返回新创建的对象，另一种是每次都返回同一个事先创建好的对象，也就是所谓的单例对象。在 Spring 框架中，我们可以通过配置 scope 属性，来区分这两种不同类型的对象。scope&#x3D;prototype 表示返回新创建的对象，scope&#x3D;singleton 表示返回单例对象。</li>\n<li>除此之外，我们还可以配置对象是否支持懒加载。如果 lazy-init&#x3D;true，对象在真正被使用到的时候（比如：BeansFactory.getBean(“userService”)）才被被创建；如果 lazy-init&#x3D;false，对象在应用启动的时候就事先创建好。</li>\n<li>不仅如此，我们还可以配置对象的 init-method 和 destroy-method 方法，比如 init-method&#x3D;loadProperties()，destroy-method&#x3D;updateConfigFile()。DI 容器在创建好对象之后，会主动调用 init-method 属性指定的方法来初始化对象。在对象被最终销毁之前，DI 容器会主动调用 destroy-method 属性指定的方法来做一些清理工作，比如释放数据库连接池、关闭文件。</li>\n</ol>\n<h2 id=\"如何实现一个简单的-DI-容器？\"><a href=\"#如何实现一个简单的-DI-容器？\" class=\"headerlink\" title=\"如何实现一个简单的 DI 容器？\"></a>如何实现一个简单的 DI 容器？</h2><p>用 Java 语言来实现一个简单的 DI 容器，核心逻辑只需要包括这样两个部分：配置文件解析、根据配置文件通过“反射”语法来创建对象。</p>\n<h3 id=\"最小原型设计\"><a href=\"#最小原型设计\" class=\"headerlink\" title=\"最小原型设计\"></a>最小原型设计</h3><p>因为我们主要是讲解设计模式，所以，在今天的讲解中，我们只实现一个 DI 容器的最小原型。像 Spring 框架这样的 DI 容器，它支持的配置格式非常灵活和复杂。为了简化代码实现，重点讲解原理，在最小原型中，我们只支持下面配置文件中涉及的配置语法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">配置文件beans.xml</span><br><span class=\"line\">&lt;beans&gt;</span><br><span class=\"line\">   &lt;bean id=<span class=\"string\">&quot;rateLimiter&quot;</span> class=<span class=\"string\">&quot;com.xzg.RateLimiter&quot;</span>&gt;</span><br><span class=\"line\">      &lt;constructor-arg ref=<span class=\"string\">&quot;redisCounter&quot;</span>/&gt;</span><br><span class=\"line\">   &lt;/bean&gt;</span><br><span class=\"line\"> </span><br><span class=\"line\">   &lt;bean id=<span class=\"string\">&quot;redisCounter&quot;</span> class=<span class=\"string\">&quot;com.xzg.redisCounter&quot;</span> scope=<span class=\"string\">&quot;singleton&quot;</span> lazy-init=<span class=\"string\">&quot;true&quot;</span>&gt;</span><br><span class=\"line\">     &lt;constructor-arg type=<span class=\"string\">&quot;String&quot;</span> value=<span class=\"string\">&quot;127.0.0.1&quot;</span>&gt;</span><br><span class=\"line\">     &lt;constructor-arg type=<span class=\"string\">&quot;int&quot;</span> value=<span class=\"number\">1234</span>&gt;</span><br><span class=\"line\">   &lt;/bean&gt;</span><br><span class=\"line\">&lt;/bean</span><br></pre></td></tr></table></figure>\n\n\n\n<p>最小原型的使用方式跟 Spring 框架非常类似，示例代码如下所示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Demo</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">ApplicationContext</span> <span class=\"variable\">applicationContext</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ClassPathXmlApplicationContext</span>(</span><br><span class=\"line\">            <span class=\"string\">&quot;beans.xml&quot;</span>);</span><br><span class=\"line\">    <span class=\"type\">RateLimiter</span> <span class=\"variable\">rateLimiter</span> <span class=\"operator\">=</span> (RateLimiter) applicationContext.getBean(<span class=\"string\">&quot;rateLimiter&quot;</span>);</span><br><span class=\"line\">    rateLimiter.test();</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"提供执行入口\"><a href=\"#提供执行入口\" class=\"headerlink\" title=\"提供执行入口\"></a>提供执行入口</h3><p>面向对象设计的最后一步是：组装类并提供执行入口。在这里，执行入口就是一组暴露给外部使用的接口和类。通过刚刚的最小原型使用示例代码，我们可以看出，执行入口主要包含两部分：ApplicationContext 和 ClassPathXmlApplicationContext。其中，ApplicationContext 是接口，ClassPathXmlApplicationContext 是接口的实现类。两个类具体实现如下所示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">ApplicationContext</span> &#123;</span><br><span class=\"line\">  Object <span class=\"title function_\">getBean</span><span class=\"params\">(String beanId)</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ClassPathXmlApplicationContext</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">ApplicationContext</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> BeansFactory beansFactory;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> BeanConfigParser beanConfigParser;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"title function_\">ClassPathXmlApplicationContext</span><span class=\"params\">(String configLocation)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.beansFactory = <span class=\"keyword\">new</span> <span class=\"title class_\">BeansFactory</span>();</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.beanConfigParser = <span class=\"keyword\">new</span> <span class=\"title class_\">XmlBeanConfigParser</span>();</span><br><span class=\"line\">    loadBeanDefinitions(configLocation);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">loadBeanDefinitions</span><span class=\"params\">(String configLocation)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">InputStream</span> <span class=\"variable\">in</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      in = <span class=\"built_in\">this</span>.getClass().getResourceAsStream(<span class=\"string\">&quot;/&quot;</span> + configLocation);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (in == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RuntimeException</span>(<span class=\"string\">&quot;Can not find config file: &quot;</span> + configLocation);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      List&lt;BeanDefinition&gt; beanDefinitions = beanConfigParser.parse(in);</span><br><span class=\"line\">      beansFactory.addBeanDefinitions(beanDefinitions);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (in != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">          in.close();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">          <span class=\"comment\">// <span class=\"doctag\">TODO:</span> log error</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> Object <span class=\"title function_\">getBean</span><span class=\"params\">(String beanId)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> beansFactory.getBean(beanId);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>从上面的代码中，我们可以看出，ClassPathXmlApplicationContext 负责组装 BeansFactory 和 BeanConfigParser 两个类，串联执行流程：从 classpath 中加载 XML 格式的配置文件，通过 BeanConfigParser 解析为统一的 BeanDefinition 格式，然后，BeansFactory 根据 BeanDefinition 来创建对象。</p>\n<h3 id=\"配置文件解析\"><a href=\"#配置文件解析\" class=\"headerlink\" title=\"配置文件解析\"></a>配置文件解析</h3><p>配置文件解析主要包含 BeanConfigParser 接口和 XmlBeanConfigParser 实现类，负责将配置文件解析为 BeanDefinition 结构，以便 BeansFactory 根据这个结构来创建对象。配置文件的解析比较繁琐，不涉及我们要讲的理论知识，不是我们讲解的重点，所以这里我只给出两个类的大致设计思路，并未给出具体的实现代码。如果感兴趣的话，你可以自行补充完整。具体的代码框架如下所示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">BeanConfigParser</span> &#123;</span><br><span class=\"line\">  List&lt;BeanDefinition&gt; <span class=\"title function_\">parse</span><span class=\"params\">(InputStream inputStream)</span>;</span><br><span class=\"line\">  List&lt;BeanDefinition&gt; <span class=\"title function_\">parse</span><span class=\"params\">(String configContent)</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">XmlBeanConfigParser</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">BeanConfigParser</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> List&lt;BeanDefinition&gt; <span class=\"title function_\">parse</span><span class=\"params\">(InputStream inputStream)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">content</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"comment\">// <span class=\"doctag\">TODO:</span>...</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> parse(content);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> List&lt;BeanDefinition&gt; <span class=\"title function_\">parse</span><span class=\"params\">(String configContent)</span> &#123;</span><br><span class=\"line\">    List&lt;BeanDefinition&gt; beanDefinitions = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">    <span class=\"comment\">// <span class=\"doctag\">TODO:</span>...</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> beanDefinitions;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">BeanDefinition</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> String id;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> String className;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> List&lt;ConstructorArg&gt; constructorArgs = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"type\">Scope</span> <span class=\"variable\">scope</span> <span class=\"operator\">=</span> Scope.SINGLETON;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"type\">boolean</span> <span class=\"variable\">lazyInit</span> <span class=\"operator\">=</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 省略必要的getter/setter/constructors</span></span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">isSingleton</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> scope.equals(Scope.SINGLETON);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">enum</span> <span class=\"title class_\">Scope</span> &#123;</span><br><span class=\"line\">    SINGLETON,</span><br><span class=\"line\">    PROTOTYPE</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ConstructorArg</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">boolean</span> isRef;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Class type;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Object arg;</span><br><span class=\"line\">    <span class=\"comment\">// 省略必要的getter/setter/constructors</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"核心工厂类设计\"><a href=\"#核心工厂类设计\" class=\"headerlink\" title=\"核心工厂类设计\"></a>核心工厂类设计</h3><ol>\n<li>最后，我们来看，BeansFactory 是如何设计和实现的。这也是我们这个 DI 容器最核心的一个类了。它负责根据从配置文件解析得到的 BeanDefinition 来创建对象。</li>\n<li>如果对象的 scope 属性是 singleton，那对象创建之后会缓存在 singletonObjects 这样一个 map 中，下次再请求此对象的时候，直接从 map 中取出返回，不需要重新创建。如果对象的 scope 属性是 prototype，那每次请求对象，BeansFactory 都会创建一个新的对象返回。</li>\n<li>实际上，BeansFactory 创建对象用到的主要技术点就是 Java 中的反射语法：一种动态加载类和创建对象的机制。我们知道，JVM 在启动的时候会根据代码自动地加载类、创建对象。至于都要加载哪些类、创建哪些对象，这些都是在代码中写死的，或者说提前写好的。但是，如果某个对象的创建并不是写死在代码中，而是放到配置文件中，我们需要在程序运行期间，动态地根据配置文件来加载类、创建对象，那这部分工作就没法让 JVM 帮我们自动完成了，我们需要利用 Java 提供的反射语法自己去编写代码。</li>\n<li>搞清楚了反射的原理，BeansFactory 的代码就不难看懂了。具体代码实现如下所示：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">BeansFactory</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> ConcurrentHashMap&lt;String, Object&gt; singletonObjects = <span class=\"keyword\">new</span> <span class=\"title class_\">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class=\"line\">  <span class=\"keyword\">private</span> ConcurrentHashMap&lt;String, BeanDefinition&gt; beanDefinitions = <span class=\"keyword\">new</span> <span class=\"title class_\">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">addBeanDefinitions</span><span class=\"params\">(List&lt;BeanDefinition&gt; beanDefinitionList)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (BeanDefinition beanDefinition : beanDefinitionList) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.beanDefinitions.putIfAbsent(beanDefinition.getId(), beanDefinition);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (BeanDefinition beanDefinition : beanDefinitionList) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (beanDefinition.isLazyInit() == <span class=\"literal\">false</span> &amp;&amp; beanDefinition.isSingleton()) &#123;</span><br><span class=\"line\">        createBean(beanDefinition);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> Object <span class=\"title function_\">getBean</span><span class=\"params\">(String beanId)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">BeanDefinition</span> <span class=\"variable\">beanDefinition</span> <span class=\"operator\">=</span> beanDefinitions.get(beanId);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (beanDefinition == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">NoSuchBeanDefinitionException</span>(<span class=\"string\">&quot;Bean is not defined: &quot;</span> + beanId);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> createBean(beanDefinition);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@VisibleForTesting</span></span><br><span class=\"line\">  <span class=\"keyword\">protected</span> Object <span class=\"title function_\">createBean</span><span class=\"params\">(BeanDefinition beanDefinition)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (beanDefinition.isSingleton() &amp;&amp; singletonObjects.contains(beanDefinition.getId())) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> singletonObjects.get(beanDefinition.getId());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">Object</span> <span class=\"variable\">bean</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      <span class=\"type\">Class</span> <span class=\"variable\">beanClass</span> <span class=\"operator\">=</span> Class.forName(beanDefinition.getClassName());</span><br><span class=\"line\">      List&lt;BeanDefinition.ConstructorArg&gt; args = beanDefinition.getConstructorArgs();</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (args.isEmpty()) &#123;</span><br><span class=\"line\">        bean = beanClass.newInstance();</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        Class[] argClasses = <span class=\"keyword\">new</span> <span class=\"title class_\">Class</span>[args.size()];</span><br><span class=\"line\">        Object[] argObjects = <span class=\"keyword\">new</span> <span class=\"title class_\">Object</span>[args.size()];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; args.size(); ++i) &#123;</span><br><span class=\"line\">          BeanDefinition.<span class=\"type\">ConstructorArg</span> <span class=\"variable\">arg</span> <span class=\"operator\">=</span> args.get(i);</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (!arg.getIsRef()) &#123;</span><br><span class=\"line\">            argClasses[i] = arg.getType();</span><br><span class=\"line\">            argObjects[i] = arg.getArg();</span><br><span class=\"line\">          &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"type\">BeanDefinition</span> <span class=\"variable\">refBeanDefinition</span> <span class=\"operator\">=</span> beanDefinitions.get(arg.getArg());</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (refBeanDefinition == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">              <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">NoSuchBeanDefinitionException</span>(<span class=\"string\">&quot;Bean is not defined: &quot;</span> + arg.getArg());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            argClasses[i] = Class.forName(refBeanDefinition.getClassName());</span><br><span class=\"line\">            argObjects[i] = createBean(refBeanDefinition);</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        bean = beanClass.getConstructor(argClasses).newInstance(argObjects);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (ClassNotFoundException | IllegalAccessException</span><br><span class=\"line\">            | InstantiationException | NoSuchMethodException | InvocationTargetException e) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">BeanCreationFailureException</span>(<span class=\"string\">&quot;&quot;</span>, e);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (bean != <span class=\"literal\">null</span> &amp;&amp; beanDefinition.isSingleton()) &#123;</span><br><span class=\"line\">      singletonObjects.putIfAbsent(beanDefinition.getId(), bean);</span><br><span class=\"line\">      <span class=\"keyword\">return</span> singletonObjects.get(beanDefinition.getId());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> bean;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>执行入口那里调用<code>addBeanDefinitions</code></li>\n<li>然后<code>addBeanDefinitions</code>再调用createBean利用反射创建对象，如果对象的 scope 属性是 singleton，那对象创建之后会缓存在 singletonObjects 这样一个 map 中</li>\n<li>最后最小原型设计那里再调用getBean从singletonObjects 获取对象。</li>\n</ol>\n<h1 id=\"建造者模式【常用】\"><a href=\"#建造者模式【常用】\" class=\"headerlink\" title=\"建造者模式【常用】\"></a>建造者模式【常用】</h1><blockquote>\n<p>只要是标注常用的，基本上用的都比较多，无论篇幅长短，都不要忽视。</p>\n</blockquote>\n<p>建造者模式的原理和代码实现非常简单，掌握起来并不难，难点在于应用场景。比如，你有没有考虑过这样几个问题：直接使用构造函数或者配合 set 方法就能创建对象，为什么还需要建造者模式来创建呢？建造者模式和工厂模式都可以创建对象，那它们两个的区别在哪里呢？</p>\n<h2 id=\"为什么需要建造者模式？\"><a href=\"#为什么需要建造者模式？\" class=\"headerlink\" title=\"为什么需要建造者模式？\"></a>为什么需要建造者模式？</h2><ol>\n<li>在平时的开发中，创建一个对象最常用的方式是，使用 new 关键字调用类的构造函数来完成。我的问题是，什么情况下这种方式就不适用了，就需要采用建造者模式来创建对象呢？你可以先思考一下，下面我通过一个例子来带你看一下。</li>\n<li>假设有这样一道设计面试题：我们需要定义一个资源池配置类 ResourcePoolConfig。这里的资源池，你可以简单理解为线程池、连接池、对象池等。在这个资源池配置类中，有以下几个成员变量，也就是可配置项。现在，请你编写代码实现这个 ResourcePoolConfig 类。</li>\n</ol>\n<img src=\"https://npm.elemecdn.com/youthlql@1.0.0/design_patterns/creational/03.02/0001.png\" />\n\n\n\n<p>只要你稍微有点开发经验，那实现这样一个类对你来说并不是件难事。最常见、最容易想到的实现思路如下代码所示。因为 maxTotal、maxIdle、minIdle 不是必填变量，所以在创建 ResourcePoolConfig 对象的时候，我们通过往构造函数中，给这几个参数传递 null 值，来表示使用默认值。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ResourcePoolConfig</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">DEFAULT_MAX_TOTAL</span> <span class=\"operator\">=</span> <span class=\"number\">8</span>;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">DEFAULT_MAX_IDLE</span> <span class=\"operator\">=</span> <span class=\"number\">8</span>;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">DEFAULT_MIN_IDLE</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"type\">int</span> <span class=\"variable\">maxTotal</span> <span class=\"operator\">=</span> DEFAULT_MAX_TOTAL;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"type\">int</span> <span class=\"variable\">maxIdle</span> <span class=\"operator\">=</span> DEFAULT_MAX_IDLE;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"type\">int</span> <span class=\"variable\">minIdle</span> <span class=\"operator\">=</span> DEFAULT_MIN_IDLE;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"title function_\">ResourcePoolConfig</span><span class=\"params\">(String name, Integer maxTotal, Integer maxIdle, Integer minIdle)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (StringUtils.isBlank(name)) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IllegalArgumentException</span>(<span class=\"string\">&quot;name should not be empty.&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.name = name;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (maxTotal != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (maxTotal &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IllegalArgumentException</span>(<span class=\"string\">&quot;maxTotal should be positive.&quot;</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.maxTotal = maxTotal;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (maxIdle != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (maxIdle &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IllegalArgumentException</span>(<span class=\"string\">&quot;maxIdle should not be negative.&quot;</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.maxIdle = maxIdle;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (minIdle != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (minIdle &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IllegalArgumentException</span>(<span class=\"string\">&quot;minIdle should not be negative.&quot;</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.minIdle = minIdle;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//...省略getter方法...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>现在，ResourcePoolConfig 只有 4 个可配置项，对应到构造函数中，也只有 4 个参数，参数的个数不多。但是，如果可配置项逐渐增多，变成了 8 个、10 个，甚至更多，那继续沿用现在的设计思路，构造函数的参数列表会变得很长，代码在可读性和易用性上都会变差。在使用构造函数的时候，我们就容易搞错各参数的顺序，传递进错误的参数值，导致非常隐蔽的 bug。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 参数太多，导致可读性差、参数可能传递错误</span></span><br><span class=\"line\"><span class=\"type\">ResourcePoolConfig</span> <span class=\"variable\">config</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ResourcePoolConfig</span>(<span class=\"string\">&quot;dbconnectionpool&quot;</span>, <span class=\"number\">16</span>, <span class=\"literal\">null</span>, <span class=\"number\">8</span>, <span class=\"literal\">null</span>, <span class=\"literal\">false</span> , <span class=\"literal\">true</span>, <span class=\"number\">10</span>, <span class=\"number\">20</span>，<span class=\"literal\">false</span>， <span class=\"literal\">true</span>);</span><br></pre></td></tr></table></figure>\n\n\n\n<p>解决这个问题的办法你应该也已经想到了，那就是用 set() 函数来给成员变量赋值，以替代冗长的构造函数。我们直接看代码，具体如下所示。其中，配置项 name 是必填的，所以我们把它放到构造函数中设置，强制创建类对象的时候就要填写。其他配置项 maxTotal、maxIdle、minIdle 都不是必填的，所以我们通过 set() 函数来设置，让使用者自主选择填写或者不填写。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ResourcePoolConfig</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">DEFAULT_MAX_TOTAL</span> <span class=\"operator\">=</span> <span class=\"number\">8</span>;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">DEFAULT_MAX_IDLE</span> <span class=\"operator\">=</span> <span class=\"number\">8</span>;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">DEFAULT_MIN_IDLE</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"type\">int</span> <span class=\"variable\">maxTotal</span> <span class=\"operator\">=</span> DEFAULT_MAX_TOTAL;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"type\">int</span> <span class=\"variable\">maxIdle</span> <span class=\"operator\">=</span> DEFAULT_MAX_IDLE;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"type\">int</span> <span class=\"variable\">minIdle</span> <span class=\"operator\">=</span> DEFAULT_MIN_IDLE;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"title function_\">ResourcePoolConfig</span><span class=\"params\">(String name)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (StringUtils.isBlank(name)) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IllegalArgumentException</span>(<span class=\"string\">&quot;name should not be empty.&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.name = name;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setMaxTotal</span><span class=\"params\">(<span class=\"type\">int</span> maxTotal)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (maxTotal &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IllegalArgumentException</span>(<span class=\"string\">&quot;maxTotal should be positive.&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.maxTotal = maxTotal;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setMaxIdle</span><span class=\"params\">(<span class=\"type\">int</span> maxIdle)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (maxIdle &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IllegalArgumentException</span>(<span class=\"string\">&quot;maxIdle should not be negative.&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.maxIdle = maxIdle;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setMinIdle</span><span class=\"params\">(<span class=\"type\">int</span> minIdle)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (minIdle &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IllegalArgumentException</span>(<span class=\"string\">&quot;minIdle should not be negative.&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.minIdle = minIdle;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//...省略getter方法...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>接下来，我们来看新的 ResourcePoolConfig 类该如何使用。我写了一个示例代码，如下所示。没有了冗长的函数调用和参数列表，代码在可读性和易用性上提高了很多。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ResourcePoolConfig使用举例</span></span><br><span class=\"line\"><span class=\"type\">ResourcePoolConfig</span> <span class=\"variable\">config</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ResourcePoolConfig</span>(<span class=\"string\">&quot;dbconnectionpool&quot;</span>);</span><br><span class=\"line\">config.setMaxTotal(<span class=\"number\">16</span>);</span><br><span class=\"line\">config.setMaxIdle(<span class=\"number\">8</span>);</span><br></pre></td></tr></table></figure>\n\n\n\n<p>至此，我们仍然没有用到建造者模式，通过构造函数设置必填项，通过 set() 方法设置可选配置项，就能实现我们的设计需求。如果我们把问题的难度再加大点，比如，还需要解决下面这三个问题，那现在的设计思路就不能满足了。</p>\n<ul>\n<li>我们刚刚讲到，name 是必填的，所以，我们把它放到构造函数中，强制创建对象的时候就设置。如果必填的配置项有很多，把这些必填配置项都放到构造函数中设置，那构造函数就又会出现参数列表很长的问题。如果我们把必填项也通过 set() 方法设置，那校验这些必填项是否已经填写的逻辑就无处安放了。</li>\n<li>除此之外，假设配置项之间有一定的依赖关系，比如，如果用户设置了 maxTotal、maxIdle、minIdle 其中一个，就必须显式地设置另外两个；或者配置项之间有一定的约束条件，比如，maxIdle 和 minIdle 要小于等于 maxTotal。如果我们继续使用现在的设计思路，那这些配置项之间的依赖关系或者约束条件的校验逻辑就无处安放了。</li>\n<li>如果我们希望 ResourcePoolConfig 类对象是不可变对象，也就是说，对象在创建好之后，就不能再修改内部的属性值。要实现这个功能，我们就不能在 ResourcePoolConfig 类中暴露 set() 方法。</li>\n</ul>\n<p>为了解决这些问题，建造者模式就派上用场了。我们可以把校验逻辑放置到 Builder 类中，先创建建造者，并且通过 set() 方法设置建造者的变量值，然后在使用 build() 方法真正创建对象之前，做集中的校验，校验通过之后才会创建对象。除此之外，我们把 ResourcePoolConfig 的构造函数改为 private 私有权限。这样我们就只能通过建造者来创建 ResourcePoolConfig 类对象。并且，ResourcePoolConfig 没有提供任何 set() 方法，这样我们创建出来的对象就是不可变对象了。我们用建造者模式重新实现了上面的需求，具体的代码如下所示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ResourcePoolConfig</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"type\">int</span> maxTotal;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"type\">int</span> maxIdle;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"type\">int</span> minIdle;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"title function_\">ResourcePoolConfig</span><span class=\"params\">(Builder builder)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.name = builder.name;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.maxTotal = builder.maxTotal;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.maxIdle = builder.maxIdle;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.minIdle = builder.minIdle;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//...省略getter方法...</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//我们将Builder类设计成了ResourcePoolConfig的内部类。</span></span><br><span class=\"line\">  <span class=\"comment\">//我们也可以将Builder类设计成独立的非内部类ResourcePoolConfigBuilder。</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Builder</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">DEFAULT_MAX_TOTAL</span> <span class=\"operator\">=</span> <span class=\"number\">8</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">DEFAULT_MAX_IDLE</span> <span class=\"operator\">=</span> <span class=\"number\">8</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">DEFAULT_MIN_IDLE</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">int</span> <span class=\"variable\">maxTotal</span> <span class=\"operator\">=</span> DEFAULT_MAX_TOTAL;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">int</span> <span class=\"variable\">maxIdle</span> <span class=\"operator\">=</span> DEFAULT_MAX_IDLE;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">int</span> <span class=\"variable\">minIdle</span> <span class=\"operator\">=</span> DEFAULT_MIN_IDLE;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> ResourcePoolConfig <span class=\"title function_\">build</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 校验逻辑放到这里来做，包括必填项校验、依赖关系校验、约束条件校验等</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (StringUtils.isBlank(name)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IllegalArgumentException</span>(<span class=\"string\">&quot;...&quot;</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (maxIdle &gt; maxTotal) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IllegalArgumentException</span>(<span class=\"string\">&quot;...&quot;</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (minIdle &gt; maxTotal || minIdle &gt; maxIdle) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IllegalArgumentException</span>(<span class=\"string\">&quot;...&quot;</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ResourcePoolConfig</span>(<span class=\"built_in\">this</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Builder <span class=\"title function_\">setName</span><span class=\"params\">(String name)</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (StringUtils.isBlank(name)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IllegalArgumentException</span>(<span class=\"string\">&quot;...&quot;</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.name = name;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Builder <span class=\"title function_\">setMaxTotal</span><span class=\"params\">(<span class=\"type\">int</span> maxTotal)</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (maxTotal &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IllegalArgumentException</span>(<span class=\"string\">&quot;...&quot;</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.maxTotal = maxTotal;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Builder <span class=\"title function_\">setMaxIdle</span><span class=\"params\">(<span class=\"type\">int</span> maxIdle)</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (maxIdle &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IllegalArgumentException</span>(<span class=\"string\">&quot;...&quot;</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.maxIdle = maxIdle;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Builder <span class=\"title function_\">setMinIdle</span><span class=\"params\">(<span class=\"type\">int</span> minIdle)</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (minIdle &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IllegalArgumentException</span>(<span class=\"string\">&quot;...&quot;</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.minIdle = minIdle;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 这段代码会抛出IllegalArgumentException，因为minIdle&gt;maxIdle</span></span><br><span class=\"line\"><span class=\"type\">ResourcePoolConfig</span> <span class=\"variable\">config</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ResourcePoolConfig</span>.Builder()</span><br><span class=\"line\">        .setName(<span class=\"string\">&quot;dbconnectionpool&quot;</span>)</span><br><span class=\"line\">        .setMaxTotal(<span class=\"number\">16</span>)</span><br><span class=\"line\">        .setMaxIdle(<span class=\"number\">10</span>)</span><br><span class=\"line\">        .setMinIdle(<span class=\"number\">12</span>)</span><br><span class=\"line\">        .build();</span><br></pre></td></tr></table></figure>\n\n\n\n<p>实际上，使用建造者模式创建对象，还能避免对象存在无效状态。我再举个例子解释一下。比如我们定义了一个长方形类，如果不使用建造者模式，采用先创建后 set 的方式，那就会导致在第一个 set 之后，对象处于无效状态。具体代码如下所示</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Rectangle</span> <span class=\"variable\">r</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Rectange</span>(); <span class=\"comment\">// r is invalid</span></span><br><span class=\"line\">r.setWidth(<span class=\"number\">2</span>); <span class=\"comment\">// r is invalid</span></span><br><span class=\"line\">r.setHeight(<span class=\"number\">3</span>); <span class=\"comment\">// r is valid</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>这里是说，长方形必须同时具备宽、高两个属性才是一个有效的长方形。只有其中一个属性，这个长方形对象就没有意义，是无效的。</p>\n</blockquote>\n<ol>\n<li>为了避免这种无效状态的存在，我们就需要使用构造函数一次性初始化好所有的成员变量。如果构造函数参数过多，我们就需要考虑使用建造者模式，先设置建造者的变量，然后再一次性地创建对象，让对象一直处于有效状态。(建造者主要解决参数过多、参数检验、控制对象创建后不可变的问题)</li>\n<li>实际上，如果我们并不是很关心对象是否有短暂的无效状态，也不是太在意对象是否是可变的。比如，对象只是用来映射数据库读出来的数据，那我们直接暴露 set() 方法来设置类的成员变量值是完全没问题的。而且，使用建造者模式来构建对象，代码实际上是有点重复的，ResourcePoolConfig 类中的成员变量，要在 Builder 类中重新再定义一遍。</li>\n</ol>\n<h2 id=\"与工厂模式有何区别？\"><a href=\"#与工厂模式有何区别？\" class=\"headerlink\" title=\"与工厂模式有何区别？\"></a>与工厂模式有何区别？</h2><ol>\n<li>从上面的讲解中，我们可以看出，建造者模式是让建造者类来负责对象的创建工作。上面讲到的工厂模式，是由工厂类来负责对象创建的工作。那它们之间有什么区别呢？</li>\n<li>实际上，工厂模式是用来创建不同但是相关类型的对象（继承同一父类或者接口的一组子类），由给定的参数来决定创建哪种类型的对象。建造者模式是用来创建一种类型的复杂对象，通过设置不同的可选参数，“定制化”地创建不同的对象。</li>\n</ol>\n<p>网上有一个经典的例子很好地解释了两者的区别:</p>\n<blockquote>\n<p>顾客走进一家餐馆点餐，我们利用工厂模式，根据用户不同的选择，来制作不同的食物，比如披萨、汉堡、沙拉。对于披萨来说，用户又有各种配料可以定制，比如奶酪、西红柿、起司，我们通过建造者模式根据用户选择的不同配料来制作披萨。</p>\n</blockquote>\n<p>实际上，我们也不要太学院派，非得把工厂模式、建造者模式分得那么清楚，我们需要知道的是，每个模式为什么这么设计，能解决什么问题。只有了解了这些最本质的东西，我们才能不生搬硬套，才能灵活应用，甚至可以混用各种模式创造出新的模式，来解决特定场景的问题。</p>\n<h1 id=\"原型模式【不常用】\"><a href=\"#原型模式【不常用】\" class=\"headerlink\" title=\"原型模式【不常用】\"></a>原型模式【不常用】</h1><p>今天的讲解跟具体某一语言的语法机制无关，而是通过一个 clone 散列表的例子带你搞清楚：原型模式的应用场景，以及它的两种实现方式：深拷贝和浅拷贝。虽然原型模式的原理和代码实现非常简单，但今天举的例子还是稍微有点复杂的</p>\n<h2 id=\"原型模式的原理与应用\"><a href=\"#原型模式的原理与应用\" class=\"headerlink\" title=\"原型模式的原理与应用\"></a>原型模式的原理与应用</h2><p>如果对象的创建成本比较大，而同一个类的不同对象之间差别不大（大部分字段都相同），在这种情况下，我们可以利用对已有对象（原型）进行复制（或者叫拷贝）的方式来创建新对象，以达到节省创建时间的目的。这种基于原型来创建对象的方式就叫作原型设计模式（Prototype Design Pattern），简称原型模式。</p>\n<blockquote>\n<p>那何为“对象的创建成本比较大”？</p>\n</blockquote>\n<ol>\n<li>实际上，创建对象包含的申请内存、给成员变量赋值这一过程，本身并不会花费太多时间，或者说对于大部分业务系统来说，这点时间完全是可以忽略的。应用一个复杂的模式，只得到一点点的性能提升，这就是所谓的过度设计，得不偿失。</li>\n<li>但是，如果对象中的数据需要经过复杂的计算才能得到（比如排序、计算哈希值），或者需要从 RPC、网络、数据库、文件系统等非常慢速的 IO 中读取，这种情况下，我们就可以利用原型模式，从其他已有对象中直接拷贝得到，而不用每次在创建新对象的时候，都重复执行这些耗时的操作。</li>\n</ol>\n<blockquote>\n<p>这么说还是比较理论，接下来，我们通过一个例子来解释一下刚刚这段话。</p>\n</blockquote>\n<ol>\n<li>假设数据库中存储了大约 10 万条“搜索关键词”信息，每条信息包含关键词、关键词被搜索的次数、信息最近被更新的时间等。系统 A 在启动的时候会加载这份数据到内存中，用于处理某些其他的业务需求。为了方便快速地查找某个关键词对应的信息，我们给关键词建立一个散列表索引。</li>\n<li>如果你熟悉的是 Java 语言，可以直接使用语言中提供的 HashMap 容器来实现。其中，HashMap 的 key 为搜索关键词，value 为关键词详细信息（比如搜索次数）。我们只需要将数据从数据库中读取出来，放入 HashMap 就可以了。</li>\n<li>不过，我们还有另外一个系统 B，专门用来分析搜索日志，定期（比如间隔 10 分钟）批量地更新数据库中的数据，并且标记为新的数据版本。比如，在下面的示例图中，我们对 v2 版本的数据进行更新，得到 v3 版本的数据。这里我们假设只有更新和新添关键词，没有删除关键词的行为。</li>\n</ol>\n<img src=\"https://npm.elemecdn.com/youthlql@1.0.0/design_patterns/creational/03.02/0002.png\"/>\n\n\n\n<ol>\n<li>为了保证系统 A 中数据的实时性（不一定非常实时，但数据也不能太旧），系统 A 需要定期根据数据库中的数据，更新内存中的索引和数据。</li>\n<li>我们该如何实现这个需求呢？实际上，也不难。我们只需要在系统 A 中，记录当前数据的版本 Va 对应的更新时间 Ta，从数据库中捞出更新时间大于 Ta 的所有搜索关键词，也就是找出 Va 版本与最新版本数据的“差集”，然后针对差集中的每个关键词进行处理。如果它已经在散列表中存在了，我们就更新相应的搜索次数、更新时间等信息；如果它在散列表中不存在，我们就将它插入到散列表中。</li>\n<li>按照这个设计思路，我给出的示例代码如下所示：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Demo</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> ConcurrentHashMap&lt;String, SearchWord&gt; currentKeywords = <span class=\"keyword\">new</span> <span class=\"title class_\">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"type\">long</span> <span class=\"variable\">lastUpdateTime</span> <span class=\"operator\">=</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">refresh</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 从数据库中取出更新时间&gt;lastUpdateTime的数据，放入到currentKeywords中</span></span><br><span class=\"line\">    List&lt;SearchWord&gt; toBeUpdatedSearchWords = getSearchWords(lastUpdateTime);</span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"variable\">maxNewUpdatedTime</span> <span class=\"operator\">=</span> lastUpdateTime;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (SearchWord searchWord : toBeUpdatedSearchWords) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (searchWord.getLastUpdateTime() &gt; maxNewUpdatedTime) &#123;</span><br><span class=\"line\">        maxNewUpdatedTime = searchWord.getLastUpdateTime();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (currentKeywords.containsKey(searchWord.getKeyword())) &#123;</span><br><span class=\"line\">        currentKeywords.replace(searchWord.getKeyword(), searchWord);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        currentKeywords.put(searchWord.getKeyword(), searchWord);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    lastUpdateTime = maxNewUpdatedTime;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> List&lt;SearchWord&gt; <span class=\"title function_\">getSearchWords</span><span class=\"params\">(<span class=\"type\">long</span> lastUpdateTime)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// <span class=\"doctag\">TODO:</span> 从数据库中取出更新时间&gt;lastUpdateTime的数据</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>不过，现在，我们有一个特殊的要求：任何时刻，系统 A 中的所有数据都必须是同一个版本的，要么都是版本 a，要么都是版本 b，不能有的是版本 a，有的是版本 b。那刚刚的更新方式就不能满足这个要求了（因为数据很多，一个一个的for循环肯定会出现不同数据版本的问题）。除此之外，我们还要求：在更新内存数据的时候，系统 A 不能处于不可用状态，也就是不能停机更新数据。</p>\n<ol>\n<li><p>那我们该如何实现现在这个需求呢？</p>\n</li>\n<li><p>实际上，也不难。我们把正在使用的数据的版本定义为“服务版本”，当我们要更新内存中的数据的时候，我们并不是直接在服务版本（假设是版本 a 数据）上更新，而是重新创建另一个版本数据（假设是版本 b 数据），等新的版本数据建好之后，再一次性地将服务版本从版本 a 切换到版本 b。这样既保证了数据一直可用，又避免了中间状态的存在。</p>\n</li>\n<li><p>按照这个设计思路，我给出的示例代码如下所示：</p>\n</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Demo</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> HashMap&lt;String, SearchWord&gt; currentKeywords=<span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">refresh</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    HashMap&lt;String, SearchWord&gt; newKeywords = <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedHashMap</span>&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 从数据库中取出所有的数据，放入到newKeywords中</span></span><br><span class=\"line\">    List&lt;SearchWord&gt; toBeUpdatedSearchWords = getSearchWords();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (SearchWord searchWord : toBeUpdatedSearchWords) &#123;</span><br><span class=\"line\">      newKeywords.put(searchWord.getKeyword(), searchWord);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    currentKeywords = newKeywords;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> List&lt;SearchWord&gt; <span class=\"title function_\">getSearchWords</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// <span class=\"doctag\">TODO:</span> 从数据库中取出所有的数据</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<ol>\n<li>不过，在上面的代码实现中，newKeywords 构建的成本比较高。我们需要将这 10 万条数据从数据库中读出，然后计算哈希值，构建 newKeywords。这个过程显然是比较耗时。为了提高效率，原型模式就派上用场了。</li>\n<li>我们拷贝 currentKeywords 数据到 newKeywords 中，然后从数据库中只捞出新增或者有更新的关键词，更新到 newKeywords 中。而相对于 10 万条数据来说，每次新增或者更新的关键词个数是比较少的，所以，这种策略大大提高了数据更新的效率。</li>\n<li>按照这个设计思路，我给出的示例代码如下所示：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Demo</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> HashMap&lt;String, SearchWord&gt; currentKeywords=<span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;();</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"type\">long</span> <span class=\"variable\">lastUpdateTime</span> <span class=\"operator\">=</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">refresh</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 原型模式就这么简单，拷贝已有对象的数据，更新少量差值</span></span><br><span class=\"line\">    HashMap&lt;String, SearchWord&gt; newKeywords = (HashMap&lt;String, SearchWord&gt;) currentKeywords.clone();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 从数据库中取出更新时间&gt;lastUpdateTime的数据，放入到newKeywords中</span></span><br><span class=\"line\">    List&lt;SearchWord&gt; toBeUpdatedSearchWords = getSearchWords(lastUpdateTime);</span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"variable\">maxNewUpdatedTime</span> <span class=\"operator\">=</span> lastUpdateTime;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (SearchWord searchWord : toBeUpdatedSearchWords) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (searchWord.getLastUpdateTime() &gt; maxNewUpdatedTime) &#123;</span><br><span class=\"line\">        maxNewUpdatedTime = searchWord.getLastUpdateTime();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (newKeywords.containsKey(searchWord.getKeyword())) &#123;</span><br><span class=\"line\">        <span class=\"type\">SearchWord</span> <span class=\"variable\">oldSearchWord</span> <span class=\"operator\">=</span> newKeywords.get(searchWord.getKeyword());</span><br><span class=\"line\">        oldSearchWord.setCount(searchWord.getCount());</span><br><span class=\"line\">        oldSearchWord.setLastUpdateTime(searchWord.getLastUpdateTime());</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        newKeywords.put(searchWord.getKeyword(), searchWord);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    lastUpdateTime = maxNewUpdatedTime;</span><br><span class=\"line\">    currentKeywords = newKeywords;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> List&lt;SearchWord&gt; <span class=\"title function_\">getSearchWords</span><span class=\"params\">(<span class=\"type\">long</span> lastUpdateTime)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// <span class=\"doctag\">TODO:</span> 从数据库中取出更新时间&gt;lastUpdateTime的数据</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>这里我们利用了 Java 中的 clone() 语法来复制一个对象。如果你熟悉的语言没有这个语法，那把数据从 currentKeywords 中一个个取出来，然后再重新计算哈希值，放入到 newKeywords 中也是可以接受的。毕竟，最耗时的还是从数据库中取数据的操作。相对于数据库的 IO 操作来说，内存操作和 CPU 计算的耗时都是可以忽略的。</li>\n<li>不过，不知道你有没有发现，实际上，刚刚的代码实现是有问题的。要弄明白到底有什么问题，我们需要先了解另外两个概念：深拷贝（Deep Copy）和浅拷贝（Shallow Copy）。</li>\n</ol>\n<h2 id=\"原型模式的实现方式：深拷贝和浅拷贝\"><a href=\"#原型模式的实现方式：深拷贝和浅拷贝\" class=\"headerlink\" title=\"原型模式的实现方式：深拷贝和浅拷贝\"></a>原型模式的实现方式：深拷贝和浅拷贝</h2><blockquote>\n<p>1、关于深拷贝浅拷贝，我觉得这篇文章讲的不错：<a href=\"https://blog.csdn.net/baiye_xing/article/details/71788741\">https://blog.csdn.net/baiye_xing/article/details/71788741</a></p>\n</blockquote>\n<blockquote>\n<p>我自己的总结：</p>\n<p><strong>浅拷贝</strong>：对一个对象进行拷贝时，这个对象对应的类里的成员变量。</p>\n<ul>\n<li>对于数据类型是基本数据类型的成员变量，浅拷贝会直接进行值拷贝，也就是将该属性值复制一份给新的对象。因为是两份不同的数据，所以对其中一个对象的该成员变量值进行修改，不会影响另一个对象拷贝得到的数据</li>\n<li>对于数据类型是引用数据类型的成员变量(也就是子对象，或者数组啥的)，也就是只是将该成员变量的引用值（引用拷贝【并发引用传递，Java本质还是值传递】）复制一份给新的对象。因为实际上两个对象的该成员变量都指向同一个实例。在这种情况下，在一个对象中修改该成员变量会影响到另一个对象的该成员变量值。</li>\n</ul>\n<ol>\n<li><strong>深拷贝</strong>：对基本数据类型进行值传递，对引用数据类型，创建一个新的对象，并复制其内容，此为深拷贝。</li>\n<li>也就是说浅拷贝对于子对象只是拷贝了引用值，并没有真正的拷贝整个对象。</li>\n</ol>\n<p><strong>深拷贝实现思路：</strong></p>\n<ol>\n<li><p>对于每个子对象都实现Cloneable 接口，并重写clone方法。最后在最顶层的类的重写的 clone 方法中调用所有子对象的 clone 方法即可实现深拷贝。【简单的说就是：每一层的每个子对象都进行浅拷贝&#x3D;深拷贝】</p>\n</li>\n<li><p>利用序列化。【先对对象进行序列化，紧接着马上反序列化出 】</p>\n</li>\n</ol>\n</blockquote>\n<p>我们来看，在内存中，用散列表组织的搜索关键词信息是如何存储的。我画了一张示意图，大致结构如下所示。从图中我们可以发现，散列表索引中，每个结点存储的 key 是搜索关键词，value 是 SearchWord 对象的内存地址。SearchWord 对象本身存储在散列表之外的内存空间中。</p>\n<img src=\"https://npm.elemecdn.com/youthlql@1.0.0/design_patterns/creational/03.02/0003.png\"  />\n\n<p>浅拷贝和深拷贝的区别在于，浅拷贝只会复制图中的索引（散列表），不会复制数据（SearchWord 对象）本身。相反，深拷贝不仅仅会复制索引，还会复制数据本身。浅拷贝得到的对象（newKeywords）跟原始对象（currentKeywords）共享数据（SearchWord 对象），而深拷贝得到的是一份完完全全独立的对象。具体的对比如下图所示：</p>\n<img src=\"https://npm.elemecdn.com/youthlql@1.0.0/design_patterns/creational/03.02/0004.png\"/>\n\n\n\n<img src=\"https://npm.elemecdn.com/youthlql@1.0.0/design_patterns/creational/03.02/0005.png\" />\n\n\n\n<ol>\n<li><p>在 Java 语言中，Object 类的 clone() 方法执行的就是我们刚刚说的浅拷贝。它只会拷贝对象中的基本数据类型的数据（比如，int、long），以及引用对象（SearchWord）的内存地址，不会递归地拷贝引用对象本身。</p>\n</li>\n<li><p>在上面的代码中，我们通过调用 HashMap 上的 clone() 浅拷贝方法来实现原型模式。当我们通过 newKeywords 更新 SearchWord 对象的时候（比如，更新“设计模式”这个搜索关键词的访问次数），newKeywords 和 currentKeywords 因为指向相同的一组 SearchWord 对象，就会导致 currentKeywords 中指向的 SearchWord，有的是老版本的，有的是新版本的，就没法满足我们之前的需求：currentKeywords 中的数据在任何时刻都是同一个版本的，不存在介于老版本与新版本之间的中间状态。</p>\n</li>\n<li><p>现在，我们又该如何来解决这个问题呢？</p>\n</li>\n<li><p>我们可以将浅拷贝替换为深拷贝。newKeywords 不仅仅复制 currentKeywords 的索引，还把 SearchWord 对象也复制一份出来，这样 newKeywords 和 currentKeywords 就指向不同的 SearchWord 对象，也就不存在更新 newKeywords 的数据会导致 currentKeywords 的数据也被更新的问题了。</p>\n</li>\n<li><p>那如何实现深拷贝呢？总结一下的话，有下面两种方法。</p>\n</li>\n</ol>\n<p>第一种方法：递归拷贝对象、对象的引用对象以及引用对象的引用对象……直到要拷贝的对象只包含基本数据类型数据，没有引用对象为止。根据这个思路对之前的代码进行重构。重构之后的代码如下所示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Demo</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> HashMap&lt;String, SearchWord&gt; currentKeywords=<span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;();</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"type\">long</span> <span class=\"variable\">lastUpdateTime</span> <span class=\"operator\">=</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">refresh</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Deep copy</span></span><br><span class=\"line\">    HashMap&lt;String, SearchWord&gt; newKeywords = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (HashMap.Entry&lt;String, SearchWord&gt; e : currentKeywords.entrySet()) &#123;</span><br><span class=\"line\">      <span class=\"type\">SearchWord</span> <span class=\"variable\">searchWord</span> <span class=\"operator\">=</span> e.getValue();</span><br><span class=\"line\">      <span class=\"type\">SearchWord</span> <span class=\"variable\">newSearchWord</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">SearchWord</span>(</span><br><span class=\"line\">              searchWord.getKeyword(), searchWord.getCount(), searchWord.getLastUpdateTime());</span><br><span class=\"line\">      newKeywords.put(e.getKey(), newSearchWord);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 从数据库中取出更新时间&gt;lastUpdateTime的数据，放入到newKeywords中</span></span><br><span class=\"line\">    List&lt;SearchWord&gt; toBeUpdatedSearchWords = getSearchWords(lastUpdateTime);</span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"variable\">maxNewUpdatedTime</span> <span class=\"operator\">=</span> lastUpdateTime;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (SearchWord searchWord : toBeUpdatedSearchWords) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (searchWord.getLastUpdateTime() &gt; maxNewUpdatedTime) &#123;</span><br><span class=\"line\">        maxNewUpdatedTime = searchWord.getLastUpdateTime();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (newKeywords.containsKey(searchWord.getKeyword())) &#123;</span><br><span class=\"line\">        <span class=\"type\">SearchWord</span> <span class=\"variable\">oldSearchWord</span> <span class=\"operator\">=</span> newKeywords.get(searchWord.getKeyword());</span><br><span class=\"line\">        oldSearchWord.setCount(searchWord.getCount());</span><br><span class=\"line\">        oldSearchWord.setLastUpdateTime(searchWord.getLastUpdateTime());</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        newKeywords.put(searchWord.getKeyword(), searchWord);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    lastUpdateTime = maxNewUpdatedTime;</span><br><span class=\"line\">    currentKeywords = newKeywords;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> List&lt;SearchWord&gt; <span class=\"title function_\">getSearchWords</span><span class=\"params\">(<span class=\"type\">long</span> lastUpdateTime)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// <span class=\"doctag\">TODO:</span> 从数据库中取出更新时间&gt;lastUpdateTime的数据</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>第二种方法：先将对象序列化，然后再反序列化成新的对象。具体的示例代码如下所示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> Object <span class=\"title function_\">deepCopy</span><span class=\"params\">(Object object)</span> &#123;</span><br><span class=\"line\">  <span class=\"type\">ByteArrayOutputStream</span> <span class=\"variable\">bo</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ByteArrayOutputStream</span>();</span><br><span class=\"line\">  <span class=\"type\">ObjectOutputStream</span> <span class=\"variable\">oo</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ObjectOutputStream</span>(bo);</span><br><span class=\"line\">  oo.writeObject(object);</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"type\">ByteArrayInputStream</span> <span class=\"variable\">bi</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ByteArrayInputStream</span>(bo.toByteArray());</span><br><span class=\"line\">  <span class=\"type\">ObjectInputStream</span> <span class=\"variable\">oi</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ObjectInputStream</span>(bi);</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">return</span> oi.readObject();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>刚刚的两种实现方法，不管采用哪种，深拷贝都要比浅拷贝耗时、耗内存空间。针对我们这个应用场景，有没有更快、更省内存的实现方式呢？</li>\n<li>我们可以先采用浅拷贝的方式创建 newKeywords。对于需要更新的 SearchWord 对象，我们再使用深度拷贝的方式创建一份新的对象，替换 newKeywords 中的老对象。毕竟需要更新的数据是很少的。这种方式即利用了浅拷贝节省时间、空间的优点，又能保证 currentKeywords 中的中数据都是老版本的数据。具体的代码实现如下所示。这也是标题中讲到的，在我们这个应用场景下，最快速 clone 散列表的方式。</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Demo</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> HashMap&lt;String, SearchWord&gt; currentKeywords=<span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;();</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"type\">long</span> <span class=\"variable\">lastUpdateTime</span> <span class=\"operator\">=</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">refresh</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Shallow copy</span></span><br><span class=\"line\">    HashMap&lt;String, SearchWord&gt; newKeywords = (HashMap&lt;String, SearchWord&gt;) currentKeywords.clone();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 从数据库中取出更新时间&gt;lastUpdateTime的数据，放入到newKeywords中</span></span><br><span class=\"line\">    List&lt;SearchWord&gt; toBeUpdatedSearchWords = getSearchWords(lastUpdateTime);</span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"variable\">maxNewUpdatedTime</span> <span class=\"operator\">=</span> lastUpdateTime;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (SearchWord searchWord : toBeUpdatedSearchWords) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (searchWord.getLastUpdateTime() &gt; maxNewUpdatedTime) &#123;</span><br><span class=\"line\">        maxNewUpdatedTime = searchWord.getLastUpdateTime();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (newKeywords.containsKey(searchWord.getKeyword())) &#123;</span><br><span class=\"line\">        newKeywords.remove(searchWord.getKeyword());</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      newKeywords.put(searchWord.getKeyword(), searchWord);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    lastUpdateTime = maxNewUpdatedTime;</span><br><span class=\"line\">    currentKeywords = newKeywords;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> List&lt;SearchWord&gt; <span class=\"title function_\">getSearchWords</span><span class=\"params\">(<span class=\"type\">long</span> lastUpdateTime)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// <span class=\"doctag\">TODO:</span> 从数据库中取出更新时间&gt;lastUpdateTime的数据</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","site":{"data":{}},"cover_type":"img","excerpt":"","more":"<h1 id=\"声明\"><a href=\"#声明\" class=\"headerlink\" title=\"声明\"></a>声明</h1><blockquote>\n<ol>\n<li>此系列文章非本人原创，是学习笔记。</li>\n<li>设计模式系列以后会持续更新，包括已经发布的设计模式文章，因为后续还要再多看一下书，教程和开源项目等，继续润色文章。</li>\n</ol>\n</blockquote>\n<h1 id=\"工厂模式【常用】\"><a href=\"#工厂模式【常用】\" class=\"headerlink\" title=\"工厂模式【常用】\"></a>工厂模式【常用】</h1><blockquote>\n<p>工厂模式很重要，后面的很多架构设计，都是工厂模式联合着其它设计模式使用。</p>\n</blockquote>\n<ol>\n<li><p>一般情况下，工厂模式分为三种更加细分的类型：简单工厂、工厂方法和抽象工厂。不过，在 GoF 的《设计模式》一书中，它将简单工厂模式看作是工厂方法模式的一种特例，所以工厂模式只被分成了工厂方法和抽象工厂两类。实际上，前面一种分类方法更加常见，所以，在今天的讲解中，我们沿用第一种分类方法。</p>\n</li>\n<li><p>在这三种细分的工厂模式中，简单工厂、工厂方法原理比较简单，在实际的项目中也比较常用。而抽象工厂的原理稍微复杂点，在实际的项目中相对也不常用。所以，我们今天讲解的重点是前两种工厂模式。对于抽象工厂，稍微了解一下即可。</p>\n</li>\n<li><p>除此之外，我们讲解的重点也不是原理和实现，因为这些都很简单，重点还是带你搞清楚应用场景：什么时候该用工厂模式？相对于直接 new 来创建对象，用工厂模式来创建究竟有什么好处呢？</p>\n</li>\n</ol>\n<h2 id=\"简单工厂（Simple-Factory）\"><a href=\"#简单工厂（Simple-Factory）\" class=\"headerlink\" title=\"简单工厂（Simple Factory）\"></a>简单工厂（Simple Factory）</h2><p>首先，我们来看，什么是简单工厂模式。我们通过一个例子来解释一下。</p>\n<p>在下面这段代码中，我们根据配置文件的后缀（json、xml、yaml、properties），选择不同的解析器（JsonRuleConfigParser、XmlRuleConfigParser……），将存储在文件中的配置解析成内存对象 RuleConfig。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">RuleConfigSource</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> RuleConfig <span class=\"title function_\">load</span><span class=\"params\">(String ruleConfigFilePath)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">ruleConfigFileExtension</span> <span class=\"operator\">=</span> getFileExtension(ruleConfigFilePath);</span><br><span class=\"line\">    <span class=\"type\">IRuleConfigParser</span> <span class=\"variable\">parser</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"string\">&quot;json&quot;</span>.equalsIgnoreCase(ruleConfigFileExtension)) &#123;</span><br><span class=\"line\">      parser = <span class=\"keyword\">new</span> <span class=\"title class_\">JsonRuleConfigParser</span>();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"string\">&quot;xml&quot;</span>.equalsIgnoreCase(ruleConfigFileExtension)) &#123;</span><br><span class=\"line\">      parser = <span class=\"keyword\">new</span> <span class=\"title class_\">XmlRuleConfigParser</span>();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"string\">&quot;yaml&quot;</span>.equalsIgnoreCase(ruleConfigFileExtension)) &#123;</span><br><span class=\"line\">      parser = <span class=\"keyword\">new</span> <span class=\"title class_\">YamlRuleConfigParser</span>();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"string\">&quot;properties&quot;</span>.equalsIgnoreCase(ruleConfigFileExtension)) &#123;</span><br><span class=\"line\">      parser = <span class=\"keyword\">new</span> <span class=\"title class_\">PropertiesRuleConfigParser</span>();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">InvalidRuleConfigException</span>(</span><br><span class=\"line\">             <span class=\"string\">&quot;Rule config file format is not supported: &quot;</span> + ruleConfigFilePath);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">configText</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">    <span class=\"comment\">//从ruleConfigFilePath文件中读取配置文本到configText中</span></span><br><span class=\"line\">    <span class=\"type\">RuleConfig</span> <span class=\"variable\">ruleConfig</span> <span class=\"operator\">=</span> parser.parse(configText);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ruleConfig;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> String <span class=\"title function_\">getFileExtension</span><span class=\"params\">(String filePath)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//...解析文件名获取扩展名，比如rule.json，返回json</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;json&quot;</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>为了让代码逻辑更加清晰，可读性更好，我们要善于将功能独立的代码块封装成函数。按照这个设计思路，我们可以将代码中涉及 parser 创建的部分逻辑剥离出来，抽象成 createParser() 函数。重构之后的代码如下所示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  <span class=\"keyword\">public</span> RuleConfig <span class=\"title function_\">load</span><span class=\"params\">(String ruleConfigFilePath)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">ruleConfigFileExtension</span> <span class=\"operator\">=</span> getFileExtension(ruleConfigFilePath);</span><br><span class=\"line\">    <span class=\"type\">IRuleConfigParser</span> <span class=\"variable\">parser</span> <span class=\"operator\">=</span> createParser(ruleConfigFileExtension);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (parser == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">InvalidRuleConfigException</span>(</span><br><span class=\"line\">              <span class=\"string\">&quot;Rule config file format is not supported: &quot;</span> + ruleConfigFilePath);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">configText</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">    <span class=\"comment\">//从ruleConfigFilePath文件中读取配置文本到configText中</span></span><br><span class=\"line\">    <span class=\"type\">RuleConfig</span> <span class=\"variable\">ruleConfig</span> <span class=\"operator\">=</span> parser.parse(configText);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ruleConfig;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> String <span class=\"title function_\">getFileExtension</span><span class=\"params\">(String filePath)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//...解析文件名获取扩展名，比如rule.json，返回json</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;json&quot;</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> IRuleConfigParser <span class=\"title function_\">createParser</span><span class=\"params\">(String configFormat)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">IRuleConfigParser</span> <span class=\"variable\">parser</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"string\">&quot;json&quot;</span>.equalsIgnoreCase(configFormat)) &#123;</span><br><span class=\"line\">      parser = <span class=\"keyword\">new</span> <span class=\"title class_\">JsonRuleConfigParser</span>();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"string\">&quot;xml&quot;</span>.equalsIgnoreCase(configFormat)) &#123;</span><br><span class=\"line\">      parser = <span class=\"keyword\">new</span> <span class=\"title class_\">XmlRuleConfigParser</span>();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"string\">&quot;yaml&quot;</span>.equalsIgnoreCase(configFormat)) &#123;</span><br><span class=\"line\">      parser = <span class=\"keyword\">new</span> <span class=\"title class_\">YamlRuleConfigParser</span>();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"string\">&quot;properties&quot;</span>.equalsIgnoreCase(configFormat)) &#123;</span><br><span class=\"line\">      parser = <span class=\"keyword\">new</span> <span class=\"title class_\">PropertiesRuleConfigParser</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> parser;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>为了让类的职责更加单一(<strong>设计模式原则中的单一职责</strong>，)、代码更加清晰，我们还可以进一步将 createParser() 函数剥离到一个独立的类中，让这个类只负责对象的创建。而这个类就是我们现在要讲的简单工厂模式类。具体的代码如下所示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">RuleConfigSource</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> RuleConfig <span class=\"title function_\">load</span><span class=\"params\">(String ruleConfigFilePath)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">ruleConfigFileExtension</span> <span class=\"operator\">=</span> getFileExtension(ruleConfigFilePath);</span><br><span class=\"line\">    <span class=\"type\">IRuleConfigParser</span> <span class=\"variable\">parser</span> <span class=\"operator\">=</span> RuleConfigParserFactory.createParser(ruleConfigFileExtension);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (parser == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">InvalidRuleConfigException</span>(</span><br><span class=\"line\">              <span class=\"string\">&quot;Rule config file format is not supported: &quot;</span> + ruleConfigFilePath);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">configText</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">    <span class=\"comment\">//从ruleConfigFilePath文件中读取配置文本到configText中</span></span><br><span class=\"line\">    <span class=\"type\">RuleConfig</span> <span class=\"variable\">ruleConfig</span> <span class=\"operator\">=</span> parser.parse(configText);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ruleConfig;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> String <span class=\"title function_\">getFileExtension</span><span class=\"params\">(String filePath)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//...解析文件名获取扩展名，比如rule.json，返回json</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;json&quot;</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">RuleConfigParserFactory</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> IRuleConfigParser <span class=\"title function_\">createParser</span><span class=\"params\">(String configFormat)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">IRuleConfigParser</span> <span class=\"variable\">parser</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"string\">&quot;json&quot;</span>.equalsIgnoreCase(configFormat)) &#123;</span><br><span class=\"line\">      parser = <span class=\"keyword\">new</span> <span class=\"title class_\">JsonRuleConfigParser</span>();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"string\">&quot;xml&quot;</span>.equalsIgnoreCase(configFormat)) &#123;</span><br><span class=\"line\">      parser = <span class=\"keyword\">new</span> <span class=\"title class_\">XmlRuleConfigParser</span>();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"string\">&quot;yaml&quot;</span>.equalsIgnoreCase(configFormat)) &#123;</span><br><span class=\"line\">      parser = <span class=\"keyword\">new</span> <span class=\"title class_\">YamlRuleConfigParser</span>();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"string\">&quot;properties&quot;</span>.equalsIgnoreCase(configFormat)) &#123;</span><br><span class=\"line\">      parser = <span class=\"keyword\">new</span> <span class=\"title class_\">PropertiesRuleConfigParser</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> parser;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<ol>\n<li>在上面的代码实现中，我们每次调用 RuleConfigParserFactory 的 createParser() 的时候，都要创建一个新的 parser。</li>\n<li>实际上，如果 parser 可以复用，为了节省内存和对象创建的时间，我们可以将 parser 事先创建好缓存起来。当调用 createParser() 函数的时候，我们从缓存中取出 parser 对象直接使用。这有点类似单例模式和简单工厂模式的结合，具体的代码实现如下所示。在接下来的讲解中，我们把上一种实现方法叫作简单工厂模式的第一种实现方法，把下面这种实现方法叫作简单工厂模式的第二种实现方法。</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">RuleConfigParserFactory</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Map&lt;String, RuleConfigParser&gt; cachedParsers = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">    cachedParsers.put(<span class=\"string\">&quot;json&quot;</span>, <span class=\"keyword\">new</span> <span class=\"title class_\">JsonRuleConfigParser</span>());</span><br><span class=\"line\">    cachedParsers.put(<span class=\"string\">&quot;xml&quot;</span>, <span class=\"keyword\">new</span> <span class=\"title class_\">XmlRuleConfigParser</span>());</span><br><span class=\"line\">    cachedParsers.put(<span class=\"string\">&quot;yaml&quot;</span>, <span class=\"keyword\">new</span> <span class=\"title class_\">YamlRuleConfigParser</span>());</span><br><span class=\"line\">    cachedParsers.put(<span class=\"string\">&quot;properties&quot;</span>, <span class=\"keyword\">new</span> <span class=\"title class_\">PropertiesRuleConfigParser</span>());</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> IRuleConfigParser <span class=\"title function_\">createParser</span><span class=\"params\">(String configFormat)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (configFormat == <span class=\"literal\">null</span> || configFormat.isEmpty()) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;<span class=\"comment\">//返回null还是IllegalArgumentException全凭你自己说了算</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">IRuleConfigParser</span> <span class=\"variable\">parser</span> <span class=\"operator\">=</span> cachedParsers.get(configFormat.toLowerCase());</span><br><span class=\"line\">    <span class=\"keyword\">return</span> parser;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<ol>\n<li>对于上面两种简单工厂模式的实现方法，如果我们要添加新的 parser，那势必要改动到 RuleConfigParserFactory 的代码，那这是不是违反开闭原则呢？实际上，如果不是需要频繁地添加新的 parser，只是偶尔修改一下 RuleConfigParserFactory 代码，稍微不符合开闭原则，也是完全可以接受的。</li>\n<li>除此之外，在 RuleConfigParserFactory 的第一种代码实现中，有一组 if 分支判断逻辑，是不是应该用多态或其他设计模式来替代呢？实际上，如果 if 分支并不是很多，代码中有 if 分支也是完全可以接受的。应用多态或设计模式来替代 if 分支判断逻辑，也并不是没有任何缺点的，它虽然提高了代码的扩展性，更加符合<strong>开闭原则</strong>，但也增加了类的个数，牺牲了代码的可读性。关于这一点，我们在后面章节中会详细讲到。</li>\n<li>总结一下，尽管简单工厂模式的代码实现中，有多处 if 分支判断逻辑，违背开闭原则，但权衡扩展性和可读性，这样的代码实现在大多数情况下（比如，不需要频繁地添加 parser，也没有太多的 parser）是没有问题的。</li>\n</ol>\n<h2 id=\"工厂方法（Factory-Method）\"><a href=\"#工厂方法（Factory-Method）\" class=\"headerlink\" title=\"工厂方法（Factory Method）\"></a>工厂方法（Factory Method）</h2><p>如果我们非得要将 if 分支逻辑去掉，那该怎么办呢？比较经典处理方法就是利用多态。按照多态的实现思路，对上面的代码进行重构。重构之后的代码如下所示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">IRuleConfigParserFactory</span> &#123;</span><br><span class=\"line\">  IRuleConfigParser <span class=\"title function_\">createParser</span><span class=\"params\">()</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">JsonRuleConfigParserFactory</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">IRuleConfigParserFactory</span> &#123;</span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> IRuleConfigParser <span class=\"title function_\">createParser</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">JsonRuleConfigParser</span>();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">XmlRuleConfigParserFactory</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">IRuleConfigParserFactory</span> &#123;</span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> IRuleConfigParser <span class=\"title function_\">createParser</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">XmlRuleConfigParser</span>();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">YamlRuleConfigParserFactory</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">IRuleConfigParserFactory</span> &#123;</span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> IRuleConfigParser <span class=\"title function_\">createParser</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">YamlRuleConfigParser</span>();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">PropertiesRuleConfigParserFactory</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">IRuleConfigParserFactory</span> &#123;</span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> IRuleConfigParser <span class=\"title function_\">createParser</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">PropertiesRuleConfigParser</span>();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>实际上，这就是工厂方法模式的典型代码实现。这样当我们新增一种 parser 的时候，只需要新增一个实现了 IRuleConfigParserFactory 接口的 Factory 类即可。所以，工厂方法模式比起简单工厂模式更加符合开闭原则。</p>\n<p>从上面的工厂方法的实现来看，一切都很完美，但是实际上存在挺大的问题。问题存在于这些工厂类的使用上。接下来，我们看一下，如何用这些工厂类来实现 RuleConfigSource 的 load() 函数。具体的代码如下所示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">RuleConfigSource</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> RuleConfig <span class=\"title function_\">load</span><span class=\"params\">(String ruleConfigFilePath)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">ruleConfigFileExtension</span> <span class=\"operator\">=</span> getFileExtension(ruleConfigFilePath);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">IRuleConfigParserFactory</span> <span class=\"variable\">parserFactory</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"string\">&quot;json&quot;</span>.equalsIgnoreCase(ruleConfigFileExtension)) &#123;</span><br><span class=\"line\">      parserFactory = <span class=\"keyword\">new</span> <span class=\"title class_\">JsonRuleConfigParserFactory</span>();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"string\">&quot;xml&quot;</span>.equalsIgnoreCase(ruleConfigFileExtension)) &#123;</span><br><span class=\"line\">      parserFactory = <span class=\"keyword\">new</span> <span class=\"title class_\">XmlRuleConfigParserFactory</span>();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"string\">&quot;yaml&quot;</span>.equalsIgnoreCase(ruleConfigFileExtension)) &#123;</span><br><span class=\"line\">      parserFactory = <span class=\"keyword\">new</span> <span class=\"title class_\">YamlRuleConfigParserFactory</span>();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"string\">&quot;properties&quot;</span>.equalsIgnoreCase(ruleConfigFileExtension)) &#123;</span><br><span class=\"line\">      parserFactory = <span class=\"keyword\">new</span> <span class=\"title class_\">PropertiesRuleConfigParserFactory</span>();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">InvalidRuleConfigException</span>(<span class=\"string\">&quot;Rule config file format is not supported: &quot;</span> + ruleConfigFilePath);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">IRuleConfigParser</span> <span class=\"variable\">parser</span> <span class=\"operator\">=</span> parserFactory.createParser();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">configText</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">    <span class=\"comment\">//从ruleConfigFilePath文件中读取配置文本到configText中</span></span><br><span class=\"line\">    <span class=\"type\">RuleConfig</span> <span class=\"variable\">ruleConfig</span> <span class=\"operator\">=</span> parser.parse(configText);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ruleConfig;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> String <span class=\"title function_\">getFileExtension</span><span class=\"params\">(String filePath)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//...解析文件名获取扩展名，比如rule.json，返回json</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;json&quot;</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<ol>\n<li>从上面的代码实现来看，工厂类对象的创建逻辑又耦合进了 load() 函数中，跟我们最初的代码版本非常相似，引入工厂方法非但没有解决问题，反倒让设计变得更加复杂了。那怎么来解决这个问题呢？</li>\n<li>我们可以为工厂类再创建一个简单工厂，也就是工厂的工厂，用来创建工厂类对象。这段话听起来有点绕，我把代码实现出来了，你一看就能明白了。其中，RuleConfigParserFactoryMap 类是创建工厂对象的工厂类，getParserFactory() 返回的是缓存好的单例工厂对象。</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">RuleConfigSource</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> RuleConfig <span class=\"title function_\">load</span><span class=\"params\">(String ruleConfigFilePath)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">ruleConfigFileExtension</span> <span class=\"operator\">=</span> getFileExtension(ruleConfigFilePath);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">IRuleConfigParserFactory</span> <span class=\"variable\">parserFactory</span> <span class=\"operator\">=</span> RuleConfigParserFactoryMap.getParserFactory(ruleConfigFileExtension);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (parserFactory == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">InvalidRuleConfigException</span>(<span class=\"string\">&quot;Rule config file format is not supported: &quot;</span> + ruleConfigFilePath);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">IRuleConfigParser</span> <span class=\"variable\">parser</span> <span class=\"operator\">=</span> parserFactory.createParser();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">configText</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">    <span class=\"comment\">//从ruleConfigFilePath文件中读取配置文本到configText中</span></span><br><span class=\"line\">    <span class=\"type\">RuleConfig</span> <span class=\"variable\">ruleConfig</span> <span class=\"operator\">=</span> parser.parse(configText);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ruleConfig;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> String <span class=\"title function_\">getFileExtension</span><span class=\"params\">(String filePath)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//...解析文件名获取扩展名，比如rule.json，返回json</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;json&quot;</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//因为工厂类只包含方法，不包含成员变量，完全可以复用，</span></span><br><span class=\"line\"><span class=\"comment\">//不需要每次都创建新的工厂类对象，所以，简单工厂模式的第二种实现思路更加合适。</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">RuleConfigParserFactoryMap</span> &#123; <span class=\"comment\">//工厂的工厂</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Map&lt;String, IRuleConfigParserFactory&gt; cachedFactories = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">    cachedFactories.put(<span class=\"string\">&quot;json&quot;</span>, <span class=\"keyword\">new</span> <span class=\"title class_\">JsonRuleConfigParserFactory</span>());</span><br><span class=\"line\">    cachedFactories.put(<span class=\"string\">&quot;xml&quot;</span>, <span class=\"keyword\">new</span> <span class=\"title class_\">XmlRuleConfigParserFactory</span>());</span><br><span class=\"line\">    cachedFactories.put(<span class=\"string\">&quot;yaml&quot;</span>, <span class=\"keyword\">new</span> <span class=\"title class_\">YamlRuleConfigParserFactory</span>());</span><br><span class=\"line\">    cachedFactories.put(<span class=\"string\">&quot;properties&quot;</span>, <span class=\"keyword\">new</span> <span class=\"title class_\">PropertiesRuleConfigParserFactory</span>());</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> IRuleConfigParserFactory <span class=\"title function_\">getParserFactory</span><span class=\"params\">(String type)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (type == <span class=\"literal\">null</span> || type.isEmpty()) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">IRuleConfigParserFactory</span> <span class=\"variable\">parserFactory</span> <span class=\"operator\">=</span> cachedFactories.get(type.toLowerCase());</span><br><span class=\"line\">    <span class=\"keyword\">return</span> parserFactory;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<ol>\n<li>当我们需要添加新的规则配置解析器的时候，我们只需要创建新的 parser 类和 parser factory 类，并且在 RuleConfigParserFactoryMap 类中，将新的 parser factory 对象添加到 cachedFactories 中即可。代码的改动非常少，基本上符合开闭原则。</li>\n<li>实际上，对于规则配置文件解析这个应用场景来说，工厂模式需要额外创建诸多 Factory 类，也会增加代码的复杂性，而且，每个 Factory 类只是做简单的 new 操作，功能非常单薄（只有一行代码），也没必要设计成独立的类，所以，在这个应用场景下，简单工厂模式简单好用，比工厂方法模式更加合适。</li>\n</ol>\n<h3 id=\"那什么时候该用工厂方法模式，而非简单工厂模式呢？\"><a href=\"#那什么时候该用工厂方法模式，而非简单工厂模式呢？\" class=\"headerlink\" title=\"那什么时候该用工厂方法模式，而非简单工厂模式呢？\"></a>那什么时候该用工厂方法模式，而非简单工厂模式呢？</h3><ol>\n<li>我们前面提到，之所以将某个代码块剥离出来，独立为函数或者类，原因是这个代码块的逻辑过于复杂，剥离之后能让代码更加清晰，更加可读、可维护。但是，如果代码块本身并不复杂，就几行代码而已，我们完全没必要将它拆分成单独的函数或者类。</li>\n<li>基于这个设计思想，当对象的创建逻辑比较复杂，不只是简单的 new 一下就可以，而是要组合其他类对象，做各种初始化操作的时候，我们推荐使用工厂方法模式，将复杂的创建逻辑拆分到多个工厂类中，让每个工厂类都不至于过于复杂。而使用简单工厂模式，将所有的创建逻辑都放到一个工厂类中，会导致这个工厂类变得很复杂。</li>\n<li>除此之外，在某些场景下，如果对象不可复用，那工厂类每次都要返回不同的对象。如果我们使用简单工厂模式来实现，就只能选择第一种包含 if 分支逻辑的实现方式。如果我们还想避免烦人的 if-else 分支逻辑，这个时候，我们就推荐使用工厂方法模式。</li>\n</ol>\n<h2 id=\"抽象工厂（Abstract-Factory）\"><a href=\"#抽象工厂（Abstract-Factory）\" class=\"headerlink\" title=\"抽象工厂（Abstract Factory）\"></a>抽象工厂（Abstract Factory）</h2><ol>\n<li>讲完了简单工厂、工厂方法，我们再来看抽象工厂模式。抽象工厂模式的应用场景比较特殊，没有前两种常用，所以不是我们学习的重点，你简单了解一下就可以了。</li>\n<li>在简单工厂和工厂方法中，类只有一种分类方式。比如，在规则配置解析那个例子中，解析器类只会根据配置文件格式（Json、Xml、Yaml……）来分类。但是，如果类有两种分类方式，比如，我们既可以按照配置文件格式来分类，也可以按照解析的对象（Rule 规则配置还是 System 系统配置）来分类，那就会对应下面这 8 个 parser 类。</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">针对规则配置的解析器：基于接口IRuleConfigParser</span><br><span class=\"line\">JsonRuleConfigParser</span><br><span class=\"line\">XmlRuleConfigParser</span><br><span class=\"line\">YamlRuleConfigParser</span><br><span class=\"line\">PropertiesRuleConfigParser</span><br><span class=\"line\"></span><br><span class=\"line\">针对系统配置的解析器：基于接口ISystemConfigParser</span><br><span class=\"line\">JsonSystemConfigParser</span><br><span class=\"line\">XmlSystemConfigParser</span><br><span class=\"line\">YamlSystemConfigParser</span><br><span class=\"line\">PropertiesSystemConfigParser</span><br></pre></td></tr></table></figure>\n\n\n\n<ol>\n<li>针对这种特殊的场景，如果还是继续用工厂方法来实现的话，我们要针对每个 parser 都编写一个工厂类，也就是要编写 8 个工厂类。如果我们未来还需要增加针对业务配置的解析器（比如 IBizConfigParser），那就要再对应地增加 4 个工厂类。而我们知道，过多的类也会让系统难维护。这个问题该怎么解决呢？</li>\n<li>抽象工厂就是针对这种非常特殊的场景而诞生的。我们可以让一个工厂负责创建多个不同类型的对象（IRuleConfigParser、ISystemConfigParser 等），而不是只创建一种 parser 对象。这样就可以有效地减少工厂类的个数。具体的代码实现如下所示：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">IConfigParserFactory</span> &#123;</span><br><span class=\"line\">  IRuleConfigParser <span class=\"title function_\">createRuleParser</span><span class=\"params\">()</span>;</span><br><span class=\"line\">  ISystemConfigParser <span class=\"title function_\">createSystemParser</span><span class=\"params\">()</span>;</span><br><span class=\"line\">  <span class=\"comment\">//此处可以扩展新的parser类型，比如IBizConfigParser</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">JsonConfigParserFactory</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">IConfigParserFactory</span> &#123;</span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> IRuleConfigParser <span class=\"title function_\">createRuleParser</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">JsonRuleConfigParser</span>();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> ISystemConfigParser <span class=\"title function_\">createSystemParser</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">JsonSystemConfigParser</span>();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">XmlConfigParserFactory</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">IConfigParserFactory</span> &#123;</span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> IRuleConfigParser <span class=\"title function_\">createRuleParser</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">XmlRuleConfigParser</span>();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> ISystemConfigParser <span class=\"title function_\">createSystemParser</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">XmlSystemConfigParser</span>();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 省略YamlConfigParserFactory和PropertiesConfigParserFactory代码</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"如何设计实现一个Dependency-Injection框架？\"><a href=\"#如何设计实现一个Dependency-Injection框架？\" class=\"headerlink\" title=\"如何设计实现一个Dependency Injection框架？\"></a>如何设计实现一个Dependency Injection框架？</h2><p>当创建对象是一个“大工程”的时候，我们一般会选择使用工厂模式，来封装对象复杂的创建过程，将对象的创建和使用分离，让代码更加清晰。那何为“大工程”呢？上面我们讲了两种情况，一种是创建过程涉及复杂的 if-else 分支判断，另一种是对象创建需要组装多个其他类对象或者需要复杂的初始化过程。</p>\n<p>今天，我们再来讲一个创建对象的“大工程”，依赖注入框架，或者叫依赖注入容器（Dependency Injection Container），简称 DI 容器。在今天的讲解中，我会带你一块搞清楚这样几个问题：DI 容器跟我们讲的工厂模式又有何区别和联系？DI 容器的核心功能有哪些，以及如何实现一个简单的 DI 容器？</p>\n<h3 id=\"工厂模式和-DI-容器有何区别？\"><a href=\"#工厂模式和-DI-容器有何区别？\" class=\"headerlink\" title=\"工厂模式和 DI 容器有何区别？\"></a>工厂模式和 DI 容器有何区别？</h3><ol>\n<li>实际上，DI 容器底层最基本的设计思路就是基于工厂模式的。DI 容器相当于一个大的工厂类，负责在程序启动的时候，根据配置（要创建哪些类对象，每个类对象的创建需要依赖哪些其他类对象）事先创建好对象。当应用程序需要使用某个类对象的时候，直接从容器中获取即可。正是因为它持有一堆对象，所以这个框架才被称为“容器”。</li>\n<li>DI 容器相对于我们上面讲的工厂模式的例子来说，它处理的是更大的对象创建工程。上面讲的工厂模式中，一个工厂类只负责某个类对象或者某一组相关类对象（继承自同一抽象类或者接口的子类）的创建，而 DI 容器负责的是整个应用中所有类对象的创建。</li>\n<li>除此之外，DI 容器负责的事情要比单纯的工厂模式要多。比如，它还包括配置的解析、对象生命周期的管理。接下来，我们就详细讲讲，一个简单的 DI 容器应该包含哪些核心功能。</li>\n</ol>\n<h3 id=\"DI-容器的核心功能有哪些？\"><a href=\"#DI-容器的核心功能有哪些？\" class=\"headerlink\" title=\"DI 容器的核心功能有哪些？\"></a>DI 容器的核心功能有哪些？</h3><p>总结一下，一个简单的 DI 容器的核心功能一般有三个：配置解析、对象创建和对象生命周期管理。</p>\n<blockquote>\n<p>首先，我们来看配置解析。</p>\n</blockquote>\n<ol>\n<li>在上面讲的工厂模式中，工厂类要创建哪个类对象是事先确定好的，并且是写死在工厂类代码中的。作为一个通用的框架来说，框架代码跟应用代码应该是高度解耦的，DI 容器事先并不知道应用会创建哪些对象，不可能把某个应用要创建的对象写死在框架代码中。所以，我们需要通过一种形式，让应用告知 DI 容器要创建哪些对象。这种形式就是我们要讲的配置。</li>\n<li>我们将需要由 DI 容器来创建的类对象和创建类对象的必要信息（使用哪个构造函数以及对应的构造函数参数都是什么等等），放到配置文件中。容器读取配置文件，根据配置文件提供的信息来创建对象。</li>\n<li>下面是一个典型的 Spring 容器的配置文件。Spring 容器读取这个配置文件，解析出要创建的两个对象：rateLimiter 和 redisCounter，并且得到两者的依赖关系：rateLimiter 依赖 redisCounter。</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">RateLimiter</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> RedisCounter redisCounter;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"title function_\">RateLimiter</span><span class=\"params\">(RedisCounter redisCounter)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.redisCounter = redisCounter;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;Hello World!&quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">RedisCounter</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> String ipAddress;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"type\">int</span> port;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"title function_\">RedisCounter</span><span class=\"params\">(String ipAddress, <span class=\"type\">int</span> port)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.ipAddress = ipAddress;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.port = port;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">配置文件beans.xml：</span><br><span class=\"line\">&lt;beans&gt;</span><br><span class=\"line\">   &lt;bean id=<span class=\"string\">&quot;rateLimiter&quot;</span> class=<span class=\"string\">&quot;com.xzg.RateLimiter&quot;</span>&gt;</span><br><span class=\"line\">      &lt;constructor-arg ref=<span class=\"string\">&quot;redisCounter&quot;</span>/&gt;</span><br><span class=\"line\">   &lt;/bean&gt;</span><br><span class=\"line\"> </span><br><span class=\"line\">   &lt;bean id=<span class=\"string\">&quot;redisCounter&quot;</span> class=<span class=\"string\">&quot;com.xzg.redisCounter&quot;</span>&gt;</span><br><span class=\"line\">     &lt;constructor-arg type=<span class=\"string\">&quot;String&quot;</span> value=<span class=\"string\">&quot;127.0.0.1&quot;</span>&gt;</span><br><span class=\"line\">     &lt;constructor-arg type=<span class=\"string\">&quot;int&quot;</span> value=<span class=\"number\">1234</span>&gt;</span><br><span class=\"line\">   &lt;/bean&gt;</span><br><span class=\"line\">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>\n\n\n\n<blockquote>\n<p>其次，我们再来看对象创建。</p>\n</blockquote>\n<ol>\n<li>在 DI 容器中，如果我们给每个类都对应创建一个工厂类，那项目中类的个数会成倍增加，这会增加代码的维护成本。要解决这个问题并不难。我们只需要将所有类对象的创建都放到一个工厂类中完成就可以了，比如 BeansFactory。</li>\n<li>你可能会说，如果要创建的类对象非常多，BeansFactory 中的代码会不会线性膨胀（代码量跟创建对象的个数成正比）呢？实际上并不会。待会讲到 DI 容器的具体实现的时候，我们会讲“反射”这种机制，它能在程序运行的过程中，动态地加载类、创建对象，不需要事先在代码中写死要创建哪些对象。所以，不管是创建一个对象还是十个对象，BeansFactory 工厂类代码都是一样的。</li>\n</ol>\n<blockquote>\n<p>最后，我们来看对象的生命周期管理。</p>\n</blockquote>\n<ol>\n<li>上面我们讲到，简单工厂模式有两种实现方式，一种是每次都返回新创建的对象，另一种是每次都返回同一个事先创建好的对象，也就是所谓的单例对象。在 Spring 框架中，我们可以通过配置 scope 属性，来区分这两种不同类型的对象。scope&#x3D;prototype 表示返回新创建的对象，scope&#x3D;singleton 表示返回单例对象。</li>\n<li>除此之外，我们还可以配置对象是否支持懒加载。如果 lazy-init&#x3D;true，对象在真正被使用到的时候（比如：BeansFactory.getBean(“userService”)）才被被创建；如果 lazy-init&#x3D;false，对象在应用启动的时候就事先创建好。</li>\n<li>不仅如此，我们还可以配置对象的 init-method 和 destroy-method 方法，比如 init-method&#x3D;loadProperties()，destroy-method&#x3D;updateConfigFile()。DI 容器在创建好对象之后，会主动调用 init-method 属性指定的方法来初始化对象。在对象被最终销毁之前，DI 容器会主动调用 destroy-method 属性指定的方法来做一些清理工作，比如释放数据库连接池、关闭文件。</li>\n</ol>\n<h2 id=\"如何实现一个简单的-DI-容器？\"><a href=\"#如何实现一个简单的-DI-容器？\" class=\"headerlink\" title=\"如何实现一个简单的 DI 容器？\"></a>如何实现一个简单的 DI 容器？</h2><p>用 Java 语言来实现一个简单的 DI 容器，核心逻辑只需要包括这样两个部分：配置文件解析、根据配置文件通过“反射”语法来创建对象。</p>\n<h3 id=\"最小原型设计\"><a href=\"#最小原型设计\" class=\"headerlink\" title=\"最小原型设计\"></a>最小原型设计</h3><p>因为我们主要是讲解设计模式，所以，在今天的讲解中，我们只实现一个 DI 容器的最小原型。像 Spring 框架这样的 DI 容器，它支持的配置格式非常灵活和复杂。为了简化代码实现，重点讲解原理，在最小原型中，我们只支持下面配置文件中涉及的配置语法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">配置文件beans.xml</span><br><span class=\"line\">&lt;beans&gt;</span><br><span class=\"line\">   &lt;bean id=<span class=\"string\">&quot;rateLimiter&quot;</span> class=<span class=\"string\">&quot;com.xzg.RateLimiter&quot;</span>&gt;</span><br><span class=\"line\">      &lt;constructor-arg ref=<span class=\"string\">&quot;redisCounter&quot;</span>/&gt;</span><br><span class=\"line\">   &lt;/bean&gt;</span><br><span class=\"line\"> </span><br><span class=\"line\">   &lt;bean id=<span class=\"string\">&quot;redisCounter&quot;</span> class=<span class=\"string\">&quot;com.xzg.redisCounter&quot;</span> scope=<span class=\"string\">&quot;singleton&quot;</span> lazy-init=<span class=\"string\">&quot;true&quot;</span>&gt;</span><br><span class=\"line\">     &lt;constructor-arg type=<span class=\"string\">&quot;String&quot;</span> value=<span class=\"string\">&quot;127.0.0.1&quot;</span>&gt;</span><br><span class=\"line\">     &lt;constructor-arg type=<span class=\"string\">&quot;int&quot;</span> value=<span class=\"number\">1234</span>&gt;</span><br><span class=\"line\">   &lt;/bean&gt;</span><br><span class=\"line\">&lt;/bean</span><br></pre></td></tr></table></figure>\n\n\n\n<p>最小原型的使用方式跟 Spring 框架非常类似，示例代码如下所示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Demo</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">ApplicationContext</span> <span class=\"variable\">applicationContext</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ClassPathXmlApplicationContext</span>(</span><br><span class=\"line\">            <span class=\"string\">&quot;beans.xml&quot;</span>);</span><br><span class=\"line\">    <span class=\"type\">RateLimiter</span> <span class=\"variable\">rateLimiter</span> <span class=\"operator\">=</span> (RateLimiter) applicationContext.getBean(<span class=\"string\">&quot;rateLimiter&quot;</span>);</span><br><span class=\"line\">    rateLimiter.test();</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"提供执行入口\"><a href=\"#提供执行入口\" class=\"headerlink\" title=\"提供执行入口\"></a>提供执行入口</h3><p>面向对象设计的最后一步是：组装类并提供执行入口。在这里，执行入口就是一组暴露给外部使用的接口和类。通过刚刚的最小原型使用示例代码，我们可以看出，执行入口主要包含两部分：ApplicationContext 和 ClassPathXmlApplicationContext。其中，ApplicationContext 是接口，ClassPathXmlApplicationContext 是接口的实现类。两个类具体实现如下所示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">ApplicationContext</span> &#123;</span><br><span class=\"line\">  Object <span class=\"title function_\">getBean</span><span class=\"params\">(String beanId)</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ClassPathXmlApplicationContext</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">ApplicationContext</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> BeansFactory beansFactory;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> BeanConfigParser beanConfigParser;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"title function_\">ClassPathXmlApplicationContext</span><span class=\"params\">(String configLocation)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.beansFactory = <span class=\"keyword\">new</span> <span class=\"title class_\">BeansFactory</span>();</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.beanConfigParser = <span class=\"keyword\">new</span> <span class=\"title class_\">XmlBeanConfigParser</span>();</span><br><span class=\"line\">    loadBeanDefinitions(configLocation);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">loadBeanDefinitions</span><span class=\"params\">(String configLocation)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">InputStream</span> <span class=\"variable\">in</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      in = <span class=\"built_in\">this</span>.getClass().getResourceAsStream(<span class=\"string\">&quot;/&quot;</span> + configLocation);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (in == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RuntimeException</span>(<span class=\"string\">&quot;Can not find config file: &quot;</span> + configLocation);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      List&lt;BeanDefinition&gt; beanDefinitions = beanConfigParser.parse(in);</span><br><span class=\"line\">      beansFactory.addBeanDefinitions(beanDefinitions);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (in != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">          in.close();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">          <span class=\"comment\">// <span class=\"doctag\">TODO:</span> log error</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> Object <span class=\"title function_\">getBean</span><span class=\"params\">(String beanId)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> beansFactory.getBean(beanId);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>从上面的代码中，我们可以看出，ClassPathXmlApplicationContext 负责组装 BeansFactory 和 BeanConfigParser 两个类，串联执行流程：从 classpath 中加载 XML 格式的配置文件，通过 BeanConfigParser 解析为统一的 BeanDefinition 格式，然后，BeansFactory 根据 BeanDefinition 来创建对象。</p>\n<h3 id=\"配置文件解析\"><a href=\"#配置文件解析\" class=\"headerlink\" title=\"配置文件解析\"></a>配置文件解析</h3><p>配置文件解析主要包含 BeanConfigParser 接口和 XmlBeanConfigParser 实现类，负责将配置文件解析为 BeanDefinition 结构，以便 BeansFactory 根据这个结构来创建对象。配置文件的解析比较繁琐，不涉及我们要讲的理论知识，不是我们讲解的重点，所以这里我只给出两个类的大致设计思路，并未给出具体的实现代码。如果感兴趣的话，你可以自行补充完整。具体的代码框架如下所示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">BeanConfigParser</span> &#123;</span><br><span class=\"line\">  List&lt;BeanDefinition&gt; <span class=\"title function_\">parse</span><span class=\"params\">(InputStream inputStream)</span>;</span><br><span class=\"line\">  List&lt;BeanDefinition&gt; <span class=\"title function_\">parse</span><span class=\"params\">(String configContent)</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">XmlBeanConfigParser</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">BeanConfigParser</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> List&lt;BeanDefinition&gt; <span class=\"title function_\">parse</span><span class=\"params\">(InputStream inputStream)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">content</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"comment\">// <span class=\"doctag\">TODO:</span>...</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> parse(content);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> List&lt;BeanDefinition&gt; <span class=\"title function_\">parse</span><span class=\"params\">(String configContent)</span> &#123;</span><br><span class=\"line\">    List&lt;BeanDefinition&gt; beanDefinitions = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">    <span class=\"comment\">// <span class=\"doctag\">TODO:</span>...</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> beanDefinitions;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">BeanDefinition</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> String id;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> String className;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> List&lt;ConstructorArg&gt; constructorArgs = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"type\">Scope</span> <span class=\"variable\">scope</span> <span class=\"operator\">=</span> Scope.SINGLETON;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"type\">boolean</span> <span class=\"variable\">lazyInit</span> <span class=\"operator\">=</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 省略必要的getter/setter/constructors</span></span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">isSingleton</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> scope.equals(Scope.SINGLETON);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">enum</span> <span class=\"title class_\">Scope</span> &#123;</span><br><span class=\"line\">    SINGLETON,</span><br><span class=\"line\">    PROTOTYPE</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ConstructorArg</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">boolean</span> isRef;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Class type;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Object arg;</span><br><span class=\"line\">    <span class=\"comment\">// 省略必要的getter/setter/constructors</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"核心工厂类设计\"><a href=\"#核心工厂类设计\" class=\"headerlink\" title=\"核心工厂类设计\"></a>核心工厂类设计</h3><ol>\n<li>最后，我们来看，BeansFactory 是如何设计和实现的。这也是我们这个 DI 容器最核心的一个类了。它负责根据从配置文件解析得到的 BeanDefinition 来创建对象。</li>\n<li>如果对象的 scope 属性是 singleton，那对象创建之后会缓存在 singletonObjects 这样一个 map 中，下次再请求此对象的时候，直接从 map 中取出返回，不需要重新创建。如果对象的 scope 属性是 prototype，那每次请求对象，BeansFactory 都会创建一个新的对象返回。</li>\n<li>实际上，BeansFactory 创建对象用到的主要技术点就是 Java 中的反射语法：一种动态加载类和创建对象的机制。我们知道，JVM 在启动的时候会根据代码自动地加载类、创建对象。至于都要加载哪些类、创建哪些对象，这些都是在代码中写死的，或者说提前写好的。但是，如果某个对象的创建并不是写死在代码中，而是放到配置文件中，我们需要在程序运行期间，动态地根据配置文件来加载类、创建对象，那这部分工作就没法让 JVM 帮我们自动完成了，我们需要利用 Java 提供的反射语法自己去编写代码。</li>\n<li>搞清楚了反射的原理，BeansFactory 的代码就不难看懂了。具体代码实现如下所示：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">BeansFactory</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> ConcurrentHashMap&lt;String, Object&gt; singletonObjects = <span class=\"keyword\">new</span> <span class=\"title class_\">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class=\"line\">  <span class=\"keyword\">private</span> ConcurrentHashMap&lt;String, BeanDefinition&gt; beanDefinitions = <span class=\"keyword\">new</span> <span class=\"title class_\">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">addBeanDefinitions</span><span class=\"params\">(List&lt;BeanDefinition&gt; beanDefinitionList)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (BeanDefinition beanDefinition : beanDefinitionList) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.beanDefinitions.putIfAbsent(beanDefinition.getId(), beanDefinition);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (BeanDefinition beanDefinition : beanDefinitionList) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (beanDefinition.isLazyInit() == <span class=\"literal\">false</span> &amp;&amp; beanDefinition.isSingleton()) &#123;</span><br><span class=\"line\">        createBean(beanDefinition);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> Object <span class=\"title function_\">getBean</span><span class=\"params\">(String beanId)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">BeanDefinition</span> <span class=\"variable\">beanDefinition</span> <span class=\"operator\">=</span> beanDefinitions.get(beanId);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (beanDefinition == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">NoSuchBeanDefinitionException</span>(<span class=\"string\">&quot;Bean is not defined: &quot;</span> + beanId);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> createBean(beanDefinition);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@VisibleForTesting</span></span><br><span class=\"line\">  <span class=\"keyword\">protected</span> Object <span class=\"title function_\">createBean</span><span class=\"params\">(BeanDefinition beanDefinition)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (beanDefinition.isSingleton() &amp;&amp; singletonObjects.contains(beanDefinition.getId())) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> singletonObjects.get(beanDefinition.getId());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">Object</span> <span class=\"variable\">bean</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      <span class=\"type\">Class</span> <span class=\"variable\">beanClass</span> <span class=\"operator\">=</span> Class.forName(beanDefinition.getClassName());</span><br><span class=\"line\">      List&lt;BeanDefinition.ConstructorArg&gt; args = beanDefinition.getConstructorArgs();</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (args.isEmpty()) &#123;</span><br><span class=\"line\">        bean = beanClass.newInstance();</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        Class[] argClasses = <span class=\"keyword\">new</span> <span class=\"title class_\">Class</span>[args.size()];</span><br><span class=\"line\">        Object[] argObjects = <span class=\"keyword\">new</span> <span class=\"title class_\">Object</span>[args.size()];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; args.size(); ++i) &#123;</span><br><span class=\"line\">          BeanDefinition.<span class=\"type\">ConstructorArg</span> <span class=\"variable\">arg</span> <span class=\"operator\">=</span> args.get(i);</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (!arg.getIsRef()) &#123;</span><br><span class=\"line\">            argClasses[i] = arg.getType();</span><br><span class=\"line\">            argObjects[i] = arg.getArg();</span><br><span class=\"line\">          &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"type\">BeanDefinition</span> <span class=\"variable\">refBeanDefinition</span> <span class=\"operator\">=</span> beanDefinitions.get(arg.getArg());</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (refBeanDefinition == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">              <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">NoSuchBeanDefinitionException</span>(<span class=\"string\">&quot;Bean is not defined: &quot;</span> + arg.getArg());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            argClasses[i] = Class.forName(refBeanDefinition.getClassName());</span><br><span class=\"line\">            argObjects[i] = createBean(refBeanDefinition);</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        bean = beanClass.getConstructor(argClasses).newInstance(argObjects);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (ClassNotFoundException | IllegalAccessException</span><br><span class=\"line\">            | InstantiationException | NoSuchMethodException | InvocationTargetException e) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">BeanCreationFailureException</span>(<span class=\"string\">&quot;&quot;</span>, e);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (bean != <span class=\"literal\">null</span> &amp;&amp; beanDefinition.isSingleton()) &#123;</span><br><span class=\"line\">      singletonObjects.putIfAbsent(beanDefinition.getId(), bean);</span><br><span class=\"line\">      <span class=\"keyword\">return</span> singletonObjects.get(beanDefinition.getId());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> bean;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>执行入口那里调用<code>addBeanDefinitions</code></li>\n<li>然后<code>addBeanDefinitions</code>再调用createBean利用反射创建对象，如果对象的 scope 属性是 singleton，那对象创建之后会缓存在 singletonObjects 这样一个 map 中</li>\n<li>最后最小原型设计那里再调用getBean从singletonObjects 获取对象。</li>\n</ol>\n<h1 id=\"建造者模式【常用】\"><a href=\"#建造者模式【常用】\" class=\"headerlink\" title=\"建造者模式【常用】\"></a>建造者模式【常用】</h1><blockquote>\n<p>只要是标注常用的，基本上用的都比较多，无论篇幅长短，都不要忽视。</p>\n</blockquote>\n<p>建造者模式的原理和代码实现非常简单，掌握起来并不难，难点在于应用场景。比如，你有没有考虑过这样几个问题：直接使用构造函数或者配合 set 方法就能创建对象，为什么还需要建造者模式来创建呢？建造者模式和工厂模式都可以创建对象，那它们两个的区别在哪里呢？</p>\n<h2 id=\"为什么需要建造者模式？\"><a href=\"#为什么需要建造者模式？\" class=\"headerlink\" title=\"为什么需要建造者模式？\"></a>为什么需要建造者模式？</h2><ol>\n<li>在平时的开发中，创建一个对象最常用的方式是，使用 new 关键字调用类的构造函数来完成。我的问题是，什么情况下这种方式就不适用了，就需要采用建造者模式来创建对象呢？你可以先思考一下，下面我通过一个例子来带你看一下。</li>\n<li>假设有这样一道设计面试题：我们需要定义一个资源池配置类 ResourcePoolConfig。这里的资源池，你可以简单理解为线程池、连接池、对象池等。在这个资源池配置类中，有以下几个成员变量，也就是可配置项。现在，请你编写代码实现这个 ResourcePoolConfig 类。</li>\n</ol>\n<img src=\"https://npm.elemecdn.com/youthlql@1.0.0/design_patterns/creational/03.02/0001.png\" />\n\n\n\n<p>只要你稍微有点开发经验，那实现这样一个类对你来说并不是件难事。最常见、最容易想到的实现思路如下代码所示。因为 maxTotal、maxIdle、minIdle 不是必填变量，所以在创建 ResourcePoolConfig 对象的时候，我们通过往构造函数中，给这几个参数传递 null 值，来表示使用默认值。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ResourcePoolConfig</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">DEFAULT_MAX_TOTAL</span> <span class=\"operator\">=</span> <span class=\"number\">8</span>;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">DEFAULT_MAX_IDLE</span> <span class=\"operator\">=</span> <span class=\"number\">8</span>;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">DEFAULT_MIN_IDLE</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"type\">int</span> <span class=\"variable\">maxTotal</span> <span class=\"operator\">=</span> DEFAULT_MAX_TOTAL;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"type\">int</span> <span class=\"variable\">maxIdle</span> <span class=\"operator\">=</span> DEFAULT_MAX_IDLE;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"type\">int</span> <span class=\"variable\">minIdle</span> <span class=\"operator\">=</span> DEFAULT_MIN_IDLE;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"title function_\">ResourcePoolConfig</span><span class=\"params\">(String name, Integer maxTotal, Integer maxIdle, Integer minIdle)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (StringUtils.isBlank(name)) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IllegalArgumentException</span>(<span class=\"string\">&quot;name should not be empty.&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.name = name;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (maxTotal != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (maxTotal &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IllegalArgumentException</span>(<span class=\"string\">&quot;maxTotal should be positive.&quot;</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.maxTotal = maxTotal;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (maxIdle != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (maxIdle &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IllegalArgumentException</span>(<span class=\"string\">&quot;maxIdle should not be negative.&quot;</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.maxIdle = maxIdle;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (minIdle != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (minIdle &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IllegalArgumentException</span>(<span class=\"string\">&quot;minIdle should not be negative.&quot;</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.minIdle = minIdle;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//...省略getter方法...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>现在，ResourcePoolConfig 只有 4 个可配置项，对应到构造函数中，也只有 4 个参数，参数的个数不多。但是，如果可配置项逐渐增多，变成了 8 个、10 个，甚至更多，那继续沿用现在的设计思路，构造函数的参数列表会变得很长，代码在可读性和易用性上都会变差。在使用构造函数的时候，我们就容易搞错各参数的顺序，传递进错误的参数值，导致非常隐蔽的 bug。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 参数太多，导致可读性差、参数可能传递错误</span></span><br><span class=\"line\"><span class=\"type\">ResourcePoolConfig</span> <span class=\"variable\">config</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ResourcePoolConfig</span>(<span class=\"string\">&quot;dbconnectionpool&quot;</span>, <span class=\"number\">16</span>, <span class=\"literal\">null</span>, <span class=\"number\">8</span>, <span class=\"literal\">null</span>, <span class=\"literal\">false</span> , <span class=\"literal\">true</span>, <span class=\"number\">10</span>, <span class=\"number\">20</span>，<span class=\"literal\">false</span>， <span class=\"literal\">true</span>);</span><br></pre></td></tr></table></figure>\n\n\n\n<p>解决这个问题的办法你应该也已经想到了，那就是用 set() 函数来给成员变量赋值，以替代冗长的构造函数。我们直接看代码，具体如下所示。其中，配置项 name 是必填的，所以我们把它放到构造函数中设置，强制创建类对象的时候就要填写。其他配置项 maxTotal、maxIdle、minIdle 都不是必填的，所以我们通过 set() 函数来设置，让使用者自主选择填写或者不填写。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ResourcePoolConfig</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">DEFAULT_MAX_TOTAL</span> <span class=\"operator\">=</span> <span class=\"number\">8</span>;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">DEFAULT_MAX_IDLE</span> <span class=\"operator\">=</span> <span class=\"number\">8</span>;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">DEFAULT_MIN_IDLE</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"type\">int</span> <span class=\"variable\">maxTotal</span> <span class=\"operator\">=</span> DEFAULT_MAX_TOTAL;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"type\">int</span> <span class=\"variable\">maxIdle</span> <span class=\"operator\">=</span> DEFAULT_MAX_IDLE;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"type\">int</span> <span class=\"variable\">minIdle</span> <span class=\"operator\">=</span> DEFAULT_MIN_IDLE;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"title function_\">ResourcePoolConfig</span><span class=\"params\">(String name)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (StringUtils.isBlank(name)) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IllegalArgumentException</span>(<span class=\"string\">&quot;name should not be empty.&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.name = name;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setMaxTotal</span><span class=\"params\">(<span class=\"type\">int</span> maxTotal)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (maxTotal &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IllegalArgumentException</span>(<span class=\"string\">&quot;maxTotal should be positive.&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.maxTotal = maxTotal;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setMaxIdle</span><span class=\"params\">(<span class=\"type\">int</span> maxIdle)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (maxIdle &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IllegalArgumentException</span>(<span class=\"string\">&quot;maxIdle should not be negative.&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.maxIdle = maxIdle;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setMinIdle</span><span class=\"params\">(<span class=\"type\">int</span> minIdle)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (minIdle &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IllegalArgumentException</span>(<span class=\"string\">&quot;minIdle should not be negative.&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.minIdle = minIdle;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//...省略getter方法...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>接下来，我们来看新的 ResourcePoolConfig 类该如何使用。我写了一个示例代码，如下所示。没有了冗长的函数调用和参数列表，代码在可读性和易用性上提高了很多。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ResourcePoolConfig使用举例</span></span><br><span class=\"line\"><span class=\"type\">ResourcePoolConfig</span> <span class=\"variable\">config</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ResourcePoolConfig</span>(<span class=\"string\">&quot;dbconnectionpool&quot;</span>);</span><br><span class=\"line\">config.setMaxTotal(<span class=\"number\">16</span>);</span><br><span class=\"line\">config.setMaxIdle(<span class=\"number\">8</span>);</span><br></pre></td></tr></table></figure>\n\n\n\n<p>至此，我们仍然没有用到建造者模式，通过构造函数设置必填项，通过 set() 方法设置可选配置项，就能实现我们的设计需求。如果我们把问题的难度再加大点，比如，还需要解决下面这三个问题，那现在的设计思路就不能满足了。</p>\n<ul>\n<li>我们刚刚讲到，name 是必填的，所以，我们把它放到构造函数中，强制创建对象的时候就设置。如果必填的配置项有很多，把这些必填配置项都放到构造函数中设置，那构造函数就又会出现参数列表很长的问题。如果我们把必填项也通过 set() 方法设置，那校验这些必填项是否已经填写的逻辑就无处安放了。</li>\n<li>除此之外，假设配置项之间有一定的依赖关系，比如，如果用户设置了 maxTotal、maxIdle、minIdle 其中一个，就必须显式地设置另外两个；或者配置项之间有一定的约束条件，比如，maxIdle 和 minIdle 要小于等于 maxTotal。如果我们继续使用现在的设计思路，那这些配置项之间的依赖关系或者约束条件的校验逻辑就无处安放了。</li>\n<li>如果我们希望 ResourcePoolConfig 类对象是不可变对象，也就是说，对象在创建好之后，就不能再修改内部的属性值。要实现这个功能，我们就不能在 ResourcePoolConfig 类中暴露 set() 方法。</li>\n</ul>\n<p>为了解决这些问题，建造者模式就派上用场了。我们可以把校验逻辑放置到 Builder 类中，先创建建造者，并且通过 set() 方法设置建造者的变量值，然后在使用 build() 方法真正创建对象之前，做集中的校验，校验通过之后才会创建对象。除此之外，我们把 ResourcePoolConfig 的构造函数改为 private 私有权限。这样我们就只能通过建造者来创建 ResourcePoolConfig 类对象。并且，ResourcePoolConfig 没有提供任何 set() 方法，这样我们创建出来的对象就是不可变对象了。我们用建造者模式重新实现了上面的需求，具体的代码如下所示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ResourcePoolConfig</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"type\">int</span> maxTotal;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"type\">int</span> maxIdle;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"type\">int</span> minIdle;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"title function_\">ResourcePoolConfig</span><span class=\"params\">(Builder builder)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.name = builder.name;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.maxTotal = builder.maxTotal;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.maxIdle = builder.maxIdle;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.minIdle = builder.minIdle;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//...省略getter方法...</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//我们将Builder类设计成了ResourcePoolConfig的内部类。</span></span><br><span class=\"line\">  <span class=\"comment\">//我们也可以将Builder类设计成独立的非内部类ResourcePoolConfigBuilder。</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Builder</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">DEFAULT_MAX_TOTAL</span> <span class=\"operator\">=</span> <span class=\"number\">8</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">DEFAULT_MAX_IDLE</span> <span class=\"operator\">=</span> <span class=\"number\">8</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">DEFAULT_MIN_IDLE</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">int</span> <span class=\"variable\">maxTotal</span> <span class=\"operator\">=</span> DEFAULT_MAX_TOTAL;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">int</span> <span class=\"variable\">maxIdle</span> <span class=\"operator\">=</span> DEFAULT_MAX_IDLE;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">int</span> <span class=\"variable\">minIdle</span> <span class=\"operator\">=</span> DEFAULT_MIN_IDLE;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> ResourcePoolConfig <span class=\"title function_\">build</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 校验逻辑放到这里来做，包括必填项校验、依赖关系校验、约束条件校验等</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (StringUtils.isBlank(name)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IllegalArgumentException</span>(<span class=\"string\">&quot;...&quot;</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (maxIdle &gt; maxTotal) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IllegalArgumentException</span>(<span class=\"string\">&quot;...&quot;</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (minIdle &gt; maxTotal || minIdle &gt; maxIdle) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IllegalArgumentException</span>(<span class=\"string\">&quot;...&quot;</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ResourcePoolConfig</span>(<span class=\"built_in\">this</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Builder <span class=\"title function_\">setName</span><span class=\"params\">(String name)</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (StringUtils.isBlank(name)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IllegalArgumentException</span>(<span class=\"string\">&quot;...&quot;</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.name = name;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Builder <span class=\"title function_\">setMaxTotal</span><span class=\"params\">(<span class=\"type\">int</span> maxTotal)</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (maxTotal &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IllegalArgumentException</span>(<span class=\"string\">&quot;...&quot;</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.maxTotal = maxTotal;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Builder <span class=\"title function_\">setMaxIdle</span><span class=\"params\">(<span class=\"type\">int</span> maxIdle)</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (maxIdle &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IllegalArgumentException</span>(<span class=\"string\">&quot;...&quot;</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.maxIdle = maxIdle;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Builder <span class=\"title function_\">setMinIdle</span><span class=\"params\">(<span class=\"type\">int</span> minIdle)</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (minIdle &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IllegalArgumentException</span>(<span class=\"string\">&quot;...&quot;</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.minIdle = minIdle;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 这段代码会抛出IllegalArgumentException，因为minIdle&gt;maxIdle</span></span><br><span class=\"line\"><span class=\"type\">ResourcePoolConfig</span> <span class=\"variable\">config</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ResourcePoolConfig</span>.Builder()</span><br><span class=\"line\">        .setName(<span class=\"string\">&quot;dbconnectionpool&quot;</span>)</span><br><span class=\"line\">        .setMaxTotal(<span class=\"number\">16</span>)</span><br><span class=\"line\">        .setMaxIdle(<span class=\"number\">10</span>)</span><br><span class=\"line\">        .setMinIdle(<span class=\"number\">12</span>)</span><br><span class=\"line\">        .build();</span><br></pre></td></tr></table></figure>\n\n\n\n<p>实际上，使用建造者模式创建对象，还能避免对象存在无效状态。我再举个例子解释一下。比如我们定义了一个长方形类，如果不使用建造者模式，采用先创建后 set 的方式，那就会导致在第一个 set 之后，对象处于无效状态。具体代码如下所示</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Rectangle</span> <span class=\"variable\">r</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Rectange</span>(); <span class=\"comment\">// r is invalid</span></span><br><span class=\"line\">r.setWidth(<span class=\"number\">2</span>); <span class=\"comment\">// r is invalid</span></span><br><span class=\"line\">r.setHeight(<span class=\"number\">3</span>); <span class=\"comment\">// r is valid</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>这里是说，长方形必须同时具备宽、高两个属性才是一个有效的长方形。只有其中一个属性，这个长方形对象就没有意义，是无效的。</p>\n</blockquote>\n<ol>\n<li>为了避免这种无效状态的存在，我们就需要使用构造函数一次性初始化好所有的成员变量。如果构造函数参数过多，我们就需要考虑使用建造者模式，先设置建造者的变量，然后再一次性地创建对象，让对象一直处于有效状态。(建造者主要解决参数过多、参数检验、控制对象创建后不可变的问题)</li>\n<li>实际上，如果我们并不是很关心对象是否有短暂的无效状态，也不是太在意对象是否是可变的。比如，对象只是用来映射数据库读出来的数据，那我们直接暴露 set() 方法来设置类的成员变量值是完全没问题的。而且，使用建造者模式来构建对象，代码实际上是有点重复的，ResourcePoolConfig 类中的成员变量，要在 Builder 类中重新再定义一遍。</li>\n</ol>\n<h2 id=\"与工厂模式有何区别？\"><a href=\"#与工厂模式有何区别？\" class=\"headerlink\" title=\"与工厂模式有何区别？\"></a>与工厂模式有何区别？</h2><ol>\n<li>从上面的讲解中，我们可以看出，建造者模式是让建造者类来负责对象的创建工作。上面讲到的工厂模式，是由工厂类来负责对象创建的工作。那它们之间有什么区别呢？</li>\n<li>实际上，工厂模式是用来创建不同但是相关类型的对象（继承同一父类或者接口的一组子类），由给定的参数来决定创建哪种类型的对象。建造者模式是用来创建一种类型的复杂对象，通过设置不同的可选参数，“定制化”地创建不同的对象。</li>\n</ol>\n<p>网上有一个经典的例子很好地解释了两者的区别:</p>\n<blockquote>\n<p>顾客走进一家餐馆点餐，我们利用工厂模式，根据用户不同的选择，来制作不同的食物，比如披萨、汉堡、沙拉。对于披萨来说，用户又有各种配料可以定制，比如奶酪、西红柿、起司，我们通过建造者模式根据用户选择的不同配料来制作披萨。</p>\n</blockquote>\n<p>实际上，我们也不要太学院派，非得把工厂模式、建造者模式分得那么清楚，我们需要知道的是，每个模式为什么这么设计，能解决什么问题。只有了解了这些最本质的东西，我们才能不生搬硬套，才能灵活应用，甚至可以混用各种模式创造出新的模式，来解决特定场景的问题。</p>\n<h1 id=\"原型模式【不常用】\"><a href=\"#原型模式【不常用】\" class=\"headerlink\" title=\"原型模式【不常用】\"></a>原型模式【不常用】</h1><p>今天的讲解跟具体某一语言的语法机制无关，而是通过一个 clone 散列表的例子带你搞清楚：原型模式的应用场景，以及它的两种实现方式：深拷贝和浅拷贝。虽然原型模式的原理和代码实现非常简单，但今天举的例子还是稍微有点复杂的</p>\n<h2 id=\"原型模式的原理与应用\"><a href=\"#原型模式的原理与应用\" class=\"headerlink\" title=\"原型模式的原理与应用\"></a>原型模式的原理与应用</h2><p>如果对象的创建成本比较大，而同一个类的不同对象之间差别不大（大部分字段都相同），在这种情况下，我们可以利用对已有对象（原型）进行复制（或者叫拷贝）的方式来创建新对象，以达到节省创建时间的目的。这种基于原型来创建对象的方式就叫作原型设计模式（Prototype Design Pattern），简称原型模式。</p>\n<blockquote>\n<p>那何为“对象的创建成本比较大”？</p>\n</blockquote>\n<ol>\n<li>实际上，创建对象包含的申请内存、给成员变量赋值这一过程，本身并不会花费太多时间，或者说对于大部分业务系统来说，这点时间完全是可以忽略的。应用一个复杂的模式，只得到一点点的性能提升，这就是所谓的过度设计，得不偿失。</li>\n<li>但是，如果对象中的数据需要经过复杂的计算才能得到（比如排序、计算哈希值），或者需要从 RPC、网络、数据库、文件系统等非常慢速的 IO 中读取，这种情况下，我们就可以利用原型模式，从其他已有对象中直接拷贝得到，而不用每次在创建新对象的时候，都重复执行这些耗时的操作。</li>\n</ol>\n<blockquote>\n<p>这么说还是比较理论，接下来，我们通过一个例子来解释一下刚刚这段话。</p>\n</blockquote>\n<ol>\n<li>假设数据库中存储了大约 10 万条“搜索关键词”信息，每条信息包含关键词、关键词被搜索的次数、信息最近被更新的时间等。系统 A 在启动的时候会加载这份数据到内存中，用于处理某些其他的业务需求。为了方便快速地查找某个关键词对应的信息，我们给关键词建立一个散列表索引。</li>\n<li>如果你熟悉的是 Java 语言，可以直接使用语言中提供的 HashMap 容器来实现。其中，HashMap 的 key 为搜索关键词，value 为关键词详细信息（比如搜索次数）。我们只需要将数据从数据库中读取出来，放入 HashMap 就可以了。</li>\n<li>不过，我们还有另外一个系统 B，专门用来分析搜索日志，定期（比如间隔 10 分钟）批量地更新数据库中的数据，并且标记为新的数据版本。比如，在下面的示例图中，我们对 v2 版本的数据进行更新，得到 v3 版本的数据。这里我们假设只有更新和新添关键词，没有删除关键词的行为。</li>\n</ol>\n<img src=\"https://npm.elemecdn.com/youthlql@1.0.0/design_patterns/creational/03.02/0002.png\"/>\n\n\n\n<ol>\n<li>为了保证系统 A 中数据的实时性（不一定非常实时，但数据也不能太旧），系统 A 需要定期根据数据库中的数据，更新内存中的索引和数据。</li>\n<li>我们该如何实现这个需求呢？实际上，也不难。我们只需要在系统 A 中，记录当前数据的版本 Va 对应的更新时间 Ta，从数据库中捞出更新时间大于 Ta 的所有搜索关键词，也就是找出 Va 版本与最新版本数据的“差集”，然后针对差集中的每个关键词进行处理。如果它已经在散列表中存在了，我们就更新相应的搜索次数、更新时间等信息；如果它在散列表中不存在，我们就将它插入到散列表中。</li>\n<li>按照这个设计思路，我给出的示例代码如下所示：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Demo</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> ConcurrentHashMap&lt;String, SearchWord&gt; currentKeywords = <span class=\"keyword\">new</span> <span class=\"title class_\">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"type\">long</span> <span class=\"variable\">lastUpdateTime</span> <span class=\"operator\">=</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">refresh</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 从数据库中取出更新时间&gt;lastUpdateTime的数据，放入到currentKeywords中</span></span><br><span class=\"line\">    List&lt;SearchWord&gt; toBeUpdatedSearchWords = getSearchWords(lastUpdateTime);</span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"variable\">maxNewUpdatedTime</span> <span class=\"operator\">=</span> lastUpdateTime;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (SearchWord searchWord : toBeUpdatedSearchWords) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (searchWord.getLastUpdateTime() &gt; maxNewUpdatedTime) &#123;</span><br><span class=\"line\">        maxNewUpdatedTime = searchWord.getLastUpdateTime();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (currentKeywords.containsKey(searchWord.getKeyword())) &#123;</span><br><span class=\"line\">        currentKeywords.replace(searchWord.getKeyword(), searchWord);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        currentKeywords.put(searchWord.getKeyword(), searchWord);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    lastUpdateTime = maxNewUpdatedTime;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> List&lt;SearchWord&gt; <span class=\"title function_\">getSearchWords</span><span class=\"params\">(<span class=\"type\">long</span> lastUpdateTime)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// <span class=\"doctag\">TODO:</span> 从数据库中取出更新时间&gt;lastUpdateTime的数据</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>不过，现在，我们有一个特殊的要求：任何时刻，系统 A 中的所有数据都必须是同一个版本的，要么都是版本 a，要么都是版本 b，不能有的是版本 a，有的是版本 b。那刚刚的更新方式就不能满足这个要求了（因为数据很多，一个一个的for循环肯定会出现不同数据版本的问题）。除此之外，我们还要求：在更新内存数据的时候，系统 A 不能处于不可用状态，也就是不能停机更新数据。</p>\n<ol>\n<li><p>那我们该如何实现现在这个需求呢？</p>\n</li>\n<li><p>实际上，也不难。我们把正在使用的数据的版本定义为“服务版本”，当我们要更新内存中的数据的时候，我们并不是直接在服务版本（假设是版本 a 数据）上更新，而是重新创建另一个版本数据（假设是版本 b 数据），等新的版本数据建好之后，再一次性地将服务版本从版本 a 切换到版本 b。这样既保证了数据一直可用，又避免了中间状态的存在。</p>\n</li>\n<li><p>按照这个设计思路，我给出的示例代码如下所示：</p>\n</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Demo</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> HashMap&lt;String, SearchWord&gt; currentKeywords=<span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">refresh</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    HashMap&lt;String, SearchWord&gt; newKeywords = <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedHashMap</span>&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 从数据库中取出所有的数据，放入到newKeywords中</span></span><br><span class=\"line\">    List&lt;SearchWord&gt; toBeUpdatedSearchWords = getSearchWords();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (SearchWord searchWord : toBeUpdatedSearchWords) &#123;</span><br><span class=\"line\">      newKeywords.put(searchWord.getKeyword(), searchWord);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    currentKeywords = newKeywords;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> List&lt;SearchWord&gt; <span class=\"title function_\">getSearchWords</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// <span class=\"doctag\">TODO:</span> 从数据库中取出所有的数据</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<ol>\n<li>不过，在上面的代码实现中，newKeywords 构建的成本比较高。我们需要将这 10 万条数据从数据库中读出，然后计算哈希值，构建 newKeywords。这个过程显然是比较耗时。为了提高效率，原型模式就派上用场了。</li>\n<li>我们拷贝 currentKeywords 数据到 newKeywords 中，然后从数据库中只捞出新增或者有更新的关键词，更新到 newKeywords 中。而相对于 10 万条数据来说，每次新增或者更新的关键词个数是比较少的，所以，这种策略大大提高了数据更新的效率。</li>\n<li>按照这个设计思路，我给出的示例代码如下所示：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Demo</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> HashMap&lt;String, SearchWord&gt; currentKeywords=<span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;();</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"type\">long</span> <span class=\"variable\">lastUpdateTime</span> <span class=\"operator\">=</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">refresh</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 原型模式就这么简单，拷贝已有对象的数据，更新少量差值</span></span><br><span class=\"line\">    HashMap&lt;String, SearchWord&gt; newKeywords = (HashMap&lt;String, SearchWord&gt;) currentKeywords.clone();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 从数据库中取出更新时间&gt;lastUpdateTime的数据，放入到newKeywords中</span></span><br><span class=\"line\">    List&lt;SearchWord&gt; toBeUpdatedSearchWords = getSearchWords(lastUpdateTime);</span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"variable\">maxNewUpdatedTime</span> <span class=\"operator\">=</span> lastUpdateTime;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (SearchWord searchWord : toBeUpdatedSearchWords) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (searchWord.getLastUpdateTime() &gt; maxNewUpdatedTime) &#123;</span><br><span class=\"line\">        maxNewUpdatedTime = searchWord.getLastUpdateTime();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (newKeywords.containsKey(searchWord.getKeyword())) &#123;</span><br><span class=\"line\">        <span class=\"type\">SearchWord</span> <span class=\"variable\">oldSearchWord</span> <span class=\"operator\">=</span> newKeywords.get(searchWord.getKeyword());</span><br><span class=\"line\">        oldSearchWord.setCount(searchWord.getCount());</span><br><span class=\"line\">        oldSearchWord.setLastUpdateTime(searchWord.getLastUpdateTime());</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        newKeywords.put(searchWord.getKeyword(), searchWord);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    lastUpdateTime = maxNewUpdatedTime;</span><br><span class=\"line\">    currentKeywords = newKeywords;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> List&lt;SearchWord&gt; <span class=\"title function_\">getSearchWords</span><span class=\"params\">(<span class=\"type\">long</span> lastUpdateTime)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// <span class=\"doctag\">TODO:</span> 从数据库中取出更新时间&gt;lastUpdateTime的数据</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>这里我们利用了 Java 中的 clone() 语法来复制一个对象。如果你熟悉的语言没有这个语法，那把数据从 currentKeywords 中一个个取出来，然后再重新计算哈希值，放入到 newKeywords 中也是可以接受的。毕竟，最耗时的还是从数据库中取数据的操作。相对于数据库的 IO 操作来说，内存操作和 CPU 计算的耗时都是可以忽略的。</li>\n<li>不过，不知道你有没有发现，实际上，刚刚的代码实现是有问题的。要弄明白到底有什么问题，我们需要先了解另外两个概念：深拷贝（Deep Copy）和浅拷贝（Shallow Copy）。</li>\n</ol>\n<h2 id=\"原型模式的实现方式：深拷贝和浅拷贝\"><a href=\"#原型模式的实现方式：深拷贝和浅拷贝\" class=\"headerlink\" title=\"原型模式的实现方式：深拷贝和浅拷贝\"></a>原型模式的实现方式：深拷贝和浅拷贝</h2><blockquote>\n<p>1、关于深拷贝浅拷贝，我觉得这篇文章讲的不错：<a href=\"https://blog.csdn.net/baiye_xing/article/details/71788741\">https://blog.csdn.net/baiye_xing/article/details/71788741</a></p>\n</blockquote>\n<blockquote>\n<p>我自己的总结：</p>\n<p><strong>浅拷贝</strong>：对一个对象进行拷贝时，这个对象对应的类里的成员变量。</p>\n<ul>\n<li>对于数据类型是基本数据类型的成员变量，浅拷贝会直接进行值拷贝，也就是将该属性值复制一份给新的对象。因为是两份不同的数据，所以对其中一个对象的该成员变量值进行修改，不会影响另一个对象拷贝得到的数据</li>\n<li>对于数据类型是引用数据类型的成员变量(也就是子对象，或者数组啥的)，也就是只是将该成员变量的引用值（引用拷贝【并发引用传递，Java本质还是值传递】）复制一份给新的对象。因为实际上两个对象的该成员变量都指向同一个实例。在这种情况下，在一个对象中修改该成员变量会影响到另一个对象的该成员变量值。</li>\n</ul>\n<ol>\n<li><strong>深拷贝</strong>：对基本数据类型进行值传递，对引用数据类型，创建一个新的对象，并复制其内容，此为深拷贝。</li>\n<li>也就是说浅拷贝对于子对象只是拷贝了引用值，并没有真正的拷贝整个对象。</li>\n</ol>\n<p><strong>深拷贝实现思路：</strong></p>\n<ol>\n<li><p>对于每个子对象都实现Cloneable 接口，并重写clone方法。最后在最顶层的类的重写的 clone 方法中调用所有子对象的 clone 方法即可实现深拷贝。【简单的说就是：每一层的每个子对象都进行浅拷贝&#x3D;深拷贝】</p>\n</li>\n<li><p>利用序列化。【先对对象进行序列化，紧接着马上反序列化出 】</p>\n</li>\n</ol>\n</blockquote>\n<p>我们来看，在内存中，用散列表组织的搜索关键词信息是如何存储的。我画了一张示意图，大致结构如下所示。从图中我们可以发现，散列表索引中，每个结点存储的 key 是搜索关键词，value 是 SearchWord 对象的内存地址。SearchWord 对象本身存储在散列表之外的内存空间中。</p>\n<img src=\"https://npm.elemecdn.com/youthlql@1.0.0/design_patterns/creational/03.02/0003.png\"  />\n\n<p>浅拷贝和深拷贝的区别在于，浅拷贝只会复制图中的索引（散列表），不会复制数据（SearchWord 对象）本身。相反，深拷贝不仅仅会复制索引，还会复制数据本身。浅拷贝得到的对象（newKeywords）跟原始对象（currentKeywords）共享数据（SearchWord 对象），而深拷贝得到的是一份完完全全独立的对象。具体的对比如下图所示：</p>\n<img src=\"https://npm.elemecdn.com/youthlql@1.0.0/design_patterns/creational/03.02/0004.png\"/>\n\n\n\n<img src=\"https://npm.elemecdn.com/youthlql@1.0.0/design_patterns/creational/03.02/0005.png\" />\n\n\n\n<ol>\n<li><p>在 Java 语言中，Object 类的 clone() 方法执行的就是我们刚刚说的浅拷贝。它只会拷贝对象中的基本数据类型的数据（比如，int、long），以及引用对象（SearchWord）的内存地址，不会递归地拷贝引用对象本身。</p>\n</li>\n<li><p>在上面的代码中，我们通过调用 HashMap 上的 clone() 浅拷贝方法来实现原型模式。当我们通过 newKeywords 更新 SearchWord 对象的时候（比如，更新“设计模式”这个搜索关键词的访问次数），newKeywords 和 currentKeywords 因为指向相同的一组 SearchWord 对象，就会导致 currentKeywords 中指向的 SearchWord，有的是老版本的，有的是新版本的，就没法满足我们之前的需求：currentKeywords 中的数据在任何时刻都是同一个版本的，不存在介于老版本与新版本之间的中间状态。</p>\n</li>\n<li><p>现在，我们又该如何来解决这个问题呢？</p>\n</li>\n<li><p>我们可以将浅拷贝替换为深拷贝。newKeywords 不仅仅复制 currentKeywords 的索引，还把 SearchWord 对象也复制一份出来，这样 newKeywords 和 currentKeywords 就指向不同的 SearchWord 对象，也就不存在更新 newKeywords 的数据会导致 currentKeywords 的数据也被更新的问题了。</p>\n</li>\n<li><p>那如何实现深拷贝呢？总结一下的话，有下面两种方法。</p>\n</li>\n</ol>\n<p>第一种方法：递归拷贝对象、对象的引用对象以及引用对象的引用对象……直到要拷贝的对象只包含基本数据类型数据，没有引用对象为止。根据这个思路对之前的代码进行重构。重构之后的代码如下所示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Demo</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> HashMap&lt;String, SearchWord&gt; currentKeywords=<span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;();</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"type\">long</span> <span class=\"variable\">lastUpdateTime</span> <span class=\"operator\">=</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">refresh</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Deep copy</span></span><br><span class=\"line\">    HashMap&lt;String, SearchWord&gt; newKeywords = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (HashMap.Entry&lt;String, SearchWord&gt; e : currentKeywords.entrySet()) &#123;</span><br><span class=\"line\">      <span class=\"type\">SearchWord</span> <span class=\"variable\">searchWord</span> <span class=\"operator\">=</span> e.getValue();</span><br><span class=\"line\">      <span class=\"type\">SearchWord</span> <span class=\"variable\">newSearchWord</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">SearchWord</span>(</span><br><span class=\"line\">              searchWord.getKeyword(), searchWord.getCount(), searchWord.getLastUpdateTime());</span><br><span class=\"line\">      newKeywords.put(e.getKey(), newSearchWord);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 从数据库中取出更新时间&gt;lastUpdateTime的数据，放入到newKeywords中</span></span><br><span class=\"line\">    List&lt;SearchWord&gt; toBeUpdatedSearchWords = getSearchWords(lastUpdateTime);</span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"variable\">maxNewUpdatedTime</span> <span class=\"operator\">=</span> lastUpdateTime;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (SearchWord searchWord : toBeUpdatedSearchWords) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (searchWord.getLastUpdateTime() &gt; maxNewUpdatedTime) &#123;</span><br><span class=\"line\">        maxNewUpdatedTime = searchWord.getLastUpdateTime();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (newKeywords.containsKey(searchWord.getKeyword())) &#123;</span><br><span class=\"line\">        <span class=\"type\">SearchWord</span> <span class=\"variable\">oldSearchWord</span> <span class=\"operator\">=</span> newKeywords.get(searchWord.getKeyword());</span><br><span class=\"line\">        oldSearchWord.setCount(searchWord.getCount());</span><br><span class=\"line\">        oldSearchWord.setLastUpdateTime(searchWord.getLastUpdateTime());</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        newKeywords.put(searchWord.getKeyword(), searchWord);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    lastUpdateTime = maxNewUpdatedTime;</span><br><span class=\"line\">    currentKeywords = newKeywords;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> List&lt;SearchWord&gt; <span class=\"title function_\">getSearchWords</span><span class=\"params\">(<span class=\"type\">long</span> lastUpdateTime)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// <span class=\"doctag\">TODO:</span> 从数据库中取出更新时间&gt;lastUpdateTime的数据</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>第二种方法：先将对象序列化，然后再反序列化成新的对象。具体的示例代码如下所示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> Object <span class=\"title function_\">deepCopy</span><span class=\"params\">(Object object)</span> &#123;</span><br><span class=\"line\">  <span class=\"type\">ByteArrayOutputStream</span> <span class=\"variable\">bo</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ByteArrayOutputStream</span>();</span><br><span class=\"line\">  <span class=\"type\">ObjectOutputStream</span> <span class=\"variable\">oo</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ObjectOutputStream</span>(bo);</span><br><span class=\"line\">  oo.writeObject(object);</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"type\">ByteArrayInputStream</span> <span class=\"variable\">bi</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ByteArrayInputStream</span>(bo.toByteArray());</span><br><span class=\"line\">  <span class=\"type\">ObjectInputStream</span> <span class=\"variable\">oi</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ObjectInputStream</span>(bi);</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">return</span> oi.readObject();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>刚刚的两种实现方法，不管采用哪种，深拷贝都要比浅拷贝耗时、耗内存空间。针对我们这个应用场景，有没有更快、更省内存的实现方式呢？</li>\n<li>我们可以先采用浅拷贝的方式创建 newKeywords。对于需要更新的 SearchWord 对象，我们再使用深度拷贝的方式创建一份新的对象，替换 newKeywords 中的老对象。毕竟需要更新的数据是很少的。这种方式即利用了浅拷贝节省时间、空间的优点，又能保证 currentKeywords 中的中数据都是老版本的数据。具体的代码实现如下所示。这也是标题中讲到的，在我们这个应用场景下，最快速 clone 散列表的方式。</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Demo</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> HashMap&lt;String, SearchWord&gt; currentKeywords=<span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;();</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"type\">long</span> <span class=\"variable\">lastUpdateTime</span> <span class=\"operator\">=</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">refresh</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Shallow copy</span></span><br><span class=\"line\">    HashMap&lt;String, SearchWord&gt; newKeywords = (HashMap&lt;String, SearchWord&gt;) currentKeywords.clone();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 从数据库中取出更新时间&gt;lastUpdateTime的数据，放入到newKeywords中</span></span><br><span class=\"line\">    List&lt;SearchWord&gt; toBeUpdatedSearchWords = getSearchWords(lastUpdateTime);</span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"variable\">maxNewUpdatedTime</span> <span class=\"operator\">=</span> lastUpdateTime;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (SearchWord searchWord : toBeUpdatedSearchWords) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (searchWord.getLastUpdateTime() &gt; maxNewUpdatedTime) &#123;</span><br><span class=\"line\">        maxNewUpdatedTime = searchWord.getLastUpdateTime();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (newKeywords.containsKey(searchWord.getKeyword())) &#123;</span><br><span class=\"line\">        newKeywords.remove(searchWord.getKeyword());</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      newKeywords.put(searchWord.getKeyword(), searchWord);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    lastUpdateTime = maxNewUpdatedTime;</span><br><span class=\"line\">    currentKeywords = newKeywords;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> List&lt;SearchWord&gt; <span class=\"title function_\">getSearchWords</span><span class=\"params\">(<span class=\"type\">long</span> lastUpdateTime)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// <span class=\"doctag\">TODO:</span> 从数据库中取出更新时间&gt;lastUpdateTime的数据</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"},{"title":"设计模式-03.01-创建型-单例","keywords":"设计模式，单例","description":"详解了单例设计模式。","cover":"https://npm.elemecdn.com/lql_static@latest/logo/design_patterns.jpg","abbrlink":"b5a1ed4a","date":"2024-05-11T13:51:58.000Z","_content":"\n# 声明\n\n> 1. 此系列文章非本人原创，是学习笔记。\n> 2. 设计模式系列以后会持续更新，包括已经发布的设计模式文章，因为后续还要再多看一下书，教程和开源项目等，继续润色文章。\n\n\n# 前言\n\n23 种经典的设计模式。它们又可以分为三大类：创建型、结构型、行为型。对于这 23 种设计模式的学习，我们要有侧重点，因为有些模式是比较常用的，有些模式是很少被用到的。对于常用的设计模式，我们要花多点时间理解掌握。对于不常用的设计模式，我们只需要稍微了解即可。按照类型和是否常用，对这些设计模式，进行了简单的分类，具体如下所示。\n\n### 创建型\n\n常用的有：单例模式、工厂模式（工厂方法和抽象工厂）、建造者模式。\n\n不常用的有：原型模式。\n\n\n\n### 结构型\n\n常用的有：代理模式、桥接模式、装饰者模式、适配器模式。\n\n不常用的有：门面模式、组合模式、享元模式。 \n\n\n\n### 行为型\n\n常用的有：观察者模式、模板模式、策略模式、职责链模式、迭代器模式、状态模式。\n\n不常用的有：访问者模式、备忘录模式、命令模式、解释器模式、中介模式。\n\n\n\n\n\n# 单例模式【常用】\n\n网上有很多讲解单例模式的文章，但大部分都侧重讲解，如何来实现一个线程安全的单例。今天也会讲到各种单例的实现方法，但是，重点还是希望带你搞清楚下面这样几个问题。\n\n- 为什么要使用单例？\n- 单例存在哪些问题？\n- 单例与静态类的区别？\n- 有何替代的解决方案？\n\n\n\n## 为什么要使用单例？\n\n单例设计模式（Singleton Design Pattern）理解起来非常简单。一个类只允许创建一个对象（或者实例），那这个类就是一个单例类，这种设计模式就叫作单例设计模式，简称单例模式。\n\n对于单例的概念，我觉得没必要解释太多，你一看就能明白。我们重点看一下，为什么我们需要单例这种设计模式？它能解决哪些问题？接下来我通过两个实战案例来讲解。\n\n\n\n### 实战案例一：处理资源访问冲突\n\n我们先来看第一个例子。在这个例子中，我们自定义实现了一个往文件中打印日志的 Logger 类。具体的代码实现如下所示：\n\n```java\npublic class Logger {\n  private FileWriter writer;\n  \n  public Logger() {\n    File file = new File(\"/Users/wangzheng/log.txt\");\n    writer = new FileWriter(file, true); //true表示追加写入\n  }\n  \n  public void log(String message) {\n    writer.write(message);\n  }\n}\n\n// Logger类的应用示例：\npublic class UserController {\n  private Logger logger = new Logger();\n  \n  public void login(String username, String password) {\n    // ...省略业务逻辑代码...\n    logger.log(username + \" logined!\");\n  }\n}\n\npublic class OrderController {\n  private Logger logger = new Logger();\n  \n  public void create(OrderVo order) {\n    // ...省略业务逻辑代码...\n    logger.log(\"Created an order: \" + order.toString());\n  }\n}\n```\n\n在上面的代码中，我们注意到，所有的日志都写入到同一个文件 /Users/wangzheng/log.txt 中。在 UserController 和 OrderController 中，我们分别创建两个 Logger 对象。在 Web 容器的 Servlet 多线程环境下，如果两个 Servlet 线程同时分别执行 login() 和 create() 两个函数，并且同时写日志到 log.txt 文件中，那就有可能存在日志信息互相覆盖的情况。【这属于并发的知识点，看不懂的可以看笔者的并发系列】\n\n\n\n那如何来解决这个问题呢？我们最先想到的就是通过加锁的方式：给 log() 函数加互斥锁，同一时刻只允许一个线程调用执行 log() 函数。\n\n```java\npublic class Logger {\n  private FileWriter writer;\n\n  public Logger() {\n    File file = new File(\"/Users/wangzheng/log.txt\");\n    writer = new FileWriter(file, true); //true表示追加写入\n  }\n  \n  public void log(String message) {\n    synchronized(this) {\n      writer.write(mesasge);\n    }\n  }\n}\n```\n\n`synchronized(this)`这种对象级别的锁，锁不住，因为不同的对象之间并不共享同一把锁。所以我们换成类级别的锁。\n\n```java\npublic class Logger {\n  private FileWriter writer;\n\n  public Logger() {\n    File file = new File(\"/Users/wangzheng/log.txt\");\n    writer = new FileWriter(file, true); //true表示追加写入\n  }\n  \n  public void log(String message) {\n    synchronized(Logger.class) { // 类级别的锁\n      writer.write(mesasge);\n    }\n  }\n}\n```\n\n除了使用类级别锁之外，实际上，解决资源竞争问题的办法还有很多，分布式锁是最常听到的一种解决方案。不过，实现一个安全可靠、无 bug、高性能的分布式锁，并不是件容易的事情。除此之外，并发队列（比如 Java 中的 BlockingQueue）也可以解决这个问题：多个线程同时往并发队列里写日志，一个单独的线程负责将并发队列中的数据，写入到日志文件。这种方式实现起来也稍微有点复杂。\n\n\n\n相对于这两种解决方案，单例模式的解决思路就简单一些了。单例模式相对于之前类级别锁的好处是，不用创建那么多 Logger 对象，一方面节省内存空间，另一方面节省系统文件句柄（对于操作系统来说，文件句柄也是一种资源，不能随便浪费）。\n\n我们将 Logger 设计成一个单例类，程序中只允许创建一个 Logger 对象，所有的线程共享使用的这一个 Logger 对象，共享一个 FileWriter 对象，而 FileWriter 本身是对象级别线程安全的，也就避免了多线程情况下写日志会互相覆盖的问题。按照这个设计思路，我们实现了 Logger 单例类。具体代码如下所示：\n\n```java\npublic class Logger {\n  private FileWriter writer;\n  private static final Logger instance = new Logger();\n\n  private Logger() {\n    File file = new File(\"/Users/wangzheng/log.txt\");\n    writer = new FileWriter(file, true); //true表示追加写入\n  }\n  \n  public static Logger getInstance() {\n    return instance;\n  }\n  \n  public void log(String message) {\n    writer.write(mesasge);\n  }\n}\n\n// Logger类的应用示例：\npublic class UserController {\n  public void login(String username, String password) {\n    // ...省略业务逻辑代码...\n    Logger.getInstance().log(username + \" logined!\");\n  }\n}\n\npublic class OrderController {  \n  public void create(OrderVo order) {\n    // ...省略业务逻辑代码...\n    Logger.getInstance().log(\"Created a order: \" + order.toString());\n  }\n}\n```\n\n\n\n### 实战案例二：表示全局唯一类\n\n从业务概念上，如果有些数据在系统中只应保存一份，那就比较适合设计为单例类。比如，配置信息类。在系统中，我们只有一个配置文件，当配置文件被加载到内存之后，以对象的形式存在，也理所应当只有一份。\n\n再比如，唯一递增 ID 号码生成器。如果程序中有两个对象，那就会存在生成重复 ID 的情况，所以，我们应该将 ID 生成器类设计为单例。\n\n```java\npublic class IdGenerator {\n  // AtomicLong是一个Java并发库中提供的一个原子变量类型,\n  // 它将一些线程不安全需要加锁的复合操作封装为了线程安全的原子操作，\n  // 比如下面会用到的incrementAndGet().\n  private AtomicLong id = new AtomicLong(0);\n  private static final IdGenerator instance = new IdGenerator();\n  private IdGenerator() {}\n  public static IdGenerator getInstance() {\n    return instance;\n  }\n  public long getId() { \n    return id.incrementAndGet();\n  }\n}\n\n// IdGenerator使用举例\nlong id = IdGenerator.getInstance().getId();\n```\n\n\n\n## 如何实现一个单例？\n\n尽管介绍如何实现一个单例模式的文章已经有很多了，但为了保证内容的完整性，我这里还是简单介绍一下几种经典实现方式。概括起来，要实现一个单例，我们需要关注的点无外乎下面几个：\n\n- 构造函数需要是 private 访问权限的，这样才能避免外部通过 new 创建实例；\n\n- 考虑对象创建时的线程安全问题；\n\n- 考虑是否支持延迟加载；\n\n- 考虑 getInstance() 性能是否高（是否加锁）。\n\n\n\n### 饿汉式(静态变量)\n\n饿汉式的实现方式比较简单。在类加载的时候，instance 静态实例就已经创建并初始化好了，所以，instance 实例的创建过程是线程安全的。不过，这样的实现方式不支持延迟加载（在真正用到 IdGenerator 的时候，再创建实例），从名字中我们也可以看出这一点。具体的代码实现如下所示：\n\n```java\npublic class IdGenerator { \n  private AtomicLong id = new AtomicLong(0);\n  private static final IdGenerator instance = new IdGenerator();\n  private IdGenerator() {}\n  public static IdGenerator getInstance() {\n    return instance;\n  }\n  public long getId() { \n    return id.incrementAndGet();\n  }\n}\n```\n\n\n\n1. 有人觉得这种实现方式不好，因为不支持延迟加载，如果实例占用资源多（比如占用内存多）或初始化耗时长（比如需要加载各种配置文件），提前初始化实例是一种浪费资源的行为。最好的方法应该在用到的时候再去初始化。不过，我个人并不认同这样的观点\n2. 如果初始化耗时长，那我们最好不要等到真正要用它的时候，才去执行这个耗时长的初始化过程，这会影响到系统的性能（比如，在响应客户端接口请求的时候，做这个初始化操作，会导致此请求的响应时间变长，甚至超时）。采用饿汉式实现方式，将耗时的初始化操作，提前到程序启动的时候完成，这样就能避免在程序运行的时候，再去初始化导致的性能问题。\n3. 如果实例占用资源多，按照 fail-fast 的设计原则（有问题及早暴露），那我们也希望在程序启动时就将这个实例初始化好。如果资源不够，就会在程序启动的时候触发报错（比如 Java 中的 PermGen Space OOM），我们可以立即去修复。这样也能避免在程序运行一段时间后，突然因为初始化这个实例占用资源过多，导致系统崩溃，影响系统的可用性。(如果初始化消耗资源过多，反而推荐懒汉式，早日发现问题)\n\n\n\n### 饿汉式(静态代码块)\n\n```java\n\npublic class SingletonTest02 {\n\n  public static void main(String[] args) {\n    // 测试\n    Singleton instance = Singleton.getInstance();\n    Singleton instance2 = Singleton.getInstance();\n    System.out.println(instance == instance2); // true\n    System.out.println(\"instance.hashCode=\" + instance.hashCode());\n    System.out.println(\"instance2.hashCode=\" + instance2.hashCode());\n  }\n}\n\n// 饿汉式(静态变量)\n\nclass Singleton {\n\n  // 1. 构造器私有化\n  private Singleton() {}\n\n  // 2.本类内部创建对象实例\n  private static Singleton instance;\n\n  static { // 在静态代码块中，创建单例对象\n    instance = new Singleton();\n  }\n\n  // 3. 提供一个公有的静态方法，返回实例对象\n  public static Singleton getInstance() {\n    return instance;\n  }\n}\n\n```\n\n没什么好说的，就是静态变量换成了静态代码块。\n\n\n\n\n\n### 懒汉式(线程安全，同步方法)\n\n懒汉式相对于饿汉式的优势是支持延迟加载。具体的代码实现如下所示：\n\n```java\npublic class IdGenerator { \n  private AtomicLong id = new AtomicLong(0);\n  private static IdGenerator instance;\n  private IdGenerator() {}\n  public static synchronized IdGenerator getInstance() {\n    if (instance == null) {\n      instance = new IdGenerator();\n    }\n    return instance;\n  }\n  public long getId() { \n    return id.incrementAndGet();\n  }\n}\n```\n\n不过懒汉式的缺点也很明显，我们给 getInstance() 这个方法加了一把大锁（synchronzed），导致这个函数的并发度很低。而这个函数是在单例使用期间，一直会被调用。如果这个单例类偶尔会被用到，那这种实现方式还可以接受。但是，如果频繁地用到，那频繁加锁、释放锁及并发度低等问题，会导致性能瓶颈，这种实现方式就不可取了。\n\n\n\n### 懒汉式(线程安全，同步代码块)\n\n```java\n// 懒汉式(线程安全，同步代码块)\nclass Singleton {\n  private static Singleton instance;\n\n  private Singleton() {}\n\n  public static Singleton getInstance() {\n    if (instance == null) {\n      synchronized (Singleton.class) {\n        instance = new Singleton();\n      }\n    }\n    return instance;\n  }\n}\n```\n\n\n\n### 懒汉式(线程不安全)\n\n\n\n```java\nclass Singleton {\n  private static Singleton instance;\n\n  private Singleton() {}\n\n  // 提供一个静态的公有方法，当使用到该方法时，才去创建 instance\n  // 即懒汉式\n  public static Singleton getInstance() {\n    if (instance == null) {\n      instance = new Singleton();\n    }\n    return instance;\n  }\n```\n\n只是为了完整性，写了出来，实际开发不推荐用线程不安全的\n\n### 双重检测\n\n饿汉式不支持延迟加载，懒汉式有性能问题，不支持高并发。那我们再来看一种既支持延迟加载、又支持高并发的单例实现方式，也就是双重检测实现方式。在这种实现方式中，只要 instance 被创建之后，即便再调用 getInstance() 函数也不会再进入到加锁逻辑中了。所以，这种实现方式解决了懒汉式并发度低的问题。具体的代码实现如下所示：\n\n```java\npublic class IdGenerator { \n  private AtomicLong id = new AtomicLong(0);\n  private static IdGenerator instance;\n  private IdGenerator() {}\n  public static IdGenerator getInstance() {\n    if (instance == null) {\n      synchronized(IdGenerator.class) { // 此处为类级别的锁\n        if (instance == null) {\n          instance = new IdGenerator();\n        }\n      }\n    }\n    return instance;\n  }\n  public long getId() { \n    return id.incrementAndGet();\n  }\n}\n```\n\n\n\n这种实现方式有些问题。因为指令重排序，可能会导致 IdGenerator 对象被 new 出来，并且赋值给 instance 之后，还没来得及初始化（执行构造函数中的代码逻辑），就被另一个线程使用了。要解决这个问题，我们需要给 instance 成员变量加上 volatile 关键字，禁止指令重排序才行。\n\n据说，只有很低版本的 Java 才会有这个问题。我们现在用的高版本的 Java 已经在 JDK 内部实现中解决了这个问题（解决的方法很简单，只要把对象 new 操作和初始化操作设计为原子操作，就自然能禁止重排序）。\n\n\n\n### 静态内部类\n\n我们再来看一种比双重检测更加简单的实现方法，那就是利用 Java 的静态内部类。它有点类似饿汉式，但又能做到了延迟加载。具体是怎么做到的呢？我们先来看它的代码实现\n\n```java\npublic class IdGenerator { \n  private AtomicLong id = new AtomicLong(0);\n  private IdGenerator() {}\n\n  private static class SingletonHolder{\n    private static final IdGenerator instance = new IdGenerator();\n  }\n  \n  public static IdGenerator getInstance() {\n    return SingletonHolder.instance;\n  }\n \n  public long getId() { \n    return id.incrementAndGet();\n  }\n}\n```\n\nSingletonHolder 是一个静态内部类，当外部类 IdGenerator 被加载的时候，并不会创建 SingletonHolder 实例对象。只有当调用 getInstance() 方法时，SingletonHolder 才会被加载，这个时候才会创建 instance。instance 的唯一性、创建过程的线程安全性，都由 JVM 来保证。所以，这种实现方法既保证了线程安全，又能做到延迟加载。\n\n\n\n### 枚举\n\n最后，我们介绍一种最简单的实现方式，基于枚举类型的单例实现。这种实现方式通过 Java 枚举类型本身的特性，保证了实例创建的线程安全性和实例的唯一性。具体的代码如下所示：\n\n```java\npublic enum IdGenerator {\n  INSTANCE;\n  private AtomicLong id = new AtomicLong(0);\n \n  public long getId() { \n    return id.incrementAndGet();\n  }\n}\n```\n\n\n\n## 单例存在哪些问题?\n\n尽管单例是一个很常用的设计模式，在实际的开发中，我们也确实经常用到它，但是，有些人认为单例是一种反模式（anti-pattern），并不推荐使用。大部分情况下，我们在项目中使用单例，都是用它来表示一些全局唯一类，比如配置信息类、连接池类、ID 生成器类。单例模式书写简洁、使用方便，在代码中，我们不需要创建对象，直接通过类似 IdGenerator.getInstance().getId() 这样的方法来调用就可以了。但是，这种使用方法有点类似硬编码（hard code），会带来诸多问题。接下来，我们就具体看看到底有哪些问题。\n\n\n\n### 单例对 OOP 特性的支持不友好\n\n我们知道，OOP 的四大特性是封装、抽象、继承、多态。单例这种设计模式对于其中的抽象、继承、多态都支持得不好。为什么这么说呢？我们还是通过 IdGenerator 这个例子来讲解。\n\n```java\npublic class Order {\n  public void create(...) {\n    //...\n    long id = IdGenerator.getInstance().getId();\n    //...\n  }\n}\n\npublic class User {\n  public void create(...) {\n    // ...\n    long id = IdGenerator.getInstance().getId();\n    //...\n  }\n}\n```\n\nIdGenerator 的使用方式违背了基于接口而非实现的设计原则，也就违背了广义上理解的 OOP 的抽象特性。如果未来某一天，我们希望针对不同的业务采用不同的 ID 生成算法。比如，订单 ID 和用户 ID 采用不同的 ID 生成器来生成。为了应对这个需求变化，我们需要修改所有用到 IdGenerator 类的地方，这样代码的改动就会比较大。\n\n```java\npublic class Order {\n  public void create(...) {\n    //...\n    long id = IdGenerator.getInstance().getId();\n    // 需要将上面一行代码，替换为下面一行代码\n    long id = OrderIdGenerator.getIntance().getId();\n    //...\n  }\n}\n\npublic class User {\n  public void create(...) {\n    // ...\n    long id = IdGenerator.getInstance().getId();\n    // 需要将上面一行代码，替换为下面一行代码\n    long id = UserIdGenerator.getIntance().getId();\n  }\n}\n```\n\n除此之外，单例对继承、多态特性的支持也不友好。这里我之所以会用“不友好”这个词，而非“完全不支持”，是因为从理论上来讲，单例类也可以被继承、也可以实现多态，只是实现起来会非常奇怪，会导致代码的可读性变差。不明白设计意图的人，看到这样的设计，会觉得莫名其妙。所以，一旦你选择将某个类设计成到单例类，也就意味着放弃了继承和多态这两个强有力的面向对象特性，也就相当于损失了可以应对未来需求变化的扩展性\n\n\n\n### 单例会隐藏类之间的依赖关系\n\n我们知道，代码的可读性非常重要。在阅读代码的时候，我们希望一眼就能看出类与类之间的依赖关系，搞清楚这个类依赖了哪些外部类。通过构造函数、参数传递等方式声明的类之间的依赖关系，我们通过查看函数的定义，就能很容易识别出来。但是，单例类不需要显示创建、不需要依赖参数传递，在函数中直接调用就可以了。如果代码比较复杂，这种调用关系就会非常隐蔽。在阅读代码的时候，我们就需要仔细查看每个函数的代码实现，才能知道这个类到底依赖了哪些单例类。\n\n\n\n\n\n### 单例对代码的扩展性不友好\n\n1. 我们知道，单例类只能有一个对象实例。如果未来某一天，我们需要在代码中创建两个实例或多个实例，那就要对代码有比较大的改动。你可能会说，会有这样的需求吗？既然单例类大部分情况下都用来表示全局类，怎么会需要两个或者多个实例呢？\n2. 实际上，这样的需求并不少见。我们拿数据库连接池来举例解释一下。\n3. 在系统设计初期，我们觉得系统中只应该有一个数据库连接池，这样能方便我们控制对数据库连接资源的消耗。所以，我们把数据库连接池类设计成了单例类。但之后我们发现，系统中有些 SQL 语句运行得非常慢。这些 SQL 语句在执行的时候，长时间占用数据库连接资源，导致其他 SQL 请求无法响应。为了解决这个问题，我们希望将慢 SQL 与其他 SQL 隔离开来执行。为了实现这样的目的，我们可以在系统中创建两个数据库连接池，慢 SQL 独享一个数据库连接池，其他 SQL 独享另外一个数据库连接池，这样就能避免慢 SQL 影响到其他 SQL 的执行。\n4. 如果我们将数据库连接池设计成单例类，显然就无法适应这样的需求变更，也就是说，单例类在某些情况下会影响代码的扩展性、灵活性。所以，数据库连接池、线程池这类的资源池，最好还是不要设计成单例类。实际上，一些开源的数据库连接池、线程池也确实没有设计成单例类。\n\n\n\n### 单例对代码的可测试性不友好\n\n1. 单例模式的使用会影响到代码的可测试性。如果单例类依赖比较重的外部资源，比如 DB，我们在写单元测试的时候，希望能通过 mock 的方式将它替换掉。而单例类这种硬编码式的使用方式，导致无法实现 mock 替换。\n\n2. 除此之外，如果单例类持有成员变量（比如 IdGenerator 中的 id 成员变量），那它实际上相当于一种全局变量，被所有的代码共享。如果这个全局变量是一个可变全局变量，也就是说，它的成员变量是可以被修改的，那我们在编写单元测试的时候，还需要注意不同测试用例之间，修改了单例类中的同一个成员变量的值，从而导致测试结果互相影响的问题。\n\n\n\n\n\n### 单例不支持有参数的构造函数\n\n单例不支持有参数的构造函数，比如我们创建一个连接池的单例对象，我们没法通过参数来指定连接池的大小。针对这个问题，我们来看下都有哪些解决方案。\n\n\n\n**第一种解决思路是**：创建完实例之后，再调用 init() 函数传递参数。需要注意的是，我们在使用这个单例类的时候，要先调用 init() 方法，然后才能调用 getInstance() 方法，否则代码会抛出异常。具体的代码实现如下所示：\n\n```java\npublic class Singleton {\n  private static Singleton instance = null;\n  private final int paramA;\n  private final int paramB;\n\n  private Singleton(int paramA, int paramB) {\n    this.paramA = paramA;\n    this.paramB = paramB;\n  }\n\n  public static Singleton getInstance() {\n    if (instance == null) {\n       throw new RuntimeException(\"Run init() first.\");\n    }\n    return instance;\n  }\n\n  public synchronized static Singleton init(int paramA, int paramB) {\n    if (instance != null){\n       throw new RuntimeException(\"Singleton has been created!\");\n    }\n    instance = new Singleton(paramA, paramB);\n    return instance;\n  }\n}\n\nSingleton.init(10, 50); // 先init，再使用\nSingleton singleton = Singleton.getInstance();\n```\n\n\n\n**第二种解决思路是**：将参数放到 getIntance() 方法中。具体的代码实现如下所示：\n\n```java\npublic class Singleton {\n  private static Singleton instance = null;\n  private final int paramA;\n  private final int paramB;\n\n  private Singleton(int paramA, int paramB) {\n    this.paramA = paramA;\n    this.paramB = paramB;\n  }\n\n  public synchronized static Singleton getInstance(int paramA, int paramB) {\n    if (instance == null) {\n      instance = new Singleton(paramA, paramB);\n    }\n    return instance;\n  }\n}\n\nSingleton singleton = Singleton.getInstance(10, 50);\n```\n\n\n\n不知道你有没有发现，上面的代码实现稍微有点问题。如果我们如下两次执行 getInstance() 方法，那获取到的 singleton1 和 signleton2 的 paramA 和 paramB 都是 10 和 50。也就是说，第二次的参数（20，30）没有起作用，而构建的过程也没有给与提示，这样就会误导用户。\n\n```java\nSingleton singleton1 = Singleton.getInstance(10, 50);\nSingleton singleton2 = Singleton.getInstance(20, 30);\n```\n\n\n\n\n\n**第三种解决思路是**：将参数放到另外一个全局变量中。具体的代码实现如下。Config 是一个存储了 paramA 和 paramB 值的全局变量。里面的值既可以像下面的代码那样通过静态常量来定义，也可以从配置文件中加载得到。**实际上，这种方式是最值得推荐的。**\n\n```java\npublic class Config {\n  public static final int PARAM_A = 123;\n  public static final int PARAM_B = 245;\n}\n\npublic class Singleton {\n  private static Singleton instance = null;\n  private final int paramA;\n  private final int paramB;\n\n  private Singleton() {\n    this.paramA = Config.PARAM_A;\n    this.paramB = Config.PARAM_B;\n  }\n\n  public synchronized static Singleton getInstance() {\n    if (instance == null) {\n      instance = new Singleton();\n    }\n    return instance;\n  }\n}\n```\n\n\n\n## 有何替代解决方案？\n\n刚刚我们提到了单例的很多问题，你可能会说，即便单例有这么多问题，但我不用不行啊。我业务上有表示全局唯一类的需求，如果不用单例，我怎么才能保证这个类的对象全局唯一呢？为了保证全局唯一，除了使用单例，我们还可以用静态方法来实现。这也是项目开发中经常用到的一种实现思路。比如， ID 唯一递增生成器的例子，用静态方法实现一下，就是下面这个样子：\n\n```java\n// 静态方法实现方式\npublic class IdGenerator {\n  private static AtomicLong id = new AtomicLong(0);\n  \n  public static long getId() { \n    return id.incrementAndGet();\n  }\n}\n// 使用举例\nlong id = IdGenerator.getId();\n```\n\n不过，静态方法这种实现思路，并不能解决我们之前提到的问题。实际上，它比单例更加不灵活，比如，它无法支持延迟加载。我们再来看看有没有其他办法。实际上，单例除了我们之前讲到的使用方法之外，还有另外一种使用方法。具体的代码如下所示：\n\n```java\n// 1. 老的使用方式\npublic demofunction() {\n  //...\n  long id = IdGenerator.getInstance().getId();\n  //...\n}\n\n// 2. 新的使用方式：依赖注入\npublic demofunction(IdGenerator idGenerator) {\n  long id = idGenerator.getId();\n}\n// 外部调用demofunction()的时候，传入idGenerator\nIdGenerator idGenerator = IdGenerator.getInsance();\ndemofunction(idGenerator);\n```\n\n\n\n1. 基于新的使用方式，我们将单例生成的对象，作为参数传递给函数（也可以通过构造函数传递给类的成员变量），可以解决单例隐藏类之间依赖关系的问题。不过，对于单例存在的其他问题，比如对 OOP 特性、扩展性、可测性不友好等问题，还是无法解决。\n2. 所以，如果要完全解决这些问题，我们可能要从根上，寻找其他方式来实现全局唯一类。实际上，类对象的全局唯一性可以通过多种不同的方式来保证。我们既可以通过单例模式来强制保证，也可以通过工厂模式、IOC 容器（比如 Spring IOC 容器）来保证，还可以通过程序员自己来保证（自己在编写代码的时候自己保证不要创建两个类对象）。这就类似 Java 中内存对象的释放由 JVM 来负责，而 C++ 中由程序员自己负责，道理是一样的。\n3. 对于替代方案工厂模式、IOC 容器的详细讲解，我们放到后面讲解。\n\n\n\n## 如何理解单例模式中的唯一性？\n\n1. 首先，我们重新看一下单例的定义：“一个类只允许创建唯一一个对象（或者实例），那这个类就是一个单例类，这种设计模式就叫作单例设计模式，简称单例模式。\n2. ”定义中提到，“一个类只允许创建唯一一个对象”。那对象的唯一性的作用范围是什么呢？是指线程内只允许创建一个对象，还是指进程内只允许创建一个对象？答案是后者，也就是说，单例模式创建的对象是进程唯一的。这里有点不好理解，我来详细地解释一下。\n3. 我们编写的代码，通过编译、链接，组织在一起，就构成了一个操作系统可以执行的文件，也就是我们平时所说的“可执行文件”（比如 Windows 下的 exe 文件）。可执行文件实际上就是代码被翻译成操作系统可理解的一组指令，你完全可以简单地理解为就是代码本身。\n4. 当我们使用命令行或者双击运行这个可执行文件的时候，操作系统会启动一个进程，将这个执行文件从磁盘加载到自己的进程地址空间（可以理解操作系统为进程分配的内存存储区，用来存储代码和数据）。接着，进程就一条一条地执行可执行文件中包含的代码。比如，当进程读到代码中的 User user = new User(); 这条语句的时候，它就在自己的地址空间中创建一个 user 临时变量和一个 User 对象。进程之间是不共享地址空间的，如果我们在一个进程中创建另外一个进程（比如，代码中有一个 fork() 语句，进程执行到这条语句的时候会创建一个新的进程），操作系统会给新进程分配新的地址空间，并且将老进程地址空间的所有内容，重新拷贝一份到新进程的地址空间中，这些内容包括代码、数据（比如 user 临时变量、User 对象）。\n5. 所以，单例类在老进程中存在且只能存在一个对象，在新进程中也会存在且只能存在一个对象。而且，这两个对象并不是同一个对象，这也就说，单例类中对象的唯一性的作用范围是进程内的，在进程间是不唯一的。\n\n\n\n## 如何实现线程唯一的单例？\n\n1. 刚刚我们讲了单例类对象是进程唯一的，一个进程只能有一个单例对象。那如何实现一个线程唯一的单例呢？\n\n2. 我们先来看一下，什么是线程唯一的单例，以及“线程唯一”和“进程唯一”的区别。\n\n3. “进程唯一”指的是进程内唯一，进程间不唯一。类比一下，“线程唯一”指的是线程内唯一，线程间可以不唯一。实际上，“进程唯一”还代表了线程内、线程间都唯一，这也是“进程唯一”和“线程唯一”的区别之处。这段话听起来有点像绕口令，我举个例子来解释一下。\n\n4. 假设 IdGenerator 是一个线程唯一的单例类。在线程 A 内，我们可以创建一个单例对象 a。因为线程内唯一，在线程 A 内就不能再创建新的 IdGenerator 对象了，而线程间可以不唯一，所以，在另外一个线程 B 内，我们还可以重新创建一个新的单例对象 b。\n\n5. 尽管概念理解起来比较复杂，但线程唯一单例的代码实现很简单，如下所示。在代码中，我们通过一个 HashMap 来存储对象，其中 key 是线程 ID，value 是对象。这样我们就可以做到，不同的线程对应不同的对象，同一个线程只能对应一个对象。实际上，Java 语言本身提供了 ThreadLocal 工具类，可以更加轻松地实现线程唯一单例。不过，ThreadLocal 底层实现原理也是基于下面代码中所示的 HashMap。\n\n   \n\n```java\npublic class IdGenerator {\n  private AtomicLong id = new AtomicLong(0);\n\n  private static final ConcurrentHashMap<Long, IdGenerator> instances\n          = new ConcurrentHashMap<>();\n\n  private IdGenerator() {}\n\n  public static IdGenerator getInstance() {\n    Long currentThreadId = Thread.currentThread().getId();\n    instances.putIfAbsent(currentThreadId, new IdGenerator());\n    return instances.get(currentThreadId);\n  }\n\n  public long getId() {\n    return id.incrementAndGet();\n  }\n}\n```\n\n\n\n\n\n## 如何实现集群环境下的单例？\n\n1. 刚刚我们讲了“进程唯一”的单例和“线程唯一”的单例，现在，我们再来看下，“集群唯一”的单例。\n2. 首先，我们还是先来解释一下，什么是“集群唯一”的单例。\n3. 我们还是将它跟“进程唯一”“线程唯一”做个对比。“进程唯一”指的是进程内唯一、进程间不唯一。“线程唯一”指的是线程内唯一、线程间不唯一。集群相当于多个进程构成的一个集合，“集群唯一”就相当于是进程内唯一、进程间也唯一。也就是说，不同的进程间共享同一个对象，不能创建同一个类的多个对象。\n4. 我们知道，经典的单例模式是进程内唯一的，那如何实现一个进程间也唯一的单例呢？如果严格按照不同的进程间共享同一个对象来实现，那集群唯一的单例实现起来就有点难度了。\n5. 具体来说，我们需要把这个单例对象序列化并存储到外部共享存储区（比如文件）。进程在使用这个单例对象的时候，需要先从外部共享存储区中将它读取到内存，并反序列化成对象，然后再使用，使用完成之后还需要再存储回外部共享存储区。\n6. 为了保证任何时刻，在进程间都只有一份对象存在，一个进程在获取到对象之后，需要对对象加锁，避免其他进程再将其获取。在进程使用完这个对象之后，还需要显式地将对象从内存中删除，并且释放对对象的加锁。按照这个思路，\n7. 我用伪代码实现了一下这个过程，具体如下所示：\n\n```java\npublic class IdGenerator {\n  private AtomicLong id = new AtomicLong(0);\n  private static IdGenerator instance;\n  private static SharedObjectStorage storage = FileSharedObjectStorage(/*入参省略，比如文件地址*/);\n  private static DistributedLock lock = new DistributedLock();\n  \n  private IdGenerator() {}\n\n  public synchronized static IdGenerator getInstance() \n    if (instance == null) {\n      lock.lock();\n      instance = storage.load(IdGenerator.class);\n    }\n    return instance;\n  }\n  \n  public synchroinzed void freeInstance() {\n    storage.save(this, IdGeneator.class);\n    instance = null; //释放对象\n    lock.unlock();\n  }\n  \n  public long getId() { \n    return id.incrementAndGet();\n  }\n}\n\n// IdGenerator使用举例\nIdGenerator idGeneator = IdGenerator.getInstance();\nlong id = idGenerator.getId();\nIdGenerator.freeInstance();\n```\n\n\n\n## 如何实现一个多例模式？\n\n跟单例模式概念相对应的还有一个多例模式。那如何实现一个多例模式呢？“单例”指的是，一个类只能创建一个对象。对应地，“多例”指的就是，一个类可以创建多个对象，但是个数是有限制的，比如只能创建 3 个对象。如果用代码来简单示例一下的话，就是下面这个样子：\n\n```java\npublic class BackendServer {\n  private long serverNo;\n  private String serverAddress;\n\n  private static final int SERVER_COUNT = 3;\n  private static final Map<Long, BackendServer> serverInstances = new HashMap<>();\n\n  static {\n    serverInstances.put(1L, new BackendServer(1L, \"192.134.22.138:8080\"));\n    serverInstances.put(2L, new BackendServer(2L, \"192.134.22.139:8080\"));\n    serverInstances.put(3L, new BackendServer(3L, \"192.134.22.140:8080\"));\n  }\n\n  private BackendServer(long serverNo, String serverAddress) {\n    this.serverNo = serverNo;\n    this.serverAddress = serverAddress;\n  }\n\n  public BackendServer getInstance(long serverNo) {\n    return serverInstances.get(serverNo);\n  }\n\n  public BackendServer getRandomInstance() {\n    Random r = new Random();\n    int no = r.nextInt(SERVER_COUNT)+1;\n    return serverInstances.get(no);\n  }\n}\n```\n\n\n\n实际上，对于多例模式，还有一种理解方式：同一类型的只能创建一个对象，不同类型的可以创建多个对象。这里的“类型”如何理解呢？我们还是通过一个例子来解释一下，具体代码如下所示。在代码中，logger name 就是刚刚说的“类型”，同一个 logger name 获取到的对象实例是相同的，不同的 logger name 获取到的对象实例是不同的。\n\n```java\npublic class Logger {\n  private static final ConcurrentHashMap<String, Logger> instances\n          = new ConcurrentHashMap<>();\n\n  private Logger() {}\n\n  public static Logger getInstance(String loggerName) {\n    instances.putIfAbsent(loggerName, new Logger());\n    return instances.get(loggerName);\n  }\n\n  public void log() {\n    //...\n  }\n}\n\n//l1==l2, l1!=l3\nLogger l1 = Logger.getInstance(\"User.class\");\nLogger l2 = Logger.getInstance(\"User.class\");\nLogger l3 = Logger.getInstance(\"Order.class\");\n```\n\n\n\n这种多例模式的理解方式有点类似工厂模式。它跟工厂模式的不同之处是，多例模式创建的对象都是同一个类的对象，而工厂模式创建的是不同子类的对象，关于这一点，后面就会讲到。实际上，它还有点类似享元模式，两者的区别等到我们讲到享元模式的时候再来分析。除此之外，实际上，枚举类型也相当于多例模式，一个类型只能对应一个对象，一个类可以创建多个对象。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/2024-05-11-设计模式-03.01-创建型-单例.md","raw":"---\ntitle: 设计模式-03.01-创建型-单例\ntags:\n  - 设计模式\n  - 单例\ncategories:\n  - 设计模式\n  - 03.创建型\nkeywords: 设计模式，单例\ndescription: 详解了单例设计模式。\ncover: 'https://npm.elemecdn.com/lql_static@latest/logo/design_patterns.jpg'\nabbrlink: b5a1ed4a\ndate: 2024-05-11 21:51:58\n---\n\n# 声明\n\n> 1. 此系列文章非本人原创，是学习笔记。\n> 2. 设计模式系列以后会持续更新，包括已经发布的设计模式文章，因为后续还要再多看一下书，教程和开源项目等，继续润色文章。\n\n\n# 前言\n\n23 种经典的设计模式。它们又可以分为三大类：创建型、结构型、行为型。对于这 23 种设计模式的学习，我们要有侧重点，因为有些模式是比较常用的，有些模式是很少被用到的。对于常用的设计模式，我们要花多点时间理解掌握。对于不常用的设计模式，我们只需要稍微了解即可。按照类型和是否常用，对这些设计模式，进行了简单的分类，具体如下所示。\n\n### 创建型\n\n常用的有：单例模式、工厂模式（工厂方法和抽象工厂）、建造者模式。\n\n不常用的有：原型模式。\n\n\n\n### 结构型\n\n常用的有：代理模式、桥接模式、装饰者模式、适配器模式。\n\n不常用的有：门面模式、组合模式、享元模式。 \n\n\n\n### 行为型\n\n常用的有：观察者模式、模板模式、策略模式、职责链模式、迭代器模式、状态模式。\n\n不常用的有：访问者模式、备忘录模式、命令模式、解释器模式、中介模式。\n\n\n\n\n\n# 单例模式【常用】\n\n网上有很多讲解单例模式的文章，但大部分都侧重讲解，如何来实现一个线程安全的单例。今天也会讲到各种单例的实现方法，但是，重点还是希望带你搞清楚下面这样几个问题。\n\n- 为什么要使用单例？\n- 单例存在哪些问题？\n- 单例与静态类的区别？\n- 有何替代的解决方案？\n\n\n\n## 为什么要使用单例？\n\n单例设计模式（Singleton Design Pattern）理解起来非常简单。一个类只允许创建一个对象（或者实例），那这个类就是一个单例类，这种设计模式就叫作单例设计模式，简称单例模式。\n\n对于单例的概念，我觉得没必要解释太多，你一看就能明白。我们重点看一下，为什么我们需要单例这种设计模式？它能解决哪些问题？接下来我通过两个实战案例来讲解。\n\n\n\n### 实战案例一：处理资源访问冲突\n\n我们先来看第一个例子。在这个例子中，我们自定义实现了一个往文件中打印日志的 Logger 类。具体的代码实现如下所示：\n\n```java\npublic class Logger {\n  private FileWriter writer;\n  \n  public Logger() {\n    File file = new File(\"/Users/wangzheng/log.txt\");\n    writer = new FileWriter(file, true); //true表示追加写入\n  }\n  \n  public void log(String message) {\n    writer.write(message);\n  }\n}\n\n// Logger类的应用示例：\npublic class UserController {\n  private Logger logger = new Logger();\n  \n  public void login(String username, String password) {\n    // ...省略业务逻辑代码...\n    logger.log(username + \" logined!\");\n  }\n}\n\npublic class OrderController {\n  private Logger logger = new Logger();\n  \n  public void create(OrderVo order) {\n    // ...省略业务逻辑代码...\n    logger.log(\"Created an order: \" + order.toString());\n  }\n}\n```\n\n在上面的代码中，我们注意到，所有的日志都写入到同一个文件 /Users/wangzheng/log.txt 中。在 UserController 和 OrderController 中，我们分别创建两个 Logger 对象。在 Web 容器的 Servlet 多线程环境下，如果两个 Servlet 线程同时分别执行 login() 和 create() 两个函数，并且同时写日志到 log.txt 文件中，那就有可能存在日志信息互相覆盖的情况。【这属于并发的知识点，看不懂的可以看笔者的并发系列】\n\n\n\n那如何来解决这个问题呢？我们最先想到的就是通过加锁的方式：给 log() 函数加互斥锁，同一时刻只允许一个线程调用执行 log() 函数。\n\n```java\npublic class Logger {\n  private FileWriter writer;\n\n  public Logger() {\n    File file = new File(\"/Users/wangzheng/log.txt\");\n    writer = new FileWriter(file, true); //true表示追加写入\n  }\n  \n  public void log(String message) {\n    synchronized(this) {\n      writer.write(mesasge);\n    }\n  }\n}\n```\n\n`synchronized(this)`这种对象级别的锁，锁不住，因为不同的对象之间并不共享同一把锁。所以我们换成类级别的锁。\n\n```java\npublic class Logger {\n  private FileWriter writer;\n\n  public Logger() {\n    File file = new File(\"/Users/wangzheng/log.txt\");\n    writer = new FileWriter(file, true); //true表示追加写入\n  }\n  \n  public void log(String message) {\n    synchronized(Logger.class) { // 类级别的锁\n      writer.write(mesasge);\n    }\n  }\n}\n```\n\n除了使用类级别锁之外，实际上，解决资源竞争问题的办法还有很多，分布式锁是最常听到的一种解决方案。不过，实现一个安全可靠、无 bug、高性能的分布式锁，并不是件容易的事情。除此之外，并发队列（比如 Java 中的 BlockingQueue）也可以解决这个问题：多个线程同时往并发队列里写日志，一个单独的线程负责将并发队列中的数据，写入到日志文件。这种方式实现起来也稍微有点复杂。\n\n\n\n相对于这两种解决方案，单例模式的解决思路就简单一些了。单例模式相对于之前类级别锁的好处是，不用创建那么多 Logger 对象，一方面节省内存空间，另一方面节省系统文件句柄（对于操作系统来说，文件句柄也是一种资源，不能随便浪费）。\n\n我们将 Logger 设计成一个单例类，程序中只允许创建一个 Logger 对象，所有的线程共享使用的这一个 Logger 对象，共享一个 FileWriter 对象，而 FileWriter 本身是对象级别线程安全的，也就避免了多线程情况下写日志会互相覆盖的问题。按照这个设计思路，我们实现了 Logger 单例类。具体代码如下所示：\n\n```java\npublic class Logger {\n  private FileWriter writer;\n  private static final Logger instance = new Logger();\n\n  private Logger() {\n    File file = new File(\"/Users/wangzheng/log.txt\");\n    writer = new FileWriter(file, true); //true表示追加写入\n  }\n  \n  public static Logger getInstance() {\n    return instance;\n  }\n  \n  public void log(String message) {\n    writer.write(mesasge);\n  }\n}\n\n// Logger类的应用示例：\npublic class UserController {\n  public void login(String username, String password) {\n    // ...省略业务逻辑代码...\n    Logger.getInstance().log(username + \" logined!\");\n  }\n}\n\npublic class OrderController {  \n  public void create(OrderVo order) {\n    // ...省略业务逻辑代码...\n    Logger.getInstance().log(\"Created a order: \" + order.toString());\n  }\n}\n```\n\n\n\n### 实战案例二：表示全局唯一类\n\n从业务概念上，如果有些数据在系统中只应保存一份，那就比较适合设计为单例类。比如，配置信息类。在系统中，我们只有一个配置文件，当配置文件被加载到内存之后，以对象的形式存在，也理所应当只有一份。\n\n再比如，唯一递增 ID 号码生成器。如果程序中有两个对象，那就会存在生成重复 ID 的情况，所以，我们应该将 ID 生成器类设计为单例。\n\n```java\npublic class IdGenerator {\n  // AtomicLong是一个Java并发库中提供的一个原子变量类型,\n  // 它将一些线程不安全需要加锁的复合操作封装为了线程安全的原子操作，\n  // 比如下面会用到的incrementAndGet().\n  private AtomicLong id = new AtomicLong(0);\n  private static final IdGenerator instance = new IdGenerator();\n  private IdGenerator() {}\n  public static IdGenerator getInstance() {\n    return instance;\n  }\n  public long getId() { \n    return id.incrementAndGet();\n  }\n}\n\n// IdGenerator使用举例\nlong id = IdGenerator.getInstance().getId();\n```\n\n\n\n## 如何实现一个单例？\n\n尽管介绍如何实现一个单例模式的文章已经有很多了，但为了保证内容的完整性，我这里还是简单介绍一下几种经典实现方式。概括起来，要实现一个单例，我们需要关注的点无外乎下面几个：\n\n- 构造函数需要是 private 访问权限的，这样才能避免外部通过 new 创建实例；\n\n- 考虑对象创建时的线程安全问题；\n\n- 考虑是否支持延迟加载；\n\n- 考虑 getInstance() 性能是否高（是否加锁）。\n\n\n\n### 饿汉式(静态变量)\n\n饿汉式的实现方式比较简单。在类加载的时候，instance 静态实例就已经创建并初始化好了，所以，instance 实例的创建过程是线程安全的。不过，这样的实现方式不支持延迟加载（在真正用到 IdGenerator 的时候，再创建实例），从名字中我们也可以看出这一点。具体的代码实现如下所示：\n\n```java\npublic class IdGenerator { \n  private AtomicLong id = new AtomicLong(0);\n  private static final IdGenerator instance = new IdGenerator();\n  private IdGenerator() {}\n  public static IdGenerator getInstance() {\n    return instance;\n  }\n  public long getId() { \n    return id.incrementAndGet();\n  }\n}\n```\n\n\n\n1. 有人觉得这种实现方式不好，因为不支持延迟加载，如果实例占用资源多（比如占用内存多）或初始化耗时长（比如需要加载各种配置文件），提前初始化实例是一种浪费资源的行为。最好的方法应该在用到的时候再去初始化。不过，我个人并不认同这样的观点\n2. 如果初始化耗时长，那我们最好不要等到真正要用它的时候，才去执行这个耗时长的初始化过程，这会影响到系统的性能（比如，在响应客户端接口请求的时候，做这个初始化操作，会导致此请求的响应时间变长，甚至超时）。采用饿汉式实现方式，将耗时的初始化操作，提前到程序启动的时候完成，这样就能避免在程序运行的时候，再去初始化导致的性能问题。\n3. 如果实例占用资源多，按照 fail-fast 的设计原则（有问题及早暴露），那我们也希望在程序启动时就将这个实例初始化好。如果资源不够，就会在程序启动的时候触发报错（比如 Java 中的 PermGen Space OOM），我们可以立即去修复。这样也能避免在程序运行一段时间后，突然因为初始化这个实例占用资源过多，导致系统崩溃，影响系统的可用性。(如果初始化消耗资源过多，反而推荐懒汉式，早日发现问题)\n\n\n\n### 饿汉式(静态代码块)\n\n```java\n\npublic class SingletonTest02 {\n\n  public static void main(String[] args) {\n    // 测试\n    Singleton instance = Singleton.getInstance();\n    Singleton instance2 = Singleton.getInstance();\n    System.out.println(instance == instance2); // true\n    System.out.println(\"instance.hashCode=\" + instance.hashCode());\n    System.out.println(\"instance2.hashCode=\" + instance2.hashCode());\n  }\n}\n\n// 饿汉式(静态变量)\n\nclass Singleton {\n\n  // 1. 构造器私有化\n  private Singleton() {}\n\n  // 2.本类内部创建对象实例\n  private static Singleton instance;\n\n  static { // 在静态代码块中，创建单例对象\n    instance = new Singleton();\n  }\n\n  // 3. 提供一个公有的静态方法，返回实例对象\n  public static Singleton getInstance() {\n    return instance;\n  }\n}\n\n```\n\n没什么好说的，就是静态变量换成了静态代码块。\n\n\n\n\n\n### 懒汉式(线程安全，同步方法)\n\n懒汉式相对于饿汉式的优势是支持延迟加载。具体的代码实现如下所示：\n\n```java\npublic class IdGenerator { \n  private AtomicLong id = new AtomicLong(0);\n  private static IdGenerator instance;\n  private IdGenerator() {}\n  public static synchronized IdGenerator getInstance() {\n    if (instance == null) {\n      instance = new IdGenerator();\n    }\n    return instance;\n  }\n  public long getId() { \n    return id.incrementAndGet();\n  }\n}\n```\n\n不过懒汉式的缺点也很明显，我们给 getInstance() 这个方法加了一把大锁（synchronzed），导致这个函数的并发度很低。而这个函数是在单例使用期间，一直会被调用。如果这个单例类偶尔会被用到，那这种实现方式还可以接受。但是，如果频繁地用到，那频繁加锁、释放锁及并发度低等问题，会导致性能瓶颈，这种实现方式就不可取了。\n\n\n\n### 懒汉式(线程安全，同步代码块)\n\n```java\n// 懒汉式(线程安全，同步代码块)\nclass Singleton {\n  private static Singleton instance;\n\n  private Singleton() {}\n\n  public static Singleton getInstance() {\n    if (instance == null) {\n      synchronized (Singleton.class) {\n        instance = new Singleton();\n      }\n    }\n    return instance;\n  }\n}\n```\n\n\n\n### 懒汉式(线程不安全)\n\n\n\n```java\nclass Singleton {\n  private static Singleton instance;\n\n  private Singleton() {}\n\n  // 提供一个静态的公有方法，当使用到该方法时，才去创建 instance\n  // 即懒汉式\n  public static Singleton getInstance() {\n    if (instance == null) {\n      instance = new Singleton();\n    }\n    return instance;\n  }\n```\n\n只是为了完整性，写了出来，实际开发不推荐用线程不安全的\n\n### 双重检测\n\n饿汉式不支持延迟加载，懒汉式有性能问题，不支持高并发。那我们再来看一种既支持延迟加载、又支持高并发的单例实现方式，也就是双重检测实现方式。在这种实现方式中，只要 instance 被创建之后，即便再调用 getInstance() 函数也不会再进入到加锁逻辑中了。所以，这种实现方式解决了懒汉式并发度低的问题。具体的代码实现如下所示：\n\n```java\npublic class IdGenerator { \n  private AtomicLong id = new AtomicLong(0);\n  private static IdGenerator instance;\n  private IdGenerator() {}\n  public static IdGenerator getInstance() {\n    if (instance == null) {\n      synchronized(IdGenerator.class) { // 此处为类级别的锁\n        if (instance == null) {\n          instance = new IdGenerator();\n        }\n      }\n    }\n    return instance;\n  }\n  public long getId() { \n    return id.incrementAndGet();\n  }\n}\n```\n\n\n\n这种实现方式有些问题。因为指令重排序，可能会导致 IdGenerator 对象被 new 出来，并且赋值给 instance 之后，还没来得及初始化（执行构造函数中的代码逻辑），就被另一个线程使用了。要解决这个问题，我们需要给 instance 成员变量加上 volatile 关键字，禁止指令重排序才行。\n\n据说，只有很低版本的 Java 才会有这个问题。我们现在用的高版本的 Java 已经在 JDK 内部实现中解决了这个问题（解决的方法很简单，只要把对象 new 操作和初始化操作设计为原子操作，就自然能禁止重排序）。\n\n\n\n### 静态内部类\n\n我们再来看一种比双重检测更加简单的实现方法，那就是利用 Java 的静态内部类。它有点类似饿汉式，但又能做到了延迟加载。具体是怎么做到的呢？我们先来看它的代码实现\n\n```java\npublic class IdGenerator { \n  private AtomicLong id = new AtomicLong(0);\n  private IdGenerator() {}\n\n  private static class SingletonHolder{\n    private static final IdGenerator instance = new IdGenerator();\n  }\n  \n  public static IdGenerator getInstance() {\n    return SingletonHolder.instance;\n  }\n \n  public long getId() { \n    return id.incrementAndGet();\n  }\n}\n```\n\nSingletonHolder 是一个静态内部类，当外部类 IdGenerator 被加载的时候，并不会创建 SingletonHolder 实例对象。只有当调用 getInstance() 方法时，SingletonHolder 才会被加载，这个时候才会创建 instance。instance 的唯一性、创建过程的线程安全性，都由 JVM 来保证。所以，这种实现方法既保证了线程安全，又能做到延迟加载。\n\n\n\n### 枚举\n\n最后，我们介绍一种最简单的实现方式，基于枚举类型的单例实现。这种实现方式通过 Java 枚举类型本身的特性，保证了实例创建的线程安全性和实例的唯一性。具体的代码如下所示：\n\n```java\npublic enum IdGenerator {\n  INSTANCE;\n  private AtomicLong id = new AtomicLong(0);\n \n  public long getId() { \n    return id.incrementAndGet();\n  }\n}\n```\n\n\n\n## 单例存在哪些问题?\n\n尽管单例是一个很常用的设计模式，在实际的开发中，我们也确实经常用到它，但是，有些人认为单例是一种反模式（anti-pattern），并不推荐使用。大部分情况下，我们在项目中使用单例，都是用它来表示一些全局唯一类，比如配置信息类、连接池类、ID 生成器类。单例模式书写简洁、使用方便，在代码中，我们不需要创建对象，直接通过类似 IdGenerator.getInstance().getId() 这样的方法来调用就可以了。但是，这种使用方法有点类似硬编码（hard code），会带来诸多问题。接下来，我们就具体看看到底有哪些问题。\n\n\n\n### 单例对 OOP 特性的支持不友好\n\n我们知道，OOP 的四大特性是封装、抽象、继承、多态。单例这种设计模式对于其中的抽象、继承、多态都支持得不好。为什么这么说呢？我们还是通过 IdGenerator 这个例子来讲解。\n\n```java\npublic class Order {\n  public void create(...) {\n    //...\n    long id = IdGenerator.getInstance().getId();\n    //...\n  }\n}\n\npublic class User {\n  public void create(...) {\n    // ...\n    long id = IdGenerator.getInstance().getId();\n    //...\n  }\n}\n```\n\nIdGenerator 的使用方式违背了基于接口而非实现的设计原则，也就违背了广义上理解的 OOP 的抽象特性。如果未来某一天，我们希望针对不同的业务采用不同的 ID 生成算法。比如，订单 ID 和用户 ID 采用不同的 ID 生成器来生成。为了应对这个需求变化，我们需要修改所有用到 IdGenerator 类的地方，这样代码的改动就会比较大。\n\n```java\npublic class Order {\n  public void create(...) {\n    //...\n    long id = IdGenerator.getInstance().getId();\n    // 需要将上面一行代码，替换为下面一行代码\n    long id = OrderIdGenerator.getIntance().getId();\n    //...\n  }\n}\n\npublic class User {\n  public void create(...) {\n    // ...\n    long id = IdGenerator.getInstance().getId();\n    // 需要将上面一行代码，替换为下面一行代码\n    long id = UserIdGenerator.getIntance().getId();\n  }\n}\n```\n\n除此之外，单例对继承、多态特性的支持也不友好。这里我之所以会用“不友好”这个词，而非“完全不支持”，是因为从理论上来讲，单例类也可以被继承、也可以实现多态，只是实现起来会非常奇怪，会导致代码的可读性变差。不明白设计意图的人，看到这样的设计，会觉得莫名其妙。所以，一旦你选择将某个类设计成到单例类，也就意味着放弃了继承和多态这两个强有力的面向对象特性，也就相当于损失了可以应对未来需求变化的扩展性\n\n\n\n### 单例会隐藏类之间的依赖关系\n\n我们知道，代码的可读性非常重要。在阅读代码的时候，我们希望一眼就能看出类与类之间的依赖关系，搞清楚这个类依赖了哪些外部类。通过构造函数、参数传递等方式声明的类之间的依赖关系，我们通过查看函数的定义，就能很容易识别出来。但是，单例类不需要显示创建、不需要依赖参数传递，在函数中直接调用就可以了。如果代码比较复杂，这种调用关系就会非常隐蔽。在阅读代码的时候，我们就需要仔细查看每个函数的代码实现，才能知道这个类到底依赖了哪些单例类。\n\n\n\n\n\n### 单例对代码的扩展性不友好\n\n1. 我们知道，单例类只能有一个对象实例。如果未来某一天，我们需要在代码中创建两个实例或多个实例，那就要对代码有比较大的改动。你可能会说，会有这样的需求吗？既然单例类大部分情况下都用来表示全局类，怎么会需要两个或者多个实例呢？\n2. 实际上，这样的需求并不少见。我们拿数据库连接池来举例解释一下。\n3. 在系统设计初期，我们觉得系统中只应该有一个数据库连接池，这样能方便我们控制对数据库连接资源的消耗。所以，我们把数据库连接池类设计成了单例类。但之后我们发现，系统中有些 SQL 语句运行得非常慢。这些 SQL 语句在执行的时候，长时间占用数据库连接资源，导致其他 SQL 请求无法响应。为了解决这个问题，我们希望将慢 SQL 与其他 SQL 隔离开来执行。为了实现这样的目的，我们可以在系统中创建两个数据库连接池，慢 SQL 独享一个数据库连接池，其他 SQL 独享另外一个数据库连接池，这样就能避免慢 SQL 影响到其他 SQL 的执行。\n4. 如果我们将数据库连接池设计成单例类，显然就无法适应这样的需求变更，也就是说，单例类在某些情况下会影响代码的扩展性、灵活性。所以，数据库连接池、线程池这类的资源池，最好还是不要设计成单例类。实际上，一些开源的数据库连接池、线程池也确实没有设计成单例类。\n\n\n\n### 单例对代码的可测试性不友好\n\n1. 单例模式的使用会影响到代码的可测试性。如果单例类依赖比较重的外部资源，比如 DB，我们在写单元测试的时候，希望能通过 mock 的方式将它替换掉。而单例类这种硬编码式的使用方式，导致无法实现 mock 替换。\n\n2. 除此之外，如果单例类持有成员变量（比如 IdGenerator 中的 id 成员变量），那它实际上相当于一种全局变量，被所有的代码共享。如果这个全局变量是一个可变全局变量，也就是说，它的成员变量是可以被修改的，那我们在编写单元测试的时候，还需要注意不同测试用例之间，修改了单例类中的同一个成员变量的值，从而导致测试结果互相影响的问题。\n\n\n\n\n\n### 单例不支持有参数的构造函数\n\n单例不支持有参数的构造函数，比如我们创建一个连接池的单例对象，我们没法通过参数来指定连接池的大小。针对这个问题，我们来看下都有哪些解决方案。\n\n\n\n**第一种解决思路是**：创建完实例之后，再调用 init() 函数传递参数。需要注意的是，我们在使用这个单例类的时候，要先调用 init() 方法，然后才能调用 getInstance() 方法，否则代码会抛出异常。具体的代码实现如下所示：\n\n```java\npublic class Singleton {\n  private static Singleton instance = null;\n  private final int paramA;\n  private final int paramB;\n\n  private Singleton(int paramA, int paramB) {\n    this.paramA = paramA;\n    this.paramB = paramB;\n  }\n\n  public static Singleton getInstance() {\n    if (instance == null) {\n       throw new RuntimeException(\"Run init() first.\");\n    }\n    return instance;\n  }\n\n  public synchronized static Singleton init(int paramA, int paramB) {\n    if (instance != null){\n       throw new RuntimeException(\"Singleton has been created!\");\n    }\n    instance = new Singleton(paramA, paramB);\n    return instance;\n  }\n}\n\nSingleton.init(10, 50); // 先init，再使用\nSingleton singleton = Singleton.getInstance();\n```\n\n\n\n**第二种解决思路是**：将参数放到 getIntance() 方法中。具体的代码实现如下所示：\n\n```java\npublic class Singleton {\n  private static Singleton instance = null;\n  private final int paramA;\n  private final int paramB;\n\n  private Singleton(int paramA, int paramB) {\n    this.paramA = paramA;\n    this.paramB = paramB;\n  }\n\n  public synchronized static Singleton getInstance(int paramA, int paramB) {\n    if (instance == null) {\n      instance = new Singleton(paramA, paramB);\n    }\n    return instance;\n  }\n}\n\nSingleton singleton = Singleton.getInstance(10, 50);\n```\n\n\n\n不知道你有没有发现，上面的代码实现稍微有点问题。如果我们如下两次执行 getInstance() 方法，那获取到的 singleton1 和 signleton2 的 paramA 和 paramB 都是 10 和 50。也就是说，第二次的参数（20，30）没有起作用，而构建的过程也没有给与提示，这样就会误导用户。\n\n```java\nSingleton singleton1 = Singleton.getInstance(10, 50);\nSingleton singleton2 = Singleton.getInstance(20, 30);\n```\n\n\n\n\n\n**第三种解决思路是**：将参数放到另外一个全局变量中。具体的代码实现如下。Config 是一个存储了 paramA 和 paramB 值的全局变量。里面的值既可以像下面的代码那样通过静态常量来定义，也可以从配置文件中加载得到。**实际上，这种方式是最值得推荐的。**\n\n```java\npublic class Config {\n  public static final int PARAM_A = 123;\n  public static final int PARAM_B = 245;\n}\n\npublic class Singleton {\n  private static Singleton instance = null;\n  private final int paramA;\n  private final int paramB;\n\n  private Singleton() {\n    this.paramA = Config.PARAM_A;\n    this.paramB = Config.PARAM_B;\n  }\n\n  public synchronized static Singleton getInstance() {\n    if (instance == null) {\n      instance = new Singleton();\n    }\n    return instance;\n  }\n}\n```\n\n\n\n## 有何替代解决方案？\n\n刚刚我们提到了单例的很多问题，你可能会说，即便单例有这么多问题，但我不用不行啊。我业务上有表示全局唯一类的需求，如果不用单例，我怎么才能保证这个类的对象全局唯一呢？为了保证全局唯一，除了使用单例，我们还可以用静态方法来实现。这也是项目开发中经常用到的一种实现思路。比如， ID 唯一递增生成器的例子，用静态方法实现一下，就是下面这个样子：\n\n```java\n// 静态方法实现方式\npublic class IdGenerator {\n  private static AtomicLong id = new AtomicLong(0);\n  \n  public static long getId() { \n    return id.incrementAndGet();\n  }\n}\n// 使用举例\nlong id = IdGenerator.getId();\n```\n\n不过，静态方法这种实现思路，并不能解决我们之前提到的问题。实际上，它比单例更加不灵活，比如，它无法支持延迟加载。我们再来看看有没有其他办法。实际上，单例除了我们之前讲到的使用方法之外，还有另外一种使用方法。具体的代码如下所示：\n\n```java\n// 1. 老的使用方式\npublic demofunction() {\n  //...\n  long id = IdGenerator.getInstance().getId();\n  //...\n}\n\n// 2. 新的使用方式：依赖注入\npublic demofunction(IdGenerator idGenerator) {\n  long id = idGenerator.getId();\n}\n// 外部调用demofunction()的时候，传入idGenerator\nIdGenerator idGenerator = IdGenerator.getInsance();\ndemofunction(idGenerator);\n```\n\n\n\n1. 基于新的使用方式，我们将单例生成的对象，作为参数传递给函数（也可以通过构造函数传递给类的成员变量），可以解决单例隐藏类之间依赖关系的问题。不过，对于单例存在的其他问题，比如对 OOP 特性、扩展性、可测性不友好等问题，还是无法解决。\n2. 所以，如果要完全解决这些问题，我们可能要从根上，寻找其他方式来实现全局唯一类。实际上，类对象的全局唯一性可以通过多种不同的方式来保证。我们既可以通过单例模式来强制保证，也可以通过工厂模式、IOC 容器（比如 Spring IOC 容器）来保证，还可以通过程序员自己来保证（自己在编写代码的时候自己保证不要创建两个类对象）。这就类似 Java 中内存对象的释放由 JVM 来负责，而 C++ 中由程序员自己负责，道理是一样的。\n3. 对于替代方案工厂模式、IOC 容器的详细讲解，我们放到后面讲解。\n\n\n\n## 如何理解单例模式中的唯一性？\n\n1. 首先，我们重新看一下单例的定义：“一个类只允许创建唯一一个对象（或者实例），那这个类就是一个单例类，这种设计模式就叫作单例设计模式，简称单例模式。\n2. ”定义中提到，“一个类只允许创建唯一一个对象”。那对象的唯一性的作用范围是什么呢？是指线程内只允许创建一个对象，还是指进程内只允许创建一个对象？答案是后者，也就是说，单例模式创建的对象是进程唯一的。这里有点不好理解，我来详细地解释一下。\n3. 我们编写的代码，通过编译、链接，组织在一起，就构成了一个操作系统可以执行的文件，也就是我们平时所说的“可执行文件”（比如 Windows 下的 exe 文件）。可执行文件实际上就是代码被翻译成操作系统可理解的一组指令，你完全可以简单地理解为就是代码本身。\n4. 当我们使用命令行或者双击运行这个可执行文件的时候，操作系统会启动一个进程，将这个执行文件从磁盘加载到自己的进程地址空间（可以理解操作系统为进程分配的内存存储区，用来存储代码和数据）。接着，进程就一条一条地执行可执行文件中包含的代码。比如，当进程读到代码中的 User user = new User(); 这条语句的时候，它就在自己的地址空间中创建一个 user 临时变量和一个 User 对象。进程之间是不共享地址空间的，如果我们在一个进程中创建另外一个进程（比如，代码中有一个 fork() 语句，进程执行到这条语句的时候会创建一个新的进程），操作系统会给新进程分配新的地址空间，并且将老进程地址空间的所有内容，重新拷贝一份到新进程的地址空间中，这些内容包括代码、数据（比如 user 临时变量、User 对象）。\n5. 所以，单例类在老进程中存在且只能存在一个对象，在新进程中也会存在且只能存在一个对象。而且，这两个对象并不是同一个对象，这也就说，单例类中对象的唯一性的作用范围是进程内的，在进程间是不唯一的。\n\n\n\n## 如何实现线程唯一的单例？\n\n1. 刚刚我们讲了单例类对象是进程唯一的，一个进程只能有一个单例对象。那如何实现一个线程唯一的单例呢？\n\n2. 我们先来看一下，什么是线程唯一的单例，以及“线程唯一”和“进程唯一”的区别。\n\n3. “进程唯一”指的是进程内唯一，进程间不唯一。类比一下，“线程唯一”指的是线程内唯一，线程间可以不唯一。实际上，“进程唯一”还代表了线程内、线程间都唯一，这也是“进程唯一”和“线程唯一”的区别之处。这段话听起来有点像绕口令，我举个例子来解释一下。\n\n4. 假设 IdGenerator 是一个线程唯一的单例类。在线程 A 内，我们可以创建一个单例对象 a。因为线程内唯一，在线程 A 内就不能再创建新的 IdGenerator 对象了，而线程间可以不唯一，所以，在另外一个线程 B 内，我们还可以重新创建一个新的单例对象 b。\n\n5. 尽管概念理解起来比较复杂，但线程唯一单例的代码实现很简单，如下所示。在代码中，我们通过一个 HashMap 来存储对象，其中 key 是线程 ID，value 是对象。这样我们就可以做到，不同的线程对应不同的对象，同一个线程只能对应一个对象。实际上，Java 语言本身提供了 ThreadLocal 工具类，可以更加轻松地实现线程唯一单例。不过，ThreadLocal 底层实现原理也是基于下面代码中所示的 HashMap。\n\n   \n\n```java\npublic class IdGenerator {\n  private AtomicLong id = new AtomicLong(0);\n\n  private static final ConcurrentHashMap<Long, IdGenerator> instances\n          = new ConcurrentHashMap<>();\n\n  private IdGenerator() {}\n\n  public static IdGenerator getInstance() {\n    Long currentThreadId = Thread.currentThread().getId();\n    instances.putIfAbsent(currentThreadId, new IdGenerator());\n    return instances.get(currentThreadId);\n  }\n\n  public long getId() {\n    return id.incrementAndGet();\n  }\n}\n```\n\n\n\n\n\n## 如何实现集群环境下的单例？\n\n1. 刚刚我们讲了“进程唯一”的单例和“线程唯一”的单例，现在，我们再来看下，“集群唯一”的单例。\n2. 首先，我们还是先来解释一下，什么是“集群唯一”的单例。\n3. 我们还是将它跟“进程唯一”“线程唯一”做个对比。“进程唯一”指的是进程内唯一、进程间不唯一。“线程唯一”指的是线程内唯一、线程间不唯一。集群相当于多个进程构成的一个集合，“集群唯一”就相当于是进程内唯一、进程间也唯一。也就是说，不同的进程间共享同一个对象，不能创建同一个类的多个对象。\n4. 我们知道，经典的单例模式是进程内唯一的，那如何实现一个进程间也唯一的单例呢？如果严格按照不同的进程间共享同一个对象来实现，那集群唯一的单例实现起来就有点难度了。\n5. 具体来说，我们需要把这个单例对象序列化并存储到外部共享存储区（比如文件）。进程在使用这个单例对象的时候，需要先从外部共享存储区中将它读取到内存，并反序列化成对象，然后再使用，使用完成之后还需要再存储回外部共享存储区。\n6. 为了保证任何时刻，在进程间都只有一份对象存在，一个进程在获取到对象之后，需要对对象加锁，避免其他进程再将其获取。在进程使用完这个对象之后，还需要显式地将对象从内存中删除，并且释放对对象的加锁。按照这个思路，\n7. 我用伪代码实现了一下这个过程，具体如下所示：\n\n```java\npublic class IdGenerator {\n  private AtomicLong id = new AtomicLong(0);\n  private static IdGenerator instance;\n  private static SharedObjectStorage storage = FileSharedObjectStorage(/*入参省略，比如文件地址*/);\n  private static DistributedLock lock = new DistributedLock();\n  \n  private IdGenerator() {}\n\n  public synchronized static IdGenerator getInstance() \n    if (instance == null) {\n      lock.lock();\n      instance = storage.load(IdGenerator.class);\n    }\n    return instance;\n  }\n  \n  public synchroinzed void freeInstance() {\n    storage.save(this, IdGeneator.class);\n    instance = null; //释放对象\n    lock.unlock();\n  }\n  \n  public long getId() { \n    return id.incrementAndGet();\n  }\n}\n\n// IdGenerator使用举例\nIdGenerator idGeneator = IdGenerator.getInstance();\nlong id = idGenerator.getId();\nIdGenerator.freeInstance();\n```\n\n\n\n## 如何实现一个多例模式？\n\n跟单例模式概念相对应的还有一个多例模式。那如何实现一个多例模式呢？“单例”指的是，一个类只能创建一个对象。对应地，“多例”指的就是，一个类可以创建多个对象，但是个数是有限制的，比如只能创建 3 个对象。如果用代码来简单示例一下的话，就是下面这个样子：\n\n```java\npublic class BackendServer {\n  private long serverNo;\n  private String serverAddress;\n\n  private static final int SERVER_COUNT = 3;\n  private static final Map<Long, BackendServer> serverInstances = new HashMap<>();\n\n  static {\n    serverInstances.put(1L, new BackendServer(1L, \"192.134.22.138:8080\"));\n    serverInstances.put(2L, new BackendServer(2L, \"192.134.22.139:8080\"));\n    serverInstances.put(3L, new BackendServer(3L, \"192.134.22.140:8080\"));\n  }\n\n  private BackendServer(long serverNo, String serverAddress) {\n    this.serverNo = serverNo;\n    this.serverAddress = serverAddress;\n  }\n\n  public BackendServer getInstance(long serverNo) {\n    return serverInstances.get(serverNo);\n  }\n\n  public BackendServer getRandomInstance() {\n    Random r = new Random();\n    int no = r.nextInt(SERVER_COUNT)+1;\n    return serverInstances.get(no);\n  }\n}\n```\n\n\n\n实际上，对于多例模式，还有一种理解方式：同一类型的只能创建一个对象，不同类型的可以创建多个对象。这里的“类型”如何理解呢？我们还是通过一个例子来解释一下，具体代码如下所示。在代码中，logger name 就是刚刚说的“类型”，同一个 logger name 获取到的对象实例是相同的，不同的 logger name 获取到的对象实例是不同的。\n\n```java\npublic class Logger {\n  private static final ConcurrentHashMap<String, Logger> instances\n          = new ConcurrentHashMap<>();\n\n  private Logger() {}\n\n  public static Logger getInstance(String loggerName) {\n    instances.putIfAbsent(loggerName, new Logger());\n    return instances.get(loggerName);\n  }\n\n  public void log() {\n    //...\n  }\n}\n\n//l1==l2, l1!=l3\nLogger l1 = Logger.getInstance(\"User.class\");\nLogger l2 = Logger.getInstance(\"User.class\");\nLogger l3 = Logger.getInstance(\"Order.class\");\n```\n\n\n\n这种多例模式的理解方式有点类似工厂模式。它跟工厂模式的不同之处是，多例模式创建的对象都是同一个类的对象，而工厂模式创建的是不同子类的对象，关于这一点，后面就会讲到。实际上，它还有点类似享元模式，两者的区别等到我们讲到享元模式的时候再来分析。除此之外，实际上，枚举类型也相当于多例模式，一个类型只能对应一个对象，一个类可以创建多个对象。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"2024-05-11-设计模式-03.01-创建型-单例","published":1,"updated":"2024-05-11T14:06:48.257Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cly2c4k3z001oqsvde8fb61mu","content":"<h1 id=\"声明\"><a href=\"#声明\" class=\"headerlink\" title=\"声明\"></a>声明</h1><blockquote>\n<ol>\n<li>此系列文章非本人原创，是学习笔记。</li>\n<li>设计模式系列以后会持续更新，包括已经发布的设计模式文章，因为后续还要再多看一下书，教程和开源项目等，继续润色文章。</li>\n</ol>\n</blockquote>\n<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>23 种经典的设计模式。它们又可以分为三大类：创建型、结构型、行为型。对于这 23 种设计模式的学习，我们要有侧重点，因为有些模式是比较常用的，有些模式是很少被用到的。对于常用的设计模式，我们要花多点时间理解掌握。对于不常用的设计模式，我们只需要稍微了解即可。按照类型和是否常用，对这些设计模式，进行了简单的分类，具体如下所示。</p>\n<h3 id=\"创建型\"><a href=\"#创建型\" class=\"headerlink\" title=\"创建型\"></a>创建型</h3><p>常用的有：单例模式、工厂模式（工厂方法和抽象工厂）、建造者模式。</p>\n<p>不常用的有：原型模式。</p>\n<h3 id=\"结构型\"><a href=\"#结构型\" class=\"headerlink\" title=\"结构型\"></a>结构型</h3><p>常用的有：代理模式、桥接模式、装饰者模式、适配器模式。</p>\n<p>不常用的有：门面模式、组合模式、享元模式。 </p>\n<h3 id=\"行为型\"><a href=\"#行为型\" class=\"headerlink\" title=\"行为型\"></a>行为型</h3><p>常用的有：观察者模式、模板模式、策略模式、职责链模式、迭代器模式、状态模式。</p>\n<p>不常用的有：访问者模式、备忘录模式、命令模式、解释器模式、中介模式。</p>\n<h1 id=\"单例模式【常用】\"><a href=\"#单例模式【常用】\" class=\"headerlink\" title=\"单例模式【常用】\"></a>单例模式【常用】</h1><p>网上有很多讲解单例模式的文章，但大部分都侧重讲解，如何来实现一个线程安全的单例。今天也会讲到各种单例的实现方法，但是，重点还是希望带你搞清楚下面这样几个问题。</p>\n<ul>\n<li>为什么要使用单例？</li>\n<li>单例存在哪些问题？</li>\n<li>单例与静态类的区别？</li>\n<li>有何替代的解决方案？</li>\n</ul>\n<h2 id=\"为什么要使用单例？\"><a href=\"#为什么要使用单例？\" class=\"headerlink\" title=\"为什么要使用单例？\"></a>为什么要使用单例？</h2><p>单例设计模式（Singleton Design Pattern）理解起来非常简单。一个类只允许创建一个对象（或者实例），那这个类就是一个单例类，这种设计模式就叫作单例设计模式，简称单例模式。</p>\n<p>对于单例的概念，我觉得没必要解释太多，你一看就能明白。我们重点看一下，为什么我们需要单例这种设计模式？它能解决哪些问题？接下来我通过两个实战案例来讲解。</p>\n<h3 id=\"实战案例一：处理资源访问冲突\"><a href=\"#实战案例一：处理资源访问冲突\" class=\"headerlink\" title=\"实战案例一：处理资源访问冲突\"></a>实战案例一：处理资源访问冲突</h3><p>我们先来看第一个例子。在这个例子中，我们自定义实现了一个往文件中打印日志的 Logger 类。具体的代码实现如下所示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Logger</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> FileWriter writer;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"title function_\">Logger</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">File</span> <span class=\"variable\">file</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">File</span>(<span class=\"string\">&quot;/Users/wangzheng/log.txt&quot;</span>);</span><br><span class=\"line\">    writer = <span class=\"keyword\">new</span> <span class=\"title class_\">FileWriter</span>(file, <span class=\"literal\">true</span>); <span class=\"comment\">//true表示追加写入</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">log</span><span class=\"params\">(String message)</span> &#123;</span><br><span class=\"line\">    writer.write(message);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Logger类的应用示例：</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">UserController</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"type\">Logger</span> <span class=\"variable\">logger</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Logger</span>();</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">login</span><span class=\"params\">(String username, String password)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...省略业务逻辑代码...</span></span><br><span class=\"line\">    logger.log(username + <span class=\"string\">&quot; logined!&quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">OrderController</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"type\">Logger</span> <span class=\"variable\">logger</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Logger</span>();</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">create</span><span class=\"params\">(OrderVo order)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...省略业务逻辑代码...</span></span><br><span class=\"line\">    logger.log(<span class=\"string\">&quot;Created an order: &quot;</span> + order.toString());</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在上面的代码中，我们注意到，所有的日志都写入到同一个文件 &#x2F;Users&#x2F;wangzheng&#x2F;log.txt 中。在 UserController 和 OrderController 中，我们分别创建两个 Logger 对象。在 Web 容器的 Servlet 多线程环境下，如果两个 Servlet 线程同时分别执行 login() 和 create() 两个函数，并且同时写日志到 log.txt 文件中，那就有可能存在日志信息互相覆盖的情况。【这属于并发的知识点，看不懂的可以看笔者的并发系列】</p>\n<p>那如何来解决这个问题呢？我们最先想到的就是通过加锁的方式：给 log() 函数加互斥锁，同一时刻只允许一个线程调用执行 log() 函数。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Logger</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> FileWriter writer;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"title function_\">Logger</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">File</span> <span class=\"variable\">file</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">File</span>(<span class=\"string\">&quot;/Users/wangzheng/log.txt&quot;</span>);</span><br><span class=\"line\">    writer = <span class=\"keyword\">new</span> <span class=\"title class_\">FileWriter</span>(file, <span class=\"literal\">true</span>); <span class=\"comment\">//true表示追加写入</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">log</span><span class=\"params\">(String message)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span>(<span class=\"built_in\">this</span>) &#123;</span><br><span class=\"line\">      writer.write(mesasge);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>synchronized(this)</code>这种对象级别的锁，锁不住，因为不同的对象之间并不共享同一把锁。所以我们换成类级别的锁。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Logger</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> FileWriter writer;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"title function_\">Logger</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">File</span> <span class=\"variable\">file</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">File</span>(<span class=\"string\">&quot;/Users/wangzheng/log.txt&quot;</span>);</span><br><span class=\"line\">    writer = <span class=\"keyword\">new</span> <span class=\"title class_\">FileWriter</span>(file, <span class=\"literal\">true</span>); <span class=\"comment\">//true表示追加写入</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">log</span><span class=\"params\">(String message)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span>(Logger.class) &#123; <span class=\"comment\">// 类级别的锁</span></span><br><span class=\"line\">      writer.write(mesasge);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>除了使用类级别锁之外，实际上，解决资源竞争问题的办法还有很多，分布式锁是最常听到的一种解决方案。不过，实现一个安全可靠、无 bug、高性能的分布式锁，并不是件容易的事情。除此之外，并发队列（比如 Java 中的 BlockingQueue）也可以解决这个问题：多个线程同时往并发队列里写日志，一个单独的线程负责将并发队列中的数据，写入到日志文件。这种方式实现起来也稍微有点复杂。</p>\n<p>相对于这两种解决方案，单例模式的解决思路就简单一些了。单例模式相对于之前类级别锁的好处是，不用创建那么多 Logger 对象，一方面节省内存空间，另一方面节省系统文件句柄（对于操作系统来说，文件句柄也是一种资源，不能随便浪费）。</p>\n<p>我们将 Logger 设计成一个单例类，程序中只允许创建一个 Logger 对象，所有的线程共享使用的这一个 Logger 对象，共享一个 FileWriter 对象，而 FileWriter 本身是对象级别线程安全的，也就避免了多线程情况下写日志会互相覆盖的问题。按照这个设计思路，我们实现了 Logger 单例类。具体代码如下所示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Logger</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> FileWriter writer;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">Logger</span> <span class=\"variable\">instance</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Logger</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"title function_\">Logger</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">File</span> <span class=\"variable\">file</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">File</span>(<span class=\"string\">&quot;/Users/wangzheng/log.txt&quot;</span>);</span><br><span class=\"line\">    writer = <span class=\"keyword\">new</span> <span class=\"title class_\">FileWriter</span>(file, <span class=\"literal\">true</span>); <span class=\"comment\">//true表示追加写入</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Logger <span class=\"title function_\">getInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">log</span><span class=\"params\">(String message)</span> &#123;</span><br><span class=\"line\">    writer.write(mesasge);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Logger类的应用示例：</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">UserController</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">login</span><span class=\"params\">(String username, String password)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...省略业务逻辑代码...</span></span><br><span class=\"line\">    Logger.getInstance().log(username + <span class=\"string\">&quot; logined!&quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">OrderController</span> &#123;  </span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">create</span><span class=\"params\">(OrderVo order)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...省略业务逻辑代码...</span></span><br><span class=\"line\">    Logger.getInstance().log(<span class=\"string\">&quot;Created a order: &quot;</span> + order.toString());</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"实战案例二：表示全局唯一类\"><a href=\"#实战案例二：表示全局唯一类\" class=\"headerlink\" title=\"实战案例二：表示全局唯一类\"></a>实战案例二：表示全局唯一类</h3><p>从业务概念上，如果有些数据在系统中只应保存一份，那就比较适合设计为单例类。比如，配置信息类。在系统中，我们只有一个配置文件，当配置文件被加载到内存之后，以对象的形式存在，也理所应当只有一份。</p>\n<p>再比如，唯一递增 ID 号码生成器。如果程序中有两个对象，那就会存在生成重复 ID 的情况，所以，我们应该将 ID 生成器类设计为单例。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">IdGenerator</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// AtomicLong是一个Java并发库中提供的一个原子变量类型,</span></span><br><span class=\"line\">  <span class=\"comment\">// 它将一些线程不安全需要加锁的复合操作封装为了线程安全的原子操作，</span></span><br><span class=\"line\">  <span class=\"comment\">// 比如下面会用到的incrementAndGet().</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"type\">AtomicLong</span> <span class=\"variable\">id</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">AtomicLong</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">IdGenerator</span> <span class=\"variable\">instance</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IdGenerator</span>();</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"title function_\">IdGenerator</span><span class=\"params\">()</span> &#123;&#125;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> IdGenerator <span class=\"title function_\">getInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"type\">long</span> <span class=\"title function_\">getId</span><span class=\"params\">()</span> &#123; </span><br><span class=\"line\">    <span class=\"keyword\">return</span> id.incrementAndGet();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// IdGenerator使用举例</span></span><br><span class=\"line\"><span class=\"type\">long</span> <span class=\"variable\">id</span> <span class=\"operator\">=</span> IdGenerator.getInstance().getId();</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"如何实现一个单例？\"><a href=\"#如何实现一个单例？\" class=\"headerlink\" title=\"如何实现一个单例？\"></a>如何实现一个单例？</h2><p>尽管介绍如何实现一个单例模式的文章已经有很多了，但为了保证内容的完整性，我这里还是简单介绍一下几种经典实现方式。概括起来，要实现一个单例，我们需要关注的点无外乎下面几个：</p>\n<ul>\n<li><p>构造函数需要是 private 访问权限的，这样才能避免外部通过 new 创建实例；</p>\n</li>\n<li><p>考虑对象创建时的线程安全问题；</p>\n</li>\n<li><p>考虑是否支持延迟加载；</p>\n</li>\n<li><p>考虑 getInstance() 性能是否高（是否加锁）。</p>\n</li>\n</ul>\n<h3 id=\"饿汉式-静态变量\"><a href=\"#饿汉式-静态变量\" class=\"headerlink\" title=\"饿汉式(静态变量)\"></a>饿汉式(静态变量)</h3><p>饿汉式的实现方式比较简单。在类加载的时候，instance 静态实例就已经创建并初始化好了，所以，instance 实例的创建过程是线程安全的。不过，这样的实现方式不支持延迟加载（在真正用到 IdGenerator 的时候，再创建实例），从名字中我们也可以看出这一点。具体的代码实现如下所示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">IdGenerator</span> &#123; </span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"type\">AtomicLong</span> <span class=\"variable\">id</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">AtomicLong</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">IdGenerator</span> <span class=\"variable\">instance</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IdGenerator</span>();</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"title function_\">IdGenerator</span><span class=\"params\">()</span> &#123;&#125;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> IdGenerator <span class=\"title function_\">getInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"type\">long</span> <span class=\"title function_\">getId</span><span class=\"params\">()</span> &#123; </span><br><span class=\"line\">    <span class=\"keyword\">return</span> id.incrementAndGet();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<ol>\n<li>有人觉得这种实现方式不好，因为不支持延迟加载，如果实例占用资源多（比如占用内存多）或初始化耗时长（比如需要加载各种配置文件），提前初始化实例是一种浪费资源的行为。最好的方法应该在用到的时候再去初始化。不过，我个人并不认同这样的观点</li>\n<li>如果初始化耗时长，那我们最好不要等到真正要用它的时候，才去执行这个耗时长的初始化过程，这会影响到系统的性能（比如，在响应客户端接口请求的时候，做这个初始化操作，会导致此请求的响应时间变长，甚至超时）。采用饿汉式实现方式，将耗时的初始化操作，提前到程序启动的时候完成，这样就能避免在程序运行的时候，再去初始化导致的性能问题。</li>\n<li>如果实例占用资源多，按照 fail-fast 的设计原则（有问题及早暴露），那我们也希望在程序启动时就将这个实例初始化好。如果资源不够，就会在程序启动的时候触发报错（比如 Java 中的 PermGen Space OOM），我们可以立即去修复。这样也能避免在程序运行一段时间后，突然因为初始化这个实例占用资源过多，导致系统崩溃，影响系统的可用性。(如果初始化消耗资源过多，反而推荐懒汉式，早日发现问题)</li>\n</ol>\n<h3 id=\"饿汉式-静态代码块\"><a href=\"#饿汉式-静态代码块\" class=\"headerlink\" title=\"饿汉式(静态代码块)\"></a>饿汉式(静态代码块)</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">SingletonTest02</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 测试</span></span><br><span class=\"line\">    <span class=\"type\">Singleton</span> <span class=\"variable\">instance</span> <span class=\"operator\">=</span> Singleton.getInstance();</span><br><span class=\"line\">    <span class=\"type\">Singleton</span> <span class=\"variable\">instance2</span> <span class=\"operator\">=</span> Singleton.getInstance();</span><br><span class=\"line\">    System.out.println(instance == instance2); <span class=\"comment\">// true</span></span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;instance.hashCode=&quot;</span> + instance.hashCode());</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;instance2.hashCode=&quot;</span> + instance2.hashCode());</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 饿汉式(静态变量)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Singleton</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 1. 构造器私有化</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"title function_\">Singleton</span><span class=\"params\">()</span> &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 2.本类内部创建对象实例</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Singleton instance;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">static</span> &#123; <span class=\"comment\">// 在静态代码块中，创建单例对象</span></span><br><span class=\"line\">    instance = <span class=\"keyword\">new</span> <span class=\"title class_\">Singleton</span>();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 3. 提供一个公有的静态方法，返回实例对象</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title function_\">getInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>没什么好说的，就是静态变量换成了静态代码块。</p>\n<h3 id=\"懒汉式-线程安全，同步方法\"><a href=\"#懒汉式-线程安全，同步方法\" class=\"headerlink\" title=\"懒汉式(线程安全，同步方法)\"></a>懒汉式(线程安全，同步方法)</h3><p>懒汉式相对于饿汉式的优势是支持延迟加载。具体的代码实现如下所示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">IdGenerator</span> &#123; </span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"type\">AtomicLong</span> <span class=\"variable\">id</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">AtomicLong</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> IdGenerator instance;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"title function_\">IdGenerator</span><span class=\"params\">()</span> &#123;&#125;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">synchronized</span> IdGenerator <span class=\"title function_\">getInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (instance == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      instance = <span class=\"keyword\">new</span> <span class=\"title class_\">IdGenerator</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"type\">long</span> <span class=\"title function_\">getId</span><span class=\"params\">()</span> &#123; </span><br><span class=\"line\">    <span class=\"keyword\">return</span> id.incrementAndGet();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>不过懒汉式的缺点也很明显，我们给 getInstance() 这个方法加了一把大锁（synchronzed），导致这个函数的并发度很低。而这个函数是在单例使用期间，一直会被调用。如果这个单例类偶尔会被用到，那这种实现方式还可以接受。但是，如果频繁地用到，那频繁加锁、释放锁及并发度低等问题，会导致性能瓶颈，这种实现方式就不可取了。</p>\n<h3 id=\"懒汉式-线程安全，同步代码块\"><a href=\"#懒汉式-线程安全，同步代码块\" class=\"headerlink\" title=\"懒汉式(线程安全，同步代码块)\"></a>懒汉式(线程安全，同步代码块)</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 懒汉式(线程安全，同步代码块)</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Singleton</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Singleton instance;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"title function_\">Singleton</span><span class=\"params\">()</span> &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title function_\">getInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (instance == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">synchronized</span> (Singleton.class) &#123;</span><br><span class=\"line\">        instance = <span class=\"keyword\">new</span> <span class=\"title class_\">Singleton</span>();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"懒汉式-线程不安全\"><a href=\"#懒汉式-线程不安全\" class=\"headerlink\" title=\"懒汉式(线程不安全)\"></a>懒汉式(线程不安全)</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Singleton</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Singleton instance;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"title function_\">Singleton</span><span class=\"params\">()</span> &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 提供一个静态的公有方法，当使用到该方法时，才去创建 instance</span></span><br><span class=\"line\">  <span class=\"comment\">// 即懒汉式</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title function_\">getInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (instance == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      instance = <span class=\"keyword\">new</span> <span class=\"title class_\">Singleton</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n<p>只是为了完整性，写了出来，实际开发不推荐用线程不安全的</p>\n<h3 id=\"双重检测\"><a href=\"#双重检测\" class=\"headerlink\" title=\"双重检测\"></a>双重检测</h3><p>饿汉式不支持延迟加载，懒汉式有性能问题，不支持高并发。那我们再来看一种既支持延迟加载、又支持高并发的单例实现方式，也就是双重检测实现方式。在这种实现方式中，只要 instance 被创建之后，即便再调用 getInstance() 函数也不会再进入到加锁逻辑中了。所以，这种实现方式解决了懒汉式并发度低的问题。具体的代码实现如下所示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">IdGenerator</span> &#123; </span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"type\">AtomicLong</span> <span class=\"variable\">id</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">AtomicLong</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> IdGenerator instance;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"title function_\">IdGenerator</span><span class=\"params\">()</span> &#123;&#125;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> IdGenerator <span class=\"title function_\">getInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (instance == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">synchronized</span>(IdGenerator.class) &#123; <span class=\"comment\">// 此处为类级别的锁</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (instance == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">          instance = <span class=\"keyword\">new</span> <span class=\"title class_\">IdGenerator</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"type\">long</span> <span class=\"title function_\">getId</span><span class=\"params\">()</span> &#123; </span><br><span class=\"line\">    <span class=\"keyword\">return</span> id.incrementAndGet();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>这种实现方式有些问题。因为指令重排序，可能会导致 IdGenerator 对象被 new 出来，并且赋值给 instance 之后，还没来得及初始化（执行构造函数中的代码逻辑），就被另一个线程使用了。要解决这个问题，我们需要给 instance 成员变量加上 volatile 关键字，禁止指令重排序才行。</p>\n<p>据说，只有很低版本的 Java 才会有这个问题。我们现在用的高版本的 Java 已经在 JDK 内部实现中解决了这个问题（解决的方法很简单，只要把对象 new 操作和初始化操作设计为原子操作，就自然能禁止重排序）。</p>\n<h3 id=\"静态内部类\"><a href=\"#静态内部类\" class=\"headerlink\" title=\"静态内部类\"></a>静态内部类</h3><p>我们再来看一种比双重检测更加简单的实现方法，那就是利用 Java 的静态内部类。它有点类似饿汉式，但又能做到了延迟加载。具体是怎么做到的呢？我们先来看它的代码实现</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">IdGenerator</span> &#123; </span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"type\">AtomicLong</span> <span class=\"variable\">id</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">AtomicLong</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"title function_\">IdGenerator</span><span class=\"params\">()</span> &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">SingletonHolder</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">IdGenerator</span> <span class=\"variable\">instance</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IdGenerator</span>();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> IdGenerator <span class=\"title function_\">getInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> SingletonHolder.instance;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"type\">long</span> <span class=\"title function_\">getId</span><span class=\"params\">()</span> &#123; </span><br><span class=\"line\">    <span class=\"keyword\">return</span> id.incrementAndGet();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>SingletonHolder 是一个静态内部类，当外部类 IdGenerator 被加载的时候，并不会创建 SingletonHolder 实例对象。只有当调用 getInstance() 方法时，SingletonHolder 才会被加载，这个时候才会创建 instance。instance 的唯一性、创建过程的线程安全性，都由 JVM 来保证。所以，这种实现方法既保证了线程安全，又能做到延迟加载。</p>\n<h3 id=\"枚举\"><a href=\"#枚举\" class=\"headerlink\" title=\"枚举\"></a>枚举</h3><p>最后，我们介绍一种最简单的实现方式，基于枚举类型的单例实现。这种实现方式通过 Java 枚举类型本身的特性，保证了实例创建的线程安全性和实例的唯一性。具体的代码如下所示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">enum</span> <span class=\"title class_\">IdGenerator</span> &#123;</span><br><span class=\"line\">  INSTANCE;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"type\">AtomicLong</span> <span class=\"variable\">id</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">AtomicLong</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"type\">long</span> <span class=\"title function_\">getId</span><span class=\"params\">()</span> &#123; </span><br><span class=\"line\">    <span class=\"keyword\">return</span> id.incrementAndGet();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"单例存在哪些问题\"><a href=\"#单例存在哪些问题\" class=\"headerlink\" title=\"单例存在哪些问题?\"></a>单例存在哪些问题?</h2><p>尽管单例是一个很常用的设计模式，在实际的开发中，我们也确实经常用到它，但是，有些人认为单例是一种反模式（anti-pattern），并不推荐使用。大部分情况下，我们在项目中使用单例，都是用它来表示一些全局唯一类，比如配置信息类、连接池类、ID 生成器类。单例模式书写简洁、使用方便，在代码中，我们不需要创建对象，直接通过类似 IdGenerator.getInstance().getId() 这样的方法来调用就可以了。但是，这种使用方法有点类似硬编码（hard code），会带来诸多问题。接下来，我们就具体看看到底有哪些问题。</p>\n<h3 id=\"单例对-OOP-特性的支持不友好\"><a href=\"#单例对-OOP-特性的支持不友好\" class=\"headerlink\" title=\"单例对 OOP 特性的支持不友好\"></a>单例对 OOP 特性的支持不友好</h3><p>我们知道，OOP 的四大特性是封装、抽象、继承、多态。单例这种设计模式对于其中的抽象、继承、多态都支持得不好。为什么这么说呢？我们还是通过 IdGenerator 这个例子来讲解。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Order</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">create</span><span class=\"params\">(...)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"variable\">id</span> <span class=\"operator\">=</span> IdGenerator.getInstance().getId();</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">User</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">create</span><span class=\"params\">(...)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"variable\">id</span> <span class=\"operator\">=</span> IdGenerator.getInstance().getId();</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>IdGenerator 的使用方式违背了基于接口而非实现的设计原则，也就违背了广义上理解的 OOP 的抽象特性。如果未来某一天，我们希望针对不同的业务采用不同的 ID 生成算法。比如，订单 ID 和用户 ID 采用不同的 ID 生成器来生成。为了应对这个需求变化，我们需要修改所有用到 IdGenerator 类的地方，这样代码的改动就会比较大。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Order</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">create</span><span class=\"params\">(...)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"variable\">id</span> <span class=\"operator\">=</span> IdGenerator.getInstance().getId();</span><br><span class=\"line\">    <span class=\"comment\">// 需要将上面一行代码，替换为下面一行代码</span></span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"variable\">id</span> <span class=\"operator\">=</span> OrderIdGenerator.getIntance().getId();</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">User</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">create</span><span class=\"params\">(...)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"variable\">id</span> <span class=\"operator\">=</span> IdGenerator.getInstance().getId();</span><br><span class=\"line\">    <span class=\"comment\">// 需要将上面一行代码，替换为下面一行代码</span></span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"variable\">id</span> <span class=\"operator\">=</span> UserIdGenerator.getIntance().getId();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>除此之外，单例对继承、多态特性的支持也不友好。这里我之所以会用“不友好”这个词，而非“完全不支持”，是因为从理论上来讲，单例类也可以被继承、也可以实现多态，只是实现起来会非常奇怪，会导致代码的可读性变差。不明白设计意图的人，看到这样的设计，会觉得莫名其妙。所以，一旦你选择将某个类设计成到单例类，也就意味着放弃了继承和多态这两个强有力的面向对象特性，也就相当于损失了可以应对未来需求变化的扩展性</p>\n<h3 id=\"单例会隐藏类之间的依赖关系\"><a href=\"#单例会隐藏类之间的依赖关系\" class=\"headerlink\" title=\"单例会隐藏类之间的依赖关系\"></a>单例会隐藏类之间的依赖关系</h3><p>我们知道，代码的可读性非常重要。在阅读代码的时候，我们希望一眼就能看出类与类之间的依赖关系，搞清楚这个类依赖了哪些外部类。通过构造函数、参数传递等方式声明的类之间的依赖关系，我们通过查看函数的定义，就能很容易识别出来。但是，单例类不需要显示创建、不需要依赖参数传递，在函数中直接调用就可以了。如果代码比较复杂，这种调用关系就会非常隐蔽。在阅读代码的时候，我们就需要仔细查看每个函数的代码实现，才能知道这个类到底依赖了哪些单例类。</p>\n<h3 id=\"单例对代码的扩展性不友好\"><a href=\"#单例对代码的扩展性不友好\" class=\"headerlink\" title=\"单例对代码的扩展性不友好\"></a>单例对代码的扩展性不友好</h3><ol>\n<li>我们知道，单例类只能有一个对象实例。如果未来某一天，我们需要在代码中创建两个实例或多个实例，那就要对代码有比较大的改动。你可能会说，会有这样的需求吗？既然单例类大部分情况下都用来表示全局类，怎么会需要两个或者多个实例呢？</li>\n<li>实际上，这样的需求并不少见。我们拿数据库连接池来举例解释一下。</li>\n<li>在系统设计初期，我们觉得系统中只应该有一个数据库连接池，这样能方便我们控制对数据库连接资源的消耗。所以，我们把数据库连接池类设计成了单例类。但之后我们发现，系统中有些 SQL 语句运行得非常慢。这些 SQL 语句在执行的时候，长时间占用数据库连接资源，导致其他 SQL 请求无法响应。为了解决这个问题，我们希望将慢 SQL 与其他 SQL 隔离开来执行。为了实现这样的目的，我们可以在系统中创建两个数据库连接池，慢 SQL 独享一个数据库连接池，其他 SQL 独享另外一个数据库连接池，这样就能避免慢 SQL 影响到其他 SQL 的执行。</li>\n<li>如果我们将数据库连接池设计成单例类，显然就无法适应这样的需求变更，也就是说，单例类在某些情况下会影响代码的扩展性、灵活性。所以，数据库连接池、线程池这类的资源池，最好还是不要设计成单例类。实际上，一些开源的数据库连接池、线程池也确实没有设计成单例类。</li>\n</ol>\n<h3 id=\"单例对代码的可测试性不友好\"><a href=\"#单例对代码的可测试性不友好\" class=\"headerlink\" title=\"单例对代码的可测试性不友好\"></a>单例对代码的可测试性不友好</h3><ol>\n<li><p>单例模式的使用会影响到代码的可测试性。如果单例类依赖比较重的外部资源，比如 DB，我们在写单元测试的时候，希望能通过 mock 的方式将它替换掉。而单例类这种硬编码式的使用方式，导致无法实现 mock 替换。</p>\n</li>\n<li><p>除此之外，如果单例类持有成员变量（比如 IdGenerator 中的 id 成员变量），那它实际上相当于一种全局变量，被所有的代码共享。如果这个全局变量是一个可变全局变量，也就是说，它的成员变量是可以被修改的，那我们在编写单元测试的时候，还需要注意不同测试用例之间，修改了单例类中的同一个成员变量的值，从而导致测试结果互相影响的问题。</p>\n</li>\n</ol>\n<h3 id=\"单例不支持有参数的构造函数\"><a href=\"#单例不支持有参数的构造函数\" class=\"headerlink\" title=\"单例不支持有参数的构造函数\"></a>单例不支持有参数的构造函数</h3><p>单例不支持有参数的构造函数，比如我们创建一个连接池的单例对象，我们没法通过参数来指定连接池的大小。针对这个问题，我们来看下都有哪些解决方案。</p>\n<p><strong>第一种解决思路是</strong>：创建完实例之后，再调用 init() 函数传递参数。需要注意的是，我们在使用这个单例类的时候，要先调用 init() 方法，然后才能调用 getInstance() 方法，否则代码会抛出异常。具体的代码实现如下所示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Singleton</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">Singleton</span> <span class=\"variable\">instance</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> paramA;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> paramB;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"title function_\">Singleton</span><span class=\"params\">(<span class=\"type\">int</span> paramA, <span class=\"type\">int</span> paramB)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.paramA = paramA;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.paramB = paramB;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title function_\">getInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (instance == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">       <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RuntimeException</span>(<span class=\"string\">&quot;Run init() first.&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">static</span> Singleton <span class=\"title function_\">init</span><span class=\"params\">(<span class=\"type\">int</span> paramA, <span class=\"type\">int</span> paramB)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (instance != <span class=\"literal\">null</span>)&#123;</span><br><span class=\"line\">       <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RuntimeException</span>(<span class=\"string\">&quot;Singleton has been created!&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    instance = <span class=\"keyword\">new</span> <span class=\"title class_\">Singleton</span>(paramA, paramB);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Singleton.init(<span class=\"number\">10</span>, <span class=\"number\">50</span>); <span class=\"comment\">// 先init，再使用</span></span><br><span class=\"line\"><span class=\"type\">Singleton</span> <span class=\"variable\">singleton</span> <span class=\"operator\">=</span> Singleton.getInstance();</span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>第二种解决思路是</strong>：将参数放到 getIntance() 方法中。具体的代码实现如下所示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Singleton</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">Singleton</span> <span class=\"variable\">instance</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> paramA;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> paramB;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"title function_\">Singleton</span><span class=\"params\">(<span class=\"type\">int</span> paramA, <span class=\"type\">int</span> paramB)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.paramA = paramA;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.paramB = paramB;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">static</span> Singleton <span class=\"title function_\">getInstance</span><span class=\"params\">(<span class=\"type\">int</span> paramA, <span class=\"type\">int</span> paramB)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (instance == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      instance = <span class=\"keyword\">new</span> <span class=\"title class_\">Singleton</span>(paramA, paramB);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">Singleton</span> <span class=\"variable\">singleton</span> <span class=\"operator\">=</span> Singleton.getInstance(<span class=\"number\">10</span>, <span class=\"number\">50</span>);</span><br></pre></td></tr></table></figure>\n\n\n\n<p>不知道你有没有发现，上面的代码实现稍微有点问题。如果我们如下两次执行 getInstance() 方法，那获取到的 singleton1 和 signleton2 的 paramA 和 paramB 都是 10 和 50。也就是说，第二次的参数（20，30）没有起作用，而构建的过程也没有给与提示，这样就会误导用户。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Singleton</span> <span class=\"variable\">singleton1</span> <span class=\"operator\">=</span> Singleton.getInstance(<span class=\"number\">10</span>, <span class=\"number\">50</span>);</span><br><span class=\"line\"><span class=\"type\">Singleton</span> <span class=\"variable\">singleton2</span> <span class=\"operator\">=</span> Singleton.getInstance(<span class=\"number\">20</span>, <span class=\"number\">30</span>);</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<p><strong>第三种解决思路是</strong>：将参数放到另外一个全局变量中。具体的代码实现如下。Config 是一个存储了 paramA 和 paramB 值的全局变量。里面的值既可以像下面的代码那样通过静态常量来定义，也可以从配置文件中加载得到。<strong>实际上，这种方式是最值得推荐的。</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Config</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">PARAM_A</span> <span class=\"operator\">=</span> <span class=\"number\">123</span>;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">PARAM_B</span> <span class=\"operator\">=</span> <span class=\"number\">245</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Singleton</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">Singleton</span> <span class=\"variable\">instance</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> paramA;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> paramB;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"title function_\">Singleton</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.paramA = Config.PARAM_A;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.paramB = Config.PARAM_B;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">static</span> Singleton <span class=\"title function_\">getInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (instance == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      instance = <span class=\"keyword\">new</span> <span class=\"title class_\">Singleton</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"有何替代解决方案？\"><a href=\"#有何替代解决方案？\" class=\"headerlink\" title=\"有何替代解决方案？\"></a>有何替代解决方案？</h2><p>刚刚我们提到了单例的很多问题，你可能会说，即便单例有这么多问题，但我不用不行啊。我业务上有表示全局唯一类的需求，如果不用单例，我怎么才能保证这个类的对象全局唯一呢？为了保证全局唯一，除了使用单例，我们还可以用静态方法来实现。这也是项目开发中经常用到的一种实现思路。比如， ID 唯一递增生成器的例子，用静态方法实现一下，就是下面这个样子：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 静态方法实现方式</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">IdGenerator</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">AtomicLong</span> <span class=\"variable\">id</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">AtomicLong</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"type\">long</span> <span class=\"title function_\">getId</span><span class=\"params\">()</span> &#123; </span><br><span class=\"line\">    <span class=\"keyword\">return</span> id.incrementAndGet();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 使用举例</span></span><br><span class=\"line\"><span class=\"type\">long</span> <span class=\"variable\">id</span> <span class=\"operator\">=</span> IdGenerator.getId();</span><br></pre></td></tr></table></figure>\n\n<p>不过，静态方法这种实现思路，并不能解决我们之前提到的问题。实际上，它比单例更加不灵活，比如，它无法支持延迟加载。我们再来看看有没有其他办法。实际上，单例除了我们之前讲到的使用方法之外，还有另外一种使用方法。具体的代码如下所示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 1. 老的使用方式</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"title function_\">demofunction</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">//...</span></span><br><span class=\"line\">  <span class=\"type\">long</span> <span class=\"variable\">id</span> <span class=\"operator\">=</span> IdGenerator.getInstance().getId();</span><br><span class=\"line\">  <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 2. 新的使用方式：依赖注入</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"title function_\">demofunction</span><span class=\"params\">(IdGenerator idGenerator)</span> &#123;</span><br><span class=\"line\">  <span class=\"type\">long</span> <span class=\"variable\">id</span> <span class=\"operator\">=</span> idGenerator.getId();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 外部调用demofunction()的时候，传入idGenerator</span></span><br><span class=\"line\"><span class=\"type\">IdGenerator</span> <span class=\"variable\">idGenerator</span> <span class=\"operator\">=</span> IdGenerator.getInsance();</span><br><span class=\"line\">demofunction(idGenerator);</span><br></pre></td></tr></table></figure>\n\n\n\n<ol>\n<li>基于新的使用方式，我们将单例生成的对象，作为参数传递给函数（也可以通过构造函数传递给类的成员变量），可以解决单例隐藏类之间依赖关系的问题。不过，对于单例存在的其他问题，比如对 OOP 特性、扩展性、可测性不友好等问题，还是无法解决。</li>\n<li>所以，如果要完全解决这些问题，我们可能要从根上，寻找其他方式来实现全局唯一类。实际上，类对象的全局唯一性可以通过多种不同的方式来保证。我们既可以通过单例模式来强制保证，也可以通过工厂模式、IOC 容器（比如 Spring IOC 容器）来保证，还可以通过程序员自己来保证（自己在编写代码的时候自己保证不要创建两个类对象）。这就类似 Java 中内存对象的释放由 JVM 来负责，而 C++ 中由程序员自己负责，道理是一样的。</li>\n<li>对于替代方案工厂模式、IOC 容器的详细讲解，我们放到后面讲解。</li>\n</ol>\n<h2 id=\"如何理解单例模式中的唯一性？\"><a href=\"#如何理解单例模式中的唯一性？\" class=\"headerlink\" title=\"如何理解单例模式中的唯一性？\"></a>如何理解单例模式中的唯一性？</h2><ol>\n<li>首先，我们重新看一下单例的定义：“一个类只允许创建唯一一个对象（或者实例），那这个类就是一个单例类，这种设计模式就叫作单例设计模式，简称单例模式。</li>\n<li>”定义中提到，“一个类只允许创建唯一一个对象”。那对象的唯一性的作用范围是什么呢？是指线程内只允许创建一个对象，还是指进程内只允许创建一个对象？答案是后者，也就是说，单例模式创建的对象是进程唯一的。这里有点不好理解，我来详细地解释一下。</li>\n<li>我们编写的代码，通过编译、链接，组织在一起，就构成了一个操作系统可以执行的文件，也就是我们平时所说的“可执行文件”（比如 Windows 下的 exe 文件）。可执行文件实际上就是代码被翻译成操作系统可理解的一组指令，你完全可以简单地理解为就是代码本身。</li>\n<li>当我们使用命令行或者双击运行这个可执行文件的时候，操作系统会启动一个进程，将这个执行文件从磁盘加载到自己的进程地址空间（可以理解操作系统为进程分配的内存存储区，用来存储代码和数据）。接着，进程就一条一条地执行可执行文件中包含的代码。比如，当进程读到代码中的 User user &#x3D; new User(); 这条语句的时候，它就在自己的地址空间中创建一个 user 临时变量和一个 User 对象。进程之间是不共享地址空间的，如果我们在一个进程中创建另外一个进程（比如，代码中有一个 fork() 语句，进程执行到这条语句的时候会创建一个新的进程），操作系统会给新进程分配新的地址空间，并且将老进程地址空间的所有内容，重新拷贝一份到新进程的地址空间中，这些内容包括代码、数据（比如 user 临时变量、User 对象）。</li>\n<li>所以，单例类在老进程中存在且只能存在一个对象，在新进程中也会存在且只能存在一个对象。而且，这两个对象并不是同一个对象，这也就说，单例类中对象的唯一性的作用范围是进程内的，在进程间是不唯一的。</li>\n</ol>\n<h2 id=\"如何实现线程唯一的单例？\"><a href=\"#如何实现线程唯一的单例？\" class=\"headerlink\" title=\"如何实现线程唯一的单例？\"></a>如何实现线程唯一的单例？</h2><ol>\n<li><p>刚刚我们讲了单例类对象是进程唯一的，一个进程只能有一个单例对象。那如何实现一个线程唯一的单例呢？</p>\n</li>\n<li><p>我们先来看一下，什么是线程唯一的单例，以及“线程唯一”和“进程唯一”的区别。</p>\n</li>\n<li><p>“进程唯一”指的是进程内唯一，进程间不唯一。类比一下，“线程唯一”指的是线程内唯一，线程间可以不唯一。实际上，“进程唯一”还代表了线程内、线程间都唯一，这也是“进程唯一”和“线程唯一”的区别之处。这段话听起来有点像绕口令，我举个例子来解释一下。</p>\n</li>\n<li><p>假设 IdGenerator 是一个线程唯一的单例类。在线程 A 内，我们可以创建一个单例对象 a。因为线程内唯一，在线程 A 内就不能再创建新的 IdGenerator 对象了，而线程间可以不唯一，所以，在另外一个线程 B 内，我们还可以重新创建一个新的单例对象 b。</p>\n</li>\n<li><p>尽管概念理解起来比较复杂，但线程唯一单例的代码实现很简单，如下所示。在代码中，我们通过一个 HashMap 来存储对象，其中 key 是线程 ID，value 是对象。这样我们就可以做到，不同的线程对应不同的对象，同一个线程只能对应一个对象。实际上，Java 语言本身提供了 ThreadLocal 工具类，可以更加轻松地实现线程唯一单例。不过，ThreadLocal 底层实现原理也是基于下面代码中所示的 HashMap。</p>\n</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">IdGenerator</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"type\">AtomicLong</span> <span class=\"variable\">id</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">AtomicLong</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> ConcurrentHashMap&lt;Long, IdGenerator&gt; instances</span><br><span class=\"line\">          = <span class=\"keyword\">new</span> <span class=\"title class_\">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"title function_\">IdGenerator</span><span class=\"params\">()</span> &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> IdGenerator <span class=\"title function_\">getInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">Long</span> <span class=\"variable\">currentThreadId</span> <span class=\"operator\">=</span> Thread.currentThread().getId();</span><br><span class=\"line\">    instances.putIfAbsent(currentThreadId, <span class=\"keyword\">new</span> <span class=\"title class_\">IdGenerator</span>());</span><br><span class=\"line\">    <span class=\"keyword\">return</span> instances.get(currentThreadId);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"type\">long</span> <span class=\"title function_\">getId</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> id.incrementAndGet();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h2 id=\"如何实现集群环境下的单例？\"><a href=\"#如何实现集群环境下的单例？\" class=\"headerlink\" title=\"如何实现集群环境下的单例？\"></a>如何实现集群环境下的单例？</h2><ol>\n<li>刚刚我们讲了“进程唯一”的单例和“线程唯一”的单例，现在，我们再来看下，“集群唯一”的单例。</li>\n<li>首先，我们还是先来解释一下，什么是“集群唯一”的单例。</li>\n<li>我们还是将它跟“进程唯一”“线程唯一”做个对比。“进程唯一”指的是进程内唯一、进程间不唯一。“线程唯一”指的是线程内唯一、线程间不唯一。集群相当于多个进程构成的一个集合，“集群唯一”就相当于是进程内唯一、进程间也唯一。也就是说，不同的进程间共享同一个对象，不能创建同一个类的多个对象。</li>\n<li>我们知道，经典的单例模式是进程内唯一的，那如何实现一个进程间也唯一的单例呢？如果严格按照不同的进程间共享同一个对象来实现，那集群唯一的单例实现起来就有点难度了。</li>\n<li>具体来说，我们需要把这个单例对象序列化并存储到外部共享存储区（比如文件）。进程在使用这个单例对象的时候，需要先从外部共享存储区中将它读取到内存，并反序列化成对象，然后再使用，使用完成之后还需要再存储回外部共享存储区。</li>\n<li>为了保证任何时刻，在进程间都只有一份对象存在，一个进程在获取到对象之后，需要对对象加锁，避免其他进程再将其获取。在进程使用完这个对象之后，还需要显式地将对象从内存中删除，并且释放对对象的加锁。按照这个思路，</li>\n<li>我用伪代码实现了一下这个过程，具体如下所示：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">IdGenerator</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"type\">AtomicLong</span> <span class=\"variable\">id</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">AtomicLong</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> IdGenerator instance;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">SharedObjectStorage</span> <span class=\"variable\">storage</span> <span class=\"operator\">=</span> FileSharedObjectStorage(<span class=\"comment\">/*入参省略，比如文件地址*/</span>);</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">DistributedLock</span> <span class=\"variable\">lock</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">DistributedLock</span>();</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"title function_\">IdGenerator</span><span class=\"params\">()</span> &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">static</span> IdGenerator <span class=\"title function_\">getInstance</span><span class=\"params\">()</span> </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (instance == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      lock.lock();</span><br><span class=\"line\">      instance = storage.load(IdGenerator.class);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">public</span> synchroinzed <span class=\"keyword\">void</span> <span class=\"title function_\">freeInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    storage.save(<span class=\"built_in\">this</span>, IdGeneator.class);</span><br><span class=\"line\">    instance = <span class=\"literal\">null</span>; <span class=\"comment\">//释放对象</span></span><br><span class=\"line\">    lock.unlock();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"type\">long</span> <span class=\"title function_\">getId</span><span class=\"params\">()</span> &#123; </span><br><span class=\"line\">    <span class=\"keyword\">return</span> id.incrementAndGet();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// IdGenerator使用举例</span></span><br><span class=\"line\"><span class=\"type\">IdGenerator</span> <span class=\"variable\">idGeneator</span> <span class=\"operator\">=</span> IdGenerator.getInstance();</span><br><span class=\"line\"><span class=\"type\">long</span> <span class=\"variable\">id</span> <span class=\"operator\">=</span> idGenerator.getId();</span><br><span class=\"line\">IdGenerator.freeInstance();</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"如何实现一个多例模式？\"><a href=\"#如何实现一个多例模式？\" class=\"headerlink\" title=\"如何实现一个多例模式？\"></a>如何实现一个多例模式？</h2><p>跟单例模式概念相对应的还有一个多例模式。那如何实现一个多例模式呢？“单例”指的是，一个类只能创建一个对象。对应地，“多例”指的就是，一个类可以创建多个对象，但是个数是有限制的，比如只能创建 3 个对象。如果用代码来简单示例一下的话，就是下面这个样子：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">BackendServer</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"type\">long</span> serverNo;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> String serverAddress;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">SERVER_COUNT</span> <span class=\"operator\">=</span> <span class=\"number\">3</span>;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Map&lt;Long, BackendServer&gt; serverInstances = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">    serverInstances.put(<span class=\"number\">1L</span>, <span class=\"keyword\">new</span> <span class=\"title class_\">BackendServer</span>(<span class=\"number\">1L</span>, <span class=\"string\">&quot;192.134.22.138:8080&quot;</span>));</span><br><span class=\"line\">    serverInstances.put(<span class=\"number\">2L</span>, <span class=\"keyword\">new</span> <span class=\"title class_\">BackendServer</span>(<span class=\"number\">2L</span>, <span class=\"string\">&quot;192.134.22.139:8080&quot;</span>));</span><br><span class=\"line\">    serverInstances.put(<span class=\"number\">3L</span>, <span class=\"keyword\">new</span> <span class=\"title class_\">BackendServer</span>(<span class=\"number\">3L</span>, <span class=\"string\">&quot;192.134.22.140:8080&quot;</span>));</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"title function_\">BackendServer</span><span class=\"params\">(<span class=\"type\">long</span> serverNo, String serverAddress)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.serverNo = serverNo;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.serverAddress = serverAddress;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> BackendServer <span class=\"title function_\">getInstance</span><span class=\"params\">(<span class=\"type\">long</span> serverNo)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> serverInstances.get(serverNo);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> BackendServer <span class=\"title function_\">getRandomInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">Random</span> <span class=\"variable\">r</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Random</span>();</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">no</span> <span class=\"operator\">=</span> r.nextInt(SERVER_COUNT)+<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> serverInstances.get(no);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>实际上，对于多例模式，还有一种理解方式：同一类型的只能创建一个对象，不同类型的可以创建多个对象。这里的“类型”如何理解呢？我们还是通过一个例子来解释一下，具体代码如下所示。在代码中，logger name 就是刚刚说的“类型”，同一个 logger name 获取到的对象实例是相同的，不同的 logger name 获取到的对象实例是不同的。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Logger</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> ConcurrentHashMap&lt;String, Logger&gt; instances</span><br><span class=\"line\">          = <span class=\"keyword\">new</span> <span class=\"title class_\">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"title function_\">Logger</span><span class=\"params\">()</span> &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Logger <span class=\"title function_\">getInstance</span><span class=\"params\">(String loggerName)</span> &#123;</span><br><span class=\"line\">    instances.putIfAbsent(loggerName, <span class=\"keyword\">new</span> <span class=\"title class_\">Logger</span>());</span><br><span class=\"line\">    <span class=\"keyword\">return</span> instances.get(loggerName);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">log</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//l1==l2, l1!=l3</span></span><br><span class=\"line\"><span class=\"type\">Logger</span> <span class=\"variable\">l1</span> <span class=\"operator\">=</span> Logger.getInstance(<span class=\"string\">&quot;User.class&quot;</span>);</span><br><span class=\"line\"><span class=\"type\">Logger</span> <span class=\"variable\">l2</span> <span class=\"operator\">=</span> Logger.getInstance(<span class=\"string\">&quot;User.class&quot;</span>);</span><br><span class=\"line\"><span class=\"type\">Logger</span> <span class=\"variable\">l3</span> <span class=\"operator\">=</span> Logger.getInstance(<span class=\"string\">&quot;Order.class&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n\n\n<p>这种多例模式的理解方式有点类似工厂模式。它跟工厂模式的不同之处是，多例模式创建的对象都是同一个类的对象，而工厂模式创建的是不同子类的对象，关于这一点，后面就会讲到。实际上，它还有点类似享元模式，两者的区别等到我们讲到享元模式的时候再来分析。除此之外，实际上，枚举类型也相当于多例模式，一个类型只能对应一个对象，一个类可以创建多个对象。</p>\n","site":{"data":{}},"cover_type":"img","excerpt":"","more":"<h1 id=\"声明\"><a href=\"#声明\" class=\"headerlink\" title=\"声明\"></a>声明</h1><blockquote>\n<ol>\n<li>此系列文章非本人原创，是学习笔记。</li>\n<li>设计模式系列以后会持续更新，包括已经发布的设计模式文章，因为后续还要再多看一下书，教程和开源项目等，继续润色文章。</li>\n</ol>\n</blockquote>\n<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>23 种经典的设计模式。它们又可以分为三大类：创建型、结构型、行为型。对于这 23 种设计模式的学习，我们要有侧重点，因为有些模式是比较常用的，有些模式是很少被用到的。对于常用的设计模式，我们要花多点时间理解掌握。对于不常用的设计模式，我们只需要稍微了解即可。按照类型和是否常用，对这些设计模式，进行了简单的分类，具体如下所示。</p>\n<h3 id=\"创建型\"><a href=\"#创建型\" class=\"headerlink\" title=\"创建型\"></a>创建型</h3><p>常用的有：单例模式、工厂模式（工厂方法和抽象工厂）、建造者模式。</p>\n<p>不常用的有：原型模式。</p>\n<h3 id=\"结构型\"><a href=\"#结构型\" class=\"headerlink\" title=\"结构型\"></a>结构型</h3><p>常用的有：代理模式、桥接模式、装饰者模式、适配器模式。</p>\n<p>不常用的有：门面模式、组合模式、享元模式。 </p>\n<h3 id=\"行为型\"><a href=\"#行为型\" class=\"headerlink\" title=\"行为型\"></a>行为型</h3><p>常用的有：观察者模式、模板模式、策略模式、职责链模式、迭代器模式、状态模式。</p>\n<p>不常用的有：访问者模式、备忘录模式、命令模式、解释器模式、中介模式。</p>\n<h1 id=\"单例模式【常用】\"><a href=\"#单例模式【常用】\" class=\"headerlink\" title=\"单例模式【常用】\"></a>单例模式【常用】</h1><p>网上有很多讲解单例模式的文章，但大部分都侧重讲解，如何来实现一个线程安全的单例。今天也会讲到各种单例的实现方法，但是，重点还是希望带你搞清楚下面这样几个问题。</p>\n<ul>\n<li>为什么要使用单例？</li>\n<li>单例存在哪些问题？</li>\n<li>单例与静态类的区别？</li>\n<li>有何替代的解决方案？</li>\n</ul>\n<h2 id=\"为什么要使用单例？\"><a href=\"#为什么要使用单例？\" class=\"headerlink\" title=\"为什么要使用单例？\"></a>为什么要使用单例？</h2><p>单例设计模式（Singleton Design Pattern）理解起来非常简单。一个类只允许创建一个对象（或者实例），那这个类就是一个单例类，这种设计模式就叫作单例设计模式，简称单例模式。</p>\n<p>对于单例的概念，我觉得没必要解释太多，你一看就能明白。我们重点看一下，为什么我们需要单例这种设计模式？它能解决哪些问题？接下来我通过两个实战案例来讲解。</p>\n<h3 id=\"实战案例一：处理资源访问冲突\"><a href=\"#实战案例一：处理资源访问冲突\" class=\"headerlink\" title=\"实战案例一：处理资源访问冲突\"></a>实战案例一：处理资源访问冲突</h3><p>我们先来看第一个例子。在这个例子中，我们自定义实现了一个往文件中打印日志的 Logger 类。具体的代码实现如下所示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Logger</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> FileWriter writer;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"title function_\">Logger</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">File</span> <span class=\"variable\">file</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">File</span>(<span class=\"string\">&quot;/Users/wangzheng/log.txt&quot;</span>);</span><br><span class=\"line\">    writer = <span class=\"keyword\">new</span> <span class=\"title class_\">FileWriter</span>(file, <span class=\"literal\">true</span>); <span class=\"comment\">//true表示追加写入</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">log</span><span class=\"params\">(String message)</span> &#123;</span><br><span class=\"line\">    writer.write(message);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Logger类的应用示例：</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">UserController</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"type\">Logger</span> <span class=\"variable\">logger</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Logger</span>();</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">login</span><span class=\"params\">(String username, String password)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...省略业务逻辑代码...</span></span><br><span class=\"line\">    logger.log(username + <span class=\"string\">&quot; logined!&quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">OrderController</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"type\">Logger</span> <span class=\"variable\">logger</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Logger</span>();</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">create</span><span class=\"params\">(OrderVo order)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...省略业务逻辑代码...</span></span><br><span class=\"line\">    logger.log(<span class=\"string\">&quot;Created an order: &quot;</span> + order.toString());</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在上面的代码中，我们注意到，所有的日志都写入到同一个文件 &#x2F;Users&#x2F;wangzheng&#x2F;log.txt 中。在 UserController 和 OrderController 中，我们分别创建两个 Logger 对象。在 Web 容器的 Servlet 多线程环境下，如果两个 Servlet 线程同时分别执行 login() 和 create() 两个函数，并且同时写日志到 log.txt 文件中，那就有可能存在日志信息互相覆盖的情况。【这属于并发的知识点，看不懂的可以看笔者的并发系列】</p>\n<p>那如何来解决这个问题呢？我们最先想到的就是通过加锁的方式：给 log() 函数加互斥锁，同一时刻只允许一个线程调用执行 log() 函数。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Logger</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> FileWriter writer;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"title function_\">Logger</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">File</span> <span class=\"variable\">file</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">File</span>(<span class=\"string\">&quot;/Users/wangzheng/log.txt&quot;</span>);</span><br><span class=\"line\">    writer = <span class=\"keyword\">new</span> <span class=\"title class_\">FileWriter</span>(file, <span class=\"literal\">true</span>); <span class=\"comment\">//true表示追加写入</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">log</span><span class=\"params\">(String message)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span>(<span class=\"built_in\">this</span>) &#123;</span><br><span class=\"line\">      writer.write(mesasge);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>synchronized(this)</code>这种对象级别的锁，锁不住，因为不同的对象之间并不共享同一把锁。所以我们换成类级别的锁。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Logger</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> FileWriter writer;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"title function_\">Logger</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">File</span> <span class=\"variable\">file</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">File</span>(<span class=\"string\">&quot;/Users/wangzheng/log.txt&quot;</span>);</span><br><span class=\"line\">    writer = <span class=\"keyword\">new</span> <span class=\"title class_\">FileWriter</span>(file, <span class=\"literal\">true</span>); <span class=\"comment\">//true表示追加写入</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">log</span><span class=\"params\">(String message)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span>(Logger.class) &#123; <span class=\"comment\">// 类级别的锁</span></span><br><span class=\"line\">      writer.write(mesasge);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>除了使用类级别锁之外，实际上，解决资源竞争问题的办法还有很多，分布式锁是最常听到的一种解决方案。不过，实现一个安全可靠、无 bug、高性能的分布式锁，并不是件容易的事情。除此之外，并发队列（比如 Java 中的 BlockingQueue）也可以解决这个问题：多个线程同时往并发队列里写日志，一个单独的线程负责将并发队列中的数据，写入到日志文件。这种方式实现起来也稍微有点复杂。</p>\n<p>相对于这两种解决方案，单例模式的解决思路就简单一些了。单例模式相对于之前类级别锁的好处是，不用创建那么多 Logger 对象，一方面节省内存空间，另一方面节省系统文件句柄（对于操作系统来说，文件句柄也是一种资源，不能随便浪费）。</p>\n<p>我们将 Logger 设计成一个单例类，程序中只允许创建一个 Logger 对象，所有的线程共享使用的这一个 Logger 对象，共享一个 FileWriter 对象，而 FileWriter 本身是对象级别线程安全的，也就避免了多线程情况下写日志会互相覆盖的问题。按照这个设计思路，我们实现了 Logger 单例类。具体代码如下所示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Logger</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> FileWriter writer;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">Logger</span> <span class=\"variable\">instance</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Logger</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"title function_\">Logger</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">File</span> <span class=\"variable\">file</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">File</span>(<span class=\"string\">&quot;/Users/wangzheng/log.txt&quot;</span>);</span><br><span class=\"line\">    writer = <span class=\"keyword\">new</span> <span class=\"title class_\">FileWriter</span>(file, <span class=\"literal\">true</span>); <span class=\"comment\">//true表示追加写入</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Logger <span class=\"title function_\">getInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">log</span><span class=\"params\">(String message)</span> &#123;</span><br><span class=\"line\">    writer.write(mesasge);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Logger类的应用示例：</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">UserController</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">login</span><span class=\"params\">(String username, String password)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...省略业务逻辑代码...</span></span><br><span class=\"line\">    Logger.getInstance().log(username + <span class=\"string\">&quot; logined!&quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">OrderController</span> &#123;  </span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">create</span><span class=\"params\">(OrderVo order)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...省略业务逻辑代码...</span></span><br><span class=\"line\">    Logger.getInstance().log(<span class=\"string\">&quot;Created a order: &quot;</span> + order.toString());</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"实战案例二：表示全局唯一类\"><a href=\"#实战案例二：表示全局唯一类\" class=\"headerlink\" title=\"实战案例二：表示全局唯一类\"></a>实战案例二：表示全局唯一类</h3><p>从业务概念上，如果有些数据在系统中只应保存一份，那就比较适合设计为单例类。比如，配置信息类。在系统中，我们只有一个配置文件，当配置文件被加载到内存之后，以对象的形式存在，也理所应当只有一份。</p>\n<p>再比如，唯一递增 ID 号码生成器。如果程序中有两个对象，那就会存在生成重复 ID 的情况，所以，我们应该将 ID 生成器类设计为单例。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">IdGenerator</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// AtomicLong是一个Java并发库中提供的一个原子变量类型,</span></span><br><span class=\"line\">  <span class=\"comment\">// 它将一些线程不安全需要加锁的复合操作封装为了线程安全的原子操作，</span></span><br><span class=\"line\">  <span class=\"comment\">// 比如下面会用到的incrementAndGet().</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"type\">AtomicLong</span> <span class=\"variable\">id</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">AtomicLong</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">IdGenerator</span> <span class=\"variable\">instance</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IdGenerator</span>();</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"title function_\">IdGenerator</span><span class=\"params\">()</span> &#123;&#125;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> IdGenerator <span class=\"title function_\">getInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"type\">long</span> <span class=\"title function_\">getId</span><span class=\"params\">()</span> &#123; </span><br><span class=\"line\">    <span class=\"keyword\">return</span> id.incrementAndGet();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// IdGenerator使用举例</span></span><br><span class=\"line\"><span class=\"type\">long</span> <span class=\"variable\">id</span> <span class=\"operator\">=</span> IdGenerator.getInstance().getId();</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"如何实现一个单例？\"><a href=\"#如何实现一个单例？\" class=\"headerlink\" title=\"如何实现一个单例？\"></a>如何实现一个单例？</h2><p>尽管介绍如何实现一个单例模式的文章已经有很多了，但为了保证内容的完整性，我这里还是简单介绍一下几种经典实现方式。概括起来，要实现一个单例，我们需要关注的点无外乎下面几个：</p>\n<ul>\n<li><p>构造函数需要是 private 访问权限的，这样才能避免外部通过 new 创建实例；</p>\n</li>\n<li><p>考虑对象创建时的线程安全问题；</p>\n</li>\n<li><p>考虑是否支持延迟加载；</p>\n</li>\n<li><p>考虑 getInstance() 性能是否高（是否加锁）。</p>\n</li>\n</ul>\n<h3 id=\"饿汉式-静态变量\"><a href=\"#饿汉式-静态变量\" class=\"headerlink\" title=\"饿汉式(静态变量)\"></a>饿汉式(静态变量)</h3><p>饿汉式的实现方式比较简单。在类加载的时候，instance 静态实例就已经创建并初始化好了，所以，instance 实例的创建过程是线程安全的。不过，这样的实现方式不支持延迟加载（在真正用到 IdGenerator 的时候，再创建实例），从名字中我们也可以看出这一点。具体的代码实现如下所示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">IdGenerator</span> &#123; </span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"type\">AtomicLong</span> <span class=\"variable\">id</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">AtomicLong</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">IdGenerator</span> <span class=\"variable\">instance</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IdGenerator</span>();</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"title function_\">IdGenerator</span><span class=\"params\">()</span> &#123;&#125;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> IdGenerator <span class=\"title function_\">getInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"type\">long</span> <span class=\"title function_\">getId</span><span class=\"params\">()</span> &#123; </span><br><span class=\"line\">    <span class=\"keyword\">return</span> id.incrementAndGet();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<ol>\n<li>有人觉得这种实现方式不好，因为不支持延迟加载，如果实例占用资源多（比如占用内存多）或初始化耗时长（比如需要加载各种配置文件），提前初始化实例是一种浪费资源的行为。最好的方法应该在用到的时候再去初始化。不过，我个人并不认同这样的观点</li>\n<li>如果初始化耗时长，那我们最好不要等到真正要用它的时候，才去执行这个耗时长的初始化过程，这会影响到系统的性能（比如，在响应客户端接口请求的时候，做这个初始化操作，会导致此请求的响应时间变长，甚至超时）。采用饿汉式实现方式，将耗时的初始化操作，提前到程序启动的时候完成，这样就能避免在程序运行的时候，再去初始化导致的性能问题。</li>\n<li>如果实例占用资源多，按照 fail-fast 的设计原则（有问题及早暴露），那我们也希望在程序启动时就将这个实例初始化好。如果资源不够，就会在程序启动的时候触发报错（比如 Java 中的 PermGen Space OOM），我们可以立即去修复。这样也能避免在程序运行一段时间后，突然因为初始化这个实例占用资源过多，导致系统崩溃，影响系统的可用性。(如果初始化消耗资源过多，反而推荐懒汉式，早日发现问题)</li>\n</ol>\n<h3 id=\"饿汉式-静态代码块\"><a href=\"#饿汉式-静态代码块\" class=\"headerlink\" title=\"饿汉式(静态代码块)\"></a>饿汉式(静态代码块)</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">SingletonTest02</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 测试</span></span><br><span class=\"line\">    <span class=\"type\">Singleton</span> <span class=\"variable\">instance</span> <span class=\"operator\">=</span> Singleton.getInstance();</span><br><span class=\"line\">    <span class=\"type\">Singleton</span> <span class=\"variable\">instance2</span> <span class=\"operator\">=</span> Singleton.getInstance();</span><br><span class=\"line\">    System.out.println(instance == instance2); <span class=\"comment\">// true</span></span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;instance.hashCode=&quot;</span> + instance.hashCode());</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;instance2.hashCode=&quot;</span> + instance2.hashCode());</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 饿汉式(静态变量)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Singleton</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 1. 构造器私有化</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"title function_\">Singleton</span><span class=\"params\">()</span> &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 2.本类内部创建对象实例</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Singleton instance;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">static</span> &#123; <span class=\"comment\">// 在静态代码块中，创建单例对象</span></span><br><span class=\"line\">    instance = <span class=\"keyword\">new</span> <span class=\"title class_\">Singleton</span>();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 3. 提供一个公有的静态方法，返回实例对象</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title function_\">getInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>没什么好说的，就是静态变量换成了静态代码块。</p>\n<h3 id=\"懒汉式-线程安全，同步方法\"><a href=\"#懒汉式-线程安全，同步方法\" class=\"headerlink\" title=\"懒汉式(线程安全，同步方法)\"></a>懒汉式(线程安全，同步方法)</h3><p>懒汉式相对于饿汉式的优势是支持延迟加载。具体的代码实现如下所示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">IdGenerator</span> &#123; </span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"type\">AtomicLong</span> <span class=\"variable\">id</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">AtomicLong</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> IdGenerator instance;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"title function_\">IdGenerator</span><span class=\"params\">()</span> &#123;&#125;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">synchronized</span> IdGenerator <span class=\"title function_\">getInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (instance == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      instance = <span class=\"keyword\">new</span> <span class=\"title class_\">IdGenerator</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"type\">long</span> <span class=\"title function_\">getId</span><span class=\"params\">()</span> &#123; </span><br><span class=\"line\">    <span class=\"keyword\">return</span> id.incrementAndGet();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>不过懒汉式的缺点也很明显，我们给 getInstance() 这个方法加了一把大锁（synchronzed），导致这个函数的并发度很低。而这个函数是在单例使用期间，一直会被调用。如果这个单例类偶尔会被用到，那这种实现方式还可以接受。但是，如果频繁地用到，那频繁加锁、释放锁及并发度低等问题，会导致性能瓶颈，这种实现方式就不可取了。</p>\n<h3 id=\"懒汉式-线程安全，同步代码块\"><a href=\"#懒汉式-线程安全，同步代码块\" class=\"headerlink\" title=\"懒汉式(线程安全，同步代码块)\"></a>懒汉式(线程安全，同步代码块)</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 懒汉式(线程安全，同步代码块)</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Singleton</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Singleton instance;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"title function_\">Singleton</span><span class=\"params\">()</span> &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title function_\">getInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (instance == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">synchronized</span> (Singleton.class) &#123;</span><br><span class=\"line\">        instance = <span class=\"keyword\">new</span> <span class=\"title class_\">Singleton</span>();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"懒汉式-线程不安全\"><a href=\"#懒汉式-线程不安全\" class=\"headerlink\" title=\"懒汉式(线程不安全)\"></a>懒汉式(线程不安全)</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Singleton</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Singleton instance;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"title function_\">Singleton</span><span class=\"params\">()</span> &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 提供一个静态的公有方法，当使用到该方法时，才去创建 instance</span></span><br><span class=\"line\">  <span class=\"comment\">// 即懒汉式</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title function_\">getInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (instance == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      instance = <span class=\"keyword\">new</span> <span class=\"title class_\">Singleton</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n<p>只是为了完整性，写了出来，实际开发不推荐用线程不安全的</p>\n<h3 id=\"双重检测\"><a href=\"#双重检测\" class=\"headerlink\" title=\"双重检测\"></a>双重检测</h3><p>饿汉式不支持延迟加载，懒汉式有性能问题，不支持高并发。那我们再来看一种既支持延迟加载、又支持高并发的单例实现方式，也就是双重检测实现方式。在这种实现方式中，只要 instance 被创建之后，即便再调用 getInstance() 函数也不会再进入到加锁逻辑中了。所以，这种实现方式解决了懒汉式并发度低的问题。具体的代码实现如下所示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">IdGenerator</span> &#123; </span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"type\">AtomicLong</span> <span class=\"variable\">id</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">AtomicLong</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> IdGenerator instance;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"title function_\">IdGenerator</span><span class=\"params\">()</span> &#123;&#125;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> IdGenerator <span class=\"title function_\">getInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (instance == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">synchronized</span>(IdGenerator.class) &#123; <span class=\"comment\">// 此处为类级别的锁</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (instance == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">          instance = <span class=\"keyword\">new</span> <span class=\"title class_\">IdGenerator</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"type\">long</span> <span class=\"title function_\">getId</span><span class=\"params\">()</span> &#123; </span><br><span class=\"line\">    <span class=\"keyword\">return</span> id.incrementAndGet();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>这种实现方式有些问题。因为指令重排序，可能会导致 IdGenerator 对象被 new 出来，并且赋值给 instance 之后，还没来得及初始化（执行构造函数中的代码逻辑），就被另一个线程使用了。要解决这个问题，我们需要给 instance 成员变量加上 volatile 关键字，禁止指令重排序才行。</p>\n<p>据说，只有很低版本的 Java 才会有这个问题。我们现在用的高版本的 Java 已经在 JDK 内部实现中解决了这个问题（解决的方法很简单，只要把对象 new 操作和初始化操作设计为原子操作，就自然能禁止重排序）。</p>\n<h3 id=\"静态内部类\"><a href=\"#静态内部类\" class=\"headerlink\" title=\"静态内部类\"></a>静态内部类</h3><p>我们再来看一种比双重检测更加简单的实现方法，那就是利用 Java 的静态内部类。它有点类似饿汉式，但又能做到了延迟加载。具体是怎么做到的呢？我们先来看它的代码实现</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">IdGenerator</span> &#123; </span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"type\">AtomicLong</span> <span class=\"variable\">id</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">AtomicLong</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"title function_\">IdGenerator</span><span class=\"params\">()</span> &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">SingletonHolder</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">IdGenerator</span> <span class=\"variable\">instance</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IdGenerator</span>();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> IdGenerator <span class=\"title function_\">getInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> SingletonHolder.instance;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"type\">long</span> <span class=\"title function_\">getId</span><span class=\"params\">()</span> &#123; </span><br><span class=\"line\">    <span class=\"keyword\">return</span> id.incrementAndGet();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>SingletonHolder 是一个静态内部类，当外部类 IdGenerator 被加载的时候，并不会创建 SingletonHolder 实例对象。只有当调用 getInstance() 方法时，SingletonHolder 才会被加载，这个时候才会创建 instance。instance 的唯一性、创建过程的线程安全性，都由 JVM 来保证。所以，这种实现方法既保证了线程安全，又能做到延迟加载。</p>\n<h3 id=\"枚举\"><a href=\"#枚举\" class=\"headerlink\" title=\"枚举\"></a>枚举</h3><p>最后，我们介绍一种最简单的实现方式，基于枚举类型的单例实现。这种实现方式通过 Java 枚举类型本身的特性，保证了实例创建的线程安全性和实例的唯一性。具体的代码如下所示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">enum</span> <span class=\"title class_\">IdGenerator</span> &#123;</span><br><span class=\"line\">  INSTANCE;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"type\">AtomicLong</span> <span class=\"variable\">id</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">AtomicLong</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"type\">long</span> <span class=\"title function_\">getId</span><span class=\"params\">()</span> &#123; </span><br><span class=\"line\">    <span class=\"keyword\">return</span> id.incrementAndGet();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"单例存在哪些问题\"><a href=\"#单例存在哪些问题\" class=\"headerlink\" title=\"单例存在哪些问题?\"></a>单例存在哪些问题?</h2><p>尽管单例是一个很常用的设计模式，在实际的开发中，我们也确实经常用到它，但是，有些人认为单例是一种反模式（anti-pattern），并不推荐使用。大部分情况下，我们在项目中使用单例，都是用它来表示一些全局唯一类，比如配置信息类、连接池类、ID 生成器类。单例模式书写简洁、使用方便，在代码中，我们不需要创建对象，直接通过类似 IdGenerator.getInstance().getId() 这样的方法来调用就可以了。但是，这种使用方法有点类似硬编码（hard code），会带来诸多问题。接下来，我们就具体看看到底有哪些问题。</p>\n<h3 id=\"单例对-OOP-特性的支持不友好\"><a href=\"#单例对-OOP-特性的支持不友好\" class=\"headerlink\" title=\"单例对 OOP 特性的支持不友好\"></a>单例对 OOP 特性的支持不友好</h3><p>我们知道，OOP 的四大特性是封装、抽象、继承、多态。单例这种设计模式对于其中的抽象、继承、多态都支持得不好。为什么这么说呢？我们还是通过 IdGenerator 这个例子来讲解。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Order</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">create</span><span class=\"params\">(...)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"variable\">id</span> <span class=\"operator\">=</span> IdGenerator.getInstance().getId();</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">User</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">create</span><span class=\"params\">(...)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"variable\">id</span> <span class=\"operator\">=</span> IdGenerator.getInstance().getId();</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>IdGenerator 的使用方式违背了基于接口而非实现的设计原则，也就违背了广义上理解的 OOP 的抽象特性。如果未来某一天，我们希望针对不同的业务采用不同的 ID 生成算法。比如，订单 ID 和用户 ID 采用不同的 ID 生成器来生成。为了应对这个需求变化，我们需要修改所有用到 IdGenerator 类的地方，这样代码的改动就会比较大。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Order</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">create</span><span class=\"params\">(...)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"variable\">id</span> <span class=\"operator\">=</span> IdGenerator.getInstance().getId();</span><br><span class=\"line\">    <span class=\"comment\">// 需要将上面一行代码，替换为下面一行代码</span></span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"variable\">id</span> <span class=\"operator\">=</span> OrderIdGenerator.getIntance().getId();</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">User</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">create</span><span class=\"params\">(...)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"variable\">id</span> <span class=\"operator\">=</span> IdGenerator.getInstance().getId();</span><br><span class=\"line\">    <span class=\"comment\">// 需要将上面一行代码，替换为下面一行代码</span></span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"variable\">id</span> <span class=\"operator\">=</span> UserIdGenerator.getIntance().getId();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>除此之外，单例对继承、多态特性的支持也不友好。这里我之所以会用“不友好”这个词，而非“完全不支持”，是因为从理论上来讲，单例类也可以被继承、也可以实现多态，只是实现起来会非常奇怪，会导致代码的可读性变差。不明白设计意图的人，看到这样的设计，会觉得莫名其妙。所以，一旦你选择将某个类设计成到单例类，也就意味着放弃了继承和多态这两个强有力的面向对象特性，也就相当于损失了可以应对未来需求变化的扩展性</p>\n<h3 id=\"单例会隐藏类之间的依赖关系\"><a href=\"#单例会隐藏类之间的依赖关系\" class=\"headerlink\" title=\"单例会隐藏类之间的依赖关系\"></a>单例会隐藏类之间的依赖关系</h3><p>我们知道，代码的可读性非常重要。在阅读代码的时候，我们希望一眼就能看出类与类之间的依赖关系，搞清楚这个类依赖了哪些外部类。通过构造函数、参数传递等方式声明的类之间的依赖关系，我们通过查看函数的定义，就能很容易识别出来。但是，单例类不需要显示创建、不需要依赖参数传递，在函数中直接调用就可以了。如果代码比较复杂，这种调用关系就会非常隐蔽。在阅读代码的时候，我们就需要仔细查看每个函数的代码实现，才能知道这个类到底依赖了哪些单例类。</p>\n<h3 id=\"单例对代码的扩展性不友好\"><a href=\"#单例对代码的扩展性不友好\" class=\"headerlink\" title=\"单例对代码的扩展性不友好\"></a>单例对代码的扩展性不友好</h3><ol>\n<li>我们知道，单例类只能有一个对象实例。如果未来某一天，我们需要在代码中创建两个实例或多个实例，那就要对代码有比较大的改动。你可能会说，会有这样的需求吗？既然单例类大部分情况下都用来表示全局类，怎么会需要两个或者多个实例呢？</li>\n<li>实际上，这样的需求并不少见。我们拿数据库连接池来举例解释一下。</li>\n<li>在系统设计初期，我们觉得系统中只应该有一个数据库连接池，这样能方便我们控制对数据库连接资源的消耗。所以，我们把数据库连接池类设计成了单例类。但之后我们发现，系统中有些 SQL 语句运行得非常慢。这些 SQL 语句在执行的时候，长时间占用数据库连接资源，导致其他 SQL 请求无法响应。为了解决这个问题，我们希望将慢 SQL 与其他 SQL 隔离开来执行。为了实现这样的目的，我们可以在系统中创建两个数据库连接池，慢 SQL 独享一个数据库连接池，其他 SQL 独享另外一个数据库连接池，这样就能避免慢 SQL 影响到其他 SQL 的执行。</li>\n<li>如果我们将数据库连接池设计成单例类，显然就无法适应这样的需求变更，也就是说，单例类在某些情况下会影响代码的扩展性、灵活性。所以，数据库连接池、线程池这类的资源池，最好还是不要设计成单例类。实际上，一些开源的数据库连接池、线程池也确实没有设计成单例类。</li>\n</ol>\n<h3 id=\"单例对代码的可测试性不友好\"><a href=\"#单例对代码的可测试性不友好\" class=\"headerlink\" title=\"单例对代码的可测试性不友好\"></a>单例对代码的可测试性不友好</h3><ol>\n<li><p>单例模式的使用会影响到代码的可测试性。如果单例类依赖比较重的外部资源，比如 DB，我们在写单元测试的时候，希望能通过 mock 的方式将它替换掉。而单例类这种硬编码式的使用方式，导致无法实现 mock 替换。</p>\n</li>\n<li><p>除此之外，如果单例类持有成员变量（比如 IdGenerator 中的 id 成员变量），那它实际上相当于一种全局变量，被所有的代码共享。如果这个全局变量是一个可变全局变量，也就是说，它的成员变量是可以被修改的，那我们在编写单元测试的时候，还需要注意不同测试用例之间，修改了单例类中的同一个成员变量的值，从而导致测试结果互相影响的问题。</p>\n</li>\n</ol>\n<h3 id=\"单例不支持有参数的构造函数\"><a href=\"#单例不支持有参数的构造函数\" class=\"headerlink\" title=\"单例不支持有参数的构造函数\"></a>单例不支持有参数的构造函数</h3><p>单例不支持有参数的构造函数，比如我们创建一个连接池的单例对象，我们没法通过参数来指定连接池的大小。针对这个问题，我们来看下都有哪些解决方案。</p>\n<p><strong>第一种解决思路是</strong>：创建完实例之后，再调用 init() 函数传递参数。需要注意的是，我们在使用这个单例类的时候，要先调用 init() 方法，然后才能调用 getInstance() 方法，否则代码会抛出异常。具体的代码实现如下所示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Singleton</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">Singleton</span> <span class=\"variable\">instance</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> paramA;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> paramB;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"title function_\">Singleton</span><span class=\"params\">(<span class=\"type\">int</span> paramA, <span class=\"type\">int</span> paramB)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.paramA = paramA;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.paramB = paramB;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title function_\">getInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (instance == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">       <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RuntimeException</span>(<span class=\"string\">&quot;Run init() first.&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">static</span> Singleton <span class=\"title function_\">init</span><span class=\"params\">(<span class=\"type\">int</span> paramA, <span class=\"type\">int</span> paramB)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (instance != <span class=\"literal\">null</span>)&#123;</span><br><span class=\"line\">       <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RuntimeException</span>(<span class=\"string\">&quot;Singleton has been created!&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    instance = <span class=\"keyword\">new</span> <span class=\"title class_\">Singleton</span>(paramA, paramB);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Singleton.init(<span class=\"number\">10</span>, <span class=\"number\">50</span>); <span class=\"comment\">// 先init，再使用</span></span><br><span class=\"line\"><span class=\"type\">Singleton</span> <span class=\"variable\">singleton</span> <span class=\"operator\">=</span> Singleton.getInstance();</span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>第二种解决思路是</strong>：将参数放到 getIntance() 方法中。具体的代码实现如下所示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Singleton</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">Singleton</span> <span class=\"variable\">instance</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> paramA;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> paramB;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"title function_\">Singleton</span><span class=\"params\">(<span class=\"type\">int</span> paramA, <span class=\"type\">int</span> paramB)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.paramA = paramA;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.paramB = paramB;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">static</span> Singleton <span class=\"title function_\">getInstance</span><span class=\"params\">(<span class=\"type\">int</span> paramA, <span class=\"type\">int</span> paramB)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (instance == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      instance = <span class=\"keyword\">new</span> <span class=\"title class_\">Singleton</span>(paramA, paramB);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">Singleton</span> <span class=\"variable\">singleton</span> <span class=\"operator\">=</span> Singleton.getInstance(<span class=\"number\">10</span>, <span class=\"number\">50</span>);</span><br></pre></td></tr></table></figure>\n\n\n\n<p>不知道你有没有发现，上面的代码实现稍微有点问题。如果我们如下两次执行 getInstance() 方法，那获取到的 singleton1 和 signleton2 的 paramA 和 paramB 都是 10 和 50。也就是说，第二次的参数（20，30）没有起作用，而构建的过程也没有给与提示，这样就会误导用户。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Singleton</span> <span class=\"variable\">singleton1</span> <span class=\"operator\">=</span> Singleton.getInstance(<span class=\"number\">10</span>, <span class=\"number\">50</span>);</span><br><span class=\"line\"><span class=\"type\">Singleton</span> <span class=\"variable\">singleton2</span> <span class=\"operator\">=</span> Singleton.getInstance(<span class=\"number\">20</span>, <span class=\"number\">30</span>);</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<p><strong>第三种解决思路是</strong>：将参数放到另外一个全局变量中。具体的代码实现如下。Config 是一个存储了 paramA 和 paramB 值的全局变量。里面的值既可以像下面的代码那样通过静态常量来定义，也可以从配置文件中加载得到。<strong>实际上，这种方式是最值得推荐的。</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Config</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">PARAM_A</span> <span class=\"operator\">=</span> <span class=\"number\">123</span>;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">PARAM_B</span> <span class=\"operator\">=</span> <span class=\"number\">245</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Singleton</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">Singleton</span> <span class=\"variable\">instance</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> paramA;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> paramB;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"title function_\">Singleton</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.paramA = Config.PARAM_A;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.paramB = Config.PARAM_B;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">static</span> Singleton <span class=\"title function_\">getInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (instance == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      instance = <span class=\"keyword\">new</span> <span class=\"title class_\">Singleton</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"有何替代解决方案？\"><a href=\"#有何替代解决方案？\" class=\"headerlink\" title=\"有何替代解决方案？\"></a>有何替代解决方案？</h2><p>刚刚我们提到了单例的很多问题，你可能会说，即便单例有这么多问题，但我不用不行啊。我业务上有表示全局唯一类的需求，如果不用单例，我怎么才能保证这个类的对象全局唯一呢？为了保证全局唯一，除了使用单例，我们还可以用静态方法来实现。这也是项目开发中经常用到的一种实现思路。比如， ID 唯一递增生成器的例子，用静态方法实现一下，就是下面这个样子：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 静态方法实现方式</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">IdGenerator</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">AtomicLong</span> <span class=\"variable\">id</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">AtomicLong</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"type\">long</span> <span class=\"title function_\">getId</span><span class=\"params\">()</span> &#123; </span><br><span class=\"line\">    <span class=\"keyword\">return</span> id.incrementAndGet();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 使用举例</span></span><br><span class=\"line\"><span class=\"type\">long</span> <span class=\"variable\">id</span> <span class=\"operator\">=</span> IdGenerator.getId();</span><br></pre></td></tr></table></figure>\n\n<p>不过，静态方法这种实现思路，并不能解决我们之前提到的问题。实际上，它比单例更加不灵活，比如，它无法支持延迟加载。我们再来看看有没有其他办法。实际上，单例除了我们之前讲到的使用方法之外，还有另外一种使用方法。具体的代码如下所示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 1. 老的使用方式</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"title function_\">demofunction</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">//...</span></span><br><span class=\"line\">  <span class=\"type\">long</span> <span class=\"variable\">id</span> <span class=\"operator\">=</span> IdGenerator.getInstance().getId();</span><br><span class=\"line\">  <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 2. 新的使用方式：依赖注入</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"title function_\">demofunction</span><span class=\"params\">(IdGenerator idGenerator)</span> &#123;</span><br><span class=\"line\">  <span class=\"type\">long</span> <span class=\"variable\">id</span> <span class=\"operator\">=</span> idGenerator.getId();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 外部调用demofunction()的时候，传入idGenerator</span></span><br><span class=\"line\"><span class=\"type\">IdGenerator</span> <span class=\"variable\">idGenerator</span> <span class=\"operator\">=</span> IdGenerator.getInsance();</span><br><span class=\"line\">demofunction(idGenerator);</span><br></pre></td></tr></table></figure>\n\n\n\n<ol>\n<li>基于新的使用方式，我们将单例生成的对象，作为参数传递给函数（也可以通过构造函数传递给类的成员变量），可以解决单例隐藏类之间依赖关系的问题。不过，对于单例存在的其他问题，比如对 OOP 特性、扩展性、可测性不友好等问题，还是无法解决。</li>\n<li>所以，如果要完全解决这些问题，我们可能要从根上，寻找其他方式来实现全局唯一类。实际上，类对象的全局唯一性可以通过多种不同的方式来保证。我们既可以通过单例模式来强制保证，也可以通过工厂模式、IOC 容器（比如 Spring IOC 容器）来保证，还可以通过程序员自己来保证（自己在编写代码的时候自己保证不要创建两个类对象）。这就类似 Java 中内存对象的释放由 JVM 来负责，而 C++ 中由程序员自己负责，道理是一样的。</li>\n<li>对于替代方案工厂模式、IOC 容器的详细讲解，我们放到后面讲解。</li>\n</ol>\n<h2 id=\"如何理解单例模式中的唯一性？\"><a href=\"#如何理解单例模式中的唯一性？\" class=\"headerlink\" title=\"如何理解单例模式中的唯一性？\"></a>如何理解单例模式中的唯一性？</h2><ol>\n<li>首先，我们重新看一下单例的定义：“一个类只允许创建唯一一个对象（或者实例），那这个类就是一个单例类，这种设计模式就叫作单例设计模式，简称单例模式。</li>\n<li>”定义中提到，“一个类只允许创建唯一一个对象”。那对象的唯一性的作用范围是什么呢？是指线程内只允许创建一个对象，还是指进程内只允许创建一个对象？答案是后者，也就是说，单例模式创建的对象是进程唯一的。这里有点不好理解，我来详细地解释一下。</li>\n<li>我们编写的代码，通过编译、链接，组织在一起，就构成了一个操作系统可以执行的文件，也就是我们平时所说的“可执行文件”（比如 Windows 下的 exe 文件）。可执行文件实际上就是代码被翻译成操作系统可理解的一组指令，你完全可以简单地理解为就是代码本身。</li>\n<li>当我们使用命令行或者双击运行这个可执行文件的时候，操作系统会启动一个进程，将这个执行文件从磁盘加载到自己的进程地址空间（可以理解操作系统为进程分配的内存存储区，用来存储代码和数据）。接着，进程就一条一条地执行可执行文件中包含的代码。比如，当进程读到代码中的 User user &#x3D; new User(); 这条语句的时候，它就在自己的地址空间中创建一个 user 临时变量和一个 User 对象。进程之间是不共享地址空间的，如果我们在一个进程中创建另外一个进程（比如，代码中有一个 fork() 语句，进程执行到这条语句的时候会创建一个新的进程），操作系统会给新进程分配新的地址空间，并且将老进程地址空间的所有内容，重新拷贝一份到新进程的地址空间中，这些内容包括代码、数据（比如 user 临时变量、User 对象）。</li>\n<li>所以，单例类在老进程中存在且只能存在一个对象，在新进程中也会存在且只能存在一个对象。而且，这两个对象并不是同一个对象，这也就说，单例类中对象的唯一性的作用范围是进程内的，在进程间是不唯一的。</li>\n</ol>\n<h2 id=\"如何实现线程唯一的单例？\"><a href=\"#如何实现线程唯一的单例？\" class=\"headerlink\" title=\"如何实现线程唯一的单例？\"></a>如何实现线程唯一的单例？</h2><ol>\n<li><p>刚刚我们讲了单例类对象是进程唯一的，一个进程只能有一个单例对象。那如何实现一个线程唯一的单例呢？</p>\n</li>\n<li><p>我们先来看一下，什么是线程唯一的单例，以及“线程唯一”和“进程唯一”的区别。</p>\n</li>\n<li><p>“进程唯一”指的是进程内唯一，进程间不唯一。类比一下，“线程唯一”指的是线程内唯一，线程间可以不唯一。实际上，“进程唯一”还代表了线程内、线程间都唯一，这也是“进程唯一”和“线程唯一”的区别之处。这段话听起来有点像绕口令，我举个例子来解释一下。</p>\n</li>\n<li><p>假设 IdGenerator 是一个线程唯一的单例类。在线程 A 内，我们可以创建一个单例对象 a。因为线程内唯一，在线程 A 内就不能再创建新的 IdGenerator 对象了，而线程间可以不唯一，所以，在另外一个线程 B 内，我们还可以重新创建一个新的单例对象 b。</p>\n</li>\n<li><p>尽管概念理解起来比较复杂，但线程唯一单例的代码实现很简单，如下所示。在代码中，我们通过一个 HashMap 来存储对象，其中 key 是线程 ID，value 是对象。这样我们就可以做到，不同的线程对应不同的对象，同一个线程只能对应一个对象。实际上，Java 语言本身提供了 ThreadLocal 工具类，可以更加轻松地实现线程唯一单例。不过，ThreadLocal 底层实现原理也是基于下面代码中所示的 HashMap。</p>\n</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">IdGenerator</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"type\">AtomicLong</span> <span class=\"variable\">id</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">AtomicLong</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> ConcurrentHashMap&lt;Long, IdGenerator&gt; instances</span><br><span class=\"line\">          = <span class=\"keyword\">new</span> <span class=\"title class_\">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"title function_\">IdGenerator</span><span class=\"params\">()</span> &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> IdGenerator <span class=\"title function_\">getInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">Long</span> <span class=\"variable\">currentThreadId</span> <span class=\"operator\">=</span> Thread.currentThread().getId();</span><br><span class=\"line\">    instances.putIfAbsent(currentThreadId, <span class=\"keyword\">new</span> <span class=\"title class_\">IdGenerator</span>());</span><br><span class=\"line\">    <span class=\"keyword\">return</span> instances.get(currentThreadId);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"type\">long</span> <span class=\"title function_\">getId</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> id.incrementAndGet();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h2 id=\"如何实现集群环境下的单例？\"><a href=\"#如何实现集群环境下的单例？\" class=\"headerlink\" title=\"如何实现集群环境下的单例？\"></a>如何实现集群环境下的单例？</h2><ol>\n<li>刚刚我们讲了“进程唯一”的单例和“线程唯一”的单例，现在，我们再来看下，“集群唯一”的单例。</li>\n<li>首先，我们还是先来解释一下，什么是“集群唯一”的单例。</li>\n<li>我们还是将它跟“进程唯一”“线程唯一”做个对比。“进程唯一”指的是进程内唯一、进程间不唯一。“线程唯一”指的是线程内唯一、线程间不唯一。集群相当于多个进程构成的一个集合，“集群唯一”就相当于是进程内唯一、进程间也唯一。也就是说，不同的进程间共享同一个对象，不能创建同一个类的多个对象。</li>\n<li>我们知道，经典的单例模式是进程内唯一的，那如何实现一个进程间也唯一的单例呢？如果严格按照不同的进程间共享同一个对象来实现，那集群唯一的单例实现起来就有点难度了。</li>\n<li>具体来说，我们需要把这个单例对象序列化并存储到外部共享存储区（比如文件）。进程在使用这个单例对象的时候，需要先从外部共享存储区中将它读取到内存，并反序列化成对象，然后再使用，使用完成之后还需要再存储回外部共享存储区。</li>\n<li>为了保证任何时刻，在进程间都只有一份对象存在，一个进程在获取到对象之后，需要对对象加锁，避免其他进程再将其获取。在进程使用完这个对象之后，还需要显式地将对象从内存中删除，并且释放对对象的加锁。按照这个思路，</li>\n<li>我用伪代码实现了一下这个过程，具体如下所示：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">IdGenerator</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"type\">AtomicLong</span> <span class=\"variable\">id</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">AtomicLong</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> IdGenerator instance;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">SharedObjectStorage</span> <span class=\"variable\">storage</span> <span class=\"operator\">=</span> FileSharedObjectStorage(<span class=\"comment\">/*入参省略，比如文件地址*/</span>);</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">DistributedLock</span> <span class=\"variable\">lock</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">DistributedLock</span>();</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"title function_\">IdGenerator</span><span class=\"params\">()</span> &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">static</span> IdGenerator <span class=\"title function_\">getInstance</span><span class=\"params\">()</span> </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (instance == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      lock.lock();</span><br><span class=\"line\">      instance = storage.load(IdGenerator.class);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">public</span> synchroinzed <span class=\"keyword\">void</span> <span class=\"title function_\">freeInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    storage.save(<span class=\"built_in\">this</span>, IdGeneator.class);</span><br><span class=\"line\">    instance = <span class=\"literal\">null</span>; <span class=\"comment\">//释放对象</span></span><br><span class=\"line\">    lock.unlock();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"type\">long</span> <span class=\"title function_\">getId</span><span class=\"params\">()</span> &#123; </span><br><span class=\"line\">    <span class=\"keyword\">return</span> id.incrementAndGet();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// IdGenerator使用举例</span></span><br><span class=\"line\"><span class=\"type\">IdGenerator</span> <span class=\"variable\">idGeneator</span> <span class=\"operator\">=</span> IdGenerator.getInstance();</span><br><span class=\"line\"><span class=\"type\">long</span> <span class=\"variable\">id</span> <span class=\"operator\">=</span> idGenerator.getId();</span><br><span class=\"line\">IdGenerator.freeInstance();</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"如何实现一个多例模式？\"><a href=\"#如何实现一个多例模式？\" class=\"headerlink\" title=\"如何实现一个多例模式？\"></a>如何实现一个多例模式？</h2><p>跟单例模式概念相对应的还有一个多例模式。那如何实现一个多例模式呢？“单例”指的是，一个类只能创建一个对象。对应地，“多例”指的就是，一个类可以创建多个对象，但是个数是有限制的，比如只能创建 3 个对象。如果用代码来简单示例一下的话，就是下面这个样子：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">BackendServer</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"type\">long</span> serverNo;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> String serverAddress;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">SERVER_COUNT</span> <span class=\"operator\">=</span> <span class=\"number\">3</span>;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Map&lt;Long, BackendServer&gt; serverInstances = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">    serverInstances.put(<span class=\"number\">1L</span>, <span class=\"keyword\">new</span> <span class=\"title class_\">BackendServer</span>(<span class=\"number\">1L</span>, <span class=\"string\">&quot;192.134.22.138:8080&quot;</span>));</span><br><span class=\"line\">    serverInstances.put(<span class=\"number\">2L</span>, <span class=\"keyword\">new</span> <span class=\"title class_\">BackendServer</span>(<span class=\"number\">2L</span>, <span class=\"string\">&quot;192.134.22.139:8080&quot;</span>));</span><br><span class=\"line\">    serverInstances.put(<span class=\"number\">3L</span>, <span class=\"keyword\">new</span> <span class=\"title class_\">BackendServer</span>(<span class=\"number\">3L</span>, <span class=\"string\">&quot;192.134.22.140:8080&quot;</span>));</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"title function_\">BackendServer</span><span class=\"params\">(<span class=\"type\">long</span> serverNo, String serverAddress)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.serverNo = serverNo;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.serverAddress = serverAddress;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> BackendServer <span class=\"title function_\">getInstance</span><span class=\"params\">(<span class=\"type\">long</span> serverNo)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> serverInstances.get(serverNo);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> BackendServer <span class=\"title function_\">getRandomInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">Random</span> <span class=\"variable\">r</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Random</span>();</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">no</span> <span class=\"operator\">=</span> r.nextInt(SERVER_COUNT)+<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> serverInstances.get(no);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>实际上，对于多例模式，还有一种理解方式：同一类型的只能创建一个对象，不同类型的可以创建多个对象。这里的“类型”如何理解呢？我们还是通过一个例子来解释一下，具体代码如下所示。在代码中，logger name 就是刚刚说的“类型”，同一个 logger name 获取到的对象实例是相同的，不同的 logger name 获取到的对象实例是不同的。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Logger</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> ConcurrentHashMap&lt;String, Logger&gt; instances</span><br><span class=\"line\">          = <span class=\"keyword\">new</span> <span class=\"title class_\">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"title function_\">Logger</span><span class=\"params\">()</span> &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Logger <span class=\"title function_\">getInstance</span><span class=\"params\">(String loggerName)</span> &#123;</span><br><span class=\"line\">    instances.putIfAbsent(loggerName, <span class=\"keyword\">new</span> <span class=\"title class_\">Logger</span>());</span><br><span class=\"line\">    <span class=\"keyword\">return</span> instances.get(loggerName);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">log</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//l1==l2, l1!=l3</span></span><br><span class=\"line\"><span class=\"type\">Logger</span> <span class=\"variable\">l1</span> <span class=\"operator\">=</span> Logger.getInstance(<span class=\"string\">&quot;User.class&quot;</span>);</span><br><span class=\"line\"><span class=\"type\">Logger</span> <span class=\"variable\">l2</span> <span class=\"operator\">=</span> Logger.getInstance(<span class=\"string\">&quot;User.class&quot;</span>);</span><br><span class=\"line\"><span class=\"type\">Logger</span> <span class=\"variable\">l3</span> <span class=\"operator\">=</span> Logger.getInstance(<span class=\"string\">&quot;Order.class&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n\n\n<p>这种多例模式的理解方式有点类似工厂模式。它跟工厂模式的不同之处是，多例模式创建的对象都是同一个类的对象，而工厂模式创建的是不同子类的对象，关于这一点，后面就会讲到。实际上，它还有点类似享元模式，两者的区别等到我们讲到享元模式的时候再来分析。除此之外，实际上，枚举类型也相当于多例模式，一个类型只能对应一个对象，一个类可以创建多个对象。</p>\n"},{"title":"设计模式-04.01-结构型-代理&桥接&装饰器&适配器","keywords":"设计模式，代理模式，桥接模式，装饰器模式，适配器模式","description":"对代理模式，桥接模式，装饰器模式，适配器模式这4个模式进行了比较详细的讲述。其实学习设计模式主要是为了后序看源码","cover":"https://npm.elemecdn.com/lql_static@latest/logo/design_patterns.jpg","abbrlink":"926a065c","date":"2024-06-30T16:10:00.000Z","_content":"\n\n# 声明\n\n> 1. 此系列文章非本人原创，是学习笔记。\n> 2. 设计模式系列以后会持续更新，包括已经发布的设计模式文章，因为后续还要再多看一下书，教程和开源项目等，继续润色文章。\n\n\n\n\n# 引言\n\n创建型模式比较好理解，后面的结构型和行为型设计模式不是那么好理解。如果遇到不好理解的设计模式，我一般会在开头举比较简单的Demo案例来帮助理解。\n\n# 代理模式【常用】\n\n1. 前面几节，我们讲了设计模式中的创建型模式。创建型模式主要解决对象的创建问题，封装复杂的创建过程，解耦对象的创建代码和使用代码。\n2. 其中，单例模式用来创建全局唯一的对象。工厂模式用来创建不同但是相关类型的对象（继承同一父类或者接口的一组子类），由给定的参数来决定创建哪种类型的对象。建造者模式是用来创建复杂对象，可以通过设置不同的可选参数，“定制化”地创建不同的对象。原型模式针对创建成本比较大的对象，利用对已有对象进行复制的方式进行创建，以达到节省创建时间的目的。\n3. 现在，我们讲另外一种类型的设计模式：结构型模式。结构型模式主要总结了一些类或对象组合在一起的经典结构，这些经典的结构可以解决特定应用场景的问题。结构型模式包括：代理模式、桥接模式、装饰器模式、适配器模式、门面模式、组合模式、享元模式。今天我们要讲其中的代理模式。它也是在实际开发中经常被用到的一种设计模式。\n4. 代理模式有不同的形式, 主要有三种 **静态代理**、**动态代理** (JDK 代理、接口代理)和 **Cglib** **代理** (可以在内存 动态的创建对象，而不需要实现接口， 他是属于动态代理的范畴) 。下面先通过几个比较简单的例子理解一下代理模式\n\n\n\n\n\n## 静态代理\n\n实例具体要求 \n\n1. 定义一个接口:ITeacherDao \n2. 目标对象 TeacherDAO 实现接口 ITeacherDAO \n3. 使用静态代理方式,就需要在代理对象 TeacherDAOProxy 中也实现 ITeacherDAO \n4. 调用的时候通过调用代理对象的方法来调用目标对象. \n5. 特别提醒：静态代理类与被代理类要实现相同的接口,然后通过调用相同的方法来调用目标对象的方法\n\n\n\n> **ITeacherDao**\n\n```java\n//接口\npublic interface ITeacherDao {\n\t\n\tvoid teach(); // 授课的方法\n}\n```\n\n\n\n> **TeacherDao** ---> 被代理类\n\n```java\npublic class TeacherDao implements ITeacherDao {\n\n\t@Override\n\tpublic void teach() {\n\t\t// TODO Auto-generated method stub\n\t\tSystem.out.println(\" 老师授课中  。。。。。\");\n\t}\n}\n```\n\n\n\n> **TeacherDaoProxy** ---> 代理类\n\n```java\n//代理对象,静态代理\npublic class TeacherDaoProxy implements ITeacherDao{\n\t\n\tprivate ITeacherDao target; // 目标对象，通过接口来聚合\n\t\n\t\n\t//构造器\n\tpublic TeacherDaoProxy(ITeacherDao target) {\n\t\tthis.target = target;\n\t}\n\n\n\n\t@Override\n\tpublic void teach() {\n\t\t// TODO Auto-generated method stub\n\t\tSystem.out.println(\"开始代理  完成某些操作。。。。。 \");//方法\n\t\ttarget.teach();\n\t\tSystem.out.println(\"提交。。。。。\");//方法\n\t}\n\n}\n```\n\n\n\n> Client\n\n```java\npublic class Client {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\t//创建目标对象(被代理对象)\n\t\tTeacherDao teacherDao = new TeacherDao();\n\t\t\n\t\t//创建代理对象, 同时将被代理对象传递给代理对象\n\t\tTeacherDaoProxy teacherDaoProxy = new TeacherDaoProxy(teacherDao);\n\t\t\n\t\t//通过代理对象，调用到被代理对象的方法\n\t\t//即：执行的是代理对象的方法，代理对象再去调用目标对象的方法 \n\t\tteacherDaoProxy.teach();\n\t}\n\n}\n```\n\n\n\n\n\n## 动态代理\n\n1. 代理对象,不需要实现接口，但是目标对象要实现接口，否则不能用动态代理 \n2. 代理对象的生成，是利用 JDK 的 API，动态的在内存中构建代理对象 \n3. 动态代理也叫做：JDK 代理、接口代理\n4. 代理类所在包:java.lang.reflect.Proxy \n5. JDK 实现代理只需要使用 **newProxyInstance** 方法,但是该方法需要接收三个参数,完整的写法是: \n\nstatic Object newProxyInstance(ClassLoader loader, Class<?>[] interfaces,InvocationHandler h ) \n\n\n\n> ITeacherDao\n\n```java\n//接口\npublic interface ITeacherDao {\n\n   void teach(); // 授课方法\n   void sayHello(String name);\n}\n```\n\n\n\n> TeacherDao\n\n```java\npublic class TeacherDao implements ITeacherDao {\n\n   @Override\n   public void teach() {\n      // TODO Auto-generated method stub\n      System.out.println(\" 老师授课中.... \");\n   }\n\n   @Override\n   public void sayHello(String name) {\n      // TODO Auto-generated method stub\n      System.out.println(\"hello \" + name);\n   }\n   \n}\n```\n\n\n\n> ProxyFactory\n\n```java\nimport java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Proxy;\n\npublic class ProxyFactory {\n\n   //维护一个目标对象 , Object\n   private Object target;\n\n   //构造器 ， 对target 进行初始化\n   public ProxyFactory(Object target) {\n      \n      this.target = target;\n   } \n   \n   //给目标对象 生成一个代理对象\n   public Object getProxyInstance() {\n      \n      /* 说明\n         public static Object newProxyInstance(ClassLoader loader,\n                                          Class<?>[] interfaces,\n                                          InvocationHandler h)\n                                          \n            1. ClassLoader loader ： 指定当前目标对象使用的类加载器, 获取加载器的方法固定\n            2. Class<?>[] interfaces: 目标对象实现的接口类型，使用泛型方法确认类型\n            3. InvocationHandler h : 事情处理，执行目标对象的方法时，会触发事情处理器方法, \n             会把当前执行的目标对象方法作为参数传入\n       */\n      return Proxy.newProxyInstance(target.getClass().getClassLoader(), \n            target.getClass().getInterfaces(), \n            new InvocationHandler() {\n               \n               @Override\n               public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n                  // TODO Auto-generated method stub\n                  System.out.println(\"JDK代理开始~~\");\n                  //反射机制调用目标对象的方法\n                  Object returnVal = method.invoke(target, args);\n                  System.out.println(\"JDK代理提交\");\n                  return returnVal;\n               }\n            }); \n   }\n}\n```\n\n\n\n> Client\n\n```\npublic class Client {\n\n   public static void main(String[] args) {\n      // TODO Auto-generated method stub\n      //创建目标对象\n      ITeacherDao target = new TeacherDao();\n      \n      //给目标对象，创建代理对象, 可以转成 ITeacherDao\n      ITeacherDao proxyInstance = (ITeacherDao)new ProxyFactory(target).getProxyInstance();\n   \n      // proxyInstance=class com.sun.proxy.$Proxy0 内存中动态生成了代理对象\n      System.out.println(\"proxyInstance=\" + proxyInstance.getClass());\n      \n      //通过代理对象，调用目标对象的方法\n      //proxyInstance.teach();\n      \n      proxyInstance.sayHello(\" tom \");\n   }\n\n}\n```\n\n\n\n## cglib代理\n\n1. 静态代理和 JDK 代理模式都要求目标对象是实现一个接口,但是有时候目标对象只是一个单独的对象,并没有实现任何的接口,这个时候可使用目标对象子类来实现代理-这就是Cglib代理\n\n2. Cglib代理也叫作**子类代理****,**它是在内存中构建一个子类对象从而实现对目标对象功能扩展, 有些书也将Cglib代理归属到动态代理。 \n\n3. Cglib 是一个强大的高性能的代码生成包,它可以在运行期扩展 java 类与实现 java 接口.它广泛的被许多 AOP 的 框架使用,例如 Spring AOP，实现方法拦截 \n\n4. 在 AOP 编程中如何选择代理模式： \n\n   - 目标对象需要实现接口，用 JDK 代理 \n\n   - 目标对象不需要实现接口，用 Cglib 代理 \n\n5. Cglib 包的底层是通过使用字节码处理框架 ASM 来转换字节码并生成新的类\n\n6. 需要引入 cglib 的 jar 文件，在内存中动态构建子类，注意代理的类不能为 final，否则报错 \n\n   `java.lang.IllegalArgumentException`，目标对象的方法如果为 final/static,那么就不会被拦截,即不会执行目标对象额外的业务方法. \n\n\n\n> TeacherDao\n\n```java\npublic class TeacherDao {\n\n   public String teach() {\n      System.out.println(\" 老师授课中  ， 我是cglib代理，不需要实现接口 \");\n      return \"hello\";\n   }\n}\n```\n\n\n\n> ProxyFactory\n\n```java\nimport java.lang.reflect.Method;\nimport net.sf.cglib.proxy.Enhancer;\nimport net.sf.cglib.proxy.MethodInterceptor;\nimport net.sf.cglib.proxy.MethodProxy;\n\npublic class ProxyFactory implements MethodInterceptor {\n\n   //维护一个目标对象\n   private Object target;\n   \n   //构造器，传入一个被代理的对象\n   public ProxyFactory(Object target) {\n      this.target = target;\n   }\n\n   //返回一个代理对象:  是 target 对象的代理对象\n   public Object getProxyInstance() {\n      //1. 创建一个工具类\n      Enhancer enhancer = new Enhancer();\n      //2. 设置父类\n      enhancer.setSuperclass(target.getClass());\n      //3. 设置回调函数\n      enhancer.setCallback(this);\n      //4. 创建子类对象，即代理对象\n      return enhancer.create();\n      \n   }\n   \n\n   //重写  intercept 方法，会调用目标对象的方法\n   @Override\n   public Object intercept(Object arg0, Method method, Object[] args, MethodProxy arg3) throws Throwable {\n      // TODO Auto-generated method stub\n      System.out.println(\"Cglib代理模式 ~~ 开始\");\n      Object returnVal = method.invoke(target, args);\n      System.out.println(\"Cglib代理模式 ~~ 提交\");\n      return returnVal;\n   }\n\n}\n```\n\n\n\n> Client\n\n```java\npublic class Client {\n\n   public static void main(String[] args) {\n      // TODO Auto-generated method stub\n      //创建目标对象\n      TeacherDao target = new TeacherDao();\n      //获取到代理对象，并且将目标对象传递给代理对象\n      TeacherDao proxyInstance = (TeacherDao)new ProxyFactory(target).getProxyInstance();\n\n      //执行代理对象的方法，触发intecept 方法，从而实现 对目标对象的调用\n      String res = proxyInstance.teach();\n      System.out.println(\"res=\" + res);\n   }\n\n}\n```\n\n## 代理模式的原理解析\n\n1. 代理模式（Proxy Design Pattern）的原理和代码实现都不难掌握。它在不改变原始类（或叫被代理类）代码的情况下，通过引入代理类来给原始类附加功能【**装饰器是增强功能，代理是附加新的功能**】。我们通过一个简单的例子来解释一下这段话。\n2. 我们开发了一个 MetricsCollector 类，用来收集接口请求的原始数据，比如访问时间、处理时长等。在业务系统中，我们采用如下方式来使用这个 MetricsCollector 类：\n\n```java\npublic class UserController {\n  //...省略其他属性和方法...\n  private MetricsCollector metricsCollector; // 依赖注入\n\n  public UserVo login(String telephone, String password) {\n    long startTimestamp = System.currentTimeMillis();\n\n    // ... 省略login逻辑...\n\n    long endTimeStamp = System.currentTimeMillis();\n    long responseTime = endTimeStamp - startTimestamp;\n    RequestInfo requestInfo = new RequestInfo(\"login\", responseTime, startTimestamp);\n    metricsCollector.recordRequest(requestInfo);\n\n    //...返回UserVo数据...\n  }\n\n  public UserVo register(String telephone, String password) {\n    long startTimestamp = System.currentTimeMillis();\n\n    // ... 省略register逻辑...\n\n    long endTimeStamp = System.currentTimeMillis();\n    long responseTime = endTimeStamp - startTimestamp;\n    RequestInfo requestInfo = new RequestInfo(\"register\", responseTime, startTimestamp);\n    metricsCollector.recordRequest(requestInfo);\n\n    //...返回UserVo数据...\n  }\n}\n```\n\n1. 很明显，上面的写法有两个问题。第一，性能计数器框架代码侵入到业务代码中，跟业务代码高度耦合。如果未来需要替换这个框架，那替换的成本会比较大。第二，收集接口请求的代码跟业务代码无关，本就不应该放到一个类中。业务类最好职责更加单一，只聚焦业务处理。\n2. 为了将框架代码和业务代码解耦，代理模式就派上用场了。代理类 UserControllerProxy 和原始类 UserController 实现相同的接口 IUserController。UserController 类只负责业务功能。代理类 UserControllerProxy 负责在业务代码执行前后附加其他逻辑代码，并通过委托的方式调用原始类来执行业务代码。具体的代码实现如下所示：\n\n```java\npublic interface IUserController {\n  UserVo login(String telephone, String password);\n  UserVo register(String telephone, String password);\n}\n\npublic class UserController implements IUserController {\n  //...省略其他属性和方法...\n\n  @Override\n  public UserVo login(String telephone, String password) {\n    //...省略login逻辑...\n    //...返回UserVo数据...\n  }\n\n  @Override\n  public UserVo register(String telephone, String password) {\n    //...省略register逻辑...\n    //...返回UserVo数据...\n  }\n}\n\npublic class UserControllerProxy implements IUserController {\n  private MetricsCollector metricsCollector;\n  private UserController userController;\n\n  public UserControllerProxy(UserController userController) {\n    this.userController = userController;\n    this.metricsCollector = new MetricsCollector();\n  }\n\n  @Override\n  public UserVo login(String telephone, String password) {\n    long startTimestamp = System.currentTimeMillis();\n\n    // 委托\n    UserVo userVo = userController.login(telephone, password);\n\n    long endTimeStamp = System.currentTimeMillis();\n    long responseTime = endTimeStamp - startTimestamp;\n    RequestInfo requestInfo = new RequestInfo(\"login\", responseTime, startTimestamp);\n    metricsCollector.recordRequest(requestInfo);\n\n    return userVo;\n  }\n\n  @Override\n  public UserVo register(String telephone, String password) {\n    long startTimestamp = System.currentTimeMillis();\n\n    UserVo userVo = userController.register(telephone, password);\n\n    long endTimeStamp = System.currentTimeMillis();\n    long responseTime = endTimeStamp - startTimestamp;\n    RequestInfo requestInfo = new RequestInfo(\"register\", responseTime, startTimestamp);\n    metricsCollector.recordRequest(requestInfo);\n\n    return userVo;\n  }\n}\n\n//UserControllerProxy使用举例\n//因为原始类和代理类实现相同的接口，是基于接口而非实现编程\n//将UserController类对象替换为UserControllerProxy类对象，不需要改动太多代码\nIUserController userController = new UserControllerProxy(new UserController());\n```\n\n1. 参照基于接口而非实现编程的设计思想，将原始类对象替换为代理类对象的时候，为了让代码改动尽量少，在刚刚的代理模式的代码实现中，代理类和原始类需要实现相同的接口。但是，如果原始类并没有定义接口，并且原始类代码并不是我们开发维护的（比如它来自一个第三方的类库），我们也没办法直接修改原始类，给它重新定义一个接口。在这种情况下，我们该如何实现代理模式呢？\n2. 对于这种外部类的扩展，我们一般都是采用继承的方式。这里也不例外。我们让代理类继承原始类，然后扩展附加功能。原理很简单，不需要过多解释，你直接看代码就能明白。具体代码如下所示：\n\n```java\n\npublic class UserControllerProxy extends UserController {\n  private MetricsCollector metricsCollector;\n\n  public UserControllerProxy() {\n    this.metricsCollector = new MetricsCollector();\n  }\n\n  public UserVo login(String telephone, String password) {\n    long startTimestamp = System.currentTimeMillis();\n\n    UserVo userVo = super.login(telephone, password);\n\n    long endTimeStamp = System.currentTimeMillis();\n    long responseTime = endTimeStamp - startTimestamp;\n    RequestInfo requestInfo = new RequestInfo(\"login\", responseTime, startTimestamp);\n    metricsCollector.recordRequest(requestInfo);\n\n    return userVo;\n  }\n\n  public UserVo register(String telephone, String password) {\n    long startTimestamp = System.currentTimeMillis();\n\n    UserVo userVo = super.register(telephone, password);\n\n    long endTimeStamp = System.currentTimeMillis();\n    long responseTime = endTimeStamp - startTimestamp;\n    RequestInfo requestInfo = new RequestInfo(\"register\", responseTime, startTimestamp);\n    metricsCollector.recordRequest(requestInfo);\n\n    return userVo;\n  }\n}\n//UserControllerProxy使用举例\nUserController userController = new UserControllerProxy();\n```\n\n\n\n## 动态代理的原理解析\n\n1. 不过，刚刚的代码实现还是有点问题。一方面，我们需要在代理类中，将原始类中的所有的方法，都重新实现一遍，并且为每个方法都附加相似的代码逻辑。另一方面，如果要添加的附加功能的类有不止一个，我们需要针对每个类都创建一个代理类。\n2. 如果有 50 个要添加附加功能的原始类，那我们就要创建 50  个对应的代理类。这会导致项目中类的个数成倍增加，增加了代码维护成本。并且，每个代理类中的代码都有点像模板式的“重复”代码，也增加了不必要的开发成本。那这个问题怎么解决呢？\n3. 我们可以使用动态代理来解决这个问题。所谓动态代理（Dynamic  Proxy），就是我们不事先为每个原始类编写代理类，而是在运行的时候，动态地创建原始类对应的代理类，然后在系统中用代理类替换掉原始类。那如何实现动态代理呢？\n4. 如果你熟悉的是 Java 语言，实现动态代理就是件很简单的事情。因为 Java 语言本身就已经提供了动态代理的语法（实际上，动态代理底层依赖的就是 Java  的反射语法）。我们来看一下，如何用 Java 的动态代理来实现刚刚的功能。具体的代码如下所示。其中，MetricsCollectorProxy  作为一个动态代理类，动态地给每个需要收集接口请求信息的类创建代理类。\n\n```java\n\npublic class MetricsCollectorProxy {\n  private MetricsCollector metricsCollector;\n\n  public MetricsCollectorProxy() {\n    this.metricsCollector = new MetricsCollector();\n  }\n\n  public Object createProxy(Object proxiedObject) {\n    Class<?>[] interfaces = proxiedObject.getClass().getInterfaces();\n    DynamicProxyHandler handler = new DynamicProxyHandler(proxiedObject);\n    return Proxy.newProxyInstance(proxiedObject.getClass().getClassLoader(), interfaces, handler);\n  }\n\n  private class DynamicProxyHandler implements InvocationHandler {\n    private Object proxiedObject;\n\n    public DynamicProxyHandler(Object proxiedObject) {\n      this.proxiedObject = proxiedObject;\n    }\n\n    @Override\n    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n      long startTimestamp = System.currentTimeMillis();\n      Object result = method.invoke(proxiedObject, args);\n      long endTimeStamp = System.currentTimeMillis();\n      long responseTime = endTimeStamp - startTimestamp;\n      String apiName = proxiedObject.getClass().getName() + \":\" + method.getName();\n      RequestInfo requestInfo = new RequestInfo(apiName, responseTime, startTimestamp);\n      metricsCollector.recordRequest(requestInfo);\n      return result;\n    }\n  }\n}\n\n//MetricsCollectorProxy使用举例\nMetricsCollectorProxy proxy = new MetricsCollectorProxy();\nIUserController userController = (IUserController) proxy.createProxy(new UserController());\n```\n\n\n\n实际上，Spring AOP  底层的实现原理就是基于动态代理。用户\b配置好需要给哪些类创建代理，并定义好在执行原始类的业务代码前后执行哪些附加功能。Spring  为这些类创建动态代理对象，并在 JVM  中替代原始类对象。原本在代码中执行的原始类的方法，被换作执行代理类的方法，也就实现了给原始类添加附加功能的目的。\n\n\n\n## 代理模式的应用场景\n\n\n\n### 业务系统的非功能性需求开发\n\n代理模式最常用的一个应用场景就是，在业务系统中开发一些非功能性需求，比如：监控、统计、鉴权、限流、事务、幂等、日志。我们将这些附加功能与业务功能解耦，放到代理类中统一处理，让程序员只需要关注业务方面的开发。实际上，前面举的搜集接口请求信息的例子，就是这个应用场景的一个典型例子。\n\n如果你熟悉 Java 语言和 Spring 开发框架，这部分工作都是可以在 Spring AOP 切面中完成的。前面我们也提到，Spring AOP  底层的实现原理就是基于动态代理。\n\n\n\n\n\n### 代理模式在 RPC、缓存中的应用\n\n实际上，RPC  框架也可以看作一种代理模式，GoF 的《设计模式》一书中把它称作远程代理。通过远程代理，将网络通信、数据编解码等细节隐藏起来。客户端在使用  RPC 服务的时候，就像使用本地函数一样，无需了解跟服务器交互的细节。除此之外，RPC  服务的开发者也只需要开发业务逻辑，就像开发本地使用的函数一样，不需要关注跟客户端的交互细节。\n\n\n\n\n\n### 代理模式在缓存中的应用\n\n1. 假设我们要开发一个接口请求的缓存功能，对于某些接口请求，如果入参相同，在设定的过期时间内，直接返回缓存结果，而不用重新进行逻辑处理。比如，针对获取用户个人信息的需求，我们可以开发两个接口，一个支持缓存，一个支持实时查询。对于需要实时数据的需求，我们让其调用实时查询接口，对于不需要实时数据的需求，我们让其调用支持缓存的接口。那如何来实现接口请求的缓存功能呢？\n2. 最简单的实现方法就是刚刚我们讲到的，给每个需要支持缓存的查询需求都开发两个不同的接口，一个支持缓存，一个支持实时查询。但是，这样做显然增加了开发成本，而且会让代码看起来非常臃肿（接口个数成倍增加），也不方便缓存接口的集中管理（增加、删除缓存接口）、集中配置（比如配置每个接口缓存过期时间）。\n3. 针对这些问题，代理模式就能派上用场了，确切地说，应该是动态代理。如果是基于 Spring 框架来开发的话，那就可以在 AOP  切面中完成接口缓存的功能。在应用启动的时候，我们从配置文件中加载需要支持缓存的接口，以及相应的缓存策略（比如过期时间）等。当请求到来的时候，我们在 AOP 切面中拦截请求，如果请求中带有支持缓存的字段（比如  http://…?..&cached=true），我们便从缓存（内存缓存或者 Redis 缓存等）中获取数据直接返回。\n\n\n\n\n\n\n\n# 桥接模式【常用】\n\n1. 上一节我们学习了第一种结构型模式：代理模式。它在不改变原始类（或者叫被代理类）代码的情况下，通过引入代理类来给原始类附加功能。代理模式在平时的开发经常被用到，常用在业务系统中开发一些非功能性需求，比如：监控、统计、鉴权、限流、事务、幂等、日志。\n2. 今天，我们再学习另外一种结构型模式：桥接模式。桥接模式的代码实现非常简单，但是理解起来稍微有点难度，并且应用场景也比较局限，所以，相当于代理模式来说，桥接模式在实际的项目中并没有那么常用，你只需要简单了解，见到能认识就可以，并不是我们学习的重点。\n3. 我们依旧是先看比较简单的例子\n\n## Demo案例-手机操作问题\n\n### 需求\n\n现在对不同手机类型的不同品牌实现操作编程(比如:开机、关机、上网，打电话等)，如图:\n\n<img src=\"https://npm.elemecdn.com/youthlql@1.0.0/design_patterns/structural_type/04.01/0001.png\"/>\n\n\n\n### 传统方案解决手机操作问题分析\n\n传统方法对应的类图\n\n<img src=\"https://npm.elemecdn.com/youthlql@1.0.0/design_patterns/structural_type/04.01/0007.png\"/>\n\n1. 扩展性问题(**类爆炸**)，如果我们再增加手机的样式(旋转式)，就需要增加各个品牌手机的类，同样如果我们增加一个手机品牌，也要在各个手机样式类下增加。 \n2. 违反了单一职责原则，当我们增加手机样式时，要同时增加所有品牌的手机，这样增加了代码维护成本.\n3. 解决方案-使用**桥接模**式 \n4. Bridge 模式基于类的最小设计原则，通过使用封装、聚合及继承等行为让不同的类承担不同的职责。它的主要特点是把抽象(Abstraction)与行为实现(Implementation)分离开来，从而可以保持各部分的独立性以及应对他们的功能扩展 \n\n### 使用桥接模式的代码\n\n#### Brand【接口】\n\n```java\n//接口\npublic interface Brand {\n   void open();\n   void close();\n   void call();\n}\n```\n\n#### Phone【抽象类】\n\n```java\npublic abstract class Phone {\n   \n   //组合品牌\n   private Brand brand;\n\n   //构造器\n   public Phone(Brand brand) {\n      super();\n      this.brand = brand;\n   }\n   \n   protected void open() {\n      this.brand.open();\n   }\n   protected void close() {\n      brand.close();\n   }\n   protected void call() {\n      brand.call();\n   }\n   \n}\n```\n\n#### Vivo\n\n```java\npublic class Vivo implements Brand {\n\n   @Override\n   public void open() {\n      // TODO Auto-generated method stub\n      System.out.println(\" Vivo手机开机 \");\n   }\n\n   @Override\n   public void close() {\n      // TODO Auto-generated method stub\n      System.out.println(\" Vivo手机关机 \");\n   }\n\n   @Override\n   public void call() {\n      // TODO Auto-generated method stub\n      System.out.println(\" Vivo手机打电话 \");\n   }\n\n}\n```\n\n#### XiaoMi\n\n```java\npublic class XiaoMi implements Brand {\n\n   @Override\n   public void open() {\n      // TODO Auto-generated method stub\n      System.out.println(\" 小米手机开机 \");\n   }\n\n   @Override\n   public void close() {\n      // TODO Auto-generated method stub\n      System.out.println(\" 小米手机关机 \");\n   }\n\n   @Override\n   public void call() {\n      // TODO Auto-generated method stub\n      System.out.println(\" 小米手机打电话 \");\n   }\n\n}\n```\n\n\n\n#### FoldedPhone\n\n```java\n//折叠式手机类，继承 抽象类 Phone\npublic class FoldedPhone extends Phone {\n\n   //构造器\n   public FoldedPhone(Brand brand) {\n      super(brand);\n   }\n   \n   public void open() {\n      super.open();\n      System.out.println(\" 折叠样式手机 \");\n   }\n   \n   public void close() {\n      super.close();\n      System.out.println(\" 折叠样式手机 \");\n   }\n   \n   public void call() {\n      super.call();\n      System.out.println(\" 折叠样式手机 \");\n   }\n}\n```\n\n\n\n#### UpRightPhone\n\n```java\npublic class UpRightPhone extends Phone {\n   \n      //构造器\n      public UpRightPhone(Brand brand) {\n         super(brand);\n      }\n      \n      public void open() {\n         super.open();\n         System.out.println(\" 直立样式手机 \");\n      }\n      \n      public void close() {\n         super.close();\n         System.out.println(\" 直立样式手机 \");\n      }\n      \n      public void call() {\n         super.call();\n         System.out.println(\" 直立样式手机 \");\n      }\n}\n```\n\n\n\n#### Client\n\n```\npublic class Client {\n\n   public static void main(String[] args) {\n      \n      //获取折叠式手机 (样式 + 品牌 )\n      \n      Phone phone1 = new FoldedPhone(new XiaoMi());\n      \n      phone1.open();\n      phone1.call();\n      phone1.close();\n      \n      System.out.println(\"=======================\");\n      \n      Phone phone2 = new FoldedPhone(new Vivo());\n      \n      phone2.open();\n      phone2.call();\n      phone2.close();\n      \n      System.out.println(\"==============\");\n      \n      UpRightPhone phone3 = new UpRightPhone(new XiaoMi());\n      \n      phone3.open();\n      phone3.call();\n      phone3.close();\n      \n      System.out.println(\"==============\");\n      \n      UpRightPhone phone4 = new UpRightPhone(new Vivo());\n      \n      phone4.open();\n      phone4.call();\n      phone4.close();\n   }\n\n}\n```\n\n\n\n> 这种简单的demo例子可能比较好理解桥接模式，下面来看看原理和实际应用\n\n## 桥接模式的原理解析\n\n1. 桥接模式，也叫作桥梁模式，英文是Bridge Design Pattern。这个模式可以说是 23 种设计模式中最难理解的模式之一了。我查阅了比较多的书籍和资料之后发现，对于这个模式有两种不同的理解方式。\n2. 当然，这其中“最纯正”的理解方式，当属 GoF 的《设计模式》一书中对桥接模式的定义。毕竟，这 23 种经典的设计模式，最初就是由这本书总结出来的。在 GoF 的《设计模式》一书中，桥接模式是这么定义的：“Decouple an abstraction from its implementation so that the two can vary independently。”翻译成中文就是：“将抽象和实现解耦，让它们可以独立变化。”\n3. 关于桥接模式，很多书籍、资料中，还有另外一种理解方式：“一个类存在两个（或多个）独立变化的维度，我们通过组合的方式，让这两个（或多个）维度可以独立进行扩展。”通过组合关系来替代继承关系，避免继承层次的指数级爆炸。这种理解方式非常类似于，我们之前讲过的“组合优于继承”设计原则，所以，这里我就不多解释了。我们重点看下 GoF 的理解方式。\n4. GoF 给出的定义非常的简短，单凭这一句话，估计没几个人能看懂是什么意思。所以，我们通过 JDBC 驱动的例子来解释一下。JDBC 驱动是桥接模式的经典应用。我们先来看一下，如何利用 JDBC 驱动来查询数据库。具体的代码如下所示：\n\n\n\n```java\n    Class.forName(\"com.mysql.jdbc.Driver\"); // 加载及注册JDBC驱动程序\n    String url = \"jdbc:mysql://localhost:3306/sample_db?user=root&password=your_password\";\n    Connection con = DriverManager.getConnection(url);\n    Statement stmt = con.createStatement();\n    String query = \"select * from test\";\n    ResultSet rs = stmt.executeQuery(query);\n    while (rs.next()) {\n      rs.getString(1);\n      rs.getInt(2);\n    }\n```\n\n\n\n1. 如果我们想要把 MySQL 数据库换成 Oracle 数据库，只需要把第一行代码中的 com.mysql.jdbc.Driver 换成 oracle.jdbc.driver.OracleDriver 就可以了。当然，也有更灵活的实现方式，我们可以把需要加载的 Driver 类写到配置文件中，当程序启动的时候，自动从配置文件中加载，这样在切换数据库的时候，我们都不需要修改代码，只需要修改配置文件就可以了。\n2. 不管是改代码还是改配置，在项目中，从一个数据库切换到另一种数据库，都只需要改动很少的代码，或者完全不需要改动代码，那如此优雅的数据库切换是如何实现的呢？\n3. 源码之下无秘密。要弄清楚这个问题，我们先从 com.mysql.jdbc.Driver 这个类的代码看起。我摘抄了部分相关代码，放到了这里，你可以看一下。\n\n\n\n```java\npackage com.mysql.jdbc;\nimport java.sql.SQLException;\n\npublic class Driver extends NonRegisteringDriver implements java.sql.Driver {\n  static {\n    try {\n      java.sql.DriverManager.registerDriver(new Driver());\n    } catch (SQLException E) {\n      throw new RuntimeException(\"Can't register driver!\");\n    }\n  }\n\n  /**\n   * Construct a new driver and register it with DriverManager\n   * @throws SQLException if a database error occurs.\n   */\n  public Driver() throws SQLException {\n  // Required for Class.forName().newInstance()\n  }\n}\n\n```\n\n\n\n结合 com.mysql.jdbc.Driver 的代码实现，我们可以发现，当执行 Class.forName(“com.mysql.jdbc.Driver”) 这条语句的时候，实际上是做了两件事情。第一件事情是要求 JVM 查找并加载指定的 Driver 类，第二件事情是执行该类的静态代码，也就是将 MySQL Driver 注册到 DriverManager 类中。\n\n\n\n现在，我们再来看一下，DriverManager 类是干什么用的。具体的代码如下所示。当我们把具体的 Driver 实现类（比如，com.mysql.jdbc.Driver）注册到 DriverManager 之后，后续所有对 JDBC 接口的调用，都会委派到对具体的 Driver 实现类来执行。而 Driver 实现类都实现了相同的接口（java.sql.Driver ），这也是可以灵活切换 Driver 的原因。\n\n\n\n```java\npublic class DriverManager {\n  private static final  CopyOnWriteArrayList<DriverInfo> registeredDrivers =  = new CopyOnWriteArrayList();\n\n  // ...\n  static {\n    loadInitialDrivers();\n    println(\"JDBC DriverManager initialized\");\n  }\n\n  // ...\n  public static synchronized void registerDriver(java.sql.Driver driver) throws SQLException {\n    if (driver != null) {\n      registeredDrivers.addIfAbsent(new DriverInfo(driver));\n    } else {\n      throw new NullPointerException();\n    }\n  }\n\n  public static Connection getConnection(String url, String user, String password)\n      throws SQLException {\n    java.util.Properties info = new java.util.Properties();\n    if (user != null) {\n      info.put(\"user\", user);\n    }\n    if (password != null) {\n      info.put(\"password\", password);\n    }\n\n    return (getConnection(url, info, Reflection.getCallerClass()));\n  }\n  // ...\n}\n\n```\n\n\n\n桥接模式的定义是“将抽象和实现解耦，让它们可以独立变化”。那弄懂定义中“抽象”和“实现”两个概念，就是理解桥接模式的关键。那在 JDBC 这个例子中，什么是“抽象”？什么是“实现”呢？\n\n\n\n实际上，JDBC 本身就相当于“抽象”。注意，这里所说的“抽象”，指的并非“抽象类”或“接口”，而是跟具体的数据库无关的、被抽象出来的一套“类库”。具体的 Driver（比如，com.mysql.jdbc.Driver）就相当于“实现”。注意，这里所说的“实现”，也并非指“接口的实现类”，而是跟具体数据库相关的一套“类库”。JDBC 和 Driver 独立开发，通过对象之间的组合关系，组装在一起。JDBC 的所有逻辑操作，最终都委托给 Driver 来执行。\n\n\n\n<img src=\"https://npm.elemecdn.com/youthlql@1.0.0/design_patterns/structural_type/04.01/0002.png\">\n\n\n\n## 桥接模式的应用举例\n\n在前面，我们讲过一个 API 接口监控告警的例子：根据不同的告警规则，触发不同类型的告警。告警支持多种通知渠道，包括：邮件、短信、微信、自动语音电话。通知的紧急程度有多种类型，包括：SEVERE（严重）、URGENCY（紧急）、NORMAL（普通）、TRIVIAL（无关紧要）。不同的紧急程度对应不同的通知渠道。比如，SERVE（严重）级别的消息会通过“自动语音电话”告知相关人员。\n\n\n\n在当时的代码实现中，关于发送告警信息那部分代码，我们只给出了粗略的设计，现在我们来一块实现一下。我们先来看最简单、最直接的一种实现方式。代码如下所示：\n\n```java\n\npublic enum NotificationEmergencyLevel {\n  SEVERE,\n  URGENCY,\n  NORMAL,\n  TRIVIAL\n}\n\npublic class Notification {\n  private List<String> emailAddresses;\n  private List<String> telephones;\n  private List<String> wechatIds;\n\n  public Notification() {}\n\n  public void setEmailAddress(List<String> emailAddress) {\n    this.emailAddresses = emailAddress;\n  }\n\n  public void setTelephones(List<String> telephones) {\n    this.telephones = telephones;\n  }\n\n  public void setWechatIds(List<String> wechatIds) {\n    this.wechatIds = wechatIds;\n  }\n\n  public void notify(NotificationEmergencyLevel level, String message) {\n    if (level.equals(NotificationEmergencyLevel.SEVERE)) {\n      // ...自动语音电话\n    } else if (level.equals(NotificationEmergencyLevel.URGENCY)) {\n      // ...发微信\n    } else if (level.equals(NotificationEmergencyLevel.NORMAL)) {\n      // ...发邮件\n    } else if (level.equals(NotificationEmergencyLevel.TRIVIAL)) {\n      // ...发邮件\n    }\n  }\n}\n\n// 在API监控告警的例子中，我们如下方式来使用Notification类：\npublic class ErrorAlertHandler extends AlertHandler {\n  public ErrorAlertHandler(AlertRule rule, Notification notification) {\n    super(rule, notification);\n  }\n\n  @Override\n  public void check(ApiStatInfo apiStatInfo) {\n    if (apiStatInfo.getErrorCount()\n        > rule.getMatchedRule(apiStatInfo.getApi()).getMaxErrorCount()) {\n      notification.notify(NotificationEmergencyLevel.SEVERE, \"...\");\n    }\n  }\n}\n\n```\n\n\n\n1. Notification 类的代码实现有一个最明显的问题，那就是有很多 if-else 分支逻辑。实际上，如果每个分支中的代码都不复杂，后期也没有无限膨胀的可能（增加更多 if-else 分支判断），那这样的设计问题并不大，没必要非得一定要摒弃 if-else 分支逻辑。\n2. 不过，Notification 的代码显然不符合这个条件。因为每个 if-else 分支中的代码逻辑都比较复杂，发送通知的所有逻辑都扎堆在 Notification 类中。我们知道，类的代码越多，就越难读懂，越难修改，维护的成本也就越高。很多设计模式都是试图将庞大的类拆分成更细小的类，然后再通过某种更合理的结构组装在一起。\n3. 针对 Notification 的代码，我们将不同渠道的发送逻辑剥离出来，形成独立的消息发送类（MsgSender 相关类）。其中，Notification 类相当于抽象，MsgSender 类相当于实现，两者可以独立开发，通过组合关系（也就是桥梁）任意组合在一起。所谓任意组合的意思就是，不同紧急程度的消息和发送渠道之间的对应关系，不是在代码中固定写死的，我们可以动态地去指定（比如，通过读取配置来获取对应关系）。\n\n\n\n按照这个设计思路，我们对代码进行重构。重构之后的代码如下所示：\n\n```java\n\npublic interface MsgSender {\n  void send(String message);\n}\n\npublic class TelephoneMsgSender implements MsgSender {\n  private List<String> telephones;\n\n  public TelephoneMsgSender(List<String> telephones) {\n    this.telephones = telephones;\n  }\n\n  @Override\n  public void send(String message) {\n    // ...\n  }\n}\n\npublic class EmailMsgSender implements MsgSender {\n  // 与TelephoneMsgSender代码结构类似，所以省略...\n}\n\npublic class WechatMsgSender implements MsgSender {\n  // 与TelephoneMsgSender代码结构类似，所以省略...\n}\n\npublic abstract class Notification {\n  protected MsgSender msgSender;\n\n  public Notification(MsgSender msgSender) {\n    this.msgSender = msgSender;\n  }\n\n  public abstract void notify(String message);\n}\n\npublic class SevereNotification extends Notification {\n  public SevereNotification(MsgSender msgSender) {\n    super(msgSender);\n  }\n\n  @Override\n  public void notify(String message) {\n    msgSender.send(message);\n  }\n}\n\npublic class UrgencyNotification extends Notification {\n  // 与SevereNotification代码结构类似，所以省略...\n}\n\npublic class NormalNotification extends Notification {\n  // 与SevereNotification代码结构类似，所以省略...\n}\n\npublic class TrivialNotification extends Notification {\n  // 与SevereNotification代码结构类似，所以省略...\n}\n\n```\n\n\n\n## 桥接模式的注意事项和细节\n\n1. 实现了抽象和实现部分的分离，从而极大的提供了系统的灵活性，让抽象部分和实现部分独立开来，这有助于系统进行分层设计，从而产生更好的结构化系统。 \n2. 对于系统的高层部分，只需要知道抽象部分和实现部分的接口就可以了，其它的部分由具体业务来完成。\n3. 桥接模式替代多层继承方案，可以减少子类的个数，降低系统的管理和维护成本\n4. 桥接模式的引入增加了系统的理解和设计难度，由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设计和编程 \n5. 桥接模式要求**正确识别出系统中两个独立变化的维度(抽象、和实现)**，因此其使用范围有一定的局限性，即需要有这样的应用场景。\n\n\n\n# 装饰器模式【常用】\n\n\n\n我们学习了桥接模式，桥接模式有两种理解方式。第一种理解方式是“将抽象和实现解耦，让它们能独立开发”。这种理解方式比较特别，应用场景也不多。另一种理解方式更加简单，类似“组合优于继承”设计原则，这种理解方式更加通用，应用场景比较多。不管是哪种理解方式，它们的代码结构都是相同的，都是一种类之间的组合关系。\n\n今天，我们通过剖析 Java IO 类的设计思想，再学习一种新的结构型模式，装饰器模式。它的代码结构跟桥接模式非常相似，不过，要解决的问题却大不相同。\n\n> 不过还是先看一个简单的demo案例，会比较好理解\n\n\n\n## Demo案例-咖啡订单项目\n\n### 星巴克咖啡订单项目\n\n1. 咖啡种类/单品咖啡：Espresso(意大利浓咖啡)、ShortBlack、LongBlack(美式咖啡)、Decaf(无因咖啡) \n2. 调料：Milk、Soy(豆浆)、Chocolate \n3. 要求在扩展新的咖啡种类时，具有良好的扩展性、改动方便、维护方便 \n4. 使用 OO 的来计算不同种类咖啡的费用: 客户可以点单品咖啡，也可以单品咖啡+调料组合。\n\n\n\n### 方案一\n\n<img src=\"https://npm.elemecdn.com/youthlql@1.0.0/design_patterns/structural_type/04.01/0003.png\"/>\n\n\n\n1. Drink 是一个抽象类，表示饮料 \n2. des 就是对咖啡的描述, 比如咖啡的名字 \n3. cost() 方法就是计算费用，Drink 类中做成一个抽象方法. \n4. Decaf 就是单品咖啡， 继承 Drink, 并实现 cost \n5. Espress && Milk 就是单品咖啡+调料， 这个组合很多\n6. 问题：**这样设计，会有很多类，当我们增加一个单品咖啡，或者一个新的调料，类的数量就会倍增，就会出现类爆炸** \n\n### 方案二\n\n前面分析到方案 1 因为咖啡单品+调料组合会造成类的倍增，因此可以做改进，将调料内置到 Drink 类，这样就不会造成类数量过多。从而提高项目的维护性(如图)\n\n<img src=\"https://npm.elemecdn.com/youthlql@1.0.0/design_patterns/structural_type/04.01/0004.png\">\n\n\n\n1. 方案 2 可以控制类的数量，不至于造成很多的类 \n2. 在增加或者删除调料种类时，代码的维护量很大 \n3. 考虑到用户可以添加多份 调料时，可以将 hasMilk 返回一个对应 int \n4. 考虑使用 **装饰者** 模式\n\n> 注意：装饰器模式是对功能的增强，而不是附加新的功能。代理模式才是附加新的功能。\n\n\n\n### 装饰器模式代码\n\n<img src=\"https://npm.elemecdn.com/youthlql@1.0.0/design_patterns/structural_type/04.01/0005.png\"/>\n\n#### Drink【抽象类-主体Component】\n\n```java\npublic abstract class Drink {\n\n   public String des; // 描述\n   private float price = 0.0f;\n   public String getDes() {\n      return des;\n   }\n   public void setDes(String des) {\n      this.des = des;\n   }\n   public float getPrice() {\n      return price;\n   }\n   public void setPrice(float price) {\n      this.price = price;\n   }\n   \n   //计算费用的抽象方法\n   //子类来实现\n   public abstract float cost();\n   \n}\n```\n\n\n\n#### Decorator\n\n```java\npublic class Decorator extends Drink {\n   private Drink obj;\n   \n   public Decorator(Drink obj) { //组合\n      // TODO Auto-generated constructor stub\n      this.obj = obj;\n   }\n   \n   @Override\n   public float cost() {\n      // TODO Auto-generated method stub\n      // getPrice 自己价格\n      return super.getPrice() + obj.cost();\n   }\n   \n   @Override\n   public String getDes() {\n      // TODO Auto-generated method stub\n      // obj.getDes() 输出被装饰者的信息\n      return des + \" \" + getPrice() + \" && \" + obj.getDes();\n   }\n   \n}\n```\n\n#### Coffee\n\n```\npublic class Coffee extends Drink {\n\n  @Override\n  public float cost() {\n    // TODO Auto-generated method stub\n    return super.getPrice();\n  }\n}\n```\n\n#### ShortBlack\n\n```java\npublic class ShortBlack extends Coffee{\n   \n   public ShortBlack() {\n      setDes(\" shortblack \");\n      setPrice(4.0f);\n   }\n}\n```\n\n#### LongBlack\n\n```java\npublic class LongBlack extends Coffee {\n\n   public LongBlack() {\n      setDes(\" longblack \");\n      setPrice(5.0f);\n   }\n}\n```\n\n#### DeCaf\n\n```java\npublic class DeCaf extends Coffee {\n\n   public DeCaf() {\n      setDes(\" 无因咖啡 \");\n      setPrice(1.0f);\n   }\n}\n```\n\n#### Espresso\n\n```java\npublic class Espresso extends Coffee {\n   \n   public Espresso() {\n      setDes(\" 意大利咖啡 \");\n      setPrice(6.0f);\n   }\n}\n```\n\n#### Chocolate\n\n```java\n//具体的Decorator， 这里就是调味品\npublic class Chocolate extends Decorator {\n\n   public Chocolate(Drink obj) {\n      super(obj);\n      setDes(\" 巧克力 \");\n      setPrice(3.0f); // 调味品 的价格\n   }\n\n}\n```\n\n#### Milk\n\n```java\npublic class Milk extends Decorator {\n\n   public Milk(Drink obj) {\n      super(obj);\n      // TODO Auto-generated constructor stub\n      setDes(\" 牛奶 \");\n      setPrice(2.0f); \n   }\n\n}\n```\n\n#### Soy\n\n```java\npublic class Soy extends Decorator{\n\n   public Soy(Drink obj) {\n      super(obj);\n      // TODO Auto-generated constructor stub\n      setDes(\" 豆浆  \");\n      setPrice(1.5f);\n   }\n\n}\n```\n\n#### CoffeeBar\n\n```java\npublic class CoffeeBar {\n\n   public static void main(String[] args) {\n      // TODO Auto-generated method stub\n      // 装饰者模式下的订单：2份巧克力+一份牛奶的LongBlack\n\n      // 1. 点一份 LongBlack\n      Drink order = new LongBlack();\n      System.out.println(\"费用1=\" + order.cost());\n      System.out.println(\"描述=\" + order.getDes());\n\n      // 2. order 加入一份牛奶\n      order = new Milk(order);\n\n      System.out.println(\"order 加入一份牛奶 费用 =\" + order.cost());\n      System.out.println(\"order 加入一份牛奶 描述 = \" + order.getDes());\n\n      // 3. order 加入一份巧克力\n\n      order = new Chocolate(order);\n\n      System.out.println(\"order 加入一份牛奶 加入一份巧克力  费用 =\" + order.cost());\n      System.out.println(\"order 加入一份牛奶 加入一份巧克力 描述 = \" + order.getDes());\n\n      // 3. order 加入一份巧克力\n\n      order = new Chocolate(order);\n\n      System.out.println(\"order 加入一份牛奶 加入2份巧克力   费用 =\" + order.cost());\n      System.out.println(\"order 加入一份牛奶 加入2份巧克力 描述 = \" + order.getDes());\n   \n      System.out.println(\"===========================\");\n      \n      Drink order2 = new DeCaf();\n      \n      System.out.println(\"order2 无因咖啡  费用 =\" + order2.cost());\n      System.out.println(\"order2 无因咖啡 描述 = \" + order2.getDes());\n      \n      order2 = new Milk(order2);\n      \n      System.out.println(\"order2 无因咖啡 加入一份牛奶  费用 =\" + order2.cost());\n      System.out.println(\"order2 无因咖啡 加入一份牛奶 描述 = \" + order2.getDes());\n\n   \n   }\n\n}\n```\n\n\n\n## 装饰者模式原理\n\n1. 装饰者模式就像打包一个快递 \n\n主体：比如：陶瓷、衣服 (Component) // 被装饰者 \n\n包装：比如：报纸填充、塑料泡沫、纸板、木板(Decorator) \n\n2. Component 主体：比如类似前面的 Drink \n\n3. ConcreteComponent 和 Decorator \n\nConcreteComponent：具体的主体， 比如前面的各个单品咖啡 \n\n4. Decorator: 装饰者，比如各调料. \n\n在Component 与 ConcreteComponent 之间，如果 ConcreteComponent 类很多,还可以设计一个缓冲层，将 共有的部分提取出来，抽象层一个类\n\n## Java IO 类的“奇怪”用法\n\nJava IO 类库非常庞大和复杂，有几十个类，负责 IO 数据的读取和写入。如果对 Java IO 类做一下分类，我们可以从下面两个维度将它划分为四类。具体如下所示：\n\n|        | 字节流       | 字符流 |\n| ------ | ------------ | ------ |\n| 输入流 | InputStream  | Reader |\n| 输出流 | OutputStream | Writer |\n\n针对不同的读取和写入场景，Java IO 又在这四个父类基础之上，扩展出了很多子类。具体如下所示：\n\n<img src=\"https://npm.elemecdn.com/youthlql@1.0.0/design_patterns/structural_type/04.01/0006.png\"/>\n\n\n\n> 说明\n>\n> 1. InputStream 是抽象类, 类似我们前面讲的 Drink\n> 2. FileInputStream 是  InputStream 子类，类似我们前面的 DeCaf, LongBlack\n> 3. FilterInputStream  是  InputStream 子类：类似我们前面 的 Decorator 修饰者\n> 4. DataInputStream 是 FilterInputStream 子类，具体的修饰者，类似前面的 Milk, Soy 等\n> 5. FilterInputStream 类 有  protected volatile InputStream in; 即含被装饰者\n> 6. 分析得出在jdk 的io体系中，就是使用装饰者模式\n\n在我初学 Java 的时候，曾经对 Java IO 的一些用法产生过很大疑惑，比如下面这样一段代码。我们打开文件 test.txt，从中读取数据。其中，InputStream 是一个抽象类，FileInputStream 是专门用来读取文件流的子类。BufferedInputStream 是一个支持带缓存功能的数据读取类，可以提高数据读取的效率。\n\n\n\n```java\nInputStream in = new FileInputStream(\"/user/test.txt\");\nInputStream bin = new BufferedInputStream(in);\nbyte[] data = new byte[128];\nwhile (bin.read(data) != -1) {\n    //...\n}\n```\n\n初看上面的代码，我们会觉得 Java IO 的用法比较麻烦，需要先创建一个 FileInputStream 对象，然后再传递给 BufferedInputStream 对象来使用。我在想，Java IO 为什么不设计一个继承 FileInputStream 并且支持缓存的 BufferedFileInputStream 类呢？这样我们就可以像下面的代码中这样，直接创建一个 BufferedFileInputStream 类对象，打开文件读取数据，用起来岂不是更加简单？\n\n\n\n```java\nInputStream bin = new BufferedFileInputStream(\"/user/test.txt\");\nbyte[] data = new byte[128];\nwhile (bin.read(data) != -1) {\n    //...\n}\n```\n\n\n\n\n\n## 基于继承的设计方案\n\n如果 InputStream 只有一个子类 FileInputStream 的话，那我们在 FileInputStream 基础之上，再设计一个孙子类 BufferedFileInputStream，也算是可以接受的，毕竟继承结构还算简单。但实际上，继承 InputStream 的子类有很多。我们需要给每一个 InputStream 的子类，再继续派生支持缓存读取的子类。\n\n\n\n除了支持缓存读取之外，如果我们还需要对功能进行其他方面的增强，比如下面的 DataInputStream 类，支持按照基本数据类型（int、boolean、long 等）来读取数据。\n\n```java\nFileInputStream in = new FileInputStream(\"/user/test.txt\");\nDataInputStream din = new DataInputStream(in);\nint data = din.readInt();\n```\n\n在这种情况下，如果我们继续按照继承的方式来实现的话，就需要再继续派生出 DataFileInputStream、DataPipedInputStream 等类。如果我们还需要既支持缓存、又支持按照基本类型读取数据的类，那就要再继续派生出 BufferedDataFileInputStream、BufferedDataPipedInputStream 等 n 多类。这还只是附加了两个增强功能，如果我们需要附加更多的增强功能，那就会导致组合爆炸，类继承结构变得无比复杂，代码既不好扩展，也不好维护。这也是我们不推荐使用继承的原因。\n\n\n\n## 基于装饰器模式的设计方案\n\n\n\n在前面，我们还讲到“组合优于继承”，可以“使用组合来替代继承”。针对刚刚的继承结构过于复杂的问题，我们可以通过将继承关系改为组合关系来解决。下面的代码展示了 Java IO 的这种设计思路。不过，我对代码做了简化，只抽象出了必要的代码结构，如果你感兴趣的话，可以直接去查看 JDK 源码。\n\n```java\nimport java.io.IOException;\n\npublic abstract class InputStream {\n  // ...\n  public int read(byte b[]) throws IOException {\n    return read(b, 0, b.length);\n  }\n  public int read(byte b[], int off, int len) throws IOException {\n    // ...\n  }\n\n  public long skip(long n) throws IOException {\n    // ...\n  }\n\n  public int available() throws IOException {\n    return 0;\n  }\n\n  public void close() throws IOException {}\n\n  public synchronized void mark(int readlimit) {}\n\n  public synchronized void reset() throws IOException {\n    throw new IOException(\"mark/reset not supported\");\n  }\n\n  public boolean markSupported() {\n    return false;\n  }\n}\n\npublic class BufferedInputStream extends InputStream {\n  protected volatile InputStream in;\n\n  protected BufferedInputStream(InputStream in) {\n    this.in = in;\n  }\n\n  // ...实现基于缓存的读数据接口...\n}\n\npublic class DataInputStream extends InputStream {\n  protected volatile InputStream in;\n\n  protected DataInputStream(InputStream in) {\n    this.in = in;\n  }\n\n  // ...实现读取基本类型数据的接口\n}\n\n```\n\n看了上面的代码，你可能会问，那装饰器模式就是简单的“用组合替代继承”吗？当然不是。从 Java IO 的设计来看，装饰器模式相对于简单的组合关系，还有两个比较特殊的地方。\n\n\n\n**第一个比较特殊的地方是：装饰器类和原始类继承同样的父类，这样我们可以对原始类“嵌套”多个装饰器类。**比如，下面这样一段代码，我们对 FileInputStream 嵌套了两个装饰器类：BufferedInputStream 和 DataInputStream，让它既支持缓存读取，又支持按照基本数据类型来读取数据。\n\n\n\n```java\nInputStream in = new FileInputStream(\"/user/test.txt\");\nInputStream bin = new BufferedInputStream(in);\nDataInputStream din = new DataInputStream(bin);\nint data = din.readInt();\n```\n\n\n\n**第二个比较特殊的地方是：装饰器类是对功能的增强，这也是装饰器模式应用场景的一个重要特点。**实际上，符合“组合关系”这种代码结构的设计模式有很多，比如之前讲过的代理模式、桥接模式，还有现在的装饰器模式。尽管它们的代码结构很相似，但是每种设计模式的意图是不同的。就拿比较相似的代理模式和装饰器模式来说吧，代理模式中，代理类附加的是跟原始类无关的功能，而在装饰器模式中，装饰器类附加的是跟原始类相关的增强功能。\n\n```java\n// 代理模式的代码结构(下面的接口也可以替换成抽象类)\npublic interface IA {\n    void f();\n}\n\npublic class A impelements IA {\n    public void f() { \n        //... \n    }\n}\n\npublic class AProxy impements IA {\n    private IA a;\n\n    public AProxy(IA a) {\n        this.a = a;\n    }\n\n    public void f() {\n        // 新添加的代理逻辑\n        a.f();\n        // 新添加的代理逻辑\n    }\n}\n\n// 装饰器模式的代码结构(下面的接口也可以替换成抽象类)\npublic interface IA {\n    void f();\n}\n\npublic class A impelements IA {\n\n    public void f() { \n        //... \n    }\n}\n\npublic class ADecorator impements IA {\n    private IA a;\n    public ADecorator(IA a) {\n        this.a = a;\n    }\n\n    public void f() {\n        // 功能增强代码\n        a.f();\n        // 功能增强代码\n    }\n}\n```\n\n\n\n1. 实际上，如果去查看 JDK 的源码，你会发现，BufferedInputStream、DataInputStream 并非继承自 InputStream，而是另外一个叫 FilterInputStream 的类。那这又是出于什么样的设计意图，才引入这样一个类呢？\n2. 我们再重新来看一下 BufferedInputStream 类的代码。InputStream 是一个抽象类而非接口，而且它的大部分函数（比如 read()、available()）都有默认实现，按理来说，我们只需要在 BufferedInputStream 类中重新实现那些需要增加缓存功能的函数就可以了，其他函数继承 InputStream 的默认实现。但实际上，这样做是行不通的。\n3. 对于即便是不需要增加缓存功能的函数来说，BufferedInputStream 还是必须把它重新实现一遍，简单包裹对 InputStream 对象的函数调用。具体的代码示例如下所示。如果不重新实现，那 BufferedInputStream 类就无法将最终读取数据的任务，委托给传递进来的 InputStream 对象来完成。这一部分稍微有点不好理解，你自己多思考一下。\n\n\n\n```java\npublic class BufferedInputStream extends InputStream {\n    protected volatile InputStream in;\n\n    protected BufferedInputStream(InputStream in) {\n        this.in = in;\n    }\n\n\t// f()函数不需要增强，只是重新调用一下InputStream in对象的f()\n    public void f() { \n        in.f();\n    }\n}\n```\n\n\n\n实际上，DataInputStream 也存在跟 BufferedInputStream 同样的问题。为了避免代码重复，Java IO 抽象出了一个装饰器父类 FilterInputStream，代码实现如下所示。InputStream 的所有的装饰器类（BufferedInputStream、DataInputStream）都继承自这个装饰器父类。这样，装饰器类只需要实现它需要增强的方法就可以了，其他方法继承装饰器父类的默认实现。\n\n\n\n```java\n\npublic class FilterInputStream extends InputStream {\n    protected volatile InputStream in;\n\n    protected FilterInputStream(InputStream in) {\n        this.in = in;\n    }\n\n    public int read() throws IOException {\n        return in.read();\n    }\n\n    public int read(byte b[]) throws IOException { \n        return read(b, 0, b.length);\n    }\n\n    public int read(byte b[], int off, int len) throws IOException {\n        return in.read(b, off, len);\n    }\n\n    public long skip(long n) throws IOException {\n        return in.skip(n);\n    }\n\n    public int available() throws IOException {\n        return in.available();\n    }\n\n    public void close() throws IOException {\n        in.close();\n    }\n\n    public synchronized void mark(int readlimit) {\n        in.mark(readlimit);\n    }\n\n    public synchronized void reset() throws IOException {\n        in.reset();\n    }\n\n    public boolean markSupported() {\n        return in.markSupported();\n    }\n\n}\n```\n\n\n\n\n\n# 适配器模式【常用】\n\n1. 前面我们学了代理模式、桥接模式、装饰器模式，今天，我们再来学习一个比较常用的结构型模式：适配器模式。这个模式相对来说还是比较简单、好理解的，应用场景也很具体，总体上来讲比较好掌握。\n2. 关于适配器模式，今天我们主要学习它的两种实现方式，类适配器和对象适配器，以及 5 种常见的应用场景。同时，我还会通过剖析 slf4j 日志框架，来给你展示这个模式在真实项目中的应用。除此之外，在文章的最后，我还对代理、桥接、装饰器、适配器，这 4 种代码结构非常相似的设计模式做简单的对比，对这几节内容做一个简单的总结。\n3. 适配器模式(Adapter Pattern)将某个类的接口转换成客户端期望的另一个接口表示，**主的目的是兼容性**，让原本因接口不匹配不能一起工作的两个类可以协同工作。其别名为包装器(Wrapper) 。适配器模式属于结构型模式。主要分为三类：**类适配器模式、对象适配器模式、接口适配器模**式 \n\n\n\n## Demo案例-充电器\n\n基本介绍：Adapter 类，通过继承 src 类，实现 dst 类接口，完成 src->dst 的适配。\n\n- 以生活中充电器的例子来讲解适配器，充电器本身相当于 Adapter，220V 交流电相当于 src (即被适配者)，我们 的目 dst(即 目标)是 5V 直流电 \n\n### 类适配器代码实现\n\n#### Voltage220V\n\n```java\n//被适配的类\npublic class Voltage220V {\n   //输出220V的电压\n   public int output220V() {\n      int src = 220;\n      System.out.println(\"电压=\" + src + \"伏\");\n      return src;\n   }\n}\n```\n\n#### IVoltage5V\n\n```java\n//适配接口\npublic interface IVoltage5V {\n   public int output5V();\n}\n```\n\n#### Phone\n\n```java\npublic class Phone {\n\n   //充电\n   public void charging(IVoltage5V iVoltage5V) {\n      if(iVoltage5V.output5V() == 5) {\n         System.out.println(\"电压为5V, 可以充电~~\");\n      } else if (iVoltage5V.output5V() > 5) {\n         System.out.println(\"电压大于5V, 不能充电~~\");\n      }\n   }\n}\n```\n\n#### VoltageAdapter\n\n```java\n//适配器类\npublic class VoltageAdapter extends Voltage220V implements IVoltage5V {\n\n   @Override\n   public int output5V() {\n      // TODO Auto-generated method stub\n      //获取到220V电压\n      int srcV = output220V();\n      int dstV = srcV / 44 ; //转成 5v\n      return dstV;\n   }\n\n}\n```\n\n#### Client\n\n```java\npublic class Client {\n\n   public static void main(String[] args) {\n      // TODO Auto-generated method stub\n      System.out.println(\" === 类适配器模式 ====\");\n      Phone phone = new Phone();\n      phone.charging(new VoltageAdapter());\n   }\n\n}\n```\n\n\n\n### 对象适配器实现\n\n基本思路和类的适配器模式相同，只是将 Adapter 类作修改，不是继承 src 类，而是持有 src 类的实例，以解决 兼容性的问题。 即：持有 src 类，实现 dst 类接口，完成 src->dst 的适配 ，在系统中尽量使用**关联关系（聚合，组合）来替代继承**关系。\n\n\n\n上面的例子代码基本没用什么改变，改变的只有以下两个类\n\n#### VoltageAdapter\n\n```java\n// 适配器类\npublic class VoltageAdapter implements IVoltage5V {\n\n  private Voltage220V voltage220V; // 关联关系-聚合\n\n  // 通过构造器，传入一个 Voltage220V 实例\n  public VoltageAdapter(Voltage220V voltage220v) {\n\n    this.voltage220V = voltage220v;\n  }\n\n  @Override\n  public int output5V() {\n\n    int dst = 0;\n    if (null != voltage220V) {\n      int src = voltage220V.output220V(); // 获取220V 电压\n      System.out.println(\"使用对象适配器，进行适配~~\");\n      dst = src / 44;\n      System.out.println(\"适配完成，输出的电压为=\" + dst);\n    }\n\n    return dst;\n  }\n}\n```\n\n#### Client\n\n```java\npublic class Client {\n\n  public static void main(String[] args) {\n    // TODO Auto-generated method stub\n    System.out.println(\" === 对象适配器模式 ====\");\n    Phone phone = new Phone();\n    phone.charging(new VoltageAdapter(new Voltage220V()));\n  }\n}\n```\n\n\n\n\n\n## 适配器模式的原理与实现\n\n顾名思义，这个模式就是用来做适配的，它将不兼容的接口转换为可兼容的接口，让原本由于接口不兼容而不能一起工作的类可以一起工作。对于这个模式，有一个经常被拿来解释它的例子，就是 USB 转接头充当适配器，把两种不兼容的接口，通过转接变得可以一起工作。\n\n\n\n原理很简单，我们再来看下它的代码实现。适配器模式有两种实现方式：类适配器和对象适配器。其中，类适配器使用继承关系来实现，对象适配器使用组合关系来实现。具体的代码实现如下所示。其中，ITarget 表示要转化成的接口定义。Adaptee 是一组不兼容 ITarget 接口定义的接口，Adaptor 将 Adaptee 转化成一组符合 ITarget 接口定义的接口。\n\n```java\n// 类适配器: 基于继承\npublic interface ITarget {\n    void f1();\n    void f2();\n    void fc();\n}\n\npublic class Adaptee {\n\n    public void fa() { \n        //... \n    }\n\n    public void fb() {\n        //... \n    }\n\n    public void fc(){\n        //... \n    }\n\n}\n\npublic class Adaptor extends Adaptee implements ITarget {\n\n    public void f1() {\n        super.fa();\n    }\n\n    public void f2() {\n        //...重新实现f2()...\n    }\n\n// 这里fc()不需要实现，直接继承自Adaptee，这是跟对象适配器最大的不同点\n}\n\n// 对象适配器：基于组合\npublic interface ITarget {\n    void f1();\n    void f2();\n    void fc();\n}\npublic class Adaptee {\n\n    public void fa() {\n        //... \n    }\n\n    public void fb() {\n        //... \n    }\n\n    public void fc(){\n        //... \n    }\n\n}\n\npublic class Adaptor implements ITarget {\n    private Adaptee adaptee;\n\n    public Adaptor(Adaptee adaptee) {\n        this.adaptee = adaptee;\n    }\n\n    public void f1() {\n        adaptee.fa(); //委托给Adaptee\n    }\n\n    public void f2() {\n        //...重新实现f2()...\n    }\n\n    public void fc() {\n        adaptee.fc();\n    }\n}\n```\n\n\n\n针对这两种实现方式，在实际的开发中，到底该如何选择使用哪一种呢？判断的标准主要有两个，一个是 Adaptee 接口的个数，另一个是 Adaptee 和 ITarget 的契合程度。\n\n- 如果 Adaptee 接口并不多，那两种实现方式都可以。\n- 如果 Adaptee 接口很多，而且 Adaptee 和 ITarget 接口定义大部分都相同，那我们推荐使用类适配器，因为 Adaptor 复用父类 Adaptee 的接口，比起对象适配器的实现方式，Adaptor 的代码量要少一些。\n- 如果 Adaptee 接口很多，而且 Adaptee 和 ITarget 接口定义大部分都不相同，那我们推荐使用对象适配器，因为组合结构相对于继承更加灵活。\n\n\n\n## 适配器模式应用场景总结\n\n1. 原理和实现讲完了，都不复杂。我们再来看，到底什么时候会用到适配器模式呢？\n\n2. 一般来说，适配器模式可以看作一种“补偿模式”，用来补救设计上的缺陷。应用这种模式算是“无奈之举”。如果在设计初期，我们就能协调规避接口不兼容的问题，那这种模式就没有应用的机会了。\n3. 前面我们反复提到，适配器模式的应用场景是“接口不兼容”。那在实际的开发中，什么情况下才会出现接口不兼容呢？我建议你先自己思考一下这个问题，然后再来看下面的总结 。\n\n\n\n### 封装有缺陷的接口设计\n\n1. 假设我们依赖的外部系统在接口设计方面有缺陷（比如包含大量静态方法），引入之后会影响到我们自身代码的可测试性。为了隔离设计上的缺陷，我们希望对外部系统提供的接口进行二次封装，抽象出更好的接口设计，这个时候就可以使用适配器模式了。\n\n2. 具体我还是举个例子来解释一下，你直接看代码应该会更清晰。具体代码如下所示：\n\n```java\npublic class CD { //这个类来自外部sdk，我们无权修改它的代码\n    //...\n    public static void staticFunction1() { //... }\n        \n    public void uglyNamingFunction2() { //... }\n        \n    public void tooManyParamsFunction3(int paramA, int paramB, ...) { //... }\n\n    public void lowPerformanceFunction4() { //... }\n\n}\n\n// 使用适配器模式进行重构\npublic class ITarget {\n\n    void function1();\n    void function2();\n    void fucntion3(ParamsWrapperDefinition paramsWrapper);\n    void function4();\n    //...\n}\n\n// 注意：适配器类的命名不一定非得末尾带Adaptor\n\npublic class CDAdaptor extends CD implements ITarget {\n    //...\n    public void function1() {\n        super.staticFunction1();\n    }\n\n    public void function2() {\n        super.uglyNamingFucntion2();\n    }\n\n    public void function3(ParamsWrapperDefinition paramsWrapper) { \n        super.tooManyParamsFunction3(paramsWrapper.getParamA(), ...);\n    }\n\n    public void function4() {\n        //...reimplement it...\n    }\n}\n```\n\n\n\n### 统一多个类的接口设计\n\n1. 某个功能的实现依赖多个外部系统（或者说类）。通过适配器模式，将它们的接口适配为统一的接口定义，然后我们就可以使用多态的特性来复用代码逻辑。具体我还是举个例子来解释一下。\n2. 假设我们的系统要对用户输入的文本内容做敏感词过滤，为了提高过滤的召回率，我们引入了多款第三方敏感词过滤系统，依次对用户输入的内容进行过滤，过滤掉尽可能多的敏感词。但是，每个系统提供的过滤接口都是不同的。这就意味着我们没法复用一套逻辑来调用各个系统。这个时候，我们就可以使用适配器模式，将所有系统的接口适配为统一的接口定义，这样我们可以复用调用敏感词过滤的代码。\n3. 你可以配合着下面的代码示例，来理解我刚才举的这个例子。\n\n```java\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class ASensitiveWordsFilter { // A敏感词过滤系统提供的接口\n  // text是原始文本，函数输出用***替换敏感词之后的文本\n  public String filterSexyWords(String text) {\n    // ...\n  }\n\n  public String filterPoliticalWords(String text) {\n    // ...\n  }\n}\n\npublic class BSensitiveWordsFilter { // B敏感词过滤系统提供的接口\n  public String filter(String text) {\n    // ...\n  }\n}\n\npublic class CSensitiveWordsFilter { // C敏感词过滤系统提供的接口\n  public String filter(String text, String mask) {\n    // ...\n  }\n}\n\n// 未使用适配器模式之前的代码：代码的可测试性、扩展性不好\npublic class RiskManagement {\n  private ASensitiveWordsFilter aFilter = new ASensitiveWordsFilter();\n  private BSensitiveWordsFilter bFilter = new BSensitiveWordsFilter();\n  private CSensitiveWordsFilter cFilter = new CSensitiveWordsFilter();\n\n  public String filterSensitiveWords(String text) {\n    String maskedText = aFilter.filterSexyWords(text);\n    maskedText = aFilter.filterPoliticalWords(maskedText);\n    maskedText = bFilter.filter(maskedText);\n    maskedText = cFilter.filter(maskedText, \"***\");\n    return maskedText;\n  }\n}\n\n// 使用适配器模式进行改造\npublic interface ISensitiveWordsFilter { // 统一接口定义\n  String filter(String text);\n}\n\npublic class ASensitiveWordsFilterAdaptor implements ISensitiveWordsFilter {\n  private ASensitiveWordsFilter aFilter;\n\n  public String filter(String text) {\n    String maskedText = aFilter.filterSexyWords(text);\n    maskedText = aFilter.filterPoliticalWords(maskedText);\n    return maskedText;\n  }\n}\n\n// ...省略BSensitiveWordsFilterAdaptor、CSensitiveWordsFilterAdaptor...\n// 扩展性更好，更加符合开闭原则，如果添加一个新的敏感词过滤系统，\n// 这个类完全不需要改动；而且基于接口而非实现编程，代码的可测试性更好。\npublic class RiskManagement {\n  private List<ISensitiveWordsFilter> filters = new ArrayList<>();\n\n  public void addSensitiveWordsFilter(ISensitiveWordsFilter filter) {\n    filters.add(filter);\n  }\n\n  public String filterSensitiveWords(String text) {\n    String maskedText = text;\n    for (ISensitiveWordsFilter filter : filters) {\n      maskedText = filter.filter(maskedText);\n    }\n\n    return maskedText;\n  }\n}\n\n```\n\n\n\n### 替换依赖的外部系统\n\n当我们把项目中依赖的一个外部系统替换为另一个外部系统的时候，利用适配器模式，可以减少对代码的改动。具体的代码示例如下所示：\n\n```java\n// 外部系统A\npublic  interface  IA  {\n//...\n  void  fa();\n}\npublic  class  A  implements  IA  {\n//...\n  public  void  fa()  { \n    //... \n  }\n}\n\n// 在我们的项目中，外部系统A的使用示例\npublic  class  Demo  {\n  private IA a;\n  public  Demo(IA a)  {\n    this.a = a;\n  }\n  //... \n\n}\n\nDemo d = new Demo(new A());\n\n// 将外部系统A替换成外部系统B\npublic  class  BAdaptor  implemnts  IA  {\n  private B b;\n  public  BAdaptor(B b)  {\n    this.b= b;\n  }\n\n  public  void  fa()  {\n  //...\n    b.fb();\n  }\n}\n\n// 借助BAdaptor，Demo的代码中，调用IA接口的地方都无需改动，\n// 只需要将BAdaptor如下注入到Demo即可。\nDemo d = new Demo(new BAdaptor(new B()));\n```\n\n\n\n### 兼容老版本接口\n\n1. 在做版本升级的时候，对于一些要废弃的接口，我们不直接将其删除，而是暂时保留，并且标注为 deprecated，并将内部实现逻辑委托为新的接口实现。这样做的好处是，让使用它的项目有个过渡期，而不是强制进行代码修改。这也可以粗略地看作适配器模式的一个应用场景。同样，我还是通过一个例子，来进一步解释一下。\n2. JDK1.0 中包含一个遍历集合容器的类 Enumeration。JDK2.0 对这个类进行了重构，将它改名为 Iterator 类，并且对它的代码实现做了优化。但是考虑到如果将 Enumeration 直接从 JDK2.0 中删除，那使用 JDK1.0 的项目如果切换到 JDK2.0，代码就会编译不通过。为了避免这种情况的发生，我们必须把项目中所有使用到 Enumeration 的地方，都修改为使用 Iterator 才行。\n3. 单独一个项目做 Enumeration 到 Iterator 的替换，勉强还能接受。但是，使用 Java 开发的项目太多了，一次 JDK 的升级，导致所有的项目不做代码修改就会编译报错，这显然是不合理的。这就是我们经常所说的不兼容升级。为了做到兼容使用低版本 JDK 的老代码，我们可以暂时保留 Enumeration 类，并将其实现替换为直接调用 Itertor。代码示例如下所示：\n\n```java\npublic  class  Collections  {\n  public  static Emueration emumeration(final Collection c)  {\n    return  new Enumeration() {\n      Iterator i = c.iterator();\n\n      public boolean hasMoreElments()  {\n        return i.hashNext();\n      }\n\n      public Object nextElement()  {\n        return i.next():\n      }\n    }\n  }\n}\n```\n\n\n\n### 适配不同格式的数据\n\n前面我们讲到，适配器模式主要用于接口的适配，实际上，它还可以用在不同格式的数据之间的适配。比如，把从不同征信系统拉取的不同格式的征信数据，统一为相同的格式，以方便存储和使用。再比如，Java 中的 Arrays.asList() 也可以看作一种数据适配器，将数组类型的数据转化为集合容器类型。\n\n```java\nList<String> stooges = Arrays.asList(\"Larry\", \"Moe\", \"Curly\");\n```\n\n\n\n\n\n### 剖析适配器模式在 Java 日志中的应用\n\n1. Java 中有很多日志框架，在项目开发中，我们常常用它们来打印日志信息。其中，比较常用的有 log4j、logback，以及 JDK 提供的 JUL(java.util.logging) 和 Apache 的 JCL(Jakarta Commons Logging) 等。\n2. 大部分日志框架都提供了相似的功能，比如按照不同级别（debug、info、warn、erro……）打印日志等，但它们却并没有实现统一的接口。这主要可能是历史的原因，它不像 JDBC 那样，一开始就制定了数据库操作的接口规范。\n3. 如果我们只是开发一个自己用的项目，那用什么日志框架都可以，log4j、logback 随便选一个就好。但是，如果我们开发的是一个集成到其他系统的组件、框架、类库等，那日志框架的选择就没那么随意了。\n4. 比如，项目中用到的某个组件使用 log4j 来打印日志，而我们项目本身使用的是 logback。将组件引入到项目之后，我们的项目就相当于有了两套日志打印框架。每种日志框架都有自己特有的配置方式。所以，我们要针对每种日志框架编写不同的配置文件（比如，日志存储的文件地址、打印日志的格式）。如果引入多个组件，每个组件使用的日志框架都不一样，那日志本身的管理工作就变得非常复杂。所以，为了解决这个问题，我们需要统一日志打印框架。\n5. 如果你是做 Java 开发的，那 Slf4j 这个\b日志框架你肯定不陌生，它相当于 JDBC 规范，提供了一套打印日志的统一接口规范。不过，它只定义了接口，并没有提供具体的实现，需要配合其他日志框架（log4j、logback……）来使用。\n6. 不仅如此，Slf4j 的出现晚于 JUL、JCL、log4j 等日志框架，所以，这些日志框架也不可能牺牲掉版本兼容性，将接口改造成符合 Slf4j 接口规范。Slf4j 也事先考虑到了这个问题，所以，它不仅仅提供了统一的接口定义，还提供了针对不同日志框架的适配器。对不同日志框架的接口进行二次封装，适配成统一的 Slf4j 接口定义。具体的代码示例如下所示：\n\n```java\n// slf4j统一的接口定义\npackage org.slf4j;\npublic  interface Logger {\n  public  boolean isTraceEnabled();\n  public  void trace(String msg);\n  public  void trace(String format, Object arg);\n  public  void trace(String format, Object arg1, Object arg2);\n  public  void trace(String format, Object[] argArray);\n  public  void trace(String msg, Throwable t);\n  public  boolean isDebugEnabled();\n  public  void debug(String msg);\n  public  void debug(String format, Object arg);\n  public  void debug(String format, Object arg1, Object arg2);\n  public  void debug(String format, Object[] argArray);\n  public  void debug(String msg, Throwable t);\n\n//...省略info、warn、error等一堆接口\n}\n\n\n// log4j日志框架的适配器\n// Log4jLoggerAdapter实现了LocationAwareLogger接口，\n// 其中LocationAwareLogger继承自Logger接口，\n// 也就相当于Log4jLoggerAdapter实现了Logger接口。\npackage org.slf4j.impl;\npublic final class Log4jLoggerAdapter extends MarkerIgnoringBase\n        implements LocationAwareLogger, Serializable {\n\n  final transient org.apache.log4j.Logger logger; // log4j\n\n  public  boolean isDebugEnabled() {\n    return logger.isDebugEnabled();\n  }\n\n  public  void debug(String msg) {\n    logger.log(FQCN, Level.DEBUG, msg, null);\n  }\n\n  public  void debug(String format, Object arg) {\n    if (logger.isDebugEnabled()) {\n      FormattingTuple ft = MessageFormatter.format(format, arg);\n      logger.log(FQCN, Level.DEBUG, ft.getMessage(), ft.getThrowable());\n    }\n  }\n\n  public  void debug(String format, Object arg1, Object arg2) {\n    if (logger.isDebugEnabled()) {\n      FormattingTuple ft = MessageFormatter.format(format, arg1, arg2);\n      logger.log(FQCN, Level.DEBUG, ft.getMessage(), ft.getThrowable());\n    }\n  }\n\n  public  void debug(String format, Object\\[\\] argArray) {\n    if (logger.isDebugEnabled()) {\n      FormattingTuple ft = MessageFormatter.arrayFormat(format, argArray);\n      logger.log(FQCN, Level.DEBUG, ft.getMessage(), ft.getThrowable());\n    }\n  }\n\n  public  void debug(String msg, Throwable t) {\n    logger.log(FQCN, Level.DEBUG, msg, t);\n  }\n\n//...省略一堆接口的实现...\n}\n```\n\n\n\n1. 所以，在开发业务系统或者开发框架、组件的时候，我们统一使用 Slf4j 提供的接口来编写打印日志的代码，具体使用哪种日志框架实现（log4j、logback……），是可以动态地指定的（使用 Java 的 SPI 技术，这里我不多解释，你自行研究吧），只需要将相应的 SDK 导入到项目中即可。\n2. 不过，你可能会说，如果一些老的项目没有使用 Slf4j，而是直接使用比如 JCL 来打印日志，那如果想要替换成其他日志框架，比如 log4j，该怎么办呢？实际上，Slf4j 不仅仅提供了从其他日志框架到 Slf4j 的适配器，还提供了反向适配器，也就是从 Slf4j 到其他日志框架的适配。我们可以先将 JCL 切换为 Slf4j，然后再将 Slf4j 切换为 log4j。经过两次适配器的转换，我们能就成功将 log4j 切换为了 logback。\n\n\n\n## 代理、桥接、装饰器、适配器 4 种设计模式的区别\n\n1. 代理、桥接、装饰器、适配器，这 4 种模式是比较常用的结构型设计模式。它们的代码结构非常相似。笼统来说，它们都可以称为 Wrapper 模式，也就是通过 Wrapper 类二次封装原始类。\n\n2. 尽管代码结构相似，但这 4 种设计模式的用意完全不同，也就是说要解决的问题、应用场景不同，这也是它们的主要区别。这里我就简单说一下它们之间的区别。\n\n\n\n- 代理模式：在不改变原始类接口的条件下，为原始类定义一个代理类，主要目的是控制访问，而非加强功能，这是它跟装饰器模式最大的不同。\n- 桥接模式：目的是将接口部分和实现部分分离，从而让它们可以较为容易、也相对独立地加以改变。\n- 装饰者模式：在不改变原始类接口的情况下，对原始类功能进行增强，并且支持多个装饰器的嵌套使用。\n- 适配器模式：是一种事后的补救策略。适配器提供跟原始类不同的接口，而代理模式、装饰器模式提供的都是跟原始类相同的接口。\n\n\n\n\n\n","source":"_posts/2024-07-01-设计模式-04.01-结构型-代理&桥接&装饰器&适配器.md","raw":"---\ntitle: 设计模式-04.01-结构型-代理&桥接&装饰器&适配器\ntags:\n  - 设计模式\n  - 代理模式\n  - 桥接模式\n  - 装饰器模式\n  - 适配器模式\ncategories:\n  - 设计模式\n  - 04.结构型\nkeywords: 设计模式，代理模式，桥接模式，装饰器模式，适配器模式\ndescription: 对代理模式，桥接模式，装饰器模式，适配器模式这4个模式进行了比较详细的讲述。其实学习设计模式主要是为了后序看源码\ncover: 'https://npm.elemecdn.com/lql_static@latest/logo/design_patterns.jpg'\nabbrlink: 926a065c\ndate: 2024-07-01 00:10:00\n---\n\n\n# 声明\n\n> 1. 此系列文章非本人原创，是学习笔记。\n> 2. 设计模式系列以后会持续更新，包括已经发布的设计模式文章，因为后续还要再多看一下书，教程和开源项目等，继续润色文章。\n\n\n\n\n# 引言\n\n创建型模式比较好理解，后面的结构型和行为型设计模式不是那么好理解。如果遇到不好理解的设计模式，我一般会在开头举比较简单的Demo案例来帮助理解。\n\n# 代理模式【常用】\n\n1. 前面几节，我们讲了设计模式中的创建型模式。创建型模式主要解决对象的创建问题，封装复杂的创建过程，解耦对象的创建代码和使用代码。\n2. 其中，单例模式用来创建全局唯一的对象。工厂模式用来创建不同但是相关类型的对象（继承同一父类或者接口的一组子类），由给定的参数来决定创建哪种类型的对象。建造者模式是用来创建复杂对象，可以通过设置不同的可选参数，“定制化”地创建不同的对象。原型模式针对创建成本比较大的对象，利用对已有对象进行复制的方式进行创建，以达到节省创建时间的目的。\n3. 现在，我们讲另外一种类型的设计模式：结构型模式。结构型模式主要总结了一些类或对象组合在一起的经典结构，这些经典的结构可以解决特定应用场景的问题。结构型模式包括：代理模式、桥接模式、装饰器模式、适配器模式、门面模式、组合模式、享元模式。今天我们要讲其中的代理模式。它也是在实际开发中经常被用到的一种设计模式。\n4. 代理模式有不同的形式, 主要有三种 **静态代理**、**动态代理** (JDK 代理、接口代理)和 **Cglib** **代理** (可以在内存 动态的创建对象，而不需要实现接口， 他是属于动态代理的范畴) 。下面先通过几个比较简单的例子理解一下代理模式\n\n\n\n\n\n## 静态代理\n\n实例具体要求 \n\n1. 定义一个接口:ITeacherDao \n2. 目标对象 TeacherDAO 实现接口 ITeacherDAO \n3. 使用静态代理方式,就需要在代理对象 TeacherDAOProxy 中也实现 ITeacherDAO \n4. 调用的时候通过调用代理对象的方法来调用目标对象. \n5. 特别提醒：静态代理类与被代理类要实现相同的接口,然后通过调用相同的方法来调用目标对象的方法\n\n\n\n> **ITeacherDao**\n\n```java\n//接口\npublic interface ITeacherDao {\n\t\n\tvoid teach(); // 授课的方法\n}\n```\n\n\n\n> **TeacherDao** ---> 被代理类\n\n```java\npublic class TeacherDao implements ITeacherDao {\n\n\t@Override\n\tpublic void teach() {\n\t\t// TODO Auto-generated method stub\n\t\tSystem.out.println(\" 老师授课中  。。。。。\");\n\t}\n}\n```\n\n\n\n> **TeacherDaoProxy** ---> 代理类\n\n```java\n//代理对象,静态代理\npublic class TeacherDaoProxy implements ITeacherDao{\n\t\n\tprivate ITeacherDao target; // 目标对象，通过接口来聚合\n\t\n\t\n\t//构造器\n\tpublic TeacherDaoProxy(ITeacherDao target) {\n\t\tthis.target = target;\n\t}\n\n\n\n\t@Override\n\tpublic void teach() {\n\t\t// TODO Auto-generated method stub\n\t\tSystem.out.println(\"开始代理  完成某些操作。。。。。 \");//方法\n\t\ttarget.teach();\n\t\tSystem.out.println(\"提交。。。。。\");//方法\n\t}\n\n}\n```\n\n\n\n> Client\n\n```java\npublic class Client {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\t//创建目标对象(被代理对象)\n\t\tTeacherDao teacherDao = new TeacherDao();\n\t\t\n\t\t//创建代理对象, 同时将被代理对象传递给代理对象\n\t\tTeacherDaoProxy teacherDaoProxy = new TeacherDaoProxy(teacherDao);\n\t\t\n\t\t//通过代理对象，调用到被代理对象的方法\n\t\t//即：执行的是代理对象的方法，代理对象再去调用目标对象的方法 \n\t\tteacherDaoProxy.teach();\n\t}\n\n}\n```\n\n\n\n\n\n## 动态代理\n\n1. 代理对象,不需要实现接口，但是目标对象要实现接口，否则不能用动态代理 \n2. 代理对象的生成，是利用 JDK 的 API，动态的在内存中构建代理对象 \n3. 动态代理也叫做：JDK 代理、接口代理\n4. 代理类所在包:java.lang.reflect.Proxy \n5. JDK 实现代理只需要使用 **newProxyInstance** 方法,但是该方法需要接收三个参数,完整的写法是: \n\nstatic Object newProxyInstance(ClassLoader loader, Class<?>[] interfaces,InvocationHandler h ) \n\n\n\n> ITeacherDao\n\n```java\n//接口\npublic interface ITeacherDao {\n\n   void teach(); // 授课方法\n   void sayHello(String name);\n}\n```\n\n\n\n> TeacherDao\n\n```java\npublic class TeacherDao implements ITeacherDao {\n\n   @Override\n   public void teach() {\n      // TODO Auto-generated method stub\n      System.out.println(\" 老师授课中.... \");\n   }\n\n   @Override\n   public void sayHello(String name) {\n      // TODO Auto-generated method stub\n      System.out.println(\"hello \" + name);\n   }\n   \n}\n```\n\n\n\n> ProxyFactory\n\n```java\nimport java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Proxy;\n\npublic class ProxyFactory {\n\n   //维护一个目标对象 , Object\n   private Object target;\n\n   //构造器 ， 对target 进行初始化\n   public ProxyFactory(Object target) {\n      \n      this.target = target;\n   } \n   \n   //给目标对象 生成一个代理对象\n   public Object getProxyInstance() {\n      \n      /* 说明\n         public static Object newProxyInstance(ClassLoader loader,\n                                          Class<?>[] interfaces,\n                                          InvocationHandler h)\n                                          \n            1. ClassLoader loader ： 指定当前目标对象使用的类加载器, 获取加载器的方法固定\n            2. Class<?>[] interfaces: 目标对象实现的接口类型，使用泛型方法确认类型\n            3. InvocationHandler h : 事情处理，执行目标对象的方法时，会触发事情处理器方法, \n             会把当前执行的目标对象方法作为参数传入\n       */\n      return Proxy.newProxyInstance(target.getClass().getClassLoader(), \n            target.getClass().getInterfaces(), \n            new InvocationHandler() {\n               \n               @Override\n               public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n                  // TODO Auto-generated method stub\n                  System.out.println(\"JDK代理开始~~\");\n                  //反射机制调用目标对象的方法\n                  Object returnVal = method.invoke(target, args);\n                  System.out.println(\"JDK代理提交\");\n                  return returnVal;\n               }\n            }); \n   }\n}\n```\n\n\n\n> Client\n\n```\npublic class Client {\n\n   public static void main(String[] args) {\n      // TODO Auto-generated method stub\n      //创建目标对象\n      ITeacherDao target = new TeacherDao();\n      \n      //给目标对象，创建代理对象, 可以转成 ITeacherDao\n      ITeacherDao proxyInstance = (ITeacherDao)new ProxyFactory(target).getProxyInstance();\n   \n      // proxyInstance=class com.sun.proxy.$Proxy0 内存中动态生成了代理对象\n      System.out.println(\"proxyInstance=\" + proxyInstance.getClass());\n      \n      //通过代理对象，调用目标对象的方法\n      //proxyInstance.teach();\n      \n      proxyInstance.sayHello(\" tom \");\n   }\n\n}\n```\n\n\n\n## cglib代理\n\n1. 静态代理和 JDK 代理模式都要求目标对象是实现一个接口,但是有时候目标对象只是一个单独的对象,并没有实现任何的接口,这个时候可使用目标对象子类来实现代理-这就是Cglib代理\n\n2. Cglib代理也叫作**子类代理****,**它是在内存中构建一个子类对象从而实现对目标对象功能扩展, 有些书也将Cglib代理归属到动态代理。 \n\n3. Cglib 是一个强大的高性能的代码生成包,它可以在运行期扩展 java 类与实现 java 接口.它广泛的被许多 AOP 的 框架使用,例如 Spring AOP，实现方法拦截 \n\n4. 在 AOP 编程中如何选择代理模式： \n\n   - 目标对象需要实现接口，用 JDK 代理 \n\n   - 目标对象不需要实现接口，用 Cglib 代理 \n\n5. Cglib 包的底层是通过使用字节码处理框架 ASM 来转换字节码并生成新的类\n\n6. 需要引入 cglib 的 jar 文件，在内存中动态构建子类，注意代理的类不能为 final，否则报错 \n\n   `java.lang.IllegalArgumentException`，目标对象的方法如果为 final/static,那么就不会被拦截,即不会执行目标对象额外的业务方法. \n\n\n\n> TeacherDao\n\n```java\npublic class TeacherDao {\n\n   public String teach() {\n      System.out.println(\" 老师授课中  ， 我是cglib代理，不需要实现接口 \");\n      return \"hello\";\n   }\n}\n```\n\n\n\n> ProxyFactory\n\n```java\nimport java.lang.reflect.Method;\nimport net.sf.cglib.proxy.Enhancer;\nimport net.sf.cglib.proxy.MethodInterceptor;\nimport net.sf.cglib.proxy.MethodProxy;\n\npublic class ProxyFactory implements MethodInterceptor {\n\n   //维护一个目标对象\n   private Object target;\n   \n   //构造器，传入一个被代理的对象\n   public ProxyFactory(Object target) {\n      this.target = target;\n   }\n\n   //返回一个代理对象:  是 target 对象的代理对象\n   public Object getProxyInstance() {\n      //1. 创建一个工具类\n      Enhancer enhancer = new Enhancer();\n      //2. 设置父类\n      enhancer.setSuperclass(target.getClass());\n      //3. 设置回调函数\n      enhancer.setCallback(this);\n      //4. 创建子类对象，即代理对象\n      return enhancer.create();\n      \n   }\n   \n\n   //重写  intercept 方法，会调用目标对象的方法\n   @Override\n   public Object intercept(Object arg0, Method method, Object[] args, MethodProxy arg3) throws Throwable {\n      // TODO Auto-generated method stub\n      System.out.println(\"Cglib代理模式 ~~ 开始\");\n      Object returnVal = method.invoke(target, args);\n      System.out.println(\"Cglib代理模式 ~~ 提交\");\n      return returnVal;\n   }\n\n}\n```\n\n\n\n> Client\n\n```java\npublic class Client {\n\n   public static void main(String[] args) {\n      // TODO Auto-generated method stub\n      //创建目标对象\n      TeacherDao target = new TeacherDao();\n      //获取到代理对象，并且将目标对象传递给代理对象\n      TeacherDao proxyInstance = (TeacherDao)new ProxyFactory(target).getProxyInstance();\n\n      //执行代理对象的方法，触发intecept 方法，从而实现 对目标对象的调用\n      String res = proxyInstance.teach();\n      System.out.println(\"res=\" + res);\n   }\n\n}\n```\n\n## 代理模式的原理解析\n\n1. 代理模式（Proxy Design Pattern）的原理和代码实现都不难掌握。它在不改变原始类（或叫被代理类）代码的情况下，通过引入代理类来给原始类附加功能【**装饰器是增强功能，代理是附加新的功能**】。我们通过一个简单的例子来解释一下这段话。\n2. 我们开发了一个 MetricsCollector 类，用来收集接口请求的原始数据，比如访问时间、处理时长等。在业务系统中，我们采用如下方式来使用这个 MetricsCollector 类：\n\n```java\npublic class UserController {\n  //...省略其他属性和方法...\n  private MetricsCollector metricsCollector; // 依赖注入\n\n  public UserVo login(String telephone, String password) {\n    long startTimestamp = System.currentTimeMillis();\n\n    // ... 省略login逻辑...\n\n    long endTimeStamp = System.currentTimeMillis();\n    long responseTime = endTimeStamp - startTimestamp;\n    RequestInfo requestInfo = new RequestInfo(\"login\", responseTime, startTimestamp);\n    metricsCollector.recordRequest(requestInfo);\n\n    //...返回UserVo数据...\n  }\n\n  public UserVo register(String telephone, String password) {\n    long startTimestamp = System.currentTimeMillis();\n\n    // ... 省略register逻辑...\n\n    long endTimeStamp = System.currentTimeMillis();\n    long responseTime = endTimeStamp - startTimestamp;\n    RequestInfo requestInfo = new RequestInfo(\"register\", responseTime, startTimestamp);\n    metricsCollector.recordRequest(requestInfo);\n\n    //...返回UserVo数据...\n  }\n}\n```\n\n1. 很明显，上面的写法有两个问题。第一，性能计数器框架代码侵入到业务代码中，跟业务代码高度耦合。如果未来需要替换这个框架，那替换的成本会比较大。第二，收集接口请求的代码跟业务代码无关，本就不应该放到一个类中。业务类最好职责更加单一，只聚焦业务处理。\n2. 为了将框架代码和业务代码解耦，代理模式就派上用场了。代理类 UserControllerProxy 和原始类 UserController 实现相同的接口 IUserController。UserController 类只负责业务功能。代理类 UserControllerProxy 负责在业务代码执行前后附加其他逻辑代码，并通过委托的方式调用原始类来执行业务代码。具体的代码实现如下所示：\n\n```java\npublic interface IUserController {\n  UserVo login(String telephone, String password);\n  UserVo register(String telephone, String password);\n}\n\npublic class UserController implements IUserController {\n  //...省略其他属性和方法...\n\n  @Override\n  public UserVo login(String telephone, String password) {\n    //...省略login逻辑...\n    //...返回UserVo数据...\n  }\n\n  @Override\n  public UserVo register(String telephone, String password) {\n    //...省略register逻辑...\n    //...返回UserVo数据...\n  }\n}\n\npublic class UserControllerProxy implements IUserController {\n  private MetricsCollector metricsCollector;\n  private UserController userController;\n\n  public UserControllerProxy(UserController userController) {\n    this.userController = userController;\n    this.metricsCollector = new MetricsCollector();\n  }\n\n  @Override\n  public UserVo login(String telephone, String password) {\n    long startTimestamp = System.currentTimeMillis();\n\n    // 委托\n    UserVo userVo = userController.login(telephone, password);\n\n    long endTimeStamp = System.currentTimeMillis();\n    long responseTime = endTimeStamp - startTimestamp;\n    RequestInfo requestInfo = new RequestInfo(\"login\", responseTime, startTimestamp);\n    metricsCollector.recordRequest(requestInfo);\n\n    return userVo;\n  }\n\n  @Override\n  public UserVo register(String telephone, String password) {\n    long startTimestamp = System.currentTimeMillis();\n\n    UserVo userVo = userController.register(telephone, password);\n\n    long endTimeStamp = System.currentTimeMillis();\n    long responseTime = endTimeStamp - startTimestamp;\n    RequestInfo requestInfo = new RequestInfo(\"register\", responseTime, startTimestamp);\n    metricsCollector.recordRequest(requestInfo);\n\n    return userVo;\n  }\n}\n\n//UserControllerProxy使用举例\n//因为原始类和代理类实现相同的接口，是基于接口而非实现编程\n//将UserController类对象替换为UserControllerProxy类对象，不需要改动太多代码\nIUserController userController = new UserControllerProxy(new UserController());\n```\n\n1. 参照基于接口而非实现编程的设计思想，将原始类对象替换为代理类对象的时候，为了让代码改动尽量少，在刚刚的代理模式的代码实现中，代理类和原始类需要实现相同的接口。但是，如果原始类并没有定义接口，并且原始类代码并不是我们开发维护的（比如它来自一个第三方的类库），我们也没办法直接修改原始类，给它重新定义一个接口。在这种情况下，我们该如何实现代理模式呢？\n2. 对于这种外部类的扩展，我们一般都是采用继承的方式。这里也不例外。我们让代理类继承原始类，然后扩展附加功能。原理很简单，不需要过多解释，你直接看代码就能明白。具体代码如下所示：\n\n```java\n\npublic class UserControllerProxy extends UserController {\n  private MetricsCollector metricsCollector;\n\n  public UserControllerProxy() {\n    this.metricsCollector = new MetricsCollector();\n  }\n\n  public UserVo login(String telephone, String password) {\n    long startTimestamp = System.currentTimeMillis();\n\n    UserVo userVo = super.login(telephone, password);\n\n    long endTimeStamp = System.currentTimeMillis();\n    long responseTime = endTimeStamp - startTimestamp;\n    RequestInfo requestInfo = new RequestInfo(\"login\", responseTime, startTimestamp);\n    metricsCollector.recordRequest(requestInfo);\n\n    return userVo;\n  }\n\n  public UserVo register(String telephone, String password) {\n    long startTimestamp = System.currentTimeMillis();\n\n    UserVo userVo = super.register(telephone, password);\n\n    long endTimeStamp = System.currentTimeMillis();\n    long responseTime = endTimeStamp - startTimestamp;\n    RequestInfo requestInfo = new RequestInfo(\"register\", responseTime, startTimestamp);\n    metricsCollector.recordRequest(requestInfo);\n\n    return userVo;\n  }\n}\n//UserControllerProxy使用举例\nUserController userController = new UserControllerProxy();\n```\n\n\n\n## 动态代理的原理解析\n\n1. 不过，刚刚的代码实现还是有点问题。一方面，我们需要在代理类中，将原始类中的所有的方法，都重新实现一遍，并且为每个方法都附加相似的代码逻辑。另一方面，如果要添加的附加功能的类有不止一个，我们需要针对每个类都创建一个代理类。\n2. 如果有 50 个要添加附加功能的原始类，那我们就要创建 50  个对应的代理类。这会导致项目中类的个数成倍增加，增加了代码维护成本。并且，每个代理类中的代码都有点像模板式的“重复”代码，也增加了不必要的开发成本。那这个问题怎么解决呢？\n3. 我们可以使用动态代理来解决这个问题。所谓动态代理（Dynamic  Proxy），就是我们不事先为每个原始类编写代理类，而是在运行的时候，动态地创建原始类对应的代理类，然后在系统中用代理类替换掉原始类。那如何实现动态代理呢？\n4. 如果你熟悉的是 Java 语言，实现动态代理就是件很简单的事情。因为 Java 语言本身就已经提供了动态代理的语法（实际上，动态代理底层依赖的就是 Java  的反射语法）。我们来看一下，如何用 Java 的动态代理来实现刚刚的功能。具体的代码如下所示。其中，MetricsCollectorProxy  作为一个动态代理类，动态地给每个需要收集接口请求信息的类创建代理类。\n\n```java\n\npublic class MetricsCollectorProxy {\n  private MetricsCollector metricsCollector;\n\n  public MetricsCollectorProxy() {\n    this.metricsCollector = new MetricsCollector();\n  }\n\n  public Object createProxy(Object proxiedObject) {\n    Class<?>[] interfaces = proxiedObject.getClass().getInterfaces();\n    DynamicProxyHandler handler = new DynamicProxyHandler(proxiedObject);\n    return Proxy.newProxyInstance(proxiedObject.getClass().getClassLoader(), interfaces, handler);\n  }\n\n  private class DynamicProxyHandler implements InvocationHandler {\n    private Object proxiedObject;\n\n    public DynamicProxyHandler(Object proxiedObject) {\n      this.proxiedObject = proxiedObject;\n    }\n\n    @Override\n    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n      long startTimestamp = System.currentTimeMillis();\n      Object result = method.invoke(proxiedObject, args);\n      long endTimeStamp = System.currentTimeMillis();\n      long responseTime = endTimeStamp - startTimestamp;\n      String apiName = proxiedObject.getClass().getName() + \":\" + method.getName();\n      RequestInfo requestInfo = new RequestInfo(apiName, responseTime, startTimestamp);\n      metricsCollector.recordRequest(requestInfo);\n      return result;\n    }\n  }\n}\n\n//MetricsCollectorProxy使用举例\nMetricsCollectorProxy proxy = new MetricsCollectorProxy();\nIUserController userController = (IUserController) proxy.createProxy(new UserController());\n```\n\n\n\n实际上，Spring AOP  底层的实现原理就是基于动态代理。用户\b配置好需要给哪些类创建代理，并定义好在执行原始类的业务代码前后执行哪些附加功能。Spring  为这些类创建动态代理对象，并在 JVM  中替代原始类对象。原本在代码中执行的原始类的方法，被换作执行代理类的方法，也就实现了给原始类添加附加功能的目的。\n\n\n\n## 代理模式的应用场景\n\n\n\n### 业务系统的非功能性需求开发\n\n代理模式最常用的一个应用场景就是，在业务系统中开发一些非功能性需求，比如：监控、统计、鉴权、限流、事务、幂等、日志。我们将这些附加功能与业务功能解耦，放到代理类中统一处理，让程序员只需要关注业务方面的开发。实际上，前面举的搜集接口请求信息的例子，就是这个应用场景的一个典型例子。\n\n如果你熟悉 Java 语言和 Spring 开发框架，这部分工作都是可以在 Spring AOP 切面中完成的。前面我们也提到，Spring AOP  底层的实现原理就是基于动态代理。\n\n\n\n\n\n### 代理模式在 RPC、缓存中的应用\n\n实际上，RPC  框架也可以看作一种代理模式，GoF 的《设计模式》一书中把它称作远程代理。通过远程代理，将网络通信、数据编解码等细节隐藏起来。客户端在使用  RPC 服务的时候，就像使用本地函数一样，无需了解跟服务器交互的细节。除此之外，RPC  服务的开发者也只需要开发业务逻辑，就像开发本地使用的函数一样，不需要关注跟客户端的交互细节。\n\n\n\n\n\n### 代理模式在缓存中的应用\n\n1. 假设我们要开发一个接口请求的缓存功能，对于某些接口请求，如果入参相同，在设定的过期时间内，直接返回缓存结果，而不用重新进行逻辑处理。比如，针对获取用户个人信息的需求，我们可以开发两个接口，一个支持缓存，一个支持实时查询。对于需要实时数据的需求，我们让其调用实时查询接口，对于不需要实时数据的需求，我们让其调用支持缓存的接口。那如何来实现接口请求的缓存功能呢？\n2. 最简单的实现方法就是刚刚我们讲到的，给每个需要支持缓存的查询需求都开发两个不同的接口，一个支持缓存，一个支持实时查询。但是，这样做显然增加了开发成本，而且会让代码看起来非常臃肿（接口个数成倍增加），也不方便缓存接口的集中管理（增加、删除缓存接口）、集中配置（比如配置每个接口缓存过期时间）。\n3. 针对这些问题，代理模式就能派上用场了，确切地说，应该是动态代理。如果是基于 Spring 框架来开发的话，那就可以在 AOP  切面中完成接口缓存的功能。在应用启动的时候，我们从配置文件中加载需要支持缓存的接口，以及相应的缓存策略（比如过期时间）等。当请求到来的时候，我们在 AOP 切面中拦截请求，如果请求中带有支持缓存的字段（比如  http://…?..&cached=true），我们便从缓存（内存缓存或者 Redis 缓存等）中获取数据直接返回。\n\n\n\n\n\n\n\n# 桥接模式【常用】\n\n1. 上一节我们学习了第一种结构型模式：代理模式。它在不改变原始类（或者叫被代理类）代码的情况下，通过引入代理类来给原始类附加功能。代理模式在平时的开发经常被用到，常用在业务系统中开发一些非功能性需求，比如：监控、统计、鉴权、限流、事务、幂等、日志。\n2. 今天，我们再学习另外一种结构型模式：桥接模式。桥接模式的代码实现非常简单，但是理解起来稍微有点难度，并且应用场景也比较局限，所以，相当于代理模式来说，桥接模式在实际的项目中并没有那么常用，你只需要简单了解，见到能认识就可以，并不是我们学习的重点。\n3. 我们依旧是先看比较简单的例子\n\n## Demo案例-手机操作问题\n\n### 需求\n\n现在对不同手机类型的不同品牌实现操作编程(比如:开机、关机、上网，打电话等)，如图:\n\n<img src=\"https://npm.elemecdn.com/youthlql@1.0.0/design_patterns/structural_type/04.01/0001.png\"/>\n\n\n\n### 传统方案解决手机操作问题分析\n\n传统方法对应的类图\n\n<img src=\"https://npm.elemecdn.com/youthlql@1.0.0/design_patterns/structural_type/04.01/0007.png\"/>\n\n1. 扩展性问题(**类爆炸**)，如果我们再增加手机的样式(旋转式)，就需要增加各个品牌手机的类，同样如果我们增加一个手机品牌，也要在各个手机样式类下增加。 \n2. 违反了单一职责原则，当我们增加手机样式时，要同时增加所有品牌的手机，这样增加了代码维护成本.\n3. 解决方案-使用**桥接模**式 \n4. Bridge 模式基于类的最小设计原则，通过使用封装、聚合及继承等行为让不同的类承担不同的职责。它的主要特点是把抽象(Abstraction)与行为实现(Implementation)分离开来，从而可以保持各部分的独立性以及应对他们的功能扩展 \n\n### 使用桥接模式的代码\n\n#### Brand【接口】\n\n```java\n//接口\npublic interface Brand {\n   void open();\n   void close();\n   void call();\n}\n```\n\n#### Phone【抽象类】\n\n```java\npublic abstract class Phone {\n   \n   //组合品牌\n   private Brand brand;\n\n   //构造器\n   public Phone(Brand brand) {\n      super();\n      this.brand = brand;\n   }\n   \n   protected void open() {\n      this.brand.open();\n   }\n   protected void close() {\n      brand.close();\n   }\n   protected void call() {\n      brand.call();\n   }\n   \n}\n```\n\n#### Vivo\n\n```java\npublic class Vivo implements Brand {\n\n   @Override\n   public void open() {\n      // TODO Auto-generated method stub\n      System.out.println(\" Vivo手机开机 \");\n   }\n\n   @Override\n   public void close() {\n      // TODO Auto-generated method stub\n      System.out.println(\" Vivo手机关机 \");\n   }\n\n   @Override\n   public void call() {\n      // TODO Auto-generated method stub\n      System.out.println(\" Vivo手机打电话 \");\n   }\n\n}\n```\n\n#### XiaoMi\n\n```java\npublic class XiaoMi implements Brand {\n\n   @Override\n   public void open() {\n      // TODO Auto-generated method stub\n      System.out.println(\" 小米手机开机 \");\n   }\n\n   @Override\n   public void close() {\n      // TODO Auto-generated method stub\n      System.out.println(\" 小米手机关机 \");\n   }\n\n   @Override\n   public void call() {\n      // TODO Auto-generated method stub\n      System.out.println(\" 小米手机打电话 \");\n   }\n\n}\n```\n\n\n\n#### FoldedPhone\n\n```java\n//折叠式手机类，继承 抽象类 Phone\npublic class FoldedPhone extends Phone {\n\n   //构造器\n   public FoldedPhone(Brand brand) {\n      super(brand);\n   }\n   \n   public void open() {\n      super.open();\n      System.out.println(\" 折叠样式手机 \");\n   }\n   \n   public void close() {\n      super.close();\n      System.out.println(\" 折叠样式手机 \");\n   }\n   \n   public void call() {\n      super.call();\n      System.out.println(\" 折叠样式手机 \");\n   }\n}\n```\n\n\n\n#### UpRightPhone\n\n```java\npublic class UpRightPhone extends Phone {\n   \n      //构造器\n      public UpRightPhone(Brand brand) {\n         super(brand);\n      }\n      \n      public void open() {\n         super.open();\n         System.out.println(\" 直立样式手机 \");\n      }\n      \n      public void close() {\n         super.close();\n         System.out.println(\" 直立样式手机 \");\n      }\n      \n      public void call() {\n         super.call();\n         System.out.println(\" 直立样式手机 \");\n      }\n}\n```\n\n\n\n#### Client\n\n```\npublic class Client {\n\n   public static void main(String[] args) {\n      \n      //获取折叠式手机 (样式 + 品牌 )\n      \n      Phone phone1 = new FoldedPhone(new XiaoMi());\n      \n      phone1.open();\n      phone1.call();\n      phone1.close();\n      \n      System.out.println(\"=======================\");\n      \n      Phone phone2 = new FoldedPhone(new Vivo());\n      \n      phone2.open();\n      phone2.call();\n      phone2.close();\n      \n      System.out.println(\"==============\");\n      \n      UpRightPhone phone3 = new UpRightPhone(new XiaoMi());\n      \n      phone3.open();\n      phone3.call();\n      phone3.close();\n      \n      System.out.println(\"==============\");\n      \n      UpRightPhone phone4 = new UpRightPhone(new Vivo());\n      \n      phone4.open();\n      phone4.call();\n      phone4.close();\n   }\n\n}\n```\n\n\n\n> 这种简单的demo例子可能比较好理解桥接模式，下面来看看原理和实际应用\n\n## 桥接模式的原理解析\n\n1. 桥接模式，也叫作桥梁模式，英文是Bridge Design Pattern。这个模式可以说是 23 种设计模式中最难理解的模式之一了。我查阅了比较多的书籍和资料之后发现，对于这个模式有两种不同的理解方式。\n2. 当然，这其中“最纯正”的理解方式，当属 GoF 的《设计模式》一书中对桥接模式的定义。毕竟，这 23 种经典的设计模式，最初就是由这本书总结出来的。在 GoF 的《设计模式》一书中，桥接模式是这么定义的：“Decouple an abstraction from its implementation so that the two can vary independently。”翻译成中文就是：“将抽象和实现解耦，让它们可以独立变化。”\n3. 关于桥接模式，很多书籍、资料中，还有另外一种理解方式：“一个类存在两个（或多个）独立变化的维度，我们通过组合的方式，让这两个（或多个）维度可以独立进行扩展。”通过组合关系来替代继承关系，避免继承层次的指数级爆炸。这种理解方式非常类似于，我们之前讲过的“组合优于继承”设计原则，所以，这里我就不多解释了。我们重点看下 GoF 的理解方式。\n4. GoF 给出的定义非常的简短，单凭这一句话，估计没几个人能看懂是什么意思。所以，我们通过 JDBC 驱动的例子来解释一下。JDBC 驱动是桥接模式的经典应用。我们先来看一下，如何利用 JDBC 驱动来查询数据库。具体的代码如下所示：\n\n\n\n```java\n    Class.forName(\"com.mysql.jdbc.Driver\"); // 加载及注册JDBC驱动程序\n    String url = \"jdbc:mysql://localhost:3306/sample_db?user=root&password=your_password\";\n    Connection con = DriverManager.getConnection(url);\n    Statement stmt = con.createStatement();\n    String query = \"select * from test\";\n    ResultSet rs = stmt.executeQuery(query);\n    while (rs.next()) {\n      rs.getString(1);\n      rs.getInt(2);\n    }\n```\n\n\n\n1. 如果我们想要把 MySQL 数据库换成 Oracle 数据库，只需要把第一行代码中的 com.mysql.jdbc.Driver 换成 oracle.jdbc.driver.OracleDriver 就可以了。当然，也有更灵活的实现方式，我们可以把需要加载的 Driver 类写到配置文件中，当程序启动的时候，自动从配置文件中加载，这样在切换数据库的时候，我们都不需要修改代码，只需要修改配置文件就可以了。\n2. 不管是改代码还是改配置，在项目中，从一个数据库切换到另一种数据库，都只需要改动很少的代码，或者完全不需要改动代码，那如此优雅的数据库切换是如何实现的呢？\n3. 源码之下无秘密。要弄清楚这个问题，我们先从 com.mysql.jdbc.Driver 这个类的代码看起。我摘抄了部分相关代码，放到了这里，你可以看一下。\n\n\n\n```java\npackage com.mysql.jdbc;\nimport java.sql.SQLException;\n\npublic class Driver extends NonRegisteringDriver implements java.sql.Driver {\n  static {\n    try {\n      java.sql.DriverManager.registerDriver(new Driver());\n    } catch (SQLException E) {\n      throw new RuntimeException(\"Can't register driver!\");\n    }\n  }\n\n  /**\n   * Construct a new driver and register it with DriverManager\n   * @throws SQLException if a database error occurs.\n   */\n  public Driver() throws SQLException {\n  // Required for Class.forName().newInstance()\n  }\n}\n\n```\n\n\n\n结合 com.mysql.jdbc.Driver 的代码实现，我们可以发现，当执行 Class.forName(“com.mysql.jdbc.Driver”) 这条语句的时候，实际上是做了两件事情。第一件事情是要求 JVM 查找并加载指定的 Driver 类，第二件事情是执行该类的静态代码，也就是将 MySQL Driver 注册到 DriverManager 类中。\n\n\n\n现在，我们再来看一下，DriverManager 类是干什么用的。具体的代码如下所示。当我们把具体的 Driver 实现类（比如，com.mysql.jdbc.Driver）注册到 DriverManager 之后，后续所有对 JDBC 接口的调用，都会委派到对具体的 Driver 实现类来执行。而 Driver 实现类都实现了相同的接口（java.sql.Driver ），这也是可以灵活切换 Driver 的原因。\n\n\n\n```java\npublic class DriverManager {\n  private static final  CopyOnWriteArrayList<DriverInfo> registeredDrivers =  = new CopyOnWriteArrayList();\n\n  // ...\n  static {\n    loadInitialDrivers();\n    println(\"JDBC DriverManager initialized\");\n  }\n\n  // ...\n  public static synchronized void registerDriver(java.sql.Driver driver) throws SQLException {\n    if (driver != null) {\n      registeredDrivers.addIfAbsent(new DriverInfo(driver));\n    } else {\n      throw new NullPointerException();\n    }\n  }\n\n  public static Connection getConnection(String url, String user, String password)\n      throws SQLException {\n    java.util.Properties info = new java.util.Properties();\n    if (user != null) {\n      info.put(\"user\", user);\n    }\n    if (password != null) {\n      info.put(\"password\", password);\n    }\n\n    return (getConnection(url, info, Reflection.getCallerClass()));\n  }\n  // ...\n}\n\n```\n\n\n\n桥接模式的定义是“将抽象和实现解耦，让它们可以独立变化”。那弄懂定义中“抽象”和“实现”两个概念，就是理解桥接模式的关键。那在 JDBC 这个例子中，什么是“抽象”？什么是“实现”呢？\n\n\n\n实际上，JDBC 本身就相当于“抽象”。注意，这里所说的“抽象”，指的并非“抽象类”或“接口”，而是跟具体的数据库无关的、被抽象出来的一套“类库”。具体的 Driver（比如，com.mysql.jdbc.Driver）就相当于“实现”。注意，这里所说的“实现”，也并非指“接口的实现类”，而是跟具体数据库相关的一套“类库”。JDBC 和 Driver 独立开发，通过对象之间的组合关系，组装在一起。JDBC 的所有逻辑操作，最终都委托给 Driver 来执行。\n\n\n\n<img src=\"https://npm.elemecdn.com/youthlql@1.0.0/design_patterns/structural_type/04.01/0002.png\">\n\n\n\n## 桥接模式的应用举例\n\n在前面，我们讲过一个 API 接口监控告警的例子：根据不同的告警规则，触发不同类型的告警。告警支持多种通知渠道，包括：邮件、短信、微信、自动语音电话。通知的紧急程度有多种类型，包括：SEVERE（严重）、URGENCY（紧急）、NORMAL（普通）、TRIVIAL（无关紧要）。不同的紧急程度对应不同的通知渠道。比如，SERVE（严重）级别的消息会通过“自动语音电话”告知相关人员。\n\n\n\n在当时的代码实现中，关于发送告警信息那部分代码，我们只给出了粗略的设计，现在我们来一块实现一下。我们先来看最简单、最直接的一种实现方式。代码如下所示：\n\n```java\n\npublic enum NotificationEmergencyLevel {\n  SEVERE,\n  URGENCY,\n  NORMAL,\n  TRIVIAL\n}\n\npublic class Notification {\n  private List<String> emailAddresses;\n  private List<String> telephones;\n  private List<String> wechatIds;\n\n  public Notification() {}\n\n  public void setEmailAddress(List<String> emailAddress) {\n    this.emailAddresses = emailAddress;\n  }\n\n  public void setTelephones(List<String> telephones) {\n    this.telephones = telephones;\n  }\n\n  public void setWechatIds(List<String> wechatIds) {\n    this.wechatIds = wechatIds;\n  }\n\n  public void notify(NotificationEmergencyLevel level, String message) {\n    if (level.equals(NotificationEmergencyLevel.SEVERE)) {\n      // ...自动语音电话\n    } else if (level.equals(NotificationEmergencyLevel.URGENCY)) {\n      // ...发微信\n    } else if (level.equals(NotificationEmergencyLevel.NORMAL)) {\n      // ...发邮件\n    } else if (level.equals(NotificationEmergencyLevel.TRIVIAL)) {\n      // ...发邮件\n    }\n  }\n}\n\n// 在API监控告警的例子中，我们如下方式来使用Notification类：\npublic class ErrorAlertHandler extends AlertHandler {\n  public ErrorAlertHandler(AlertRule rule, Notification notification) {\n    super(rule, notification);\n  }\n\n  @Override\n  public void check(ApiStatInfo apiStatInfo) {\n    if (apiStatInfo.getErrorCount()\n        > rule.getMatchedRule(apiStatInfo.getApi()).getMaxErrorCount()) {\n      notification.notify(NotificationEmergencyLevel.SEVERE, \"...\");\n    }\n  }\n}\n\n```\n\n\n\n1. Notification 类的代码实现有一个最明显的问题，那就是有很多 if-else 分支逻辑。实际上，如果每个分支中的代码都不复杂，后期也没有无限膨胀的可能（增加更多 if-else 分支判断），那这样的设计问题并不大，没必要非得一定要摒弃 if-else 分支逻辑。\n2. 不过，Notification 的代码显然不符合这个条件。因为每个 if-else 分支中的代码逻辑都比较复杂，发送通知的所有逻辑都扎堆在 Notification 类中。我们知道，类的代码越多，就越难读懂，越难修改，维护的成本也就越高。很多设计模式都是试图将庞大的类拆分成更细小的类，然后再通过某种更合理的结构组装在一起。\n3. 针对 Notification 的代码，我们将不同渠道的发送逻辑剥离出来，形成独立的消息发送类（MsgSender 相关类）。其中，Notification 类相当于抽象，MsgSender 类相当于实现，两者可以独立开发，通过组合关系（也就是桥梁）任意组合在一起。所谓任意组合的意思就是，不同紧急程度的消息和发送渠道之间的对应关系，不是在代码中固定写死的，我们可以动态地去指定（比如，通过读取配置来获取对应关系）。\n\n\n\n按照这个设计思路，我们对代码进行重构。重构之后的代码如下所示：\n\n```java\n\npublic interface MsgSender {\n  void send(String message);\n}\n\npublic class TelephoneMsgSender implements MsgSender {\n  private List<String> telephones;\n\n  public TelephoneMsgSender(List<String> telephones) {\n    this.telephones = telephones;\n  }\n\n  @Override\n  public void send(String message) {\n    // ...\n  }\n}\n\npublic class EmailMsgSender implements MsgSender {\n  // 与TelephoneMsgSender代码结构类似，所以省略...\n}\n\npublic class WechatMsgSender implements MsgSender {\n  // 与TelephoneMsgSender代码结构类似，所以省略...\n}\n\npublic abstract class Notification {\n  protected MsgSender msgSender;\n\n  public Notification(MsgSender msgSender) {\n    this.msgSender = msgSender;\n  }\n\n  public abstract void notify(String message);\n}\n\npublic class SevereNotification extends Notification {\n  public SevereNotification(MsgSender msgSender) {\n    super(msgSender);\n  }\n\n  @Override\n  public void notify(String message) {\n    msgSender.send(message);\n  }\n}\n\npublic class UrgencyNotification extends Notification {\n  // 与SevereNotification代码结构类似，所以省略...\n}\n\npublic class NormalNotification extends Notification {\n  // 与SevereNotification代码结构类似，所以省略...\n}\n\npublic class TrivialNotification extends Notification {\n  // 与SevereNotification代码结构类似，所以省略...\n}\n\n```\n\n\n\n## 桥接模式的注意事项和细节\n\n1. 实现了抽象和实现部分的分离，从而极大的提供了系统的灵活性，让抽象部分和实现部分独立开来，这有助于系统进行分层设计，从而产生更好的结构化系统。 \n2. 对于系统的高层部分，只需要知道抽象部分和实现部分的接口就可以了，其它的部分由具体业务来完成。\n3. 桥接模式替代多层继承方案，可以减少子类的个数，降低系统的管理和维护成本\n4. 桥接模式的引入增加了系统的理解和设计难度，由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设计和编程 \n5. 桥接模式要求**正确识别出系统中两个独立变化的维度(抽象、和实现)**，因此其使用范围有一定的局限性，即需要有这样的应用场景。\n\n\n\n# 装饰器模式【常用】\n\n\n\n我们学习了桥接模式，桥接模式有两种理解方式。第一种理解方式是“将抽象和实现解耦，让它们能独立开发”。这种理解方式比较特别，应用场景也不多。另一种理解方式更加简单，类似“组合优于继承”设计原则，这种理解方式更加通用，应用场景比较多。不管是哪种理解方式，它们的代码结构都是相同的，都是一种类之间的组合关系。\n\n今天，我们通过剖析 Java IO 类的设计思想，再学习一种新的结构型模式，装饰器模式。它的代码结构跟桥接模式非常相似，不过，要解决的问题却大不相同。\n\n> 不过还是先看一个简单的demo案例，会比较好理解\n\n\n\n## Demo案例-咖啡订单项目\n\n### 星巴克咖啡订单项目\n\n1. 咖啡种类/单品咖啡：Espresso(意大利浓咖啡)、ShortBlack、LongBlack(美式咖啡)、Decaf(无因咖啡) \n2. 调料：Milk、Soy(豆浆)、Chocolate \n3. 要求在扩展新的咖啡种类时，具有良好的扩展性、改动方便、维护方便 \n4. 使用 OO 的来计算不同种类咖啡的费用: 客户可以点单品咖啡，也可以单品咖啡+调料组合。\n\n\n\n### 方案一\n\n<img src=\"https://npm.elemecdn.com/youthlql@1.0.0/design_patterns/structural_type/04.01/0003.png\"/>\n\n\n\n1. Drink 是一个抽象类，表示饮料 \n2. des 就是对咖啡的描述, 比如咖啡的名字 \n3. cost() 方法就是计算费用，Drink 类中做成一个抽象方法. \n4. Decaf 就是单品咖啡， 继承 Drink, 并实现 cost \n5. Espress && Milk 就是单品咖啡+调料， 这个组合很多\n6. 问题：**这样设计，会有很多类，当我们增加一个单品咖啡，或者一个新的调料，类的数量就会倍增，就会出现类爆炸** \n\n### 方案二\n\n前面分析到方案 1 因为咖啡单品+调料组合会造成类的倍增，因此可以做改进，将调料内置到 Drink 类，这样就不会造成类数量过多。从而提高项目的维护性(如图)\n\n<img src=\"https://npm.elemecdn.com/youthlql@1.0.0/design_patterns/structural_type/04.01/0004.png\">\n\n\n\n1. 方案 2 可以控制类的数量，不至于造成很多的类 \n2. 在增加或者删除调料种类时，代码的维护量很大 \n3. 考虑到用户可以添加多份 调料时，可以将 hasMilk 返回一个对应 int \n4. 考虑使用 **装饰者** 模式\n\n> 注意：装饰器模式是对功能的增强，而不是附加新的功能。代理模式才是附加新的功能。\n\n\n\n### 装饰器模式代码\n\n<img src=\"https://npm.elemecdn.com/youthlql@1.0.0/design_patterns/structural_type/04.01/0005.png\"/>\n\n#### Drink【抽象类-主体Component】\n\n```java\npublic abstract class Drink {\n\n   public String des; // 描述\n   private float price = 0.0f;\n   public String getDes() {\n      return des;\n   }\n   public void setDes(String des) {\n      this.des = des;\n   }\n   public float getPrice() {\n      return price;\n   }\n   public void setPrice(float price) {\n      this.price = price;\n   }\n   \n   //计算费用的抽象方法\n   //子类来实现\n   public abstract float cost();\n   \n}\n```\n\n\n\n#### Decorator\n\n```java\npublic class Decorator extends Drink {\n   private Drink obj;\n   \n   public Decorator(Drink obj) { //组合\n      // TODO Auto-generated constructor stub\n      this.obj = obj;\n   }\n   \n   @Override\n   public float cost() {\n      // TODO Auto-generated method stub\n      // getPrice 自己价格\n      return super.getPrice() + obj.cost();\n   }\n   \n   @Override\n   public String getDes() {\n      // TODO Auto-generated method stub\n      // obj.getDes() 输出被装饰者的信息\n      return des + \" \" + getPrice() + \" && \" + obj.getDes();\n   }\n   \n}\n```\n\n#### Coffee\n\n```\npublic class Coffee extends Drink {\n\n  @Override\n  public float cost() {\n    // TODO Auto-generated method stub\n    return super.getPrice();\n  }\n}\n```\n\n#### ShortBlack\n\n```java\npublic class ShortBlack extends Coffee{\n   \n   public ShortBlack() {\n      setDes(\" shortblack \");\n      setPrice(4.0f);\n   }\n}\n```\n\n#### LongBlack\n\n```java\npublic class LongBlack extends Coffee {\n\n   public LongBlack() {\n      setDes(\" longblack \");\n      setPrice(5.0f);\n   }\n}\n```\n\n#### DeCaf\n\n```java\npublic class DeCaf extends Coffee {\n\n   public DeCaf() {\n      setDes(\" 无因咖啡 \");\n      setPrice(1.0f);\n   }\n}\n```\n\n#### Espresso\n\n```java\npublic class Espresso extends Coffee {\n   \n   public Espresso() {\n      setDes(\" 意大利咖啡 \");\n      setPrice(6.0f);\n   }\n}\n```\n\n#### Chocolate\n\n```java\n//具体的Decorator， 这里就是调味品\npublic class Chocolate extends Decorator {\n\n   public Chocolate(Drink obj) {\n      super(obj);\n      setDes(\" 巧克力 \");\n      setPrice(3.0f); // 调味品 的价格\n   }\n\n}\n```\n\n#### Milk\n\n```java\npublic class Milk extends Decorator {\n\n   public Milk(Drink obj) {\n      super(obj);\n      // TODO Auto-generated constructor stub\n      setDes(\" 牛奶 \");\n      setPrice(2.0f); \n   }\n\n}\n```\n\n#### Soy\n\n```java\npublic class Soy extends Decorator{\n\n   public Soy(Drink obj) {\n      super(obj);\n      // TODO Auto-generated constructor stub\n      setDes(\" 豆浆  \");\n      setPrice(1.5f);\n   }\n\n}\n```\n\n#### CoffeeBar\n\n```java\npublic class CoffeeBar {\n\n   public static void main(String[] args) {\n      // TODO Auto-generated method stub\n      // 装饰者模式下的订单：2份巧克力+一份牛奶的LongBlack\n\n      // 1. 点一份 LongBlack\n      Drink order = new LongBlack();\n      System.out.println(\"费用1=\" + order.cost());\n      System.out.println(\"描述=\" + order.getDes());\n\n      // 2. order 加入一份牛奶\n      order = new Milk(order);\n\n      System.out.println(\"order 加入一份牛奶 费用 =\" + order.cost());\n      System.out.println(\"order 加入一份牛奶 描述 = \" + order.getDes());\n\n      // 3. order 加入一份巧克力\n\n      order = new Chocolate(order);\n\n      System.out.println(\"order 加入一份牛奶 加入一份巧克力  费用 =\" + order.cost());\n      System.out.println(\"order 加入一份牛奶 加入一份巧克力 描述 = \" + order.getDes());\n\n      // 3. order 加入一份巧克力\n\n      order = new Chocolate(order);\n\n      System.out.println(\"order 加入一份牛奶 加入2份巧克力   费用 =\" + order.cost());\n      System.out.println(\"order 加入一份牛奶 加入2份巧克力 描述 = \" + order.getDes());\n   \n      System.out.println(\"===========================\");\n      \n      Drink order2 = new DeCaf();\n      \n      System.out.println(\"order2 无因咖啡  费用 =\" + order2.cost());\n      System.out.println(\"order2 无因咖啡 描述 = \" + order2.getDes());\n      \n      order2 = new Milk(order2);\n      \n      System.out.println(\"order2 无因咖啡 加入一份牛奶  费用 =\" + order2.cost());\n      System.out.println(\"order2 无因咖啡 加入一份牛奶 描述 = \" + order2.getDes());\n\n   \n   }\n\n}\n```\n\n\n\n## 装饰者模式原理\n\n1. 装饰者模式就像打包一个快递 \n\n主体：比如：陶瓷、衣服 (Component) // 被装饰者 \n\n包装：比如：报纸填充、塑料泡沫、纸板、木板(Decorator) \n\n2. Component 主体：比如类似前面的 Drink \n\n3. ConcreteComponent 和 Decorator \n\nConcreteComponent：具体的主体， 比如前面的各个单品咖啡 \n\n4. Decorator: 装饰者，比如各调料. \n\n在Component 与 ConcreteComponent 之间，如果 ConcreteComponent 类很多,还可以设计一个缓冲层，将 共有的部分提取出来，抽象层一个类\n\n## Java IO 类的“奇怪”用法\n\nJava IO 类库非常庞大和复杂，有几十个类，负责 IO 数据的读取和写入。如果对 Java IO 类做一下分类，我们可以从下面两个维度将它划分为四类。具体如下所示：\n\n|        | 字节流       | 字符流 |\n| ------ | ------------ | ------ |\n| 输入流 | InputStream  | Reader |\n| 输出流 | OutputStream | Writer |\n\n针对不同的读取和写入场景，Java IO 又在这四个父类基础之上，扩展出了很多子类。具体如下所示：\n\n<img src=\"https://npm.elemecdn.com/youthlql@1.0.0/design_patterns/structural_type/04.01/0006.png\"/>\n\n\n\n> 说明\n>\n> 1. InputStream 是抽象类, 类似我们前面讲的 Drink\n> 2. FileInputStream 是  InputStream 子类，类似我们前面的 DeCaf, LongBlack\n> 3. FilterInputStream  是  InputStream 子类：类似我们前面 的 Decorator 修饰者\n> 4. DataInputStream 是 FilterInputStream 子类，具体的修饰者，类似前面的 Milk, Soy 等\n> 5. FilterInputStream 类 有  protected volatile InputStream in; 即含被装饰者\n> 6. 分析得出在jdk 的io体系中，就是使用装饰者模式\n\n在我初学 Java 的时候，曾经对 Java IO 的一些用法产生过很大疑惑，比如下面这样一段代码。我们打开文件 test.txt，从中读取数据。其中，InputStream 是一个抽象类，FileInputStream 是专门用来读取文件流的子类。BufferedInputStream 是一个支持带缓存功能的数据读取类，可以提高数据读取的效率。\n\n\n\n```java\nInputStream in = new FileInputStream(\"/user/test.txt\");\nInputStream bin = new BufferedInputStream(in);\nbyte[] data = new byte[128];\nwhile (bin.read(data) != -1) {\n    //...\n}\n```\n\n初看上面的代码，我们会觉得 Java IO 的用法比较麻烦，需要先创建一个 FileInputStream 对象，然后再传递给 BufferedInputStream 对象来使用。我在想，Java IO 为什么不设计一个继承 FileInputStream 并且支持缓存的 BufferedFileInputStream 类呢？这样我们就可以像下面的代码中这样，直接创建一个 BufferedFileInputStream 类对象，打开文件读取数据，用起来岂不是更加简单？\n\n\n\n```java\nInputStream bin = new BufferedFileInputStream(\"/user/test.txt\");\nbyte[] data = new byte[128];\nwhile (bin.read(data) != -1) {\n    //...\n}\n```\n\n\n\n\n\n## 基于继承的设计方案\n\n如果 InputStream 只有一个子类 FileInputStream 的话，那我们在 FileInputStream 基础之上，再设计一个孙子类 BufferedFileInputStream，也算是可以接受的，毕竟继承结构还算简单。但实际上，继承 InputStream 的子类有很多。我们需要给每一个 InputStream 的子类，再继续派生支持缓存读取的子类。\n\n\n\n除了支持缓存读取之外，如果我们还需要对功能进行其他方面的增强，比如下面的 DataInputStream 类，支持按照基本数据类型（int、boolean、long 等）来读取数据。\n\n```java\nFileInputStream in = new FileInputStream(\"/user/test.txt\");\nDataInputStream din = new DataInputStream(in);\nint data = din.readInt();\n```\n\n在这种情况下，如果我们继续按照继承的方式来实现的话，就需要再继续派生出 DataFileInputStream、DataPipedInputStream 等类。如果我们还需要既支持缓存、又支持按照基本类型读取数据的类，那就要再继续派生出 BufferedDataFileInputStream、BufferedDataPipedInputStream 等 n 多类。这还只是附加了两个增强功能，如果我们需要附加更多的增强功能，那就会导致组合爆炸，类继承结构变得无比复杂，代码既不好扩展，也不好维护。这也是我们不推荐使用继承的原因。\n\n\n\n## 基于装饰器模式的设计方案\n\n\n\n在前面，我们还讲到“组合优于继承”，可以“使用组合来替代继承”。针对刚刚的继承结构过于复杂的问题，我们可以通过将继承关系改为组合关系来解决。下面的代码展示了 Java IO 的这种设计思路。不过，我对代码做了简化，只抽象出了必要的代码结构，如果你感兴趣的话，可以直接去查看 JDK 源码。\n\n```java\nimport java.io.IOException;\n\npublic abstract class InputStream {\n  // ...\n  public int read(byte b[]) throws IOException {\n    return read(b, 0, b.length);\n  }\n  public int read(byte b[], int off, int len) throws IOException {\n    // ...\n  }\n\n  public long skip(long n) throws IOException {\n    // ...\n  }\n\n  public int available() throws IOException {\n    return 0;\n  }\n\n  public void close() throws IOException {}\n\n  public synchronized void mark(int readlimit) {}\n\n  public synchronized void reset() throws IOException {\n    throw new IOException(\"mark/reset not supported\");\n  }\n\n  public boolean markSupported() {\n    return false;\n  }\n}\n\npublic class BufferedInputStream extends InputStream {\n  protected volatile InputStream in;\n\n  protected BufferedInputStream(InputStream in) {\n    this.in = in;\n  }\n\n  // ...实现基于缓存的读数据接口...\n}\n\npublic class DataInputStream extends InputStream {\n  protected volatile InputStream in;\n\n  protected DataInputStream(InputStream in) {\n    this.in = in;\n  }\n\n  // ...实现读取基本类型数据的接口\n}\n\n```\n\n看了上面的代码，你可能会问，那装饰器模式就是简单的“用组合替代继承”吗？当然不是。从 Java IO 的设计来看，装饰器模式相对于简单的组合关系，还有两个比较特殊的地方。\n\n\n\n**第一个比较特殊的地方是：装饰器类和原始类继承同样的父类，这样我们可以对原始类“嵌套”多个装饰器类。**比如，下面这样一段代码，我们对 FileInputStream 嵌套了两个装饰器类：BufferedInputStream 和 DataInputStream，让它既支持缓存读取，又支持按照基本数据类型来读取数据。\n\n\n\n```java\nInputStream in = new FileInputStream(\"/user/test.txt\");\nInputStream bin = new BufferedInputStream(in);\nDataInputStream din = new DataInputStream(bin);\nint data = din.readInt();\n```\n\n\n\n**第二个比较特殊的地方是：装饰器类是对功能的增强，这也是装饰器模式应用场景的一个重要特点。**实际上，符合“组合关系”这种代码结构的设计模式有很多，比如之前讲过的代理模式、桥接模式，还有现在的装饰器模式。尽管它们的代码结构很相似，但是每种设计模式的意图是不同的。就拿比较相似的代理模式和装饰器模式来说吧，代理模式中，代理类附加的是跟原始类无关的功能，而在装饰器模式中，装饰器类附加的是跟原始类相关的增强功能。\n\n```java\n// 代理模式的代码结构(下面的接口也可以替换成抽象类)\npublic interface IA {\n    void f();\n}\n\npublic class A impelements IA {\n    public void f() { \n        //... \n    }\n}\n\npublic class AProxy impements IA {\n    private IA a;\n\n    public AProxy(IA a) {\n        this.a = a;\n    }\n\n    public void f() {\n        // 新添加的代理逻辑\n        a.f();\n        // 新添加的代理逻辑\n    }\n}\n\n// 装饰器模式的代码结构(下面的接口也可以替换成抽象类)\npublic interface IA {\n    void f();\n}\n\npublic class A impelements IA {\n\n    public void f() { \n        //... \n    }\n}\n\npublic class ADecorator impements IA {\n    private IA a;\n    public ADecorator(IA a) {\n        this.a = a;\n    }\n\n    public void f() {\n        // 功能增强代码\n        a.f();\n        // 功能增强代码\n    }\n}\n```\n\n\n\n1. 实际上，如果去查看 JDK 的源码，你会发现，BufferedInputStream、DataInputStream 并非继承自 InputStream，而是另外一个叫 FilterInputStream 的类。那这又是出于什么样的设计意图，才引入这样一个类呢？\n2. 我们再重新来看一下 BufferedInputStream 类的代码。InputStream 是一个抽象类而非接口，而且它的大部分函数（比如 read()、available()）都有默认实现，按理来说，我们只需要在 BufferedInputStream 类中重新实现那些需要增加缓存功能的函数就可以了，其他函数继承 InputStream 的默认实现。但实际上，这样做是行不通的。\n3. 对于即便是不需要增加缓存功能的函数来说，BufferedInputStream 还是必须把它重新实现一遍，简单包裹对 InputStream 对象的函数调用。具体的代码示例如下所示。如果不重新实现，那 BufferedInputStream 类就无法将最终读取数据的任务，委托给传递进来的 InputStream 对象来完成。这一部分稍微有点不好理解，你自己多思考一下。\n\n\n\n```java\npublic class BufferedInputStream extends InputStream {\n    protected volatile InputStream in;\n\n    protected BufferedInputStream(InputStream in) {\n        this.in = in;\n    }\n\n\t// f()函数不需要增强，只是重新调用一下InputStream in对象的f()\n    public void f() { \n        in.f();\n    }\n}\n```\n\n\n\n实际上，DataInputStream 也存在跟 BufferedInputStream 同样的问题。为了避免代码重复，Java IO 抽象出了一个装饰器父类 FilterInputStream，代码实现如下所示。InputStream 的所有的装饰器类（BufferedInputStream、DataInputStream）都继承自这个装饰器父类。这样，装饰器类只需要实现它需要增强的方法就可以了，其他方法继承装饰器父类的默认实现。\n\n\n\n```java\n\npublic class FilterInputStream extends InputStream {\n    protected volatile InputStream in;\n\n    protected FilterInputStream(InputStream in) {\n        this.in = in;\n    }\n\n    public int read() throws IOException {\n        return in.read();\n    }\n\n    public int read(byte b[]) throws IOException { \n        return read(b, 0, b.length);\n    }\n\n    public int read(byte b[], int off, int len) throws IOException {\n        return in.read(b, off, len);\n    }\n\n    public long skip(long n) throws IOException {\n        return in.skip(n);\n    }\n\n    public int available() throws IOException {\n        return in.available();\n    }\n\n    public void close() throws IOException {\n        in.close();\n    }\n\n    public synchronized void mark(int readlimit) {\n        in.mark(readlimit);\n    }\n\n    public synchronized void reset() throws IOException {\n        in.reset();\n    }\n\n    public boolean markSupported() {\n        return in.markSupported();\n    }\n\n}\n```\n\n\n\n\n\n# 适配器模式【常用】\n\n1. 前面我们学了代理模式、桥接模式、装饰器模式，今天，我们再来学习一个比较常用的结构型模式：适配器模式。这个模式相对来说还是比较简单、好理解的，应用场景也很具体，总体上来讲比较好掌握。\n2. 关于适配器模式，今天我们主要学习它的两种实现方式，类适配器和对象适配器，以及 5 种常见的应用场景。同时，我还会通过剖析 slf4j 日志框架，来给你展示这个模式在真实项目中的应用。除此之外，在文章的最后，我还对代理、桥接、装饰器、适配器，这 4 种代码结构非常相似的设计模式做简单的对比，对这几节内容做一个简单的总结。\n3. 适配器模式(Adapter Pattern)将某个类的接口转换成客户端期望的另一个接口表示，**主的目的是兼容性**，让原本因接口不匹配不能一起工作的两个类可以协同工作。其别名为包装器(Wrapper) 。适配器模式属于结构型模式。主要分为三类：**类适配器模式、对象适配器模式、接口适配器模**式 \n\n\n\n## Demo案例-充电器\n\n基本介绍：Adapter 类，通过继承 src 类，实现 dst 类接口，完成 src->dst 的适配。\n\n- 以生活中充电器的例子来讲解适配器，充电器本身相当于 Adapter，220V 交流电相当于 src (即被适配者)，我们 的目 dst(即 目标)是 5V 直流电 \n\n### 类适配器代码实现\n\n#### Voltage220V\n\n```java\n//被适配的类\npublic class Voltage220V {\n   //输出220V的电压\n   public int output220V() {\n      int src = 220;\n      System.out.println(\"电压=\" + src + \"伏\");\n      return src;\n   }\n}\n```\n\n#### IVoltage5V\n\n```java\n//适配接口\npublic interface IVoltage5V {\n   public int output5V();\n}\n```\n\n#### Phone\n\n```java\npublic class Phone {\n\n   //充电\n   public void charging(IVoltage5V iVoltage5V) {\n      if(iVoltage5V.output5V() == 5) {\n         System.out.println(\"电压为5V, 可以充电~~\");\n      } else if (iVoltage5V.output5V() > 5) {\n         System.out.println(\"电压大于5V, 不能充电~~\");\n      }\n   }\n}\n```\n\n#### VoltageAdapter\n\n```java\n//适配器类\npublic class VoltageAdapter extends Voltage220V implements IVoltage5V {\n\n   @Override\n   public int output5V() {\n      // TODO Auto-generated method stub\n      //获取到220V电压\n      int srcV = output220V();\n      int dstV = srcV / 44 ; //转成 5v\n      return dstV;\n   }\n\n}\n```\n\n#### Client\n\n```java\npublic class Client {\n\n   public static void main(String[] args) {\n      // TODO Auto-generated method stub\n      System.out.println(\" === 类适配器模式 ====\");\n      Phone phone = new Phone();\n      phone.charging(new VoltageAdapter());\n   }\n\n}\n```\n\n\n\n### 对象适配器实现\n\n基本思路和类的适配器模式相同，只是将 Adapter 类作修改，不是继承 src 类，而是持有 src 类的实例，以解决 兼容性的问题。 即：持有 src 类，实现 dst 类接口，完成 src->dst 的适配 ，在系统中尽量使用**关联关系（聚合，组合）来替代继承**关系。\n\n\n\n上面的例子代码基本没用什么改变，改变的只有以下两个类\n\n#### VoltageAdapter\n\n```java\n// 适配器类\npublic class VoltageAdapter implements IVoltage5V {\n\n  private Voltage220V voltage220V; // 关联关系-聚合\n\n  // 通过构造器，传入一个 Voltage220V 实例\n  public VoltageAdapter(Voltage220V voltage220v) {\n\n    this.voltage220V = voltage220v;\n  }\n\n  @Override\n  public int output5V() {\n\n    int dst = 0;\n    if (null != voltage220V) {\n      int src = voltage220V.output220V(); // 获取220V 电压\n      System.out.println(\"使用对象适配器，进行适配~~\");\n      dst = src / 44;\n      System.out.println(\"适配完成，输出的电压为=\" + dst);\n    }\n\n    return dst;\n  }\n}\n```\n\n#### Client\n\n```java\npublic class Client {\n\n  public static void main(String[] args) {\n    // TODO Auto-generated method stub\n    System.out.println(\" === 对象适配器模式 ====\");\n    Phone phone = new Phone();\n    phone.charging(new VoltageAdapter(new Voltage220V()));\n  }\n}\n```\n\n\n\n\n\n## 适配器模式的原理与实现\n\n顾名思义，这个模式就是用来做适配的，它将不兼容的接口转换为可兼容的接口，让原本由于接口不兼容而不能一起工作的类可以一起工作。对于这个模式，有一个经常被拿来解释它的例子，就是 USB 转接头充当适配器，把两种不兼容的接口，通过转接变得可以一起工作。\n\n\n\n原理很简单，我们再来看下它的代码实现。适配器模式有两种实现方式：类适配器和对象适配器。其中，类适配器使用继承关系来实现，对象适配器使用组合关系来实现。具体的代码实现如下所示。其中，ITarget 表示要转化成的接口定义。Adaptee 是一组不兼容 ITarget 接口定义的接口，Adaptor 将 Adaptee 转化成一组符合 ITarget 接口定义的接口。\n\n```java\n// 类适配器: 基于继承\npublic interface ITarget {\n    void f1();\n    void f2();\n    void fc();\n}\n\npublic class Adaptee {\n\n    public void fa() { \n        //... \n    }\n\n    public void fb() {\n        //... \n    }\n\n    public void fc(){\n        //... \n    }\n\n}\n\npublic class Adaptor extends Adaptee implements ITarget {\n\n    public void f1() {\n        super.fa();\n    }\n\n    public void f2() {\n        //...重新实现f2()...\n    }\n\n// 这里fc()不需要实现，直接继承自Adaptee，这是跟对象适配器最大的不同点\n}\n\n// 对象适配器：基于组合\npublic interface ITarget {\n    void f1();\n    void f2();\n    void fc();\n}\npublic class Adaptee {\n\n    public void fa() {\n        //... \n    }\n\n    public void fb() {\n        //... \n    }\n\n    public void fc(){\n        //... \n    }\n\n}\n\npublic class Adaptor implements ITarget {\n    private Adaptee adaptee;\n\n    public Adaptor(Adaptee adaptee) {\n        this.adaptee = adaptee;\n    }\n\n    public void f1() {\n        adaptee.fa(); //委托给Adaptee\n    }\n\n    public void f2() {\n        //...重新实现f2()...\n    }\n\n    public void fc() {\n        adaptee.fc();\n    }\n}\n```\n\n\n\n针对这两种实现方式，在实际的开发中，到底该如何选择使用哪一种呢？判断的标准主要有两个，一个是 Adaptee 接口的个数，另一个是 Adaptee 和 ITarget 的契合程度。\n\n- 如果 Adaptee 接口并不多，那两种实现方式都可以。\n- 如果 Adaptee 接口很多，而且 Adaptee 和 ITarget 接口定义大部分都相同，那我们推荐使用类适配器，因为 Adaptor 复用父类 Adaptee 的接口，比起对象适配器的实现方式，Adaptor 的代码量要少一些。\n- 如果 Adaptee 接口很多，而且 Adaptee 和 ITarget 接口定义大部分都不相同，那我们推荐使用对象适配器，因为组合结构相对于继承更加灵活。\n\n\n\n## 适配器模式应用场景总结\n\n1. 原理和实现讲完了，都不复杂。我们再来看，到底什么时候会用到适配器模式呢？\n\n2. 一般来说，适配器模式可以看作一种“补偿模式”，用来补救设计上的缺陷。应用这种模式算是“无奈之举”。如果在设计初期，我们就能协调规避接口不兼容的问题，那这种模式就没有应用的机会了。\n3. 前面我们反复提到，适配器模式的应用场景是“接口不兼容”。那在实际的开发中，什么情况下才会出现接口不兼容呢？我建议你先自己思考一下这个问题，然后再来看下面的总结 。\n\n\n\n### 封装有缺陷的接口设计\n\n1. 假设我们依赖的外部系统在接口设计方面有缺陷（比如包含大量静态方法），引入之后会影响到我们自身代码的可测试性。为了隔离设计上的缺陷，我们希望对外部系统提供的接口进行二次封装，抽象出更好的接口设计，这个时候就可以使用适配器模式了。\n\n2. 具体我还是举个例子来解释一下，你直接看代码应该会更清晰。具体代码如下所示：\n\n```java\npublic class CD { //这个类来自外部sdk，我们无权修改它的代码\n    //...\n    public static void staticFunction1() { //... }\n        \n    public void uglyNamingFunction2() { //... }\n        \n    public void tooManyParamsFunction3(int paramA, int paramB, ...) { //... }\n\n    public void lowPerformanceFunction4() { //... }\n\n}\n\n// 使用适配器模式进行重构\npublic class ITarget {\n\n    void function1();\n    void function2();\n    void fucntion3(ParamsWrapperDefinition paramsWrapper);\n    void function4();\n    //...\n}\n\n// 注意：适配器类的命名不一定非得末尾带Adaptor\n\npublic class CDAdaptor extends CD implements ITarget {\n    //...\n    public void function1() {\n        super.staticFunction1();\n    }\n\n    public void function2() {\n        super.uglyNamingFucntion2();\n    }\n\n    public void function3(ParamsWrapperDefinition paramsWrapper) { \n        super.tooManyParamsFunction3(paramsWrapper.getParamA(), ...);\n    }\n\n    public void function4() {\n        //...reimplement it...\n    }\n}\n```\n\n\n\n### 统一多个类的接口设计\n\n1. 某个功能的实现依赖多个外部系统（或者说类）。通过适配器模式，将它们的接口适配为统一的接口定义，然后我们就可以使用多态的特性来复用代码逻辑。具体我还是举个例子来解释一下。\n2. 假设我们的系统要对用户输入的文本内容做敏感词过滤，为了提高过滤的召回率，我们引入了多款第三方敏感词过滤系统，依次对用户输入的内容进行过滤，过滤掉尽可能多的敏感词。但是，每个系统提供的过滤接口都是不同的。这就意味着我们没法复用一套逻辑来调用各个系统。这个时候，我们就可以使用适配器模式，将所有系统的接口适配为统一的接口定义，这样我们可以复用调用敏感词过滤的代码。\n3. 你可以配合着下面的代码示例，来理解我刚才举的这个例子。\n\n```java\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class ASensitiveWordsFilter { // A敏感词过滤系统提供的接口\n  // text是原始文本，函数输出用***替换敏感词之后的文本\n  public String filterSexyWords(String text) {\n    // ...\n  }\n\n  public String filterPoliticalWords(String text) {\n    // ...\n  }\n}\n\npublic class BSensitiveWordsFilter { // B敏感词过滤系统提供的接口\n  public String filter(String text) {\n    // ...\n  }\n}\n\npublic class CSensitiveWordsFilter { // C敏感词过滤系统提供的接口\n  public String filter(String text, String mask) {\n    // ...\n  }\n}\n\n// 未使用适配器模式之前的代码：代码的可测试性、扩展性不好\npublic class RiskManagement {\n  private ASensitiveWordsFilter aFilter = new ASensitiveWordsFilter();\n  private BSensitiveWordsFilter bFilter = new BSensitiveWordsFilter();\n  private CSensitiveWordsFilter cFilter = new CSensitiveWordsFilter();\n\n  public String filterSensitiveWords(String text) {\n    String maskedText = aFilter.filterSexyWords(text);\n    maskedText = aFilter.filterPoliticalWords(maskedText);\n    maskedText = bFilter.filter(maskedText);\n    maskedText = cFilter.filter(maskedText, \"***\");\n    return maskedText;\n  }\n}\n\n// 使用适配器模式进行改造\npublic interface ISensitiveWordsFilter { // 统一接口定义\n  String filter(String text);\n}\n\npublic class ASensitiveWordsFilterAdaptor implements ISensitiveWordsFilter {\n  private ASensitiveWordsFilter aFilter;\n\n  public String filter(String text) {\n    String maskedText = aFilter.filterSexyWords(text);\n    maskedText = aFilter.filterPoliticalWords(maskedText);\n    return maskedText;\n  }\n}\n\n// ...省略BSensitiveWordsFilterAdaptor、CSensitiveWordsFilterAdaptor...\n// 扩展性更好，更加符合开闭原则，如果添加一个新的敏感词过滤系统，\n// 这个类完全不需要改动；而且基于接口而非实现编程，代码的可测试性更好。\npublic class RiskManagement {\n  private List<ISensitiveWordsFilter> filters = new ArrayList<>();\n\n  public void addSensitiveWordsFilter(ISensitiveWordsFilter filter) {\n    filters.add(filter);\n  }\n\n  public String filterSensitiveWords(String text) {\n    String maskedText = text;\n    for (ISensitiveWordsFilter filter : filters) {\n      maskedText = filter.filter(maskedText);\n    }\n\n    return maskedText;\n  }\n}\n\n```\n\n\n\n### 替换依赖的外部系统\n\n当我们把项目中依赖的一个外部系统替换为另一个外部系统的时候，利用适配器模式，可以减少对代码的改动。具体的代码示例如下所示：\n\n```java\n// 外部系统A\npublic  interface  IA  {\n//...\n  void  fa();\n}\npublic  class  A  implements  IA  {\n//...\n  public  void  fa()  { \n    //... \n  }\n}\n\n// 在我们的项目中，外部系统A的使用示例\npublic  class  Demo  {\n  private IA a;\n  public  Demo(IA a)  {\n    this.a = a;\n  }\n  //... \n\n}\n\nDemo d = new Demo(new A());\n\n// 将外部系统A替换成外部系统B\npublic  class  BAdaptor  implemnts  IA  {\n  private B b;\n  public  BAdaptor(B b)  {\n    this.b= b;\n  }\n\n  public  void  fa()  {\n  //...\n    b.fb();\n  }\n}\n\n// 借助BAdaptor，Demo的代码中，调用IA接口的地方都无需改动，\n// 只需要将BAdaptor如下注入到Demo即可。\nDemo d = new Demo(new BAdaptor(new B()));\n```\n\n\n\n### 兼容老版本接口\n\n1. 在做版本升级的时候，对于一些要废弃的接口，我们不直接将其删除，而是暂时保留，并且标注为 deprecated，并将内部实现逻辑委托为新的接口实现。这样做的好处是，让使用它的项目有个过渡期，而不是强制进行代码修改。这也可以粗略地看作适配器模式的一个应用场景。同样，我还是通过一个例子，来进一步解释一下。\n2. JDK1.0 中包含一个遍历集合容器的类 Enumeration。JDK2.0 对这个类进行了重构，将它改名为 Iterator 类，并且对它的代码实现做了优化。但是考虑到如果将 Enumeration 直接从 JDK2.0 中删除，那使用 JDK1.0 的项目如果切换到 JDK2.0，代码就会编译不通过。为了避免这种情况的发生，我们必须把项目中所有使用到 Enumeration 的地方，都修改为使用 Iterator 才行。\n3. 单独一个项目做 Enumeration 到 Iterator 的替换，勉强还能接受。但是，使用 Java 开发的项目太多了，一次 JDK 的升级，导致所有的项目不做代码修改就会编译报错，这显然是不合理的。这就是我们经常所说的不兼容升级。为了做到兼容使用低版本 JDK 的老代码，我们可以暂时保留 Enumeration 类，并将其实现替换为直接调用 Itertor。代码示例如下所示：\n\n```java\npublic  class  Collections  {\n  public  static Emueration emumeration(final Collection c)  {\n    return  new Enumeration() {\n      Iterator i = c.iterator();\n\n      public boolean hasMoreElments()  {\n        return i.hashNext();\n      }\n\n      public Object nextElement()  {\n        return i.next():\n      }\n    }\n  }\n}\n```\n\n\n\n### 适配不同格式的数据\n\n前面我们讲到，适配器模式主要用于接口的适配，实际上，它还可以用在不同格式的数据之间的适配。比如，把从不同征信系统拉取的不同格式的征信数据，统一为相同的格式，以方便存储和使用。再比如，Java 中的 Arrays.asList() 也可以看作一种数据适配器，将数组类型的数据转化为集合容器类型。\n\n```java\nList<String> stooges = Arrays.asList(\"Larry\", \"Moe\", \"Curly\");\n```\n\n\n\n\n\n### 剖析适配器模式在 Java 日志中的应用\n\n1. Java 中有很多日志框架，在项目开发中，我们常常用它们来打印日志信息。其中，比较常用的有 log4j、logback，以及 JDK 提供的 JUL(java.util.logging) 和 Apache 的 JCL(Jakarta Commons Logging) 等。\n2. 大部分日志框架都提供了相似的功能，比如按照不同级别（debug、info、warn、erro……）打印日志等，但它们却并没有实现统一的接口。这主要可能是历史的原因，它不像 JDBC 那样，一开始就制定了数据库操作的接口规范。\n3. 如果我们只是开发一个自己用的项目，那用什么日志框架都可以，log4j、logback 随便选一个就好。但是，如果我们开发的是一个集成到其他系统的组件、框架、类库等，那日志框架的选择就没那么随意了。\n4. 比如，项目中用到的某个组件使用 log4j 来打印日志，而我们项目本身使用的是 logback。将组件引入到项目之后，我们的项目就相当于有了两套日志打印框架。每种日志框架都有自己特有的配置方式。所以，我们要针对每种日志框架编写不同的配置文件（比如，日志存储的文件地址、打印日志的格式）。如果引入多个组件，每个组件使用的日志框架都不一样，那日志本身的管理工作就变得非常复杂。所以，为了解决这个问题，我们需要统一日志打印框架。\n5. 如果你是做 Java 开发的，那 Slf4j 这个\b日志框架你肯定不陌生，它相当于 JDBC 规范，提供了一套打印日志的统一接口规范。不过，它只定义了接口，并没有提供具体的实现，需要配合其他日志框架（log4j、logback……）来使用。\n6. 不仅如此，Slf4j 的出现晚于 JUL、JCL、log4j 等日志框架，所以，这些日志框架也不可能牺牲掉版本兼容性，将接口改造成符合 Slf4j 接口规范。Slf4j 也事先考虑到了这个问题，所以，它不仅仅提供了统一的接口定义，还提供了针对不同日志框架的适配器。对不同日志框架的接口进行二次封装，适配成统一的 Slf4j 接口定义。具体的代码示例如下所示：\n\n```java\n// slf4j统一的接口定义\npackage org.slf4j;\npublic  interface Logger {\n  public  boolean isTraceEnabled();\n  public  void trace(String msg);\n  public  void trace(String format, Object arg);\n  public  void trace(String format, Object arg1, Object arg2);\n  public  void trace(String format, Object[] argArray);\n  public  void trace(String msg, Throwable t);\n  public  boolean isDebugEnabled();\n  public  void debug(String msg);\n  public  void debug(String format, Object arg);\n  public  void debug(String format, Object arg1, Object arg2);\n  public  void debug(String format, Object[] argArray);\n  public  void debug(String msg, Throwable t);\n\n//...省略info、warn、error等一堆接口\n}\n\n\n// log4j日志框架的适配器\n// Log4jLoggerAdapter实现了LocationAwareLogger接口，\n// 其中LocationAwareLogger继承自Logger接口，\n// 也就相当于Log4jLoggerAdapter实现了Logger接口。\npackage org.slf4j.impl;\npublic final class Log4jLoggerAdapter extends MarkerIgnoringBase\n        implements LocationAwareLogger, Serializable {\n\n  final transient org.apache.log4j.Logger logger; // log4j\n\n  public  boolean isDebugEnabled() {\n    return logger.isDebugEnabled();\n  }\n\n  public  void debug(String msg) {\n    logger.log(FQCN, Level.DEBUG, msg, null);\n  }\n\n  public  void debug(String format, Object arg) {\n    if (logger.isDebugEnabled()) {\n      FormattingTuple ft = MessageFormatter.format(format, arg);\n      logger.log(FQCN, Level.DEBUG, ft.getMessage(), ft.getThrowable());\n    }\n  }\n\n  public  void debug(String format, Object arg1, Object arg2) {\n    if (logger.isDebugEnabled()) {\n      FormattingTuple ft = MessageFormatter.format(format, arg1, arg2);\n      logger.log(FQCN, Level.DEBUG, ft.getMessage(), ft.getThrowable());\n    }\n  }\n\n  public  void debug(String format, Object\\[\\] argArray) {\n    if (logger.isDebugEnabled()) {\n      FormattingTuple ft = MessageFormatter.arrayFormat(format, argArray);\n      logger.log(FQCN, Level.DEBUG, ft.getMessage(), ft.getThrowable());\n    }\n  }\n\n  public  void debug(String msg, Throwable t) {\n    logger.log(FQCN, Level.DEBUG, msg, t);\n  }\n\n//...省略一堆接口的实现...\n}\n```\n\n\n\n1. 所以，在开发业务系统或者开发框架、组件的时候，我们统一使用 Slf4j 提供的接口来编写打印日志的代码，具体使用哪种日志框架实现（log4j、logback……），是可以动态地指定的（使用 Java 的 SPI 技术，这里我不多解释，你自行研究吧），只需要将相应的 SDK 导入到项目中即可。\n2. 不过，你可能会说，如果一些老的项目没有使用 Slf4j，而是直接使用比如 JCL 来打印日志，那如果想要替换成其他日志框架，比如 log4j，该怎么办呢？实际上，Slf4j 不仅仅提供了从其他日志框架到 Slf4j 的适配器，还提供了反向适配器，也就是从 Slf4j 到其他日志框架的适配。我们可以先将 JCL 切换为 Slf4j，然后再将 Slf4j 切换为 log4j。经过两次适配器的转换，我们能就成功将 log4j 切换为了 logback。\n\n\n\n## 代理、桥接、装饰器、适配器 4 种设计模式的区别\n\n1. 代理、桥接、装饰器、适配器，这 4 种模式是比较常用的结构型设计模式。它们的代码结构非常相似。笼统来说，它们都可以称为 Wrapper 模式，也就是通过 Wrapper 类二次封装原始类。\n\n2. 尽管代码结构相似，但这 4 种设计模式的用意完全不同，也就是说要解决的问题、应用场景不同，这也是它们的主要区别。这里我就简单说一下它们之间的区别。\n\n\n\n- 代理模式：在不改变原始类接口的条件下，为原始类定义一个代理类，主要目的是控制访问，而非加强功能，这是它跟装饰器模式最大的不同。\n- 桥接模式：目的是将接口部分和实现部分分离，从而让它们可以较为容易、也相对独立地加以改变。\n- 装饰者模式：在不改变原始类接口的情况下，对原始类功能进行增强，并且支持多个装饰器的嵌套使用。\n- 适配器模式：是一种事后的补救策略。适配器提供跟原始类不同的接口，而代理模式、装饰器模式提供的都是跟原始类相同的接口。\n\n\n\n\n\n","slug":"2024-07-01-设计模式-04.01-结构型-代理&桥接&装饰器&适配器","published":1,"updated":"2024-07-01T02:01:10.002Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cly2c4k41001uqsvd120ugq8t","content":"<h1 id=\"声明\"><a href=\"#声明\" class=\"headerlink\" title=\"声明\"></a>声明</h1><blockquote>\n<ol>\n<li>此系列文章非本人原创，是学习笔记。</li>\n<li>设计模式系列以后会持续更新，包括已经发布的设计模式文章，因为后续还要再多看一下书，教程和开源项目等，继续润色文章。</li>\n</ol>\n</blockquote>\n<h1 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h1><p>创建型模式比较好理解，后面的结构型和行为型设计模式不是那么好理解。如果遇到不好理解的设计模式，我一般会在开头举比较简单的Demo案例来帮助理解。</p>\n<h1 id=\"代理模式【常用】\"><a href=\"#代理模式【常用】\" class=\"headerlink\" title=\"代理模式【常用】\"></a>代理模式【常用】</h1><ol>\n<li>前面几节，我们讲了设计模式中的创建型模式。创建型模式主要解决对象的创建问题，封装复杂的创建过程，解耦对象的创建代码和使用代码。</li>\n<li>其中，单例模式用来创建全局唯一的对象。工厂模式用来创建不同但是相关类型的对象（继承同一父类或者接口的一组子类），由给定的参数来决定创建哪种类型的对象。建造者模式是用来创建复杂对象，可以通过设置不同的可选参数，“定制化”地创建不同的对象。原型模式针对创建成本比较大的对象，利用对已有对象进行复制的方式进行创建，以达到节省创建时间的目的。</li>\n<li>现在，我们讲另外一种类型的设计模式：结构型模式。结构型模式主要总结了一些类或对象组合在一起的经典结构，这些经典的结构可以解决特定应用场景的问题。结构型模式包括：代理模式、桥接模式、装饰器模式、适配器模式、门面模式、组合模式、享元模式。今天我们要讲其中的代理模式。它也是在实际开发中经常被用到的一种设计模式。</li>\n<li>代理模式有不同的形式, 主要有三种 <strong>静态代理</strong>、<strong>动态代理</strong> (JDK 代理、接口代理)和 <strong>Cglib</strong> <strong>代理</strong> (可以在内存 动态的创建对象，而不需要实现接口， 他是属于动态代理的范畴) 。下面先通过几个比较简单的例子理解一下代理模式</li>\n</ol>\n<h2 id=\"静态代理\"><a href=\"#静态代理\" class=\"headerlink\" title=\"静态代理\"></a>静态代理</h2><p>实例具体要求 </p>\n<ol>\n<li>定义一个接口:ITeacherDao </li>\n<li>目标对象 TeacherDAO 实现接口 ITeacherDAO </li>\n<li>使用静态代理方式,就需要在代理对象 TeacherDAOProxy 中也实现 ITeacherDAO </li>\n<li>调用的时候通过调用代理对象的方法来调用目标对象. </li>\n<li>特别提醒：静态代理类与被代理类要实现相同的接口,然后通过调用相同的方法来调用目标对象的方法</li>\n</ol>\n<blockquote>\n<p><strong>ITeacherDao</strong></p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//接口</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">ITeacherDao</span> &#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">void</span> <span class=\"title function_\">teach</span><span class=\"params\">()</span>; <span class=\"comment\">// 授课的方法</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<blockquote>\n<p><strong>TeacherDao</strong> —&gt; 被代理类</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">TeacherDao</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">ITeacherDao</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">teach</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// TODO Auto-generated method stub</span></span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot; 老师授课中  。。。。。&quot;</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<blockquote>\n<p><strong>TeacherDaoProxy</strong> —&gt; 代理类</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//代理对象,静态代理</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">TeacherDaoProxy</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">ITeacherDao</span>&#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> ITeacherDao target; <span class=\"comment\">// 目标对象，通过接口来聚合</span></span><br><span class=\"line\">\t</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">//构造器</span></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"title function_\">TeacherDaoProxy</span><span class=\"params\">(ITeacherDao target)</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">this</span>.target = target;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">teach</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// TODO Auto-generated method stub</span></span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;开始代理  完成某些操作。。。。。 &quot;</span>);<span class=\"comment\">//方法</span></span><br><span class=\"line\">\t\ttarget.teach();</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;提交。。。。。&quot;</span>);<span class=\"comment\">//方法</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<blockquote>\n<p>Client</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Client</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// TODO Auto-generated method stub</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//创建目标对象(被代理对象)</span></span><br><span class=\"line\">\t\t<span class=\"type\">TeacherDao</span> <span class=\"variable\">teacherDao</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">TeacherDao</span>();</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"comment\">//创建代理对象, 同时将被代理对象传递给代理对象</span></span><br><span class=\"line\">\t\t<span class=\"type\">TeacherDaoProxy</span> <span class=\"variable\">teacherDaoProxy</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">TeacherDaoProxy</span>(teacherDao);</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"comment\">//通过代理对象，调用到被代理对象的方法</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//即：执行的是代理对象的方法，代理对象再去调用目标对象的方法 </span></span><br><span class=\"line\">\t\tteacherDaoProxy.teach();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h2 id=\"动态代理\"><a href=\"#动态代理\" class=\"headerlink\" title=\"动态代理\"></a>动态代理</h2><ol>\n<li>代理对象,不需要实现接口，但是目标对象要实现接口，否则不能用动态代理 </li>\n<li>代理对象的生成，是利用 JDK 的 API，动态的在内存中构建代理对象 </li>\n<li>动态代理也叫做：JDK 代理、接口代理</li>\n<li>代理类所在包:java.lang.reflect.Proxy </li>\n<li>JDK 实现代理只需要使用 <strong>newProxyInstance</strong> 方法,但是该方法需要接收三个参数,完整的写法是:</li>\n</ol>\n<p>static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces,InvocationHandler h ) </p>\n<blockquote>\n<p>ITeacherDao</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//接口</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">ITeacherDao</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">void</span> <span class=\"title function_\">teach</span><span class=\"params\">()</span>; <span class=\"comment\">// 授课方法</span></span><br><span class=\"line\">   <span class=\"keyword\">void</span> <span class=\"title function_\">sayHello</span><span class=\"params\">(String name)</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<blockquote>\n<p>TeacherDao</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">TeacherDao</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">ITeacherDao</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"meta\">@Override</span></span><br><span class=\"line\">   <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">teach</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// TODO Auto-generated method stub</span></span><br><span class=\"line\">      System.out.println(<span class=\"string\">&quot; 老师授课中.... &quot;</span>);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"meta\">@Override</span></span><br><span class=\"line\">   <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">sayHello</span><span class=\"params\">(String name)</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// TODO Auto-generated method stub</span></span><br><span class=\"line\">      System.out.println(<span class=\"string\">&quot;hello &quot;</span> + name);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<blockquote>\n<p>ProxyFactory</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.lang.reflect.InvocationHandler;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.lang.reflect.Method;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.lang.reflect.Proxy;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ProxyFactory</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">//维护一个目标对象 , Object</span></span><br><span class=\"line\">   <span class=\"keyword\">private</span> Object target;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">//构造器 ， 对target 进行初始化</span></span><br><span class=\"line\">   <span class=\"keyword\">public</span> <span class=\"title function_\">ProxyFactory</span><span class=\"params\">(Object target)</span> &#123;</span><br><span class=\"line\">      </span><br><span class=\"line\">      <span class=\"built_in\">this</span>.target = target;</span><br><span class=\"line\">   &#125; </span><br><span class=\"line\">   </span><br><span class=\"line\">   <span class=\"comment\">//给目标对象 生成一个代理对象</span></span><br><span class=\"line\">   <span class=\"keyword\">public</span> Object <span class=\"title function_\">getProxyInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">      </span><br><span class=\"line\">      <span class=\"comment\">/* 说明</span></span><br><span class=\"line\"><span class=\"comment\">         public static Object newProxyInstance(ClassLoader loader,</span></span><br><span class=\"line\"><span class=\"comment\">                                          Class&lt;?&gt;[] interfaces,</span></span><br><span class=\"line\"><span class=\"comment\">                                          InvocationHandler h)</span></span><br><span class=\"line\"><span class=\"comment\">                                          </span></span><br><span class=\"line\"><span class=\"comment\">            1. ClassLoader loader ： 指定当前目标对象使用的类加载器, 获取加载器的方法固定</span></span><br><span class=\"line\"><span class=\"comment\">            2. Class&lt;?&gt;[] interfaces: 目标对象实现的接口类型，使用泛型方法确认类型</span></span><br><span class=\"line\"><span class=\"comment\">            3. InvocationHandler h : 事情处理，执行目标对象的方法时，会触发事情处理器方法, </span></span><br><span class=\"line\"><span class=\"comment\">             会把当前执行的目标对象方法作为参数传入</span></span><br><span class=\"line\"><span class=\"comment\">       */</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> Proxy.newProxyInstance(target.getClass().getClassLoader(), </span><br><span class=\"line\">            target.getClass().getInterfaces(), </span><br><span class=\"line\">            <span class=\"keyword\">new</span> <span class=\"title class_\">InvocationHandler</span>() &#123;</span><br><span class=\"line\">               </span><br><span class=\"line\">               <span class=\"meta\">@Override</span></span><br><span class=\"line\">               <span class=\"keyword\">public</span> Object <span class=\"title function_\">invoke</span><span class=\"params\">(Object proxy, Method method, Object[] args)</span> <span class=\"keyword\">throws</span> Throwable &#123;</span><br><span class=\"line\">                  <span class=\"comment\">// TODO Auto-generated method stub</span></span><br><span class=\"line\">                  System.out.println(<span class=\"string\">&quot;JDK代理开始~~&quot;</span>);</span><br><span class=\"line\">                  <span class=\"comment\">//反射机制调用目标对象的方法</span></span><br><span class=\"line\">                  <span class=\"type\">Object</span> <span class=\"variable\">returnVal</span> <span class=\"operator\">=</span> method.invoke(target, args);</span><br><span class=\"line\">                  System.out.println(<span class=\"string\">&quot;JDK代理提交&quot;</span>);</span><br><span class=\"line\">                  <span class=\"keyword\">return</span> returnVal;</span><br><span class=\"line\">               &#125;</span><br><span class=\"line\">            &#125;); </span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<blockquote>\n<p>Client</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Client &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">   public static void main(String[] args) &#123;</span><br><span class=\"line\">      // TODO Auto-generated method stub</span><br><span class=\"line\">      //创建目标对象</span><br><span class=\"line\">      ITeacherDao target = new TeacherDao();</span><br><span class=\"line\">      </span><br><span class=\"line\">      //给目标对象，创建代理对象, 可以转成 ITeacherDao</span><br><span class=\"line\">      ITeacherDao proxyInstance = (ITeacherDao)new ProxyFactory(target).getProxyInstance();</span><br><span class=\"line\">   </span><br><span class=\"line\">      // proxyInstance=class com.sun.proxy.$Proxy0 内存中动态生成了代理对象</span><br><span class=\"line\">      System.out.println(&quot;proxyInstance=&quot; + proxyInstance.getClass());</span><br><span class=\"line\">      </span><br><span class=\"line\">      //通过代理对象，调用目标对象的方法</span><br><span class=\"line\">      //proxyInstance.teach();</span><br><span class=\"line\">      </span><br><span class=\"line\">      proxyInstance.sayHello(&quot; tom &quot;);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"cglib代理\"><a href=\"#cglib代理\" class=\"headerlink\" title=\"cglib代理\"></a>cglib代理</h2><ol>\n<li><p>静态代理和 JDK 代理模式都要求目标对象是实现一个接口,但是有时候目标对象只是一个单独的对象,并没有实现任何的接口,这个时候可使用目标对象子类来实现代理-这就是Cglib代理</p>\n</li>\n<li><p>Cglib代理也叫作<strong>子类代理</strong>**,**它是在内存中构建一个子类对象从而实现对目标对象功能扩展, 有些书也将Cglib代理归属到动态代理。 </p>\n</li>\n<li><p>Cglib 是一个强大的高性能的代码生成包,它可以在运行期扩展 java 类与实现 java 接口.它广泛的被许多 AOP 的 框架使用,例如 Spring AOP，实现方法拦截 </p>\n</li>\n<li><p>在 AOP 编程中如何选择代理模式： </p>\n<ul>\n<li><p>目标对象需要实现接口，用 JDK 代理 </p>\n</li>\n<li><p>目标对象不需要实现接口，用 Cglib 代理</p>\n</li>\n</ul>\n</li>\n<li><p>Cglib 包的底层是通过使用字节码处理框架 ASM 来转换字节码并生成新的类</p>\n</li>\n<li><p>需要引入 cglib 的 jar 文件，在内存中动态构建子类，注意代理的类不能为 final，否则报错 </p>\n<p><code>java.lang.IllegalArgumentException</code>，目标对象的方法如果为 final&#x2F;static,那么就不会被拦截,即不会执行目标对象额外的业务方法.</p>\n</li>\n</ol>\n<blockquote>\n<p>TeacherDao</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">TeacherDao</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">public</span> String <span class=\"title function_\">teach</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">      System.out.println(<span class=\"string\">&quot; 老师授课中  ， 我是cglib代理，不需要实现接口 &quot;</span>);</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"string\">&quot;hello&quot;</span>;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<blockquote>\n<p>ProxyFactory</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.lang.reflect.Method;</span><br><span class=\"line\"><span class=\"keyword\">import</span> net.sf.cglib.proxy.Enhancer;</span><br><span class=\"line\"><span class=\"keyword\">import</span> net.sf.cglib.proxy.MethodInterceptor;</span><br><span class=\"line\"><span class=\"keyword\">import</span> net.sf.cglib.proxy.MethodProxy;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ProxyFactory</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">MethodInterceptor</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">//维护一个目标对象</span></span><br><span class=\"line\">   <span class=\"keyword\">private</span> Object target;</span><br><span class=\"line\">   </span><br><span class=\"line\">   <span class=\"comment\">//构造器，传入一个被代理的对象</span></span><br><span class=\"line\">   <span class=\"keyword\">public</span> <span class=\"title function_\">ProxyFactory</span><span class=\"params\">(Object target)</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.target = target;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">//返回一个代理对象:  是 target 对象的代理对象</span></span><br><span class=\"line\">   <span class=\"keyword\">public</span> Object <span class=\"title function_\">getProxyInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">//1. 创建一个工具类</span></span><br><span class=\"line\">      <span class=\"type\">Enhancer</span> <span class=\"variable\">enhancer</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Enhancer</span>();</span><br><span class=\"line\">      <span class=\"comment\">//2. 设置父类</span></span><br><span class=\"line\">      enhancer.setSuperclass(target.getClass());</span><br><span class=\"line\">      <span class=\"comment\">//3. 设置回调函数</span></span><br><span class=\"line\">      enhancer.setCallback(<span class=\"built_in\">this</span>);</span><br><span class=\"line\">      <span class=\"comment\">//4. 创建子类对象，即代理对象</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> enhancer.create();</span><br><span class=\"line\">      </span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   </span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">//重写  intercept 方法，会调用目标对象的方法</span></span><br><span class=\"line\">   <span class=\"meta\">@Override</span></span><br><span class=\"line\">   <span class=\"keyword\">public</span> Object <span class=\"title function_\">intercept</span><span class=\"params\">(Object arg0, Method method, Object[] args, MethodProxy arg3)</span> <span class=\"keyword\">throws</span> Throwable &#123;</span><br><span class=\"line\">      <span class=\"comment\">// TODO Auto-generated method stub</span></span><br><span class=\"line\">      System.out.println(<span class=\"string\">&quot;Cglib代理模式 ~~ 开始&quot;</span>);</span><br><span class=\"line\">      <span class=\"type\">Object</span> <span class=\"variable\">returnVal</span> <span class=\"operator\">=</span> method.invoke(target, args);</span><br><span class=\"line\">      System.out.println(<span class=\"string\">&quot;Cglib代理模式 ~~ 提交&quot;</span>);</span><br><span class=\"line\">      <span class=\"keyword\">return</span> returnVal;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<blockquote>\n<p>Client</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Client</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// TODO Auto-generated method stub</span></span><br><span class=\"line\">      <span class=\"comment\">//创建目标对象</span></span><br><span class=\"line\">      <span class=\"type\">TeacherDao</span> <span class=\"variable\">target</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">TeacherDao</span>();</span><br><span class=\"line\">      <span class=\"comment\">//获取到代理对象，并且将目标对象传递给代理对象</span></span><br><span class=\"line\">      <span class=\"type\">TeacherDao</span> <span class=\"variable\">proxyInstance</span> <span class=\"operator\">=</span> (TeacherDao)<span class=\"keyword\">new</span> <span class=\"title class_\">ProxyFactory</span>(target).getProxyInstance();</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">//执行代理对象的方法，触发intecept 方法，从而实现 对目标对象的调用</span></span><br><span class=\"line\">      <span class=\"type\">String</span> <span class=\"variable\">res</span> <span class=\"operator\">=</span> proxyInstance.teach();</span><br><span class=\"line\">      System.out.println(<span class=\"string\">&quot;res=&quot;</span> + res);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"代理模式的原理解析\"><a href=\"#代理模式的原理解析\" class=\"headerlink\" title=\"代理模式的原理解析\"></a>代理模式的原理解析</h2><ol>\n<li>代理模式（Proxy Design Pattern）的原理和代码实现都不难掌握。它在不改变原始类（或叫被代理类）代码的情况下，通过引入代理类来给原始类附加功能【<strong>装饰器是增强功能，代理是附加新的功能</strong>】。我们通过一个简单的例子来解释一下这段话。</li>\n<li>我们开发了一个 MetricsCollector 类，用来收集接口请求的原始数据，比如访问时间、处理时长等。在业务系统中，我们采用如下方式来使用这个 MetricsCollector 类：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">UserController</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">//...省略其他属性和方法...</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> MetricsCollector metricsCollector; <span class=\"comment\">// 依赖注入</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> UserVo <span class=\"title function_\">login</span><span class=\"params\">(String telephone, String password)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"variable\">startTimestamp</span> <span class=\"operator\">=</span> System.currentTimeMillis();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// ... 省略login逻辑...</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"variable\">endTimeStamp</span> <span class=\"operator\">=</span> System.currentTimeMillis();</span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"variable\">responseTime</span> <span class=\"operator\">=</span> endTimeStamp - startTimestamp;</span><br><span class=\"line\">    <span class=\"type\">RequestInfo</span> <span class=\"variable\">requestInfo</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RequestInfo</span>(<span class=\"string\">&quot;login&quot;</span>, responseTime, startTimestamp);</span><br><span class=\"line\">    metricsCollector.recordRequest(requestInfo);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//...返回UserVo数据...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> UserVo <span class=\"title function_\">register</span><span class=\"params\">(String telephone, String password)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"variable\">startTimestamp</span> <span class=\"operator\">=</span> System.currentTimeMillis();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// ... 省略register逻辑...</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"variable\">endTimeStamp</span> <span class=\"operator\">=</span> System.currentTimeMillis();</span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"variable\">responseTime</span> <span class=\"operator\">=</span> endTimeStamp - startTimestamp;</span><br><span class=\"line\">    <span class=\"type\">RequestInfo</span> <span class=\"variable\">requestInfo</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RequestInfo</span>(<span class=\"string\">&quot;register&quot;</span>, responseTime, startTimestamp);</span><br><span class=\"line\">    metricsCollector.recordRequest(requestInfo);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//...返回UserVo数据...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>很明显，上面的写法有两个问题。第一，性能计数器框架代码侵入到业务代码中，跟业务代码高度耦合。如果未来需要替换这个框架，那替换的成本会比较大。第二，收集接口请求的代码跟业务代码无关，本就不应该放到一个类中。业务类最好职责更加单一，只聚焦业务处理。</li>\n<li>为了将框架代码和业务代码解耦，代理模式就派上用场了。代理类 UserControllerProxy 和原始类 UserController 实现相同的接口 IUserController。UserController 类只负责业务功能。代理类 UserControllerProxy 负责在业务代码执行前后附加其他逻辑代码，并通过委托的方式调用原始类来执行业务代码。具体的代码实现如下所示：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">IUserController</span> &#123;</span><br><span class=\"line\">  UserVo <span class=\"title function_\">login</span><span class=\"params\">(String telephone, String password)</span>;</span><br><span class=\"line\">  UserVo <span class=\"title function_\">register</span><span class=\"params\">(String telephone, String password)</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">UserController</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">IUserController</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">//...省略其他属性和方法...</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> UserVo <span class=\"title function_\">login</span><span class=\"params\">(String telephone, String password)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//...省略login逻辑...</span></span><br><span class=\"line\">    <span class=\"comment\">//...返回UserVo数据...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> UserVo <span class=\"title function_\">register</span><span class=\"params\">(String telephone, String password)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//...省略register逻辑...</span></span><br><span class=\"line\">    <span class=\"comment\">//...返回UserVo数据...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">UserControllerProxy</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">IUserController</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> MetricsCollector metricsCollector;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> UserController userController;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"title function_\">UserControllerProxy</span><span class=\"params\">(UserController userController)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.userController = userController;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.metricsCollector = <span class=\"keyword\">new</span> <span class=\"title class_\">MetricsCollector</span>();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> UserVo <span class=\"title function_\">login</span><span class=\"params\">(String telephone, String password)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"variable\">startTimestamp</span> <span class=\"operator\">=</span> System.currentTimeMillis();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 委托</span></span><br><span class=\"line\">    <span class=\"type\">UserVo</span> <span class=\"variable\">userVo</span> <span class=\"operator\">=</span> userController.login(telephone, password);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"variable\">endTimeStamp</span> <span class=\"operator\">=</span> System.currentTimeMillis();</span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"variable\">responseTime</span> <span class=\"operator\">=</span> endTimeStamp - startTimestamp;</span><br><span class=\"line\">    <span class=\"type\">RequestInfo</span> <span class=\"variable\">requestInfo</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RequestInfo</span>(<span class=\"string\">&quot;login&quot;</span>, responseTime, startTimestamp);</span><br><span class=\"line\">    metricsCollector.recordRequest(requestInfo);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> userVo;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> UserVo <span class=\"title function_\">register</span><span class=\"params\">(String telephone, String password)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"variable\">startTimestamp</span> <span class=\"operator\">=</span> System.currentTimeMillis();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">UserVo</span> <span class=\"variable\">userVo</span> <span class=\"operator\">=</span> userController.register(telephone, password);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"variable\">endTimeStamp</span> <span class=\"operator\">=</span> System.currentTimeMillis();</span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"variable\">responseTime</span> <span class=\"operator\">=</span> endTimeStamp - startTimestamp;</span><br><span class=\"line\">    <span class=\"type\">RequestInfo</span> <span class=\"variable\">requestInfo</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RequestInfo</span>(<span class=\"string\">&quot;register&quot;</span>, responseTime, startTimestamp);</span><br><span class=\"line\">    metricsCollector.recordRequest(requestInfo);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> userVo;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//UserControllerProxy使用举例</span></span><br><span class=\"line\"><span class=\"comment\">//因为原始类和代理类实现相同的接口，是基于接口而非实现编程</span></span><br><span class=\"line\"><span class=\"comment\">//将UserController类对象替换为UserControllerProxy类对象，不需要改动太多代码</span></span><br><span class=\"line\"><span class=\"type\">IUserController</span> <span class=\"variable\">userController</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">UserControllerProxy</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">UserController</span>());</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>参照基于接口而非实现编程的设计思想，将原始类对象替换为代理类对象的时候，为了让代码改动尽量少，在刚刚的代理模式的代码实现中，代理类和原始类需要实现相同的接口。但是，如果原始类并没有定义接口，并且原始类代码并不是我们开发维护的（比如它来自一个第三方的类库），我们也没办法直接修改原始类，给它重新定义一个接口。在这种情况下，我们该如何实现代理模式呢？</li>\n<li>对于这种外部类的扩展，我们一般都是采用继承的方式。这里也不例外。我们让代理类继承原始类，然后扩展附加功能。原理很简单，不需要过多解释，你直接看代码就能明白。具体代码如下所示：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">UserControllerProxy</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">UserController</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> MetricsCollector metricsCollector;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"title function_\">UserControllerProxy</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.metricsCollector = <span class=\"keyword\">new</span> <span class=\"title class_\">MetricsCollector</span>();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> UserVo <span class=\"title function_\">login</span><span class=\"params\">(String telephone, String password)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"variable\">startTimestamp</span> <span class=\"operator\">=</span> System.currentTimeMillis();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">UserVo</span> <span class=\"variable\">userVo</span> <span class=\"operator\">=</span> <span class=\"built_in\">super</span>.login(telephone, password);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"variable\">endTimeStamp</span> <span class=\"operator\">=</span> System.currentTimeMillis();</span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"variable\">responseTime</span> <span class=\"operator\">=</span> endTimeStamp - startTimestamp;</span><br><span class=\"line\">    <span class=\"type\">RequestInfo</span> <span class=\"variable\">requestInfo</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RequestInfo</span>(<span class=\"string\">&quot;login&quot;</span>, responseTime, startTimestamp);</span><br><span class=\"line\">    metricsCollector.recordRequest(requestInfo);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> userVo;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> UserVo <span class=\"title function_\">register</span><span class=\"params\">(String telephone, String password)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"variable\">startTimestamp</span> <span class=\"operator\">=</span> System.currentTimeMillis();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">UserVo</span> <span class=\"variable\">userVo</span> <span class=\"operator\">=</span> <span class=\"built_in\">super</span>.register(telephone, password);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"variable\">endTimeStamp</span> <span class=\"operator\">=</span> System.currentTimeMillis();</span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"variable\">responseTime</span> <span class=\"operator\">=</span> endTimeStamp - startTimestamp;</span><br><span class=\"line\">    <span class=\"type\">RequestInfo</span> <span class=\"variable\">requestInfo</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RequestInfo</span>(<span class=\"string\">&quot;register&quot;</span>, responseTime, startTimestamp);</span><br><span class=\"line\">    metricsCollector.recordRequest(requestInfo);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> userVo;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//UserControllerProxy使用举例</span></span><br><span class=\"line\"><span class=\"type\">UserController</span> <span class=\"variable\">userController</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">UserControllerProxy</span>();</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"动态代理的原理解析\"><a href=\"#动态代理的原理解析\" class=\"headerlink\" title=\"动态代理的原理解析\"></a>动态代理的原理解析</h2><ol>\n<li>不过，刚刚的代码实现还是有点问题。一方面，我们需要在代理类中，将原始类中的所有的方法，都重新实现一遍，并且为每个方法都附加相似的代码逻辑。另一方面，如果要添加的附加功能的类有不止一个，我们需要针对每个类都创建一个代理类。</li>\n<li>如果有 50 个要添加附加功能的原始类，那我们就要创建 50  个对应的代理类。这会导致项目中类的个数成倍增加，增加了代码维护成本。并且，每个代理类中的代码都有点像模板式的“重复”代码，也增加了不必要的开发成本。那这个问题怎么解决呢？</li>\n<li>我们可以使用动态代理来解决这个问题。所谓动态代理（Dynamic  Proxy），就是我们不事先为每个原始类编写代理类，而是在运行的时候，动态地创建原始类对应的代理类，然后在系统中用代理类替换掉原始类。那如何实现动态代理呢？</li>\n<li>如果你熟悉的是 Java 语言，实现动态代理就是件很简单的事情。因为 Java 语言本身就已经提供了动态代理的语法（实际上，动态代理底层依赖的就是 Java  的反射语法）。我们来看一下，如何用 Java 的动态代理来实现刚刚的功能。具体的代码如下所示。其中，MetricsCollectorProxy  作为一个动态代理类，动态地给每个需要收集接口请求信息的类创建代理类。</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">MetricsCollectorProxy</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> MetricsCollector metricsCollector;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"title function_\">MetricsCollectorProxy</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.metricsCollector = <span class=\"keyword\">new</span> <span class=\"title class_\">MetricsCollector</span>();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> Object <span class=\"title function_\">createProxy</span><span class=\"params\">(Object proxiedObject)</span> &#123;</span><br><span class=\"line\">    Class&lt;?&gt;[] interfaces = proxiedObject.getClass().getInterfaces();</span><br><span class=\"line\">    <span class=\"type\">DynamicProxyHandler</span> <span class=\"variable\">handler</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">DynamicProxyHandler</span>(proxiedObject);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Proxy.newProxyInstance(proxiedObject.getClass().getClassLoader(), interfaces, handler);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">class</span> <span class=\"title class_\">DynamicProxyHandler</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">InvocationHandler</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Object proxiedObject;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">DynamicProxyHandler</span><span class=\"params\">(Object proxiedObject)</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.proxiedObject = proxiedObject;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Object <span class=\"title function_\">invoke</span><span class=\"params\">(Object proxy, Method method, Object[] args)</span> <span class=\"keyword\">throws</span> Throwable &#123;</span><br><span class=\"line\">      <span class=\"type\">long</span> <span class=\"variable\">startTimestamp</span> <span class=\"operator\">=</span> System.currentTimeMillis();</span><br><span class=\"line\">      <span class=\"type\">Object</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> method.invoke(proxiedObject, args);</span><br><span class=\"line\">      <span class=\"type\">long</span> <span class=\"variable\">endTimeStamp</span> <span class=\"operator\">=</span> System.currentTimeMillis();</span><br><span class=\"line\">      <span class=\"type\">long</span> <span class=\"variable\">responseTime</span> <span class=\"operator\">=</span> endTimeStamp - startTimestamp;</span><br><span class=\"line\">      <span class=\"type\">String</span> <span class=\"variable\">apiName</span> <span class=\"operator\">=</span> proxiedObject.getClass().getName() + <span class=\"string\">&quot;:&quot;</span> + method.getName();</span><br><span class=\"line\">      <span class=\"type\">RequestInfo</span> <span class=\"variable\">requestInfo</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RequestInfo</span>(apiName, responseTime, startTimestamp);</span><br><span class=\"line\">      metricsCollector.recordRequest(requestInfo);</span><br><span class=\"line\">      <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//MetricsCollectorProxy使用举例</span></span><br><span class=\"line\"><span class=\"type\">MetricsCollectorProxy</span> <span class=\"variable\">proxy</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">MetricsCollectorProxy</span>();</span><br><span class=\"line\"><span class=\"type\">IUserController</span> <span class=\"variable\">userController</span> <span class=\"operator\">=</span> (IUserController) proxy.createProxy(<span class=\"keyword\">new</span> <span class=\"title class_\">UserController</span>());</span><br></pre></td></tr></table></figure>\n\n\n\n<p>实际上，Spring AOP  底层的实现原理就是基于动态代理。用户\b配置好需要给哪些类创建代理，并定义好在执行原始类的业务代码前后执行哪些附加功能。Spring  为这些类创建动态代理对象，并在 JVM  中替代原始类对象。原本在代码中执行的原始类的方法，被换作执行代理类的方法，也就实现了给原始类添加附加功能的目的。</p>\n<h2 id=\"代理模式的应用场景\"><a href=\"#代理模式的应用场景\" class=\"headerlink\" title=\"代理模式的应用场景\"></a>代理模式的应用场景</h2><h3 id=\"业务系统的非功能性需求开发\"><a href=\"#业务系统的非功能性需求开发\" class=\"headerlink\" title=\"业务系统的非功能性需求开发\"></a>业务系统的非功能性需求开发</h3><p>代理模式最常用的一个应用场景就是，在业务系统中开发一些非功能性需求，比如：监控、统计、鉴权、限流、事务、幂等、日志。我们将这些附加功能与业务功能解耦，放到代理类中统一处理，让程序员只需要关注业务方面的开发。实际上，前面举的搜集接口请求信息的例子，就是这个应用场景的一个典型例子。</p>\n<p>如果你熟悉 Java 语言和 Spring 开发框架，这部分工作都是可以在 Spring AOP 切面中完成的。前面我们也提到，Spring AOP  底层的实现原理就是基于动态代理。</p>\n<h3 id=\"代理模式在-RPC、缓存中的应用\"><a href=\"#代理模式在-RPC、缓存中的应用\" class=\"headerlink\" title=\"代理模式在 RPC、缓存中的应用\"></a>代理模式在 RPC、缓存中的应用</h3><p>实际上，RPC  框架也可以看作一种代理模式，GoF 的《设计模式》一书中把它称作远程代理。通过远程代理，将网络通信、数据编解码等细节隐藏起来。客户端在使用  RPC 服务的时候，就像使用本地函数一样，无需了解跟服务器交互的细节。除此之外，RPC  服务的开发者也只需要开发业务逻辑，就像开发本地使用的函数一样，不需要关注跟客户端的交互细节。</p>\n<h3 id=\"代理模式在缓存中的应用\"><a href=\"#代理模式在缓存中的应用\" class=\"headerlink\" title=\"代理模式在缓存中的应用\"></a>代理模式在缓存中的应用</h3><ol>\n<li>假设我们要开发一个接口请求的缓存功能，对于某些接口请求，如果入参相同，在设定的过期时间内，直接返回缓存结果，而不用重新进行逻辑处理。比如，针对获取用户个人信息的需求，我们可以开发两个接口，一个支持缓存，一个支持实时查询。对于需要实时数据的需求，我们让其调用实时查询接口，对于不需要实时数据的需求，我们让其调用支持缓存的接口。那如何来实现接口请求的缓存功能呢？</li>\n<li>最简单的实现方法就是刚刚我们讲到的，给每个需要支持缓存的查询需求都开发两个不同的接口，一个支持缓存，一个支持实时查询。但是，这样做显然增加了开发成本，而且会让代码看起来非常臃肿（接口个数成倍增加），也不方便缓存接口的集中管理（增加、删除缓存接口）、集中配置（比如配置每个接口缓存过期时间）。</li>\n<li>针对这些问题，代理模式就能派上用场了，确切地说，应该是动态代理。如果是基于 Spring 框架来开发的话，那就可以在 AOP  切面中完成接口缓存的功能。在应用启动的时候，我们从配置文件中加载需要支持缓存的接口，以及相应的缓存策略（比如过期时间）等。当请求到来的时候，我们在 AOP 切面中拦截请求，如果请求中带有支持缓存的字段（比如  http:&#x2F;&#x2F;…?..&amp;cached&#x3D;true），我们便从缓存（内存缓存或者 Redis 缓存等）中获取数据直接返回。</li>\n</ol>\n<h1 id=\"桥接模式【常用】\"><a href=\"#桥接模式【常用】\" class=\"headerlink\" title=\"桥接模式【常用】\"></a>桥接模式【常用】</h1><ol>\n<li>上一节我们学习了第一种结构型模式：代理模式。它在不改变原始类（或者叫被代理类）代码的情况下，通过引入代理类来给原始类附加功能。代理模式在平时的开发经常被用到，常用在业务系统中开发一些非功能性需求，比如：监控、统计、鉴权、限流、事务、幂等、日志。</li>\n<li>今天，我们再学习另外一种结构型模式：桥接模式。桥接模式的代码实现非常简单，但是理解起来稍微有点难度，并且应用场景也比较局限，所以，相当于代理模式来说，桥接模式在实际的项目中并没有那么常用，你只需要简单了解，见到能认识就可以，并不是我们学习的重点。</li>\n<li>我们依旧是先看比较简单的例子</li>\n</ol>\n<h2 id=\"Demo案例-手机操作问题\"><a href=\"#Demo案例-手机操作问题\" class=\"headerlink\" title=\"Demo案例-手机操作问题\"></a>Demo案例-手机操作问题</h2><h3 id=\"需求\"><a href=\"#需求\" class=\"headerlink\" title=\"需求\"></a>需求</h3><p>现在对不同手机类型的不同品牌实现操作编程(比如:开机、关机、上网，打电话等)，如图:</p>\n<img src=\"https://npm.elemecdn.com/youthlql@1.0.0/design_patterns/structural_type/04.01/0001.png\"/>\n\n\n\n<h3 id=\"传统方案解决手机操作问题分析\"><a href=\"#传统方案解决手机操作问题分析\" class=\"headerlink\" title=\"传统方案解决手机操作问题分析\"></a>传统方案解决手机操作问题分析</h3><p>传统方法对应的类图</p>\n<img src=\"https://npm.elemecdn.com/youthlql@1.0.0/design_patterns/structural_type/04.01/0007.png\"/>\n\n<ol>\n<li>扩展性问题(<strong>类爆炸</strong>)，如果我们再增加手机的样式(旋转式)，就需要增加各个品牌手机的类，同样如果我们增加一个手机品牌，也要在各个手机样式类下增加。 </li>\n<li>违反了单一职责原则，当我们增加手机样式时，要同时增加所有品牌的手机，这样增加了代码维护成本.</li>\n<li>解决方案-使用<strong>桥接模</strong>式 </li>\n<li>Bridge 模式基于类的最小设计原则，通过使用封装、聚合及继承等行为让不同的类承担不同的职责。它的主要特点是把抽象(Abstraction)与行为实现(Implementation)分离开来，从而可以保持各部分的独立性以及应对他们的功能扩展</li>\n</ol>\n<h3 id=\"使用桥接模式的代码\"><a href=\"#使用桥接模式的代码\" class=\"headerlink\" title=\"使用桥接模式的代码\"></a>使用桥接模式的代码</h3><h4 id=\"Brand【接口】\"><a href=\"#Brand【接口】\" class=\"headerlink\" title=\"Brand【接口】\"></a>Brand【接口】</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//接口</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">Brand</span> &#123;</span><br><span class=\"line\">   <span class=\"keyword\">void</span> <span class=\"title function_\">open</span><span class=\"params\">()</span>;</span><br><span class=\"line\">   <span class=\"keyword\">void</span> <span class=\"title function_\">close</span><span class=\"params\">()</span>;</span><br><span class=\"line\">   <span class=\"keyword\">void</span> <span class=\"title function_\">call</span><span class=\"params\">()</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Phone【抽象类】\"><a href=\"#Phone【抽象类】\" class=\"headerlink\" title=\"Phone【抽象类】\"></a>Phone【抽象类】</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Phone</span> &#123;</span><br><span class=\"line\">   </span><br><span class=\"line\">   <span class=\"comment\">//组合品牌</span></span><br><span class=\"line\">   <span class=\"keyword\">private</span> Brand brand;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">//构造器</span></span><br><span class=\"line\">   <span class=\"keyword\">public</span> <span class=\"title function_\">Phone</span><span class=\"params\">(Brand brand)</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">super</span>();</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.brand = brand;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   </span><br><span class=\"line\">   <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">open</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.brand.open();</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">close</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">      brand.close();</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">call</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">      brand.call();</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Vivo\"><a href=\"#Vivo\" class=\"headerlink\" title=\"Vivo\"></a>Vivo</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Vivo</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Brand</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"meta\">@Override</span></span><br><span class=\"line\">   <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">open</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// TODO Auto-generated method stub</span></span><br><span class=\"line\">      System.out.println(<span class=\"string\">&quot; Vivo手机开机 &quot;</span>);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"meta\">@Override</span></span><br><span class=\"line\">   <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">close</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// TODO Auto-generated method stub</span></span><br><span class=\"line\">      System.out.println(<span class=\"string\">&quot; Vivo手机关机 &quot;</span>);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"meta\">@Override</span></span><br><span class=\"line\">   <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">call</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// TODO Auto-generated method stub</span></span><br><span class=\"line\">      System.out.println(<span class=\"string\">&quot; Vivo手机打电话 &quot;</span>);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"XiaoMi\"><a href=\"#XiaoMi\" class=\"headerlink\" title=\"XiaoMi\"></a>XiaoMi</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">XiaoMi</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Brand</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"meta\">@Override</span></span><br><span class=\"line\">   <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">open</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// TODO Auto-generated method stub</span></span><br><span class=\"line\">      System.out.println(<span class=\"string\">&quot; 小米手机开机 &quot;</span>);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"meta\">@Override</span></span><br><span class=\"line\">   <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">close</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// TODO Auto-generated method stub</span></span><br><span class=\"line\">      System.out.println(<span class=\"string\">&quot; 小米手机关机 &quot;</span>);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"meta\">@Override</span></span><br><span class=\"line\">   <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">call</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// TODO Auto-generated method stub</span></span><br><span class=\"line\">      System.out.println(<span class=\"string\">&quot; 小米手机打电话 &quot;</span>);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"FoldedPhone\"><a href=\"#FoldedPhone\" class=\"headerlink\" title=\"FoldedPhone\"></a>FoldedPhone</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//折叠式手机类，继承 抽象类 Phone</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">FoldedPhone</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Phone</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">//构造器</span></span><br><span class=\"line\">   <span class=\"keyword\">public</span> <span class=\"title function_\">FoldedPhone</span><span class=\"params\">(Brand brand)</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">super</span>(brand);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   </span><br><span class=\"line\">   <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">open</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">super</span>.open();</span><br><span class=\"line\">      System.out.println(<span class=\"string\">&quot; 折叠样式手机 &quot;</span>);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   </span><br><span class=\"line\">   <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">close</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">super</span>.close();</span><br><span class=\"line\">      System.out.println(<span class=\"string\">&quot; 折叠样式手机 &quot;</span>);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   </span><br><span class=\"line\">   <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">call</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">super</span>.call();</span><br><span class=\"line\">      System.out.println(<span class=\"string\">&quot; 折叠样式手机 &quot;</span>);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"UpRightPhone\"><a href=\"#UpRightPhone\" class=\"headerlink\" title=\"UpRightPhone\"></a>UpRightPhone</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">UpRightPhone</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Phone</span> &#123;</span><br><span class=\"line\">   </span><br><span class=\"line\">      <span class=\"comment\">//构造器</span></span><br><span class=\"line\">      <span class=\"keyword\">public</span> <span class=\"title function_\">UpRightPhone</span><span class=\"params\">(Brand brand)</span> &#123;</span><br><span class=\"line\">         <span class=\"built_in\">super</span>(brand);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      </span><br><span class=\"line\">      <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">open</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">         <span class=\"built_in\">super</span>.open();</span><br><span class=\"line\">         System.out.println(<span class=\"string\">&quot; 直立样式手机 &quot;</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      </span><br><span class=\"line\">      <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">close</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">         <span class=\"built_in\">super</span>.close();</span><br><span class=\"line\">         System.out.println(<span class=\"string\">&quot; 直立样式手机 &quot;</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      </span><br><span class=\"line\">      <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">call</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">         <span class=\"built_in\">super</span>.call();</span><br><span class=\"line\">         System.out.println(<span class=\"string\">&quot; 直立样式手机 &quot;</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"Client\"><a href=\"#Client\" class=\"headerlink\" title=\"Client\"></a>Client</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Client &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">   public static void main(String[] args) &#123;</span><br><span class=\"line\">      </span><br><span class=\"line\">      //获取折叠式手机 (样式 + 品牌 )</span><br><span class=\"line\">      </span><br><span class=\"line\">      Phone phone1 = new FoldedPhone(new XiaoMi());</span><br><span class=\"line\">      </span><br><span class=\"line\">      phone1.open();</span><br><span class=\"line\">      phone1.call();</span><br><span class=\"line\">      phone1.close();</span><br><span class=\"line\">      </span><br><span class=\"line\">      System.out.println(&quot;=======================&quot;);</span><br><span class=\"line\">      </span><br><span class=\"line\">      Phone phone2 = new FoldedPhone(new Vivo());</span><br><span class=\"line\">      </span><br><span class=\"line\">      phone2.open();</span><br><span class=\"line\">      phone2.call();</span><br><span class=\"line\">      phone2.close();</span><br><span class=\"line\">      </span><br><span class=\"line\">      System.out.println(&quot;==============&quot;);</span><br><span class=\"line\">      </span><br><span class=\"line\">      UpRightPhone phone3 = new UpRightPhone(new XiaoMi());</span><br><span class=\"line\">      </span><br><span class=\"line\">      phone3.open();</span><br><span class=\"line\">      phone3.call();</span><br><span class=\"line\">      phone3.close();</span><br><span class=\"line\">      </span><br><span class=\"line\">      System.out.println(&quot;==============&quot;);</span><br><span class=\"line\">      </span><br><span class=\"line\">      UpRightPhone phone4 = new UpRightPhone(new Vivo());</span><br><span class=\"line\">      </span><br><span class=\"line\">      phone4.open();</span><br><span class=\"line\">      phone4.call();</span><br><span class=\"line\">      phone4.close();</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<blockquote>\n<p>这种简单的demo例子可能比较好理解桥接模式，下面来看看原理和实际应用</p>\n</blockquote>\n<h2 id=\"桥接模式的原理解析\"><a href=\"#桥接模式的原理解析\" class=\"headerlink\" title=\"桥接模式的原理解析\"></a>桥接模式的原理解析</h2><ol>\n<li>桥接模式，也叫作桥梁模式，英文是Bridge Design Pattern。这个模式可以说是 23 种设计模式中最难理解的模式之一了。我查阅了比较多的书籍和资料之后发现，对于这个模式有两种不同的理解方式。</li>\n<li>当然，这其中“最纯正”的理解方式，当属 GoF 的《设计模式》一书中对桥接模式的定义。毕竟，这 23 种经典的设计模式，最初就是由这本书总结出来的。在 GoF 的《设计模式》一书中，桥接模式是这么定义的：“Decouple an abstraction from its implementation so that the two can vary independently。”翻译成中文就是：“将抽象和实现解耦，让它们可以独立变化。”</li>\n<li>关于桥接模式，很多书籍、资料中，还有另外一种理解方式：“一个类存在两个（或多个）独立变化的维度，我们通过组合的方式，让这两个（或多个）维度可以独立进行扩展。”通过组合关系来替代继承关系，避免继承层次的指数级爆炸。这种理解方式非常类似于，我们之前讲过的“组合优于继承”设计原则，所以，这里我就不多解释了。我们重点看下 GoF 的理解方式。</li>\n<li>GoF 给出的定义非常的简短，单凭这一句话，估计没几个人能看懂是什么意思。所以，我们通过 JDBC 驱动的例子来解释一下。JDBC 驱动是桥接模式的经典应用。我们先来看一下，如何利用 JDBC 驱动来查询数据库。具体的代码如下所示：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Class.forName(<span class=\"string\">&quot;com.mysql.jdbc.Driver&quot;</span>); <span class=\"comment\">// 加载及注册JDBC驱动程序</span></span><br><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">url</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;jdbc:mysql://localhost:3306/sample_db?user=root&amp;password=your_password&quot;</span>;</span><br><span class=\"line\"><span class=\"type\">Connection</span> <span class=\"variable\">con</span> <span class=\"operator\">=</span> DriverManager.getConnection(url);</span><br><span class=\"line\"><span class=\"type\">Statement</span> <span class=\"variable\">stmt</span> <span class=\"operator\">=</span> con.createStatement();</span><br><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">query</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;select * from test&quot;</span>;</span><br><span class=\"line\"><span class=\"type\">ResultSet</span> <span class=\"variable\">rs</span> <span class=\"operator\">=</span> stmt.executeQuery(query);</span><br><span class=\"line\"><span class=\"keyword\">while</span> (rs.next()) &#123;</span><br><span class=\"line\">  rs.getString(<span class=\"number\">1</span>);</span><br><span class=\"line\">  rs.getInt(<span class=\"number\">2</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<ol>\n<li>如果我们想要把 MySQL 数据库换成 Oracle 数据库，只需要把第一行代码中的 com.mysql.jdbc.Driver 换成 oracle.jdbc.driver.OracleDriver 就可以了。当然，也有更灵活的实现方式，我们可以把需要加载的 Driver 类写到配置文件中，当程序启动的时候，自动从配置文件中加载，这样在切换数据库的时候，我们都不需要修改代码，只需要修改配置文件就可以了。</li>\n<li>不管是改代码还是改配置，在项目中，从一个数据库切换到另一种数据库，都只需要改动很少的代码，或者完全不需要改动代码，那如此优雅的数据库切换是如何实现的呢？</li>\n<li>源码之下无秘密。要弄清楚这个问题，我们先从 com.mysql.jdbc.Driver 这个类的代码看起。我摘抄了部分相关代码，放到了这里，你可以看一下。</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.mysql.jdbc;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.sql.SQLException;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Driver</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">NonRegisteringDriver</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">java</span>.sql.Driver &#123;</span><br><span class=\"line\">  <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      java.sql.DriverManager.registerDriver(<span class=\"keyword\">new</span> <span class=\"title class_\">Driver</span>());</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (SQLException E) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RuntimeException</span>(<span class=\"string\">&quot;Can&#x27;t register driver!&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * Construct a new driver and register it with DriverManager</span></span><br><span class=\"line\"><span class=\"comment\">   * <span class=\"doctag\">@throws</span> SQLException if a database error occurs.</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"title function_\">Driver</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> SQLException &#123;</span><br><span class=\"line\">  <span class=\"comment\">// Required for Class.forName().newInstance()</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<p>结合 com.mysql.jdbc.Driver 的代码实现，我们可以发现，当执行 Class.forName(“com.mysql.jdbc.Driver”) 这条语句的时候，实际上是做了两件事情。第一件事情是要求 JVM 查找并加载指定的 Driver 类，第二件事情是执行该类的静态代码，也就是将 MySQL Driver 注册到 DriverManager 类中。</p>\n<p>现在，我们再来看一下，DriverManager 类是干什么用的。具体的代码如下所示。当我们把具体的 Driver 实现类（比如，com.mysql.jdbc.Driver）注册到 DriverManager 之后，后续所有对 JDBC 接口的调用，都会委派到对具体的 Driver 实现类来执行。而 Driver 实现类都实现了相同的接口（java.sql.Driver ），这也是可以灵活切换 Driver 的原因。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">DriverManager</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span>  CopyOnWriteArrayList&lt;DriverInfo&gt; registeredDrivers =  = <span class=\"keyword\">new</span> <span class=\"title class_\">CopyOnWriteArrayList</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">    loadInitialDrivers();</span><br><span class=\"line\">    println(<span class=\"string\">&quot;JDBC DriverManager initialized&quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title function_\">registerDriver</span><span class=\"params\">(java.sql.Driver driver)</span> <span class=\"keyword\">throws</span> SQLException &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (driver != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      registeredDrivers.addIfAbsent(<span class=\"keyword\">new</span> <span class=\"title class_\">DriverInfo</span>(driver));</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">NullPointerException</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Connection <span class=\"title function_\">getConnection</span><span class=\"params\">(String url, String user, String password)</span></span><br><span class=\"line\">      <span class=\"keyword\">throws</span> SQLException &#123;</span><br><span class=\"line\">    java.util.<span class=\"type\">Properties</span> <span class=\"variable\">info</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">java</span>.util.Properties();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (user != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      info.put(<span class=\"string\">&quot;user&quot;</span>, user);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (password != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      info.put(<span class=\"string\">&quot;password&quot;</span>, password);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> (getConnection(url, info, Reflection.getCallerClass()));</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<p>桥接模式的定义是“将抽象和实现解耦，让它们可以独立变化”。那弄懂定义中“抽象”和“实现”两个概念，就是理解桥接模式的关键。那在 JDBC 这个例子中，什么是“抽象”？什么是“实现”呢？</p>\n<p>实际上，JDBC 本身就相当于“抽象”。注意，这里所说的“抽象”，指的并非“抽象类”或“接口”，而是跟具体的数据库无关的、被抽象出来的一套“类库”。具体的 Driver（比如，com.mysql.jdbc.Driver）就相当于“实现”。注意，这里所说的“实现”，也并非指“接口的实现类”，而是跟具体数据库相关的一套“类库”。JDBC 和 Driver 独立开发，通过对象之间的组合关系，组装在一起。JDBC 的所有逻辑操作，最终都委托给 Driver 来执行。</p>\n<img src=\"https://npm.elemecdn.com/youthlql@1.0.0/design_patterns/structural_type/04.01/0002.png\">\n\n\n\n<h2 id=\"桥接模式的应用举例\"><a href=\"#桥接模式的应用举例\" class=\"headerlink\" title=\"桥接模式的应用举例\"></a>桥接模式的应用举例</h2><p>在前面，我们讲过一个 API 接口监控告警的例子：根据不同的告警规则，触发不同类型的告警。告警支持多种通知渠道，包括：邮件、短信、微信、自动语音电话。通知的紧急程度有多种类型，包括：SEVERE（严重）、URGENCY（紧急）、NORMAL（普通）、TRIVIAL（无关紧要）。不同的紧急程度对应不同的通知渠道。比如，SERVE（严重）级别的消息会通过“自动语音电话”告知相关人员。</p>\n<p>在当时的代码实现中，关于发送告警信息那部分代码，我们只给出了粗略的设计，现在我们来一块实现一下。我们先来看最简单、最直接的一种实现方式。代码如下所示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">enum</span> <span class=\"title class_\">NotificationEmergencyLevel</span> &#123;</span><br><span class=\"line\">  SEVERE,</span><br><span class=\"line\">  URGENCY,</span><br><span class=\"line\">  NORMAL,</span><br><span class=\"line\">  TRIVIAL</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Notification</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> List&lt;String&gt; emailAddresses;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> List&lt;String&gt; telephones;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> List&lt;String&gt; wechatIds;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"title function_\">Notification</span><span class=\"params\">()</span> &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setEmailAddress</span><span class=\"params\">(List&lt;String&gt; emailAddress)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.emailAddresses = emailAddress;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setTelephones</span><span class=\"params\">(List&lt;String&gt; telephones)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.telephones = telephones;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setWechatIds</span><span class=\"params\">(List&lt;String&gt; wechatIds)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.wechatIds = wechatIds;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">notify</span><span class=\"params\">(NotificationEmergencyLevel level, String message)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (level.equals(NotificationEmergencyLevel.SEVERE)) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// ...自动语音电话</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (level.equals(NotificationEmergencyLevel.URGENCY)) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// ...发微信</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (level.equals(NotificationEmergencyLevel.NORMAL)) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// ...发邮件</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (level.equals(NotificationEmergencyLevel.TRIVIAL)) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// ...发邮件</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 在API监控告警的例子中，我们如下方式来使用Notification类：</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ErrorAlertHandler</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">AlertHandler</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"title function_\">ErrorAlertHandler</span><span class=\"params\">(AlertRule rule, Notification notification)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">super</span>(rule, notification);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">check</span><span class=\"params\">(ApiStatInfo apiStatInfo)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (apiStatInfo.getErrorCount()</span><br><span class=\"line\">        &gt; rule.getMatchedRule(apiStatInfo.getApi()).getMaxErrorCount()) &#123;</span><br><span class=\"line\">      notification.notify(NotificationEmergencyLevel.SEVERE, <span class=\"string\">&quot;...&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<ol>\n<li>Notification 类的代码实现有一个最明显的问题，那就是有很多 if-else 分支逻辑。实际上，如果每个分支中的代码都不复杂，后期也没有无限膨胀的可能（增加更多 if-else 分支判断），那这样的设计问题并不大，没必要非得一定要摒弃 if-else 分支逻辑。</li>\n<li>不过，Notification 的代码显然不符合这个条件。因为每个 if-else 分支中的代码逻辑都比较复杂，发送通知的所有逻辑都扎堆在 Notification 类中。我们知道，类的代码越多，就越难读懂，越难修改，维护的成本也就越高。很多设计模式都是试图将庞大的类拆分成更细小的类，然后再通过某种更合理的结构组装在一起。</li>\n<li>针对 Notification 的代码，我们将不同渠道的发送逻辑剥离出来，形成独立的消息发送类（MsgSender 相关类）。其中，Notification 类相当于抽象，MsgSender 类相当于实现，两者可以独立开发，通过组合关系（也就是桥梁）任意组合在一起。所谓任意组合的意思就是，不同紧急程度的消息和发送渠道之间的对应关系，不是在代码中固定写死的，我们可以动态地去指定（比如，通过读取配置来获取对应关系）。</li>\n</ol>\n<p>按照这个设计思路，我们对代码进行重构。重构之后的代码如下所示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">MsgSender</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">void</span> <span class=\"title function_\">send</span><span class=\"params\">(String message)</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">TelephoneMsgSender</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">MsgSender</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> List&lt;String&gt; telephones;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"title function_\">TelephoneMsgSender</span><span class=\"params\">(List&lt;String&gt; telephones)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.telephones = telephones;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">send</span><span class=\"params\">(String message)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">EmailMsgSender</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">MsgSender</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 与TelephoneMsgSender代码结构类似，所以省略...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">WechatMsgSender</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">MsgSender</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 与TelephoneMsgSender代码结构类似，所以省略...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Notification</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">protected</span> MsgSender msgSender;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"title function_\">Notification</span><span class=\"params\">(MsgSender msgSender)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.msgSender = msgSender;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title function_\">notify</span><span class=\"params\">(String message)</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">SevereNotification</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Notification</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"title function_\">SevereNotification</span><span class=\"params\">(MsgSender msgSender)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">super</span>(msgSender);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">notify</span><span class=\"params\">(String message)</span> &#123;</span><br><span class=\"line\">    msgSender.send(message);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">UrgencyNotification</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Notification</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 与SevereNotification代码结构类似，所以省略...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">NormalNotification</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Notification</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 与SevereNotification代码结构类似，所以省略...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">TrivialNotification</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Notification</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 与SevereNotification代码结构类似，所以省略...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"桥接模式的注意事项和细节\"><a href=\"#桥接模式的注意事项和细节\" class=\"headerlink\" title=\"桥接模式的注意事项和细节\"></a>桥接模式的注意事项和细节</h2><ol>\n<li>实现了抽象和实现部分的分离，从而极大的提供了系统的灵活性，让抽象部分和实现部分独立开来，这有助于系统进行分层设计，从而产生更好的结构化系统。 </li>\n<li>对于系统的高层部分，只需要知道抽象部分和实现部分的接口就可以了，其它的部分由具体业务来完成。</li>\n<li>桥接模式替代多层继承方案，可以减少子类的个数，降低系统的管理和维护成本</li>\n<li>桥接模式的引入增加了系统的理解和设计难度，由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设计和编程 </li>\n<li>桥接模式要求**正确识别出系统中两个独立变化的维度(抽象、和实现)**，因此其使用范围有一定的局限性，即需要有这样的应用场景。</li>\n</ol>\n<h1 id=\"装饰器模式【常用】\"><a href=\"#装饰器模式【常用】\" class=\"headerlink\" title=\"装饰器模式【常用】\"></a>装饰器模式【常用】</h1><p>我们学习了桥接模式，桥接模式有两种理解方式。第一种理解方式是“将抽象和实现解耦，让它们能独立开发”。这种理解方式比较特别，应用场景也不多。另一种理解方式更加简单，类似“组合优于继承”设计原则，这种理解方式更加通用，应用场景比较多。不管是哪种理解方式，它们的代码结构都是相同的，都是一种类之间的组合关系。</p>\n<p>今天，我们通过剖析 Java IO 类的设计思想，再学习一种新的结构型模式，装饰器模式。它的代码结构跟桥接模式非常相似，不过，要解决的问题却大不相同。</p>\n<blockquote>\n<p>不过还是先看一个简单的demo案例，会比较好理解</p>\n</blockquote>\n<h2 id=\"Demo案例-咖啡订单项目\"><a href=\"#Demo案例-咖啡订单项目\" class=\"headerlink\" title=\"Demo案例-咖啡订单项目\"></a>Demo案例-咖啡订单项目</h2><h3 id=\"星巴克咖啡订单项目\"><a href=\"#星巴克咖啡订单项目\" class=\"headerlink\" title=\"星巴克咖啡订单项目\"></a>星巴克咖啡订单项目</h3><ol>\n<li>咖啡种类&#x2F;单品咖啡：Espresso(意大利浓咖啡)、ShortBlack、LongBlack(美式咖啡)、Decaf(无因咖啡) </li>\n<li>调料：Milk、Soy(豆浆)、Chocolate </li>\n<li>要求在扩展新的咖啡种类时，具有良好的扩展性、改动方便、维护方便 </li>\n<li>使用 OO 的来计算不同种类咖啡的费用: 客户可以点单品咖啡，也可以单品咖啡+调料组合。</li>\n</ol>\n<h3 id=\"方案一\"><a href=\"#方案一\" class=\"headerlink\" title=\"方案一\"></a>方案一</h3><img src=\"https://npm.elemecdn.com/youthlql@1.0.0/design_patterns/structural_type/04.01/0003.png\"/>\n\n\n\n<ol>\n<li>Drink 是一个抽象类，表示饮料 </li>\n<li>des 就是对咖啡的描述, 比如咖啡的名字 </li>\n<li>cost() 方法就是计算费用，Drink 类中做成一个抽象方法. </li>\n<li>Decaf 就是单品咖啡， 继承 Drink, 并实现 cost </li>\n<li>Espress &amp;&amp; Milk 就是单品咖啡+调料， 这个组合很多</li>\n<li>问题：<strong>这样设计，会有很多类，当我们增加一个单品咖啡，或者一个新的调料，类的数量就会倍增，就会出现类爆炸</strong></li>\n</ol>\n<h3 id=\"方案二\"><a href=\"#方案二\" class=\"headerlink\" title=\"方案二\"></a>方案二</h3><p>前面分析到方案 1 因为咖啡单品+调料组合会造成类的倍增，因此可以做改进，将调料内置到 Drink 类，这样就不会造成类数量过多。从而提高项目的维护性(如图)</p>\n<img src=\"https://npm.elemecdn.com/youthlql@1.0.0/design_patterns/structural_type/04.01/0004.png\">\n\n\n\n<ol>\n<li>方案 2 可以控制类的数量，不至于造成很多的类 </li>\n<li>在增加或者删除调料种类时，代码的维护量很大 </li>\n<li>考虑到用户可以添加多份 调料时，可以将 hasMilk 返回一个对应 int </li>\n<li>考虑使用 <strong>装饰者</strong> 模式</li>\n</ol>\n<blockquote>\n<p>注意：装饰器模式是对功能的增强，而不是附加新的功能。代理模式才是附加新的功能。</p>\n</blockquote>\n<h3 id=\"装饰器模式代码\"><a href=\"#装饰器模式代码\" class=\"headerlink\" title=\"装饰器模式代码\"></a>装饰器模式代码</h3><img src=\"https://npm.elemecdn.com/youthlql@1.0.0/design_patterns/structural_type/04.01/0005.png\"/>\n\n<h4 id=\"Drink【抽象类-主体Component】\"><a href=\"#Drink【抽象类-主体Component】\" class=\"headerlink\" title=\"Drink【抽象类-主体Component】\"></a>Drink【抽象类-主体Component】</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Drink</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">public</span> String des; <span class=\"comment\">// 描述</span></span><br><span class=\"line\">   <span class=\"keyword\">private</span> <span class=\"type\">float</span> <span class=\"variable\">price</span> <span class=\"operator\">=</span> <span class=\"number\">0.0f</span>;</span><br><span class=\"line\">   <span class=\"keyword\">public</span> String <span class=\"title function_\">getDes</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> des;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setDes</span><span class=\"params\">(String des)</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.des = des;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"keyword\">public</span> <span class=\"type\">float</span> <span class=\"title function_\">getPrice</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> price;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setPrice</span><span class=\"params\">(<span class=\"type\">float</span> price)</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.price = price;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   </span><br><span class=\"line\">   <span class=\"comment\">//计算费用的抽象方法</span></span><br><span class=\"line\">   <span class=\"comment\">//子类来实现</span></span><br><span class=\"line\">   <span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"type\">float</span> <span class=\"title function_\">cost</span><span class=\"params\">()</span>;</span><br><span class=\"line\">   </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"Decorator\"><a href=\"#Decorator\" class=\"headerlink\" title=\"Decorator\"></a>Decorator</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Decorator</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Drink</span> &#123;</span><br><span class=\"line\">   <span class=\"keyword\">private</span> Drink obj;</span><br><span class=\"line\">   </span><br><span class=\"line\">   <span class=\"keyword\">public</span> <span class=\"title function_\">Decorator</span><span class=\"params\">(Drink obj)</span> &#123; <span class=\"comment\">//组合</span></span><br><span class=\"line\">      <span class=\"comment\">// TODO Auto-generated constructor stub</span></span><br><span class=\"line\">      <span class=\"built_in\">this</span>.obj = obj;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   </span><br><span class=\"line\">   <span class=\"meta\">@Override</span></span><br><span class=\"line\">   <span class=\"keyword\">public</span> <span class=\"type\">float</span> <span class=\"title function_\">cost</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// TODO Auto-generated method stub</span></span><br><span class=\"line\">      <span class=\"comment\">// getPrice 自己价格</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"built_in\">super</span>.getPrice() + obj.cost();</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   </span><br><span class=\"line\">   <span class=\"meta\">@Override</span></span><br><span class=\"line\">   <span class=\"keyword\">public</span> String <span class=\"title function_\">getDes</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// TODO Auto-generated method stub</span></span><br><span class=\"line\">      <span class=\"comment\">// obj.getDes() 输出被装饰者的信息</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> des + <span class=\"string\">&quot; &quot;</span> + getPrice() + <span class=\"string\">&quot; &amp;&amp; &quot;</span> + obj.getDes();</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Coffee\"><a href=\"#Coffee\" class=\"headerlink\" title=\"Coffee\"></a>Coffee</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Coffee extends Drink &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  @Override</span><br><span class=\"line\">  public float cost() &#123;</span><br><span class=\"line\">    // TODO Auto-generated method stub</span><br><span class=\"line\">    return super.getPrice();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"ShortBlack\"><a href=\"#ShortBlack\" class=\"headerlink\" title=\"ShortBlack\"></a>ShortBlack</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ShortBlack</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Coffee</span>&#123;</span><br><span class=\"line\">   </span><br><span class=\"line\">   <span class=\"keyword\">public</span> <span class=\"title function_\">ShortBlack</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">      setDes(<span class=\"string\">&quot; shortblack &quot;</span>);</span><br><span class=\"line\">      setPrice(<span class=\"number\">4.0f</span>);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"LongBlack\"><a href=\"#LongBlack\" class=\"headerlink\" title=\"LongBlack\"></a>LongBlack</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">LongBlack</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Coffee</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">public</span> <span class=\"title function_\">LongBlack</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">      setDes(<span class=\"string\">&quot; longblack &quot;</span>);</span><br><span class=\"line\">      setPrice(<span class=\"number\">5.0f</span>);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"DeCaf\"><a href=\"#DeCaf\" class=\"headerlink\" title=\"DeCaf\"></a>DeCaf</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">DeCaf</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Coffee</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">public</span> <span class=\"title function_\">DeCaf</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">      setDes(<span class=\"string\">&quot; 无因咖啡 &quot;</span>);</span><br><span class=\"line\">      setPrice(<span class=\"number\">1.0f</span>);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Espresso\"><a href=\"#Espresso\" class=\"headerlink\" title=\"Espresso\"></a>Espresso</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Espresso</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Coffee</span> &#123;</span><br><span class=\"line\">   </span><br><span class=\"line\">   <span class=\"keyword\">public</span> <span class=\"title function_\">Espresso</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">      setDes(<span class=\"string\">&quot; 意大利咖啡 &quot;</span>);</span><br><span class=\"line\">      setPrice(<span class=\"number\">6.0f</span>);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Chocolate\"><a href=\"#Chocolate\" class=\"headerlink\" title=\"Chocolate\"></a>Chocolate</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//具体的Decorator， 这里就是调味品</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Chocolate</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Decorator</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">public</span> <span class=\"title function_\">Chocolate</span><span class=\"params\">(Drink obj)</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">super</span>(obj);</span><br><span class=\"line\">      setDes(<span class=\"string\">&quot; 巧克力 &quot;</span>);</span><br><span class=\"line\">      setPrice(<span class=\"number\">3.0f</span>); <span class=\"comment\">// 调味品 的价格</span></span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Milk\"><a href=\"#Milk\" class=\"headerlink\" title=\"Milk\"></a>Milk</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Milk</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Decorator</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">public</span> <span class=\"title function_\">Milk</span><span class=\"params\">(Drink obj)</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">super</span>(obj);</span><br><span class=\"line\">      <span class=\"comment\">// TODO Auto-generated constructor stub</span></span><br><span class=\"line\">      setDes(<span class=\"string\">&quot; 牛奶 &quot;</span>);</span><br><span class=\"line\">      setPrice(<span class=\"number\">2.0f</span>); </span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Soy\"><a href=\"#Soy\" class=\"headerlink\" title=\"Soy\"></a>Soy</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Soy</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Decorator</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">public</span> <span class=\"title function_\">Soy</span><span class=\"params\">(Drink obj)</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">super</span>(obj);</span><br><span class=\"line\">      <span class=\"comment\">// TODO Auto-generated constructor stub</span></span><br><span class=\"line\">      setDes(<span class=\"string\">&quot; 豆浆  &quot;</span>);</span><br><span class=\"line\">      setPrice(<span class=\"number\">1.5f</span>);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"CoffeeBar\"><a href=\"#CoffeeBar\" class=\"headerlink\" title=\"CoffeeBar\"></a>CoffeeBar</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">CoffeeBar</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// TODO Auto-generated method stub</span></span><br><span class=\"line\">      <span class=\"comment\">// 装饰者模式下的订单：2份巧克力+一份牛奶的LongBlack</span></span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// 1. 点一份 LongBlack</span></span><br><span class=\"line\">      <span class=\"type\">Drink</span> <span class=\"variable\">order</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">LongBlack</span>();</span><br><span class=\"line\">      System.out.println(<span class=\"string\">&quot;费用1=&quot;</span> + order.cost());</span><br><span class=\"line\">      System.out.println(<span class=\"string\">&quot;描述=&quot;</span> + order.getDes());</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// 2. order 加入一份牛奶</span></span><br><span class=\"line\">      order = <span class=\"keyword\">new</span> <span class=\"title class_\">Milk</span>(order);</span><br><span class=\"line\"></span><br><span class=\"line\">      System.out.println(<span class=\"string\">&quot;order 加入一份牛奶 费用 =&quot;</span> + order.cost());</span><br><span class=\"line\">      System.out.println(<span class=\"string\">&quot;order 加入一份牛奶 描述 = &quot;</span> + order.getDes());</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// 3. order 加入一份巧克力</span></span><br><span class=\"line\"></span><br><span class=\"line\">      order = <span class=\"keyword\">new</span> <span class=\"title class_\">Chocolate</span>(order);</span><br><span class=\"line\"></span><br><span class=\"line\">      System.out.println(<span class=\"string\">&quot;order 加入一份牛奶 加入一份巧克力  费用 =&quot;</span> + order.cost());</span><br><span class=\"line\">      System.out.println(<span class=\"string\">&quot;order 加入一份牛奶 加入一份巧克力 描述 = &quot;</span> + order.getDes());</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// 3. order 加入一份巧克力</span></span><br><span class=\"line\"></span><br><span class=\"line\">      order = <span class=\"keyword\">new</span> <span class=\"title class_\">Chocolate</span>(order);</span><br><span class=\"line\"></span><br><span class=\"line\">      System.out.println(<span class=\"string\">&quot;order 加入一份牛奶 加入2份巧克力   费用 =&quot;</span> + order.cost());</span><br><span class=\"line\">      System.out.println(<span class=\"string\">&quot;order 加入一份牛奶 加入2份巧克力 描述 = &quot;</span> + order.getDes());</span><br><span class=\"line\">   </span><br><span class=\"line\">      System.out.println(<span class=\"string\">&quot;===========================&quot;</span>);</span><br><span class=\"line\">      </span><br><span class=\"line\">      <span class=\"type\">Drink</span> <span class=\"variable\">order2</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">DeCaf</span>();</span><br><span class=\"line\">      </span><br><span class=\"line\">      System.out.println(<span class=\"string\">&quot;order2 无因咖啡  费用 =&quot;</span> + order2.cost());</span><br><span class=\"line\">      System.out.println(<span class=\"string\">&quot;order2 无因咖啡 描述 = &quot;</span> + order2.getDes());</span><br><span class=\"line\">      </span><br><span class=\"line\">      order2 = <span class=\"keyword\">new</span> <span class=\"title class_\">Milk</span>(order2);</span><br><span class=\"line\">      </span><br><span class=\"line\">      System.out.println(<span class=\"string\">&quot;order2 无因咖啡 加入一份牛奶  费用 =&quot;</span> + order2.cost());</span><br><span class=\"line\">      System.out.println(<span class=\"string\">&quot;order2 无因咖啡 加入一份牛奶 描述 = &quot;</span> + order2.getDes());</span><br><span class=\"line\"></span><br><span class=\"line\">   </span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"装饰者模式原理\"><a href=\"#装饰者模式原理\" class=\"headerlink\" title=\"装饰者模式原理\"></a>装饰者模式原理</h2><ol>\n<li>装饰者模式就像打包一个快递</li>\n</ol>\n<p>主体：比如：陶瓷、衣服 (Component) &#x2F;&#x2F; 被装饰者 </p>\n<p>包装：比如：报纸填充、塑料泡沫、纸板、木板(Decorator) </p>\n<ol start=\"2\">\n<li><p>Component 主体：比如类似前面的 Drink </p>\n</li>\n<li><p>ConcreteComponent 和 Decorator</p>\n</li>\n</ol>\n<p>ConcreteComponent：具体的主体， 比如前面的各个单品咖啡 </p>\n<ol start=\"4\">\n<li>Decorator: 装饰者，比如各调料.</li>\n</ol>\n<p>在Component 与 ConcreteComponent 之间，如果 ConcreteComponent 类很多,还可以设计一个缓冲层，将 共有的部分提取出来，抽象层一个类</p>\n<h2 id=\"Java-IO-类的“奇怪”用法\"><a href=\"#Java-IO-类的“奇怪”用法\" class=\"headerlink\" title=\"Java IO 类的“奇怪”用法\"></a>Java IO 类的“奇怪”用法</h2><p>Java IO 类库非常庞大和复杂，有几十个类，负责 IO 数据的读取和写入。如果对 Java IO 类做一下分类，我们可以从下面两个维度将它划分为四类。具体如下所示：</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>字节流</th>\n<th>字符流</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>输入流</td>\n<td>InputStream</td>\n<td>Reader</td>\n</tr>\n<tr>\n<td>输出流</td>\n<td>OutputStream</td>\n<td>Writer</td>\n</tr>\n</tbody></table>\n<p>针对不同的读取和写入场景，Java IO 又在这四个父类基础之上，扩展出了很多子类。具体如下所示：</p>\n<img src=\"https://npm.elemecdn.com/youthlql@1.0.0/design_patterns/structural_type/04.01/0006.png\"/>\n\n\n\n<blockquote>\n<p>说明</p>\n<ol>\n<li>InputStream 是抽象类, 类似我们前面讲的 Drink</li>\n<li>FileInputStream 是  InputStream 子类，类似我们前面的 DeCaf, LongBlack</li>\n<li>FilterInputStream  是  InputStream 子类：类似我们前面 的 Decorator 修饰者</li>\n<li>DataInputStream 是 FilterInputStream 子类，具体的修饰者，类似前面的 Milk, Soy 等</li>\n<li>FilterInputStream 类 有  protected volatile InputStream in; 即含被装饰者</li>\n<li>分析得出在jdk 的io体系中，就是使用装饰者模式</li>\n</ol>\n</blockquote>\n<p>在我初学 Java 的时候，曾经对 Java IO 的一些用法产生过很大疑惑，比如下面这样一段代码。我们打开文件 test.txt，从中读取数据。其中，InputStream 是一个抽象类，FileInputStream 是专门用来读取文件流的子类。BufferedInputStream 是一个支持带缓存功能的数据读取类，可以提高数据读取的效率。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">InputStream</span> <span class=\"variable\">in</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">FileInputStream</span>(<span class=\"string\">&quot;/user/test.txt&quot;</span>);</span><br><span class=\"line\"><span class=\"type\">InputStream</span> <span class=\"variable\">bin</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">BufferedInputStream</span>(in);</span><br><span class=\"line\"><span class=\"type\">byte</span>[] data = <span class=\"keyword\">new</span> <span class=\"title class_\">byte</span>[<span class=\"number\">128</span>];</span><br><span class=\"line\"><span class=\"keyword\">while</span> (bin.read(data) != -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>初看上面的代码，我们会觉得 Java IO 的用法比较麻烦，需要先创建一个 FileInputStream 对象，然后再传递给 BufferedInputStream 对象来使用。我在想，Java IO 为什么不设计一个继承 FileInputStream 并且支持缓存的 BufferedFileInputStream 类呢？这样我们就可以像下面的代码中这样，直接创建一个 BufferedFileInputStream 类对象，打开文件读取数据，用起来岂不是更加简单？</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">InputStream</span> <span class=\"variable\">bin</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">BufferedFileInputStream</span>(<span class=\"string\">&quot;/user/test.txt&quot;</span>);</span><br><span class=\"line\"><span class=\"type\">byte</span>[] data = <span class=\"keyword\">new</span> <span class=\"title class_\">byte</span>[<span class=\"number\">128</span>];</span><br><span class=\"line\"><span class=\"keyword\">while</span> (bin.read(data) != -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h2 id=\"基于继承的设计方案\"><a href=\"#基于继承的设计方案\" class=\"headerlink\" title=\"基于继承的设计方案\"></a>基于继承的设计方案</h2><p>如果 InputStream 只有一个子类 FileInputStream 的话，那我们在 FileInputStream 基础之上，再设计一个孙子类 BufferedFileInputStream，也算是可以接受的，毕竟继承结构还算简单。但实际上，继承 InputStream 的子类有很多。我们需要给每一个 InputStream 的子类，再继续派生支持缓存读取的子类。</p>\n<p>除了支持缓存读取之外，如果我们还需要对功能进行其他方面的增强，比如下面的 DataInputStream 类，支持按照基本数据类型（int、boolean、long 等）来读取数据。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">FileInputStream</span> <span class=\"variable\">in</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">FileInputStream</span>(<span class=\"string\">&quot;/user/test.txt&quot;</span>);</span><br><span class=\"line\"><span class=\"type\">DataInputStream</span> <span class=\"variable\">din</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">DataInputStream</span>(in);</span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"variable\">data</span> <span class=\"operator\">=</span> din.readInt();</span><br></pre></td></tr></table></figure>\n\n<p>在这种情况下，如果我们继续按照继承的方式来实现的话，就需要再继续派生出 DataFileInputStream、DataPipedInputStream 等类。如果我们还需要既支持缓存、又支持按照基本类型读取数据的类，那就要再继续派生出 BufferedDataFileInputStream、BufferedDataPipedInputStream 等 n 多类。这还只是附加了两个增强功能，如果我们需要附加更多的增强功能，那就会导致组合爆炸，类继承结构变得无比复杂，代码既不好扩展，也不好维护。这也是我们不推荐使用继承的原因。</p>\n<h2 id=\"基于装饰器模式的设计方案\"><a href=\"#基于装饰器模式的设计方案\" class=\"headerlink\" title=\"基于装饰器模式的设计方案\"></a>基于装饰器模式的设计方案</h2><p>在前面，我们还讲到“组合优于继承”，可以“使用组合来替代继承”。针对刚刚的继承结构过于复杂的问题，我们可以通过将继承关系改为组合关系来解决。下面的代码展示了 Java IO 的这种设计思路。不过，我对代码做了简化，只抽象出了必要的代码结构，如果你感兴趣的话，可以直接去查看 JDK 源码。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.io.IOException;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">class</span> <span class=\"title class_\">InputStream</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">read</span><span class=\"params\">(<span class=\"type\">byte</span> b[])</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> read(b, <span class=\"number\">0</span>, b.length);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">read</span><span class=\"params\">(<span class=\"type\">byte</span> b[], <span class=\"type\">int</span> off, <span class=\"type\">int</span> len)</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"type\">long</span> <span class=\"title function_\">skip</span><span class=\"params\">(<span class=\"type\">long</span> n)</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">available</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">close</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title function_\">mark</span><span class=\"params\">(<span class=\"type\">int</span> readlimit)</span> &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title function_\">reset</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IOException</span>(<span class=\"string\">&quot;mark/reset not supported&quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">markSupported</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">BufferedInputStream</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">InputStream</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">protected</span> <span class=\"keyword\">volatile</span> InputStream in;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">protected</span> <span class=\"title function_\">BufferedInputStream</span><span class=\"params\">(InputStream in)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.in = in;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// ...实现基于缓存的读数据接口...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">DataInputStream</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">InputStream</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">protected</span> <span class=\"keyword\">volatile</span> InputStream in;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">protected</span> <span class=\"title function_\">DataInputStream</span><span class=\"params\">(InputStream in)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.in = in;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// ...实现读取基本类型数据的接口</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>看了上面的代码，你可能会问，那装饰器模式就是简单的“用组合替代继承”吗？当然不是。从 Java IO 的设计来看，装饰器模式相对于简单的组合关系，还有两个比较特殊的地方。</p>\n<p><strong>第一个比较特殊的地方是：装饰器类和原始类继承同样的父类，这样我们可以对原始类“嵌套”多个装饰器类。</strong>比如，下面这样一段代码，我们对 FileInputStream 嵌套了两个装饰器类：BufferedInputStream 和 DataInputStream，让它既支持缓存读取，又支持按照基本数据类型来读取数据。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">InputStream</span> <span class=\"variable\">in</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">FileInputStream</span>(<span class=\"string\">&quot;/user/test.txt&quot;</span>);</span><br><span class=\"line\"><span class=\"type\">InputStream</span> <span class=\"variable\">bin</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">BufferedInputStream</span>(in);</span><br><span class=\"line\"><span class=\"type\">DataInputStream</span> <span class=\"variable\">din</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">DataInputStream</span>(bin);</span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"variable\">data</span> <span class=\"operator\">=</span> din.readInt();</span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>第二个比较特殊的地方是：装饰器类是对功能的增强，这也是装饰器模式应用场景的一个重要特点。</strong>实际上，符合“组合关系”这种代码结构的设计模式有很多，比如之前讲过的代理模式、桥接模式，还有现在的装饰器模式。尽管它们的代码结构很相似，但是每种设计模式的意图是不同的。就拿比较相似的代理模式和装饰器模式来说吧，代理模式中，代理类附加的是跟原始类无关的功能，而在装饰器模式中，装饰器类附加的是跟原始类相关的增强功能。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 代理模式的代码结构(下面的接口也可以替换成抽象类)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">IA</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">f</span><span class=\"params\">()</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">A</span> impelements IA &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">f</span><span class=\"params\">()</span> &#123; </span><br><span class=\"line\">        <span class=\"comment\">//... </span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AProxy</span> impements IA &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> IA a;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">AProxy</span><span class=\"params\">(IA a)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.a = a;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">f</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 新添加的代理逻辑</span></span><br><span class=\"line\">        a.f();</span><br><span class=\"line\">        <span class=\"comment\">// 新添加的代理逻辑</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 装饰器模式的代码结构(下面的接口也可以替换成抽象类)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">IA</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">f</span><span class=\"params\">()</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">A</span> impelements IA &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">f</span><span class=\"params\">()</span> &#123; </span><br><span class=\"line\">        <span class=\"comment\">//... </span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ADecorator</span> impements IA &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> IA a;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">ADecorator</span><span class=\"params\">(IA a)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.a = a;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">f</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 功能增强代码</span></span><br><span class=\"line\">        a.f();</span><br><span class=\"line\">        <span class=\"comment\">// 功能增强代码</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<ol>\n<li>实际上，如果去查看 JDK 的源码，你会发现，BufferedInputStream、DataInputStream 并非继承自 InputStream，而是另外一个叫 FilterInputStream 的类。那这又是出于什么样的设计意图，才引入这样一个类呢？</li>\n<li>我们再重新来看一下 BufferedInputStream 类的代码。InputStream 是一个抽象类而非接口，而且它的大部分函数（比如 read()、available()）都有默认实现，按理来说，我们只需要在 BufferedInputStream 类中重新实现那些需要增加缓存功能的函数就可以了，其他函数继承 InputStream 的默认实现。但实际上，这样做是行不通的。</li>\n<li>对于即便是不需要增加缓存功能的函数来说，BufferedInputStream 还是必须把它重新实现一遍，简单包裹对 InputStream 对象的函数调用。具体的代码示例如下所示。如果不重新实现，那 BufferedInputStream 类就无法将最终读取数据的任务，委托给传递进来的 InputStream 对象来完成。这一部分稍微有点不好理解，你自己多思考一下。</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">BufferedInputStream</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">InputStream</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">volatile</span> InputStream in;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"title function_\">BufferedInputStream</span><span class=\"params\">(InputStream in)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.in = in;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// f()函数不需要增强，只是重新调用一下InputStream in对象的f()</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">f</span><span class=\"params\">()</span> &#123; </span><br><span class=\"line\">        in.f();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>实际上，DataInputStream 也存在跟 BufferedInputStream 同样的问题。为了避免代码重复，Java IO 抽象出了一个装饰器父类 FilterInputStream，代码实现如下所示。InputStream 的所有的装饰器类（BufferedInputStream、DataInputStream）都继承自这个装饰器父类。这样，装饰器类只需要实现它需要增强的方法就可以了，其他方法继承装饰器父类的默认实现。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">FilterInputStream</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">InputStream</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">volatile</span> InputStream in;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"title function_\">FilterInputStream</span><span class=\"params\">(InputStream in)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.in = in;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">read</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> in.read();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">read</span><span class=\"params\">(<span class=\"type\">byte</span> b[])</span> <span class=\"keyword\">throws</span> IOException &#123; </span><br><span class=\"line\">        <span class=\"keyword\">return</span> read(b, <span class=\"number\">0</span>, b.length);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">read</span><span class=\"params\">(<span class=\"type\">byte</span> b[], <span class=\"type\">int</span> off, <span class=\"type\">int</span> len)</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> in.read(b, off, len);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">long</span> <span class=\"title function_\">skip</span><span class=\"params\">(<span class=\"type\">long</span> n)</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> in.skip(n);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">available</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> in.available();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">close</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">        in.close();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title function_\">mark</span><span class=\"params\">(<span class=\"type\">int</span> readlimit)</span> &#123;</span><br><span class=\"line\">        in.mark(readlimit);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title function_\">reset</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">        in.reset();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">markSupported</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> in.markSupported();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h1 id=\"适配器模式【常用】\"><a href=\"#适配器模式【常用】\" class=\"headerlink\" title=\"适配器模式【常用】\"></a>适配器模式【常用】</h1><ol>\n<li>前面我们学了代理模式、桥接模式、装饰器模式，今天，我们再来学习一个比较常用的结构型模式：适配器模式。这个模式相对来说还是比较简单、好理解的，应用场景也很具体，总体上来讲比较好掌握。</li>\n<li>关于适配器模式，今天我们主要学习它的两种实现方式，类适配器和对象适配器，以及 5 种常见的应用场景。同时，我还会通过剖析 slf4j 日志框架，来给你展示这个模式在真实项目中的应用。除此之外，在文章的最后，我还对代理、桥接、装饰器、适配器，这 4 种代码结构非常相似的设计模式做简单的对比，对这几节内容做一个简单的总结。</li>\n<li>适配器模式(Adapter Pattern)将某个类的接口转换成客户端期望的另一个接口表示，<strong>主的目的是兼容性</strong>，让原本因接口不匹配不能一起工作的两个类可以协同工作。其别名为包装器(Wrapper) 。适配器模式属于结构型模式。主要分为三类：<strong>类适配器模式、对象适配器模式、接口适配器模</strong>式</li>\n</ol>\n<h2 id=\"Demo案例-充电器\"><a href=\"#Demo案例-充电器\" class=\"headerlink\" title=\"Demo案例-充电器\"></a>Demo案例-充电器</h2><p>基本介绍：Adapter 类，通过继承 src 类，实现 dst 类接口，完成 src-&gt;dst 的适配。</p>\n<ul>\n<li>以生活中充电器的例子来讲解适配器，充电器本身相当于 Adapter，220V 交流电相当于 src (即被适配者)，我们 的目 dst(即 目标)是 5V 直流电</li>\n</ul>\n<h3 id=\"类适配器代码实现\"><a href=\"#类适配器代码实现\" class=\"headerlink\" title=\"类适配器代码实现\"></a>类适配器代码实现</h3><h4 id=\"Voltage220V\"><a href=\"#Voltage220V\" class=\"headerlink\" title=\"Voltage220V\"></a>Voltage220V</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//被适配的类</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Voltage220V</span> &#123;</span><br><span class=\"line\">   <span class=\"comment\">//输出220V的电压</span></span><br><span class=\"line\">   <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">output220V</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">      <span class=\"type\">int</span> <span class=\"variable\">src</span> <span class=\"operator\">=</span> <span class=\"number\">220</span>;</span><br><span class=\"line\">      System.out.println(<span class=\"string\">&quot;电压=&quot;</span> + src + <span class=\"string\">&quot;伏&quot;</span>);</span><br><span class=\"line\">      <span class=\"keyword\">return</span> src;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"IVoltage5V\"><a href=\"#IVoltage5V\" class=\"headerlink\" title=\"IVoltage5V\"></a>IVoltage5V</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//适配接口</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">IVoltage5V</span> &#123;</span><br><span class=\"line\">   <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">output5V</span><span class=\"params\">()</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Phone\"><a href=\"#Phone\" class=\"headerlink\" title=\"Phone\"></a>Phone</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Phone</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">//充电</span></span><br><span class=\"line\">   <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">charging</span><span class=\"params\">(IVoltage5V iVoltage5V)</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(iVoltage5V.output5V() == <span class=\"number\">5</span>) &#123;</span><br><span class=\"line\">         System.out.println(<span class=\"string\">&quot;电压为5V, 可以充电~~&quot;</span>);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (iVoltage5V.output5V() &gt; <span class=\"number\">5</span>) &#123;</span><br><span class=\"line\">         System.out.println(<span class=\"string\">&quot;电压大于5V, 不能充电~~&quot;</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"VoltageAdapter\"><a href=\"#VoltageAdapter\" class=\"headerlink\" title=\"VoltageAdapter\"></a>VoltageAdapter</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//适配器类</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">VoltageAdapter</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Voltage220V</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">IVoltage5V</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"meta\">@Override</span></span><br><span class=\"line\">   <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">output5V</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// TODO Auto-generated method stub</span></span><br><span class=\"line\">      <span class=\"comment\">//获取到220V电压</span></span><br><span class=\"line\">      <span class=\"type\">int</span> <span class=\"variable\">srcV</span> <span class=\"operator\">=</span> output220V();</span><br><span class=\"line\">      <span class=\"type\">int</span> <span class=\"variable\">dstV</span> <span class=\"operator\">=</span> srcV / <span class=\"number\">44</span> ; <span class=\"comment\">//转成 5v</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> dstV;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Client-1\"><a href=\"#Client-1\" class=\"headerlink\" title=\"Client\"></a>Client</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Client</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// TODO Auto-generated method stub</span></span><br><span class=\"line\">      System.out.println(<span class=\"string\">&quot; === 类适配器模式 ====&quot;</span>);</span><br><span class=\"line\">      <span class=\"type\">Phone</span> <span class=\"variable\">phone</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Phone</span>();</span><br><span class=\"line\">      phone.charging(<span class=\"keyword\">new</span> <span class=\"title class_\">VoltageAdapter</span>());</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"对象适配器实现\"><a href=\"#对象适配器实现\" class=\"headerlink\" title=\"对象适配器实现\"></a>对象适配器实现</h3><p>基本思路和类的适配器模式相同，只是将 Adapter 类作修改，不是继承 src 类，而是持有 src 类的实例，以解决 兼容性的问题。 即：持有 src 类，实现 dst 类接口，完成 src-&gt;dst 的适配 ，在系统中尽量使用<strong>关联关系（聚合，组合）来替代继承</strong>关系。</p>\n<p>上面的例子代码基本没用什么改变，改变的只有以下两个类</p>\n<h4 id=\"VoltageAdapter-1\"><a href=\"#VoltageAdapter-1\" class=\"headerlink\" title=\"VoltageAdapter\"></a>VoltageAdapter</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 适配器类</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">VoltageAdapter</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">IVoltage5V</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> Voltage220V voltage220V; <span class=\"comment\">// 关联关系-聚合</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 通过构造器，传入一个 Voltage220V 实例</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"title function_\">VoltageAdapter</span><span class=\"params\">(Voltage220V voltage220v)</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.voltage220V = voltage220v;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">output5V</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">dst</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"literal\">null</span> != voltage220V) &#123;</span><br><span class=\"line\">      <span class=\"type\">int</span> <span class=\"variable\">src</span> <span class=\"operator\">=</span> voltage220V.output220V(); <span class=\"comment\">// 获取220V 电压</span></span><br><span class=\"line\">      System.out.println(<span class=\"string\">&quot;使用对象适配器，进行适配~~&quot;</span>);</span><br><span class=\"line\">      dst = src / <span class=\"number\">44</span>;</span><br><span class=\"line\">      System.out.println(<span class=\"string\">&quot;适配完成，输出的电压为=&quot;</span> + dst);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> dst;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Client-2\"><a href=\"#Client-2\" class=\"headerlink\" title=\"Client\"></a>Client</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Client</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// TODO Auto-generated method stub</span></span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot; === 对象适配器模式 ====&quot;</span>);</span><br><span class=\"line\">    <span class=\"type\">Phone</span> <span class=\"variable\">phone</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Phone</span>();</span><br><span class=\"line\">    phone.charging(<span class=\"keyword\">new</span> <span class=\"title class_\">VoltageAdapter</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">Voltage220V</span>()));</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h2 id=\"适配器模式的原理与实现\"><a href=\"#适配器模式的原理与实现\" class=\"headerlink\" title=\"适配器模式的原理与实现\"></a>适配器模式的原理与实现</h2><p>顾名思义，这个模式就是用来做适配的，它将不兼容的接口转换为可兼容的接口，让原本由于接口不兼容而不能一起工作的类可以一起工作。对于这个模式，有一个经常被拿来解释它的例子，就是 USB 转接头充当适配器，把两种不兼容的接口，通过转接变得可以一起工作。</p>\n<p>原理很简单，我们再来看下它的代码实现。适配器模式有两种实现方式：类适配器和对象适配器。其中，类适配器使用继承关系来实现，对象适配器使用组合关系来实现。具体的代码实现如下所示。其中，ITarget 表示要转化成的接口定义。Adaptee 是一组不兼容 ITarget 接口定义的接口，Adaptor 将 Adaptee 转化成一组符合 ITarget 接口定义的接口。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 类适配器: 基于继承</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">ITarget</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">f1</span><span class=\"params\">()</span>;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">f2</span><span class=\"params\">()</span>;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">fc</span><span class=\"params\">()</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Adaptee</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">fa</span><span class=\"params\">()</span> &#123; </span><br><span class=\"line\">        <span class=\"comment\">//... </span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">fb</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//... </span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">fc</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//... </span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Adaptor</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Adaptee</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">ITarget</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">f1</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">super</span>.fa();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">f2</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//...重新实现f2()...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 这里fc()不需要实现，直接继承自Adaptee，这是跟对象适配器最大的不同点</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 对象适配器：基于组合</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">ITarget</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">f1</span><span class=\"params\">()</span>;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">f2</span><span class=\"params\">()</span>;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">fc</span><span class=\"params\">()</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Adaptee</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">fa</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//... </span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">fb</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//... </span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">fc</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//... </span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Adaptor</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">ITarget</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Adaptee adaptee;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">Adaptor</span><span class=\"params\">(Adaptee adaptee)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.adaptee = adaptee;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">f1</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        adaptee.fa(); <span class=\"comment\">//委托给Adaptee</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">f2</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//...重新实现f2()...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">fc</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        adaptee.fc();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>针对这两种实现方式，在实际的开发中，到底该如何选择使用哪一种呢？判断的标准主要有两个，一个是 Adaptee 接口的个数，另一个是 Adaptee 和 ITarget 的契合程度。</p>\n<ul>\n<li>如果 Adaptee 接口并不多，那两种实现方式都可以。</li>\n<li>如果 Adaptee 接口很多，而且 Adaptee 和 ITarget 接口定义大部分都相同，那我们推荐使用类适配器，因为 Adaptor 复用父类 Adaptee 的接口，比起对象适配器的实现方式，Adaptor 的代码量要少一些。</li>\n<li>如果 Adaptee 接口很多，而且 Adaptee 和 ITarget 接口定义大部分都不相同，那我们推荐使用对象适配器，因为组合结构相对于继承更加灵活。</li>\n</ul>\n<h2 id=\"适配器模式应用场景总结\"><a href=\"#适配器模式应用场景总结\" class=\"headerlink\" title=\"适配器模式应用场景总结\"></a>适配器模式应用场景总结</h2><ol>\n<li><p>原理和实现讲完了，都不复杂。我们再来看，到底什么时候会用到适配器模式呢？</p>\n</li>\n<li><p>一般来说，适配器模式可以看作一种“补偿模式”，用来补救设计上的缺陷。应用这种模式算是“无奈之举”。如果在设计初期，我们就能协调规避接口不兼容的问题，那这种模式就没有应用的机会了。</p>\n</li>\n<li><p>前面我们反复提到，适配器模式的应用场景是“接口不兼容”。那在实际的开发中，什么情况下才会出现接口不兼容呢？我建议你先自己思考一下这个问题，然后再来看下面的总结 。</p>\n</li>\n</ol>\n<h3 id=\"封装有缺陷的接口设计\"><a href=\"#封装有缺陷的接口设计\" class=\"headerlink\" title=\"封装有缺陷的接口设计\"></a>封装有缺陷的接口设计</h3><ol>\n<li><p>假设我们依赖的外部系统在接口设计方面有缺陷（比如包含大量静态方法），引入之后会影响到我们自身代码的可测试性。为了隔离设计上的缺陷，我们希望对外部系统提供的接口进行二次封装，抽象出更好的接口设计，这个时候就可以使用适配器模式了。</p>\n</li>\n<li><p>具体我还是举个例子来解释一下，你直接看代码应该会更清晰。具体代码如下所示：</p>\n</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">CD</span> &#123; <span class=\"comment\">//这个类来自外部sdk，我们无权修改它的代码</span></span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">staticFunction1</span><span class=\"params\">()</span> &#123; <span class=\"comment\">//... &#125;</span></span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">uglyNamingFunction2</span><span class=\"params\">()</span> &#123; <span class=\"comment\">//... &#125;</span></span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">tooManyParamsFunction3</span><span class=\"params\">(<span class=\"type\">int</span> paramA, <span class=\"type\">int</span> paramB, ...)</span> &#123; <span class=\"comment\">//... &#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">lowPerformanceFunction4</span><span class=\"params\">()</span> &#123; <span class=\"comment\">//... &#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用适配器模式进行重构</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ITarget</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">function1</span><span class=\"params\">()</span>;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">function2</span><span class=\"params\">()</span>;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">fucntion3</span><span class=\"params\">(ParamsWrapperDefinition paramsWrapper)</span>;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">function4</span><span class=\"params\">()</span>;</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 注意：适配器类的命名不一定非得末尾带Adaptor</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">CDAdaptor</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">CD</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">ITarget</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">function1</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">super</span>.staticFunction1();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">function2</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">super</span>.uglyNamingFucntion2();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">function3</span><span class=\"params\">(ParamsWrapperDefinition paramsWrapper)</span> &#123; </span><br><span class=\"line\">        <span class=\"built_in\">super</span>.tooManyParamsFunction3(paramsWrapper.getParamA(), ...);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">function4</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//...reimplement it...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"统一多个类的接口设计\"><a href=\"#统一多个类的接口设计\" class=\"headerlink\" title=\"统一多个类的接口设计\"></a>统一多个类的接口设计</h3><ol>\n<li>某个功能的实现依赖多个外部系统（或者说类）。通过适配器模式，将它们的接口适配为统一的接口定义，然后我们就可以使用多态的特性来复用代码逻辑。具体我还是举个例子来解释一下。</li>\n<li>假设我们的系统要对用户输入的文本内容做敏感词过滤，为了提高过滤的召回率，我们引入了多款第三方敏感词过滤系统，依次对用户输入的内容进行过滤，过滤掉尽可能多的敏感词。但是，每个系统提供的过滤接口都是不同的。这就意味着我们没法复用一套逻辑来调用各个系统。这个时候，我们就可以使用适配器模式，将所有系统的接口适配为统一的接口定义，这样我们可以复用调用敏感词过滤的代码。</li>\n<li>你可以配合着下面的代码示例，来理解我刚才举的这个例子。</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.ArrayList;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.List;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ASensitiveWordsFilter</span> &#123; <span class=\"comment\">// A敏感词过滤系统提供的接口</span></span><br><span class=\"line\">  <span class=\"comment\">// text是原始文本，函数输出用***替换敏感词之后的文本</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> String <span class=\"title function_\">filterSexyWords</span><span class=\"params\">(String text)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> String <span class=\"title function_\">filterPoliticalWords</span><span class=\"params\">(String text)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">BSensitiveWordsFilter</span> &#123; <span class=\"comment\">// B敏感词过滤系统提供的接口</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> String <span class=\"title function_\">filter</span><span class=\"params\">(String text)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">CSensitiveWordsFilter</span> &#123; <span class=\"comment\">// C敏感词过滤系统提供的接口</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> String <span class=\"title function_\">filter</span><span class=\"params\">(String text, String mask)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 未使用适配器模式之前的代码：代码的可测试性、扩展性不好</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">RiskManagement</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"type\">ASensitiveWordsFilter</span> <span class=\"variable\">aFilter</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ASensitiveWordsFilter</span>();</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"type\">BSensitiveWordsFilter</span> <span class=\"variable\">bFilter</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">BSensitiveWordsFilter</span>();</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"type\">CSensitiveWordsFilter</span> <span class=\"variable\">cFilter</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">CSensitiveWordsFilter</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> String <span class=\"title function_\">filterSensitiveWords</span><span class=\"params\">(String text)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">maskedText</span> <span class=\"operator\">=</span> aFilter.filterSexyWords(text);</span><br><span class=\"line\">    maskedText = aFilter.filterPoliticalWords(maskedText);</span><br><span class=\"line\">    maskedText = bFilter.filter(maskedText);</span><br><span class=\"line\">    maskedText = cFilter.filter(maskedText, <span class=\"string\">&quot;***&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> maskedText;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用适配器模式进行改造</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">ISensitiveWordsFilter</span> &#123; <span class=\"comment\">// 统一接口定义</span></span><br><span class=\"line\">  String <span class=\"title function_\">filter</span><span class=\"params\">(String text)</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ASensitiveWordsFilterAdaptor</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">ISensitiveWordsFilter</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> ASensitiveWordsFilter aFilter;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> String <span class=\"title function_\">filter</span><span class=\"params\">(String text)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">maskedText</span> <span class=\"operator\">=</span> aFilter.filterSexyWords(text);</span><br><span class=\"line\">    maskedText = aFilter.filterPoliticalWords(maskedText);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> maskedText;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ...省略BSensitiveWordsFilterAdaptor、CSensitiveWordsFilterAdaptor...</span></span><br><span class=\"line\"><span class=\"comment\">// 扩展性更好，更加符合开闭原则，如果添加一个新的敏感词过滤系统，</span></span><br><span class=\"line\"><span class=\"comment\">// 这个类完全不需要改动；而且基于接口而非实现编程，代码的可测试性更好。</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">RiskManagement</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> List&lt;ISensitiveWordsFilter&gt; filters = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">addSensitiveWordsFilter</span><span class=\"params\">(ISensitiveWordsFilter filter)</span> &#123;</span><br><span class=\"line\">    filters.add(filter);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> String <span class=\"title function_\">filterSensitiveWords</span><span class=\"params\">(String text)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">maskedText</span> <span class=\"operator\">=</span> text;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (ISensitiveWordsFilter filter : filters) &#123;</span><br><span class=\"line\">      maskedText = filter.filter(maskedText);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> maskedText;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"替换依赖的外部系统\"><a href=\"#替换依赖的外部系统\" class=\"headerlink\" title=\"替换依赖的外部系统\"></a>替换依赖的外部系统</h3><p>当我们把项目中依赖的一个外部系统替换为另一个外部系统的时候，利用适配器模式，可以减少对代码的改动。具体的代码示例如下所示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 外部系统A</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>  <span class=\"keyword\">interface</span>  <span class=\"title class_\">IA</span>  &#123;</span><br><span class=\"line\"><span class=\"comment\">//...</span></span><br><span class=\"line\">  <span class=\"keyword\">void</span>  <span class=\"title function_\">fa</span><span class=\"params\">()</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span>  <span class=\"keyword\">class</span>  <span class=\"title class_\">A</span>  <span class=\"keyword\">implements</span>  <span class=\"title class_\">IA</span>  &#123;</span><br><span class=\"line\"><span class=\"comment\">//...</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span>  <span class=\"keyword\">void</span>  <span class=\"title function_\">fa</span><span class=\"params\">()</span>  &#123; </span><br><span class=\"line\">    <span class=\"comment\">//... </span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 在我们的项目中，外部系统A的使用示例</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>  <span class=\"keyword\">class</span>  <span class=\"title class_\">Demo</span>  &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> IA a;</span><br><span class=\"line\">  <span class=\"keyword\">public</span>  <span class=\"title function_\">Demo</span><span class=\"params\">(IA a)</span>  &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.a = a;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//... </span></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">Demo</span> <span class=\"variable\">d</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Demo</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">A</span>());</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 将外部系统A替换成外部系统B</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>  <span class=\"keyword\">class</span>  <span class=\"title class_\">BAdaptor</span>  implemnts  IA  &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> B b;</span><br><span class=\"line\">  <span class=\"keyword\">public</span>  <span class=\"title function_\">BAdaptor</span><span class=\"params\">(B b)</span>  &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.b= b;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span>  <span class=\"keyword\">void</span>  <span class=\"title function_\">fa</span><span class=\"params\">()</span>  &#123;</span><br><span class=\"line\">  <span class=\"comment\">//...</span></span><br><span class=\"line\">    b.fb();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 借助BAdaptor，Demo的代码中，调用IA接口的地方都无需改动，</span></span><br><span class=\"line\"><span class=\"comment\">// 只需要将BAdaptor如下注入到Demo即可。</span></span><br><span class=\"line\"><span class=\"type\">Demo</span> <span class=\"variable\">d</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Demo</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">BAdaptor</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">B</span>()));</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"兼容老版本接口\"><a href=\"#兼容老版本接口\" class=\"headerlink\" title=\"兼容老版本接口\"></a>兼容老版本接口</h3><ol>\n<li>在做版本升级的时候，对于一些要废弃的接口，我们不直接将其删除，而是暂时保留，并且标注为 deprecated，并将内部实现逻辑委托为新的接口实现。这样做的好处是，让使用它的项目有个过渡期，而不是强制进行代码修改。这也可以粗略地看作适配器模式的一个应用场景。同样，我还是通过一个例子，来进一步解释一下。</li>\n<li>JDK1.0 中包含一个遍历集合容器的类 Enumeration。JDK2.0 对这个类进行了重构，将它改名为 Iterator 类，并且对它的代码实现做了优化。但是考虑到如果将 Enumeration 直接从 JDK2.0 中删除，那使用 JDK1.0 的项目如果切换到 JDK2.0，代码就会编译不通过。为了避免这种情况的发生，我们必须把项目中所有使用到 Enumeration 的地方，都修改为使用 Iterator 才行。</li>\n<li>单独一个项目做 Enumeration 到 Iterator 的替换，勉强还能接受。但是，使用 Java 开发的项目太多了，一次 JDK 的升级，导致所有的项目不做代码修改就会编译报错，这显然是不合理的。这就是我们经常所说的不兼容升级。为了做到兼容使用低版本 JDK 的老代码，我们可以暂时保留 Enumeration 类，并将其实现替换为直接调用 Itertor。代码示例如下所示：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span>  <span class=\"keyword\">class</span>  <span class=\"title class_\">Collections</span>  &#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span>  <span class=\"keyword\">static</span> Emueration <span class=\"title function_\">emumeration</span><span class=\"params\">(<span class=\"keyword\">final</span> Collection c)</span>  &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>  <span class=\"keyword\">new</span> <span class=\"title class_\">Enumeration</span>() &#123;</span><br><span class=\"line\">      <span class=\"type\">Iterator</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> c.iterator();</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">hasMoreElments</span><span class=\"params\">()</span>  &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> i.hashNext();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">public</span> Object <span class=\"title function_\">nextElement</span><span class=\"params\">()</span>  &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> i.next():</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"适配不同格式的数据\"><a href=\"#适配不同格式的数据\" class=\"headerlink\" title=\"适配不同格式的数据\"></a>适配不同格式的数据</h3><p>前面我们讲到，适配器模式主要用于接口的适配，实际上，它还可以用在不同格式的数据之间的适配。比如，把从不同征信系统拉取的不同格式的征信数据，统一为相同的格式，以方便存储和使用。再比如，Java 中的 Arrays.asList() 也可以看作一种数据适配器，将数组类型的数据转化为集合容器类型。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;String&gt; stooges = Arrays.asList(<span class=\"string\">&quot;Larry&quot;</span>, <span class=\"string\">&quot;Moe&quot;</span>, <span class=\"string\">&quot;Curly&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h3 id=\"剖析适配器模式在-Java-日志中的应用\"><a href=\"#剖析适配器模式在-Java-日志中的应用\" class=\"headerlink\" title=\"剖析适配器模式在 Java 日志中的应用\"></a>剖析适配器模式在 Java 日志中的应用</h3><ol>\n<li>Java 中有很多日志框架，在项目开发中，我们常常用它们来打印日志信息。其中，比较常用的有 log4j、logback，以及 JDK 提供的 JUL(java.util.logging) 和 Apache 的 JCL(Jakarta Commons Logging) 等。</li>\n<li>大部分日志框架都提供了相似的功能，比如按照不同级别（debug、info、warn、erro……）打印日志等，但它们却并没有实现统一的接口。这主要可能是历史的原因，它不像 JDBC 那样，一开始就制定了数据库操作的接口规范。</li>\n<li>如果我们只是开发一个自己用的项目，那用什么日志框架都可以，log4j、logback 随便选一个就好。但是，如果我们开发的是一个集成到其他系统的组件、框架、类库等，那日志框架的选择就没那么随意了。</li>\n<li>比如，项目中用到的某个组件使用 log4j 来打印日志，而我们项目本身使用的是 logback。将组件引入到项目之后，我们的项目就相当于有了两套日志打印框架。每种日志框架都有自己特有的配置方式。所以，我们要针对每种日志框架编写不同的配置文件（比如，日志存储的文件地址、打印日志的格式）。如果引入多个组件，每个组件使用的日志框架都不一样，那日志本身的管理工作就变得非常复杂。所以，为了解决这个问题，我们需要统一日志打印框架。</li>\n<li>如果你是做 Java 开发的，那 Slf4j 这个\b日志框架你肯定不陌生，它相当于 JDBC 规范，提供了一套打印日志的统一接口规范。不过，它只定义了接口，并没有提供具体的实现，需要配合其他日志框架（log4j、logback……）来使用。</li>\n<li>不仅如此，Slf4j 的出现晚于 JUL、JCL、log4j 等日志框架，所以，这些日志框架也不可能牺牲掉版本兼容性，将接口改造成符合 Slf4j 接口规范。Slf4j 也事先考虑到了这个问题，所以，它不仅仅提供了统一的接口定义，还提供了针对不同日志框架的适配器。对不同日志框架的接口进行二次封装，适配成统一的 Slf4j 接口定义。具体的代码示例如下所示：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// slf4j统一的接口定义</span></span><br><span class=\"line\"><span class=\"keyword\">package</span> org.slf4j;</span><br><span class=\"line\"><span class=\"keyword\">public</span>  <span class=\"keyword\">interface</span> <span class=\"title class_\">Logger</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span>  <span class=\"type\">boolean</span> <span class=\"title function_\">isTraceEnabled</span><span class=\"params\">()</span>;</span><br><span class=\"line\">  <span class=\"keyword\">public</span>  <span class=\"keyword\">void</span> <span class=\"title function_\">trace</span><span class=\"params\">(String msg)</span>;</span><br><span class=\"line\">  <span class=\"keyword\">public</span>  <span class=\"keyword\">void</span> <span class=\"title function_\">trace</span><span class=\"params\">(String format, Object arg)</span>;</span><br><span class=\"line\">  <span class=\"keyword\">public</span>  <span class=\"keyword\">void</span> <span class=\"title function_\">trace</span><span class=\"params\">(String format, Object arg1, Object arg2)</span>;</span><br><span class=\"line\">  <span class=\"keyword\">public</span>  <span class=\"keyword\">void</span> <span class=\"title function_\">trace</span><span class=\"params\">(String format, Object[] argArray)</span>;</span><br><span class=\"line\">  <span class=\"keyword\">public</span>  <span class=\"keyword\">void</span> <span class=\"title function_\">trace</span><span class=\"params\">(String msg, Throwable t)</span>;</span><br><span class=\"line\">  <span class=\"keyword\">public</span>  <span class=\"type\">boolean</span> <span class=\"title function_\">isDebugEnabled</span><span class=\"params\">()</span>;</span><br><span class=\"line\">  <span class=\"keyword\">public</span>  <span class=\"keyword\">void</span> <span class=\"title function_\">debug</span><span class=\"params\">(String msg)</span>;</span><br><span class=\"line\">  <span class=\"keyword\">public</span>  <span class=\"keyword\">void</span> <span class=\"title function_\">debug</span><span class=\"params\">(String format, Object arg)</span>;</span><br><span class=\"line\">  <span class=\"keyword\">public</span>  <span class=\"keyword\">void</span> <span class=\"title function_\">debug</span><span class=\"params\">(String format, Object arg1, Object arg2)</span>;</span><br><span class=\"line\">  <span class=\"keyword\">public</span>  <span class=\"keyword\">void</span> <span class=\"title function_\">debug</span><span class=\"params\">(String format, Object[] argArray)</span>;</span><br><span class=\"line\">  <span class=\"keyword\">public</span>  <span class=\"keyword\">void</span> <span class=\"title function_\">debug</span><span class=\"params\">(String msg, Throwable t)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//...省略info、warn、error等一堆接口</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// log4j日志框架的适配器</span></span><br><span class=\"line\"><span class=\"comment\">// Log4jLoggerAdapter实现了LocationAwareLogger接口，</span></span><br><span class=\"line\"><span class=\"comment\">// 其中LocationAwareLogger继承自Logger接口，</span></span><br><span class=\"line\"><span class=\"comment\">// 也就相当于Log4jLoggerAdapter实现了Logger接口。</span></span><br><span class=\"line\"><span class=\"keyword\">package</span> org.slf4j.impl;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Log4jLoggerAdapter</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">MarkerIgnoringBase</span></span><br><span class=\"line\">        <span class=\"keyword\">implements</span> <span class=\"title class_\">LocationAwareLogger</span>, Serializable &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">final</span> <span class=\"keyword\">transient</span> org.apache.log4j.Logger logger; <span class=\"comment\">// log4j</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span>  <span class=\"type\">boolean</span> <span class=\"title function_\">isDebugEnabled</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> logger.isDebugEnabled();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span>  <span class=\"keyword\">void</span> <span class=\"title function_\">debug</span><span class=\"params\">(String msg)</span> &#123;</span><br><span class=\"line\">    logger.log(FQCN, Level.DEBUG, msg, <span class=\"literal\">null</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span>  <span class=\"keyword\">void</span> <span class=\"title function_\">debug</span><span class=\"params\">(String format, Object arg)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class=\"line\">      <span class=\"type\">FormattingTuple</span> <span class=\"variable\">ft</span> <span class=\"operator\">=</span> MessageFormatter.format(format, arg);</span><br><span class=\"line\">      logger.log(FQCN, Level.DEBUG, ft.getMessage(), ft.getThrowable());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span>  <span class=\"keyword\">void</span> <span class=\"title function_\">debug</span><span class=\"params\">(String format, Object arg1, Object arg2)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class=\"line\">      <span class=\"type\">FormattingTuple</span> <span class=\"variable\">ft</span> <span class=\"operator\">=</span> MessageFormatter.format(format, arg1, arg2);</span><br><span class=\"line\">      logger.log(FQCN, Level.DEBUG, ft.getMessage(), ft.getThrowable());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span>  <span class=\"keyword\">void</span> <span class=\"title function_\">debug</span><span class=\"params\">(String format, Object\\[\\] argArray)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class=\"line\">      <span class=\"type\">FormattingTuple</span> <span class=\"variable\">ft</span> <span class=\"operator\">=</span> MessageFormatter.arrayFormat(format, argArray);</span><br><span class=\"line\">      logger.log(FQCN, Level.DEBUG, ft.getMessage(), ft.getThrowable());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span>  <span class=\"keyword\">void</span> <span class=\"title function_\">debug</span><span class=\"params\">(String msg, Throwable t)</span> &#123;</span><br><span class=\"line\">    logger.log(FQCN, Level.DEBUG, msg, t);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//...省略一堆接口的实现...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<ol>\n<li>所以，在开发业务系统或者开发框架、组件的时候，我们统一使用 Slf4j 提供的接口来编写打印日志的代码，具体使用哪种日志框架实现（log4j、logback……），是可以动态地指定的（使用 Java 的 SPI 技术，这里我不多解释，你自行研究吧），只需要将相应的 SDK 导入到项目中即可。</li>\n<li>不过，你可能会说，如果一些老的项目没有使用 Slf4j，而是直接使用比如 JCL 来打印日志，那如果想要替换成其他日志框架，比如 log4j，该怎么办呢？实际上，Slf4j 不仅仅提供了从其他日志框架到 Slf4j 的适配器，还提供了反向适配器，也就是从 Slf4j 到其他日志框架的适配。我们可以先将 JCL 切换为 Slf4j，然后再将 Slf4j 切换为 log4j。经过两次适配器的转换，我们能就成功将 log4j 切换为了 logback。</li>\n</ol>\n<h2 id=\"代理、桥接、装饰器、适配器-4-种设计模式的区别\"><a href=\"#代理、桥接、装饰器、适配器-4-种设计模式的区别\" class=\"headerlink\" title=\"代理、桥接、装饰器、适配器 4 种设计模式的区别\"></a>代理、桥接、装饰器、适配器 4 种设计模式的区别</h2><ol>\n<li><p>代理、桥接、装饰器、适配器，这 4 种模式是比较常用的结构型设计模式。它们的代码结构非常相似。笼统来说，它们都可以称为 Wrapper 模式，也就是通过 Wrapper 类二次封装原始类。</p>\n</li>\n<li><p>尽管代码结构相似，但这 4 种设计模式的用意完全不同，也就是说要解决的问题、应用场景不同，这也是它们的主要区别。这里我就简单说一下它们之间的区别。</p>\n</li>\n</ol>\n<ul>\n<li>代理模式：在不改变原始类接口的条件下，为原始类定义一个代理类，主要目的是控制访问，而非加强功能，这是它跟装饰器模式最大的不同。</li>\n<li>桥接模式：目的是将接口部分和实现部分分离，从而让它们可以较为容易、也相对独立地加以改变。</li>\n<li>装饰者模式：在不改变原始类接口的情况下，对原始类功能进行增强，并且支持多个装饰器的嵌套使用。</li>\n<li>适配器模式：是一种事后的补救策略。适配器提供跟原始类不同的接口，而代理模式、装饰器模式提供的都是跟原始类相同的接口。</li>\n</ul>\n","site":{"data":{}},"cover_type":"img","excerpt":"","more":"<h1 id=\"声明\"><a href=\"#声明\" class=\"headerlink\" title=\"声明\"></a>声明</h1><blockquote>\n<ol>\n<li>此系列文章非本人原创，是学习笔记。</li>\n<li>设计模式系列以后会持续更新，包括已经发布的设计模式文章，因为后续还要再多看一下书，教程和开源项目等，继续润色文章。</li>\n</ol>\n</blockquote>\n<h1 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h1><p>创建型模式比较好理解，后面的结构型和行为型设计模式不是那么好理解。如果遇到不好理解的设计模式，我一般会在开头举比较简单的Demo案例来帮助理解。</p>\n<h1 id=\"代理模式【常用】\"><a href=\"#代理模式【常用】\" class=\"headerlink\" title=\"代理模式【常用】\"></a>代理模式【常用】</h1><ol>\n<li>前面几节，我们讲了设计模式中的创建型模式。创建型模式主要解决对象的创建问题，封装复杂的创建过程，解耦对象的创建代码和使用代码。</li>\n<li>其中，单例模式用来创建全局唯一的对象。工厂模式用来创建不同但是相关类型的对象（继承同一父类或者接口的一组子类），由给定的参数来决定创建哪种类型的对象。建造者模式是用来创建复杂对象，可以通过设置不同的可选参数，“定制化”地创建不同的对象。原型模式针对创建成本比较大的对象，利用对已有对象进行复制的方式进行创建，以达到节省创建时间的目的。</li>\n<li>现在，我们讲另外一种类型的设计模式：结构型模式。结构型模式主要总结了一些类或对象组合在一起的经典结构，这些经典的结构可以解决特定应用场景的问题。结构型模式包括：代理模式、桥接模式、装饰器模式、适配器模式、门面模式、组合模式、享元模式。今天我们要讲其中的代理模式。它也是在实际开发中经常被用到的一种设计模式。</li>\n<li>代理模式有不同的形式, 主要有三种 <strong>静态代理</strong>、<strong>动态代理</strong> (JDK 代理、接口代理)和 <strong>Cglib</strong> <strong>代理</strong> (可以在内存 动态的创建对象，而不需要实现接口， 他是属于动态代理的范畴) 。下面先通过几个比较简单的例子理解一下代理模式</li>\n</ol>\n<h2 id=\"静态代理\"><a href=\"#静态代理\" class=\"headerlink\" title=\"静态代理\"></a>静态代理</h2><p>实例具体要求 </p>\n<ol>\n<li>定义一个接口:ITeacherDao </li>\n<li>目标对象 TeacherDAO 实现接口 ITeacherDAO </li>\n<li>使用静态代理方式,就需要在代理对象 TeacherDAOProxy 中也实现 ITeacherDAO </li>\n<li>调用的时候通过调用代理对象的方法来调用目标对象. </li>\n<li>特别提醒：静态代理类与被代理类要实现相同的接口,然后通过调用相同的方法来调用目标对象的方法</li>\n</ol>\n<blockquote>\n<p><strong>ITeacherDao</strong></p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//接口</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">ITeacherDao</span> &#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">void</span> <span class=\"title function_\">teach</span><span class=\"params\">()</span>; <span class=\"comment\">// 授课的方法</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<blockquote>\n<p><strong>TeacherDao</strong> —&gt; 被代理类</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">TeacherDao</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">ITeacherDao</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">teach</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// TODO Auto-generated method stub</span></span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot; 老师授课中  。。。。。&quot;</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<blockquote>\n<p><strong>TeacherDaoProxy</strong> —&gt; 代理类</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//代理对象,静态代理</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">TeacherDaoProxy</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">ITeacherDao</span>&#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> ITeacherDao target; <span class=\"comment\">// 目标对象，通过接口来聚合</span></span><br><span class=\"line\">\t</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">//构造器</span></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"title function_\">TeacherDaoProxy</span><span class=\"params\">(ITeacherDao target)</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">this</span>.target = target;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">teach</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// TODO Auto-generated method stub</span></span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;开始代理  完成某些操作。。。。。 &quot;</span>);<span class=\"comment\">//方法</span></span><br><span class=\"line\">\t\ttarget.teach();</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;提交。。。。。&quot;</span>);<span class=\"comment\">//方法</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<blockquote>\n<p>Client</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Client</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// TODO Auto-generated method stub</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//创建目标对象(被代理对象)</span></span><br><span class=\"line\">\t\t<span class=\"type\">TeacherDao</span> <span class=\"variable\">teacherDao</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">TeacherDao</span>();</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"comment\">//创建代理对象, 同时将被代理对象传递给代理对象</span></span><br><span class=\"line\">\t\t<span class=\"type\">TeacherDaoProxy</span> <span class=\"variable\">teacherDaoProxy</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">TeacherDaoProxy</span>(teacherDao);</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"comment\">//通过代理对象，调用到被代理对象的方法</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//即：执行的是代理对象的方法，代理对象再去调用目标对象的方法 </span></span><br><span class=\"line\">\t\tteacherDaoProxy.teach();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h2 id=\"动态代理\"><a href=\"#动态代理\" class=\"headerlink\" title=\"动态代理\"></a>动态代理</h2><ol>\n<li>代理对象,不需要实现接口，但是目标对象要实现接口，否则不能用动态代理 </li>\n<li>代理对象的生成，是利用 JDK 的 API，动态的在内存中构建代理对象 </li>\n<li>动态代理也叫做：JDK 代理、接口代理</li>\n<li>代理类所在包:java.lang.reflect.Proxy </li>\n<li>JDK 实现代理只需要使用 <strong>newProxyInstance</strong> 方法,但是该方法需要接收三个参数,完整的写法是:</li>\n</ol>\n<p>static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces,InvocationHandler h ) </p>\n<blockquote>\n<p>ITeacherDao</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//接口</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">ITeacherDao</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">void</span> <span class=\"title function_\">teach</span><span class=\"params\">()</span>; <span class=\"comment\">// 授课方法</span></span><br><span class=\"line\">   <span class=\"keyword\">void</span> <span class=\"title function_\">sayHello</span><span class=\"params\">(String name)</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<blockquote>\n<p>TeacherDao</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">TeacherDao</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">ITeacherDao</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"meta\">@Override</span></span><br><span class=\"line\">   <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">teach</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// TODO Auto-generated method stub</span></span><br><span class=\"line\">      System.out.println(<span class=\"string\">&quot; 老师授课中.... &quot;</span>);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"meta\">@Override</span></span><br><span class=\"line\">   <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">sayHello</span><span class=\"params\">(String name)</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// TODO Auto-generated method stub</span></span><br><span class=\"line\">      System.out.println(<span class=\"string\">&quot;hello &quot;</span> + name);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<blockquote>\n<p>ProxyFactory</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.lang.reflect.InvocationHandler;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.lang.reflect.Method;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.lang.reflect.Proxy;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ProxyFactory</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">//维护一个目标对象 , Object</span></span><br><span class=\"line\">   <span class=\"keyword\">private</span> Object target;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">//构造器 ， 对target 进行初始化</span></span><br><span class=\"line\">   <span class=\"keyword\">public</span> <span class=\"title function_\">ProxyFactory</span><span class=\"params\">(Object target)</span> &#123;</span><br><span class=\"line\">      </span><br><span class=\"line\">      <span class=\"built_in\">this</span>.target = target;</span><br><span class=\"line\">   &#125; </span><br><span class=\"line\">   </span><br><span class=\"line\">   <span class=\"comment\">//给目标对象 生成一个代理对象</span></span><br><span class=\"line\">   <span class=\"keyword\">public</span> Object <span class=\"title function_\">getProxyInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">      </span><br><span class=\"line\">      <span class=\"comment\">/* 说明</span></span><br><span class=\"line\"><span class=\"comment\">         public static Object newProxyInstance(ClassLoader loader,</span></span><br><span class=\"line\"><span class=\"comment\">                                          Class&lt;?&gt;[] interfaces,</span></span><br><span class=\"line\"><span class=\"comment\">                                          InvocationHandler h)</span></span><br><span class=\"line\"><span class=\"comment\">                                          </span></span><br><span class=\"line\"><span class=\"comment\">            1. ClassLoader loader ： 指定当前目标对象使用的类加载器, 获取加载器的方法固定</span></span><br><span class=\"line\"><span class=\"comment\">            2. Class&lt;?&gt;[] interfaces: 目标对象实现的接口类型，使用泛型方法确认类型</span></span><br><span class=\"line\"><span class=\"comment\">            3. InvocationHandler h : 事情处理，执行目标对象的方法时，会触发事情处理器方法, </span></span><br><span class=\"line\"><span class=\"comment\">             会把当前执行的目标对象方法作为参数传入</span></span><br><span class=\"line\"><span class=\"comment\">       */</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> Proxy.newProxyInstance(target.getClass().getClassLoader(), </span><br><span class=\"line\">            target.getClass().getInterfaces(), </span><br><span class=\"line\">            <span class=\"keyword\">new</span> <span class=\"title class_\">InvocationHandler</span>() &#123;</span><br><span class=\"line\">               </span><br><span class=\"line\">               <span class=\"meta\">@Override</span></span><br><span class=\"line\">               <span class=\"keyword\">public</span> Object <span class=\"title function_\">invoke</span><span class=\"params\">(Object proxy, Method method, Object[] args)</span> <span class=\"keyword\">throws</span> Throwable &#123;</span><br><span class=\"line\">                  <span class=\"comment\">// TODO Auto-generated method stub</span></span><br><span class=\"line\">                  System.out.println(<span class=\"string\">&quot;JDK代理开始~~&quot;</span>);</span><br><span class=\"line\">                  <span class=\"comment\">//反射机制调用目标对象的方法</span></span><br><span class=\"line\">                  <span class=\"type\">Object</span> <span class=\"variable\">returnVal</span> <span class=\"operator\">=</span> method.invoke(target, args);</span><br><span class=\"line\">                  System.out.println(<span class=\"string\">&quot;JDK代理提交&quot;</span>);</span><br><span class=\"line\">                  <span class=\"keyword\">return</span> returnVal;</span><br><span class=\"line\">               &#125;</span><br><span class=\"line\">            &#125;); </span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<blockquote>\n<p>Client</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Client &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">   public static void main(String[] args) &#123;</span><br><span class=\"line\">      // TODO Auto-generated method stub</span><br><span class=\"line\">      //创建目标对象</span><br><span class=\"line\">      ITeacherDao target = new TeacherDao();</span><br><span class=\"line\">      </span><br><span class=\"line\">      //给目标对象，创建代理对象, 可以转成 ITeacherDao</span><br><span class=\"line\">      ITeacherDao proxyInstance = (ITeacherDao)new ProxyFactory(target).getProxyInstance();</span><br><span class=\"line\">   </span><br><span class=\"line\">      // proxyInstance=class com.sun.proxy.$Proxy0 内存中动态生成了代理对象</span><br><span class=\"line\">      System.out.println(&quot;proxyInstance=&quot; + proxyInstance.getClass());</span><br><span class=\"line\">      </span><br><span class=\"line\">      //通过代理对象，调用目标对象的方法</span><br><span class=\"line\">      //proxyInstance.teach();</span><br><span class=\"line\">      </span><br><span class=\"line\">      proxyInstance.sayHello(&quot; tom &quot;);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"cglib代理\"><a href=\"#cglib代理\" class=\"headerlink\" title=\"cglib代理\"></a>cglib代理</h2><ol>\n<li><p>静态代理和 JDK 代理模式都要求目标对象是实现一个接口,但是有时候目标对象只是一个单独的对象,并没有实现任何的接口,这个时候可使用目标对象子类来实现代理-这就是Cglib代理</p>\n</li>\n<li><p>Cglib代理也叫作<strong>子类代理</strong>**,**它是在内存中构建一个子类对象从而实现对目标对象功能扩展, 有些书也将Cglib代理归属到动态代理。 </p>\n</li>\n<li><p>Cglib 是一个强大的高性能的代码生成包,它可以在运行期扩展 java 类与实现 java 接口.它广泛的被许多 AOP 的 框架使用,例如 Spring AOP，实现方法拦截 </p>\n</li>\n<li><p>在 AOP 编程中如何选择代理模式： </p>\n<ul>\n<li><p>目标对象需要实现接口，用 JDK 代理 </p>\n</li>\n<li><p>目标对象不需要实现接口，用 Cglib 代理</p>\n</li>\n</ul>\n</li>\n<li><p>Cglib 包的底层是通过使用字节码处理框架 ASM 来转换字节码并生成新的类</p>\n</li>\n<li><p>需要引入 cglib 的 jar 文件，在内存中动态构建子类，注意代理的类不能为 final，否则报错 </p>\n<p><code>java.lang.IllegalArgumentException</code>，目标对象的方法如果为 final&#x2F;static,那么就不会被拦截,即不会执行目标对象额外的业务方法.</p>\n</li>\n</ol>\n<blockquote>\n<p>TeacherDao</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">TeacherDao</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">public</span> String <span class=\"title function_\">teach</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">      System.out.println(<span class=\"string\">&quot; 老师授课中  ， 我是cglib代理，不需要实现接口 &quot;</span>);</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"string\">&quot;hello&quot;</span>;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<blockquote>\n<p>ProxyFactory</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.lang.reflect.Method;</span><br><span class=\"line\"><span class=\"keyword\">import</span> net.sf.cglib.proxy.Enhancer;</span><br><span class=\"line\"><span class=\"keyword\">import</span> net.sf.cglib.proxy.MethodInterceptor;</span><br><span class=\"line\"><span class=\"keyword\">import</span> net.sf.cglib.proxy.MethodProxy;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ProxyFactory</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">MethodInterceptor</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">//维护一个目标对象</span></span><br><span class=\"line\">   <span class=\"keyword\">private</span> Object target;</span><br><span class=\"line\">   </span><br><span class=\"line\">   <span class=\"comment\">//构造器，传入一个被代理的对象</span></span><br><span class=\"line\">   <span class=\"keyword\">public</span> <span class=\"title function_\">ProxyFactory</span><span class=\"params\">(Object target)</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.target = target;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">//返回一个代理对象:  是 target 对象的代理对象</span></span><br><span class=\"line\">   <span class=\"keyword\">public</span> Object <span class=\"title function_\">getProxyInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">//1. 创建一个工具类</span></span><br><span class=\"line\">      <span class=\"type\">Enhancer</span> <span class=\"variable\">enhancer</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Enhancer</span>();</span><br><span class=\"line\">      <span class=\"comment\">//2. 设置父类</span></span><br><span class=\"line\">      enhancer.setSuperclass(target.getClass());</span><br><span class=\"line\">      <span class=\"comment\">//3. 设置回调函数</span></span><br><span class=\"line\">      enhancer.setCallback(<span class=\"built_in\">this</span>);</span><br><span class=\"line\">      <span class=\"comment\">//4. 创建子类对象，即代理对象</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> enhancer.create();</span><br><span class=\"line\">      </span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   </span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">//重写  intercept 方法，会调用目标对象的方法</span></span><br><span class=\"line\">   <span class=\"meta\">@Override</span></span><br><span class=\"line\">   <span class=\"keyword\">public</span> Object <span class=\"title function_\">intercept</span><span class=\"params\">(Object arg0, Method method, Object[] args, MethodProxy arg3)</span> <span class=\"keyword\">throws</span> Throwable &#123;</span><br><span class=\"line\">      <span class=\"comment\">// TODO Auto-generated method stub</span></span><br><span class=\"line\">      System.out.println(<span class=\"string\">&quot;Cglib代理模式 ~~ 开始&quot;</span>);</span><br><span class=\"line\">      <span class=\"type\">Object</span> <span class=\"variable\">returnVal</span> <span class=\"operator\">=</span> method.invoke(target, args);</span><br><span class=\"line\">      System.out.println(<span class=\"string\">&quot;Cglib代理模式 ~~ 提交&quot;</span>);</span><br><span class=\"line\">      <span class=\"keyword\">return</span> returnVal;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<blockquote>\n<p>Client</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Client</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// TODO Auto-generated method stub</span></span><br><span class=\"line\">      <span class=\"comment\">//创建目标对象</span></span><br><span class=\"line\">      <span class=\"type\">TeacherDao</span> <span class=\"variable\">target</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">TeacherDao</span>();</span><br><span class=\"line\">      <span class=\"comment\">//获取到代理对象，并且将目标对象传递给代理对象</span></span><br><span class=\"line\">      <span class=\"type\">TeacherDao</span> <span class=\"variable\">proxyInstance</span> <span class=\"operator\">=</span> (TeacherDao)<span class=\"keyword\">new</span> <span class=\"title class_\">ProxyFactory</span>(target).getProxyInstance();</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">//执行代理对象的方法，触发intecept 方法，从而实现 对目标对象的调用</span></span><br><span class=\"line\">      <span class=\"type\">String</span> <span class=\"variable\">res</span> <span class=\"operator\">=</span> proxyInstance.teach();</span><br><span class=\"line\">      System.out.println(<span class=\"string\">&quot;res=&quot;</span> + res);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"代理模式的原理解析\"><a href=\"#代理模式的原理解析\" class=\"headerlink\" title=\"代理模式的原理解析\"></a>代理模式的原理解析</h2><ol>\n<li>代理模式（Proxy Design Pattern）的原理和代码实现都不难掌握。它在不改变原始类（或叫被代理类）代码的情况下，通过引入代理类来给原始类附加功能【<strong>装饰器是增强功能，代理是附加新的功能</strong>】。我们通过一个简单的例子来解释一下这段话。</li>\n<li>我们开发了一个 MetricsCollector 类，用来收集接口请求的原始数据，比如访问时间、处理时长等。在业务系统中，我们采用如下方式来使用这个 MetricsCollector 类：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">UserController</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">//...省略其他属性和方法...</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> MetricsCollector metricsCollector; <span class=\"comment\">// 依赖注入</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> UserVo <span class=\"title function_\">login</span><span class=\"params\">(String telephone, String password)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"variable\">startTimestamp</span> <span class=\"operator\">=</span> System.currentTimeMillis();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// ... 省略login逻辑...</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"variable\">endTimeStamp</span> <span class=\"operator\">=</span> System.currentTimeMillis();</span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"variable\">responseTime</span> <span class=\"operator\">=</span> endTimeStamp - startTimestamp;</span><br><span class=\"line\">    <span class=\"type\">RequestInfo</span> <span class=\"variable\">requestInfo</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RequestInfo</span>(<span class=\"string\">&quot;login&quot;</span>, responseTime, startTimestamp);</span><br><span class=\"line\">    metricsCollector.recordRequest(requestInfo);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//...返回UserVo数据...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> UserVo <span class=\"title function_\">register</span><span class=\"params\">(String telephone, String password)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"variable\">startTimestamp</span> <span class=\"operator\">=</span> System.currentTimeMillis();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// ... 省略register逻辑...</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"variable\">endTimeStamp</span> <span class=\"operator\">=</span> System.currentTimeMillis();</span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"variable\">responseTime</span> <span class=\"operator\">=</span> endTimeStamp - startTimestamp;</span><br><span class=\"line\">    <span class=\"type\">RequestInfo</span> <span class=\"variable\">requestInfo</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RequestInfo</span>(<span class=\"string\">&quot;register&quot;</span>, responseTime, startTimestamp);</span><br><span class=\"line\">    metricsCollector.recordRequest(requestInfo);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//...返回UserVo数据...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>很明显，上面的写法有两个问题。第一，性能计数器框架代码侵入到业务代码中，跟业务代码高度耦合。如果未来需要替换这个框架，那替换的成本会比较大。第二，收集接口请求的代码跟业务代码无关，本就不应该放到一个类中。业务类最好职责更加单一，只聚焦业务处理。</li>\n<li>为了将框架代码和业务代码解耦，代理模式就派上用场了。代理类 UserControllerProxy 和原始类 UserController 实现相同的接口 IUserController。UserController 类只负责业务功能。代理类 UserControllerProxy 负责在业务代码执行前后附加其他逻辑代码，并通过委托的方式调用原始类来执行业务代码。具体的代码实现如下所示：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">IUserController</span> &#123;</span><br><span class=\"line\">  UserVo <span class=\"title function_\">login</span><span class=\"params\">(String telephone, String password)</span>;</span><br><span class=\"line\">  UserVo <span class=\"title function_\">register</span><span class=\"params\">(String telephone, String password)</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">UserController</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">IUserController</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">//...省略其他属性和方法...</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> UserVo <span class=\"title function_\">login</span><span class=\"params\">(String telephone, String password)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//...省略login逻辑...</span></span><br><span class=\"line\">    <span class=\"comment\">//...返回UserVo数据...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> UserVo <span class=\"title function_\">register</span><span class=\"params\">(String telephone, String password)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//...省略register逻辑...</span></span><br><span class=\"line\">    <span class=\"comment\">//...返回UserVo数据...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">UserControllerProxy</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">IUserController</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> MetricsCollector metricsCollector;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> UserController userController;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"title function_\">UserControllerProxy</span><span class=\"params\">(UserController userController)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.userController = userController;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.metricsCollector = <span class=\"keyword\">new</span> <span class=\"title class_\">MetricsCollector</span>();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> UserVo <span class=\"title function_\">login</span><span class=\"params\">(String telephone, String password)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"variable\">startTimestamp</span> <span class=\"operator\">=</span> System.currentTimeMillis();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 委托</span></span><br><span class=\"line\">    <span class=\"type\">UserVo</span> <span class=\"variable\">userVo</span> <span class=\"operator\">=</span> userController.login(telephone, password);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"variable\">endTimeStamp</span> <span class=\"operator\">=</span> System.currentTimeMillis();</span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"variable\">responseTime</span> <span class=\"operator\">=</span> endTimeStamp - startTimestamp;</span><br><span class=\"line\">    <span class=\"type\">RequestInfo</span> <span class=\"variable\">requestInfo</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RequestInfo</span>(<span class=\"string\">&quot;login&quot;</span>, responseTime, startTimestamp);</span><br><span class=\"line\">    metricsCollector.recordRequest(requestInfo);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> userVo;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> UserVo <span class=\"title function_\">register</span><span class=\"params\">(String telephone, String password)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"variable\">startTimestamp</span> <span class=\"operator\">=</span> System.currentTimeMillis();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">UserVo</span> <span class=\"variable\">userVo</span> <span class=\"operator\">=</span> userController.register(telephone, password);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"variable\">endTimeStamp</span> <span class=\"operator\">=</span> System.currentTimeMillis();</span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"variable\">responseTime</span> <span class=\"operator\">=</span> endTimeStamp - startTimestamp;</span><br><span class=\"line\">    <span class=\"type\">RequestInfo</span> <span class=\"variable\">requestInfo</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RequestInfo</span>(<span class=\"string\">&quot;register&quot;</span>, responseTime, startTimestamp);</span><br><span class=\"line\">    metricsCollector.recordRequest(requestInfo);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> userVo;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//UserControllerProxy使用举例</span></span><br><span class=\"line\"><span class=\"comment\">//因为原始类和代理类实现相同的接口，是基于接口而非实现编程</span></span><br><span class=\"line\"><span class=\"comment\">//将UserController类对象替换为UserControllerProxy类对象，不需要改动太多代码</span></span><br><span class=\"line\"><span class=\"type\">IUserController</span> <span class=\"variable\">userController</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">UserControllerProxy</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">UserController</span>());</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>参照基于接口而非实现编程的设计思想，将原始类对象替换为代理类对象的时候，为了让代码改动尽量少，在刚刚的代理模式的代码实现中，代理类和原始类需要实现相同的接口。但是，如果原始类并没有定义接口，并且原始类代码并不是我们开发维护的（比如它来自一个第三方的类库），我们也没办法直接修改原始类，给它重新定义一个接口。在这种情况下，我们该如何实现代理模式呢？</li>\n<li>对于这种外部类的扩展，我们一般都是采用继承的方式。这里也不例外。我们让代理类继承原始类，然后扩展附加功能。原理很简单，不需要过多解释，你直接看代码就能明白。具体代码如下所示：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">UserControllerProxy</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">UserController</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> MetricsCollector metricsCollector;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"title function_\">UserControllerProxy</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.metricsCollector = <span class=\"keyword\">new</span> <span class=\"title class_\">MetricsCollector</span>();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> UserVo <span class=\"title function_\">login</span><span class=\"params\">(String telephone, String password)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"variable\">startTimestamp</span> <span class=\"operator\">=</span> System.currentTimeMillis();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">UserVo</span> <span class=\"variable\">userVo</span> <span class=\"operator\">=</span> <span class=\"built_in\">super</span>.login(telephone, password);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"variable\">endTimeStamp</span> <span class=\"operator\">=</span> System.currentTimeMillis();</span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"variable\">responseTime</span> <span class=\"operator\">=</span> endTimeStamp - startTimestamp;</span><br><span class=\"line\">    <span class=\"type\">RequestInfo</span> <span class=\"variable\">requestInfo</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RequestInfo</span>(<span class=\"string\">&quot;login&quot;</span>, responseTime, startTimestamp);</span><br><span class=\"line\">    metricsCollector.recordRequest(requestInfo);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> userVo;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> UserVo <span class=\"title function_\">register</span><span class=\"params\">(String telephone, String password)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"variable\">startTimestamp</span> <span class=\"operator\">=</span> System.currentTimeMillis();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">UserVo</span> <span class=\"variable\">userVo</span> <span class=\"operator\">=</span> <span class=\"built_in\">super</span>.register(telephone, password);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"variable\">endTimeStamp</span> <span class=\"operator\">=</span> System.currentTimeMillis();</span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"variable\">responseTime</span> <span class=\"operator\">=</span> endTimeStamp - startTimestamp;</span><br><span class=\"line\">    <span class=\"type\">RequestInfo</span> <span class=\"variable\">requestInfo</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RequestInfo</span>(<span class=\"string\">&quot;register&quot;</span>, responseTime, startTimestamp);</span><br><span class=\"line\">    metricsCollector.recordRequest(requestInfo);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> userVo;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//UserControllerProxy使用举例</span></span><br><span class=\"line\"><span class=\"type\">UserController</span> <span class=\"variable\">userController</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">UserControllerProxy</span>();</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"动态代理的原理解析\"><a href=\"#动态代理的原理解析\" class=\"headerlink\" title=\"动态代理的原理解析\"></a>动态代理的原理解析</h2><ol>\n<li>不过，刚刚的代码实现还是有点问题。一方面，我们需要在代理类中，将原始类中的所有的方法，都重新实现一遍，并且为每个方法都附加相似的代码逻辑。另一方面，如果要添加的附加功能的类有不止一个，我们需要针对每个类都创建一个代理类。</li>\n<li>如果有 50 个要添加附加功能的原始类，那我们就要创建 50  个对应的代理类。这会导致项目中类的个数成倍增加，增加了代码维护成本。并且，每个代理类中的代码都有点像模板式的“重复”代码，也增加了不必要的开发成本。那这个问题怎么解决呢？</li>\n<li>我们可以使用动态代理来解决这个问题。所谓动态代理（Dynamic  Proxy），就是我们不事先为每个原始类编写代理类，而是在运行的时候，动态地创建原始类对应的代理类，然后在系统中用代理类替换掉原始类。那如何实现动态代理呢？</li>\n<li>如果你熟悉的是 Java 语言，实现动态代理就是件很简单的事情。因为 Java 语言本身就已经提供了动态代理的语法（实际上，动态代理底层依赖的就是 Java  的反射语法）。我们来看一下，如何用 Java 的动态代理来实现刚刚的功能。具体的代码如下所示。其中，MetricsCollectorProxy  作为一个动态代理类，动态地给每个需要收集接口请求信息的类创建代理类。</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">MetricsCollectorProxy</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> MetricsCollector metricsCollector;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"title function_\">MetricsCollectorProxy</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.metricsCollector = <span class=\"keyword\">new</span> <span class=\"title class_\">MetricsCollector</span>();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> Object <span class=\"title function_\">createProxy</span><span class=\"params\">(Object proxiedObject)</span> &#123;</span><br><span class=\"line\">    Class&lt;?&gt;[] interfaces = proxiedObject.getClass().getInterfaces();</span><br><span class=\"line\">    <span class=\"type\">DynamicProxyHandler</span> <span class=\"variable\">handler</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">DynamicProxyHandler</span>(proxiedObject);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Proxy.newProxyInstance(proxiedObject.getClass().getClassLoader(), interfaces, handler);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">class</span> <span class=\"title class_\">DynamicProxyHandler</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">InvocationHandler</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Object proxiedObject;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">DynamicProxyHandler</span><span class=\"params\">(Object proxiedObject)</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.proxiedObject = proxiedObject;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Object <span class=\"title function_\">invoke</span><span class=\"params\">(Object proxy, Method method, Object[] args)</span> <span class=\"keyword\">throws</span> Throwable &#123;</span><br><span class=\"line\">      <span class=\"type\">long</span> <span class=\"variable\">startTimestamp</span> <span class=\"operator\">=</span> System.currentTimeMillis();</span><br><span class=\"line\">      <span class=\"type\">Object</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> method.invoke(proxiedObject, args);</span><br><span class=\"line\">      <span class=\"type\">long</span> <span class=\"variable\">endTimeStamp</span> <span class=\"operator\">=</span> System.currentTimeMillis();</span><br><span class=\"line\">      <span class=\"type\">long</span> <span class=\"variable\">responseTime</span> <span class=\"operator\">=</span> endTimeStamp - startTimestamp;</span><br><span class=\"line\">      <span class=\"type\">String</span> <span class=\"variable\">apiName</span> <span class=\"operator\">=</span> proxiedObject.getClass().getName() + <span class=\"string\">&quot;:&quot;</span> + method.getName();</span><br><span class=\"line\">      <span class=\"type\">RequestInfo</span> <span class=\"variable\">requestInfo</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RequestInfo</span>(apiName, responseTime, startTimestamp);</span><br><span class=\"line\">      metricsCollector.recordRequest(requestInfo);</span><br><span class=\"line\">      <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//MetricsCollectorProxy使用举例</span></span><br><span class=\"line\"><span class=\"type\">MetricsCollectorProxy</span> <span class=\"variable\">proxy</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">MetricsCollectorProxy</span>();</span><br><span class=\"line\"><span class=\"type\">IUserController</span> <span class=\"variable\">userController</span> <span class=\"operator\">=</span> (IUserController) proxy.createProxy(<span class=\"keyword\">new</span> <span class=\"title class_\">UserController</span>());</span><br></pre></td></tr></table></figure>\n\n\n\n<p>实际上，Spring AOP  底层的实现原理就是基于动态代理。用户\b配置好需要给哪些类创建代理，并定义好在执行原始类的业务代码前后执行哪些附加功能。Spring  为这些类创建动态代理对象，并在 JVM  中替代原始类对象。原本在代码中执行的原始类的方法，被换作执行代理类的方法，也就实现了给原始类添加附加功能的目的。</p>\n<h2 id=\"代理模式的应用场景\"><a href=\"#代理模式的应用场景\" class=\"headerlink\" title=\"代理模式的应用场景\"></a>代理模式的应用场景</h2><h3 id=\"业务系统的非功能性需求开发\"><a href=\"#业务系统的非功能性需求开发\" class=\"headerlink\" title=\"业务系统的非功能性需求开发\"></a>业务系统的非功能性需求开发</h3><p>代理模式最常用的一个应用场景就是，在业务系统中开发一些非功能性需求，比如：监控、统计、鉴权、限流、事务、幂等、日志。我们将这些附加功能与业务功能解耦，放到代理类中统一处理，让程序员只需要关注业务方面的开发。实际上，前面举的搜集接口请求信息的例子，就是这个应用场景的一个典型例子。</p>\n<p>如果你熟悉 Java 语言和 Spring 开发框架，这部分工作都是可以在 Spring AOP 切面中完成的。前面我们也提到，Spring AOP  底层的实现原理就是基于动态代理。</p>\n<h3 id=\"代理模式在-RPC、缓存中的应用\"><a href=\"#代理模式在-RPC、缓存中的应用\" class=\"headerlink\" title=\"代理模式在 RPC、缓存中的应用\"></a>代理模式在 RPC、缓存中的应用</h3><p>实际上，RPC  框架也可以看作一种代理模式，GoF 的《设计模式》一书中把它称作远程代理。通过远程代理，将网络通信、数据编解码等细节隐藏起来。客户端在使用  RPC 服务的时候，就像使用本地函数一样，无需了解跟服务器交互的细节。除此之外，RPC  服务的开发者也只需要开发业务逻辑，就像开发本地使用的函数一样，不需要关注跟客户端的交互细节。</p>\n<h3 id=\"代理模式在缓存中的应用\"><a href=\"#代理模式在缓存中的应用\" class=\"headerlink\" title=\"代理模式在缓存中的应用\"></a>代理模式在缓存中的应用</h3><ol>\n<li>假设我们要开发一个接口请求的缓存功能，对于某些接口请求，如果入参相同，在设定的过期时间内，直接返回缓存结果，而不用重新进行逻辑处理。比如，针对获取用户个人信息的需求，我们可以开发两个接口，一个支持缓存，一个支持实时查询。对于需要实时数据的需求，我们让其调用实时查询接口，对于不需要实时数据的需求，我们让其调用支持缓存的接口。那如何来实现接口请求的缓存功能呢？</li>\n<li>最简单的实现方法就是刚刚我们讲到的，给每个需要支持缓存的查询需求都开发两个不同的接口，一个支持缓存，一个支持实时查询。但是，这样做显然增加了开发成本，而且会让代码看起来非常臃肿（接口个数成倍增加），也不方便缓存接口的集中管理（增加、删除缓存接口）、集中配置（比如配置每个接口缓存过期时间）。</li>\n<li>针对这些问题，代理模式就能派上用场了，确切地说，应该是动态代理。如果是基于 Spring 框架来开发的话，那就可以在 AOP  切面中完成接口缓存的功能。在应用启动的时候，我们从配置文件中加载需要支持缓存的接口，以及相应的缓存策略（比如过期时间）等。当请求到来的时候，我们在 AOP 切面中拦截请求，如果请求中带有支持缓存的字段（比如  http:&#x2F;&#x2F;…?..&amp;cached&#x3D;true），我们便从缓存（内存缓存或者 Redis 缓存等）中获取数据直接返回。</li>\n</ol>\n<h1 id=\"桥接模式【常用】\"><a href=\"#桥接模式【常用】\" class=\"headerlink\" title=\"桥接模式【常用】\"></a>桥接模式【常用】</h1><ol>\n<li>上一节我们学习了第一种结构型模式：代理模式。它在不改变原始类（或者叫被代理类）代码的情况下，通过引入代理类来给原始类附加功能。代理模式在平时的开发经常被用到，常用在业务系统中开发一些非功能性需求，比如：监控、统计、鉴权、限流、事务、幂等、日志。</li>\n<li>今天，我们再学习另外一种结构型模式：桥接模式。桥接模式的代码实现非常简单，但是理解起来稍微有点难度，并且应用场景也比较局限，所以，相当于代理模式来说，桥接模式在实际的项目中并没有那么常用，你只需要简单了解，见到能认识就可以，并不是我们学习的重点。</li>\n<li>我们依旧是先看比较简单的例子</li>\n</ol>\n<h2 id=\"Demo案例-手机操作问题\"><a href=\"#Demo案例-手机操作问题\" class=\"headerlink\" title=\"Demo案例-手机操作问题\"></a>Demo案例-手机操作问题</h2><h3 id=\"需求\"><a href=\"#需求\" class=\"headerlink\" title=\"需求\"></a>需求</h3><p>现在对不同手机类型的不同品牌实现操作编程(比如:开机、关机、上网，打电话等)，如图:</p>\n<img src=\"https://npm.elemecdn.com/youthlql@1.0.0/design_patterns/structural_type/04.01/0001.png\"/>\n\n\n\n<h3 id=\"传统方案解决手机操作问题分析\"><a href=\"#传统方案解决手机操作问题分析\" class=\"headerlink\" title=\"传统方案解决手机操作问题分析\"></a>传统方案解决手机操作问题分析</h3><p>传统方法对应的类图</p>\n<img src=\"https://npm.elemecdn.com/youthlql@1.0.0/design_patterns/structural_type/04.01/0007.png\"/>\n\n<ol>\n<li>扩展性问题(<strong>类爆炸</strong>)，如果我们再增加手机的样式(旋转式)，就需要增加各个品牌手机的类，同样如果我们增加一个手机品牌，也要在各个手机样式类下增加。 </li>\n<li>违反了单一职责原则，当我们增加手机样式时，要同时增加所有品牌的手机，这样增加了代码维护成本.</li>\n<li>解决方案-使用<strong>桥接模</strong>式 </li>\n<li>Bridge 模式基于类的最小设计原则，通过使用封装、聚合及继承等行为让不同的类承担不同的职责。它的主要特点是把抽象(Abstraction)与行为实现(Implementation)分离开来，从而可以保持各部分的独立性以及应对他们的功能扩展</li>\n</ol>\n<h3 id=\"使用桥接模式的代码\"><a href=\"#使用桥接模式的代码\" class=\"headerlink\" title=\"使用桥接模式的代码\"></a>使用桥接模式的代码</h3><h4 id=\"Brand【接口】\"><a href=\"#Brand【接口】\" class=\"headerlink\" title=\"Brand【接口】\"></a>Brand【接口】</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//接口</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">Brand</span> &#123;</span><br><span class=\"line\">   <span class=\"keyword\">void</span> <span class=\"title function_\">open</span><span class=\"params\">()</span>;</span><br><span class=\"line\">   <span class=\"keyword\">void</span> <span class=\"title function_\">close</span><span class=\"params\">()</span>;</span><br><span class=\"line\">   <span class=\"keyword\">void</span> <span class=\"title function_\">call</span><span class=\"params\">()</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Phone【抽象类】\"><a href=\"#Phone【抽象类】\" class=\"headerlink\" title=\"Phone【抽象类】\"></a>Phone【抽象类】</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Phone</span> &#123;</span><br><span class=\"line\">   </span><br><span class=\"line\">   <span class=\"comment\">//组合品牌</span></span><br><span class=\"line\">   <span class=\"keyword\">private</span> Brand brand;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">//构造器</span></span><br><span class=\"line\">   <span class=\"keyword\">public</span> <span class=\"title function_\">Phone</span><span class=\"params\">(Brand brand)</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">super</span>();</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.brand = brand;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   </span><br><span class=\"line\">   <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">open</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.brand.open();</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">close</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">      brand.close();</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">call</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">      brand.call();</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Vivo\"><a href=\"#Vivo\" class=\"headerlink\" title=\"Vivo\"></a>Vivo</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Vivo</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Brand</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"meta\">@Override</span></span><br><span class=\"line\">   <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">open</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// TODO Auto-generated method stub</span></span><br><span class=\"line\">      System.out.println(<span class=\"string\">&quot; Vivo手机开机 &quot;</span>);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"meta\">@Override</span></span><br><span class=\"line\">   <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">close</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// TODO Auto-generated method stub</span></span><br><span class=\"line\">      System.out.println(<span class=\"string\">&quot; Vivo手机关机 &quot;</span>);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"meta\">@Override</span></span><br><span class=\"line\">   <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">call</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// TODO Auto-generated method stub</span></span><br><span class=\"line\">      System.out.println(<span class=\"string\">&quot; Vivo手机打电话 &quot;</span>);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"XiaoMi\"><a href=\"#XiaoMi\" class=\"headerlink\" title=\"XiaoMi\"></a>XiaoMi</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">XiaoMi</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Brand</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"meta\">@Override</span></span><br><span class=\"line\">   <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">open</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// TODO Auto-generated method stub</span></span><br><span class=\"line\">      System.out.println(<span class=\"string\">&quot; 小米手机开机 &quot;</span>);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"meta\">@Override</span></span><br><span class=\"line\">   <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">close</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// TODO Auto-generated method stub</span></span><br><span class=\"line\">      System.out.println(<span class=\"string\">&quot; 小米手机关机 &quot;</span>);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"meta\">@Override</span></span><br><span class=\"line\">   <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">call</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// TODO Auto-generated method stub</span></span><br><span class=\"line\">      System.out.println(<span class=\"string\">&quot; 小米手机打电话 &quot;</span>);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"FoldedPhone\"><a href=\"#FoldedPhone\" class=\"headerlink\" title=\"FoldedPhone\"></a>FoldedPhone</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//折叠式手机类，继承 抽象类 Phone</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">FoldedPhone</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Phone</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">//构造器</span></span><br><span class=\"line\">   <span class=\"keyword\">public</span> <span class=\"title function_\">FoldedPhone</span><span class=\"params\">(Brand brand)</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">super</span>(brand);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   </span><br><span class=\"line\">   <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">open</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">super</span>.open();</span><br><span class=\"line\">      System.out.println(<span class=\"string\">&quot; 折叠样式手机 &quot;</span>);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   </span><br><span class=\"line\">   <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">close</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">super</span>.close();</span><br><span class=\"line\">      System.out.println(<span class=\"string\">&quot; 折叠样式手机 &quot;</span>);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   </span><br><span class=\"line\">   <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">call</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">super</span>.call();</span><br><span class=\"line\">      System.out.println(<span class=\"string\">&quot; 折叠样式手机 &quot;</span>);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"UpRightPhone\"><a href=\"#UpRightPhone\" class=\"headerlink\" title=\"UpRightPhone\"></a>UpRightPhone</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">UpRightPhone</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Phone</span> &#123;</span><br><span class=\"line\">   </span><br><span class=\"line\">      <span class=\"comment\">//构造器</span></span><br><span class=\"line\">      <span class=\"keyword\">public</span> <span class=\"title function_\">UpRightPhone</span><span class=\"params\">(Brand brand)</span> &#123;</span><br><span class=\"line\">         <span class=\"built_in\">super</span>(brand);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      </span><br><span class=\"line\">      <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">open</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">         <span class=\"built_in\">super</span>.open();</span><br><span class=\"line\">         System.out.println(<span class=\"string\">&quot; 直立样式手机 &quot;</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      </span><br><span class=\"line\">      <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">close</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">         <span class=\"built_in\">super</span>.close();</span><br><span class=\"line\">         System.out.println(<span class=\"string\">&quot; 直立样式手机 &quot;</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      </span><br><span class=\"line\">      <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">call</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">         <span class=\"built_in\">super</span>.call();</span><br><span class=\"line\">         System.out.println(<span class=\"string\">&quot; 直立样式手机 &quot;</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"Client\"><a href=\"#Client\" class=\"headerlink\" title=\"Client\"></a>Client</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Client &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">   public static void main(String[] args) &#123;</span><br><span class=\"line\">      </span><br><span class=\"line\">      //获取折叠式手机 (样式 + 品牌 )</span><br><span class=\"line\">      </span><br><span class=\"line\">      Phone phone1 = new FoldedPhone(new XiaoMi());</span><br><span class=\"line\">      </span><br><span class=\"line\">      phone1.open();</span><br><span class=\"line\">      phone1.call();</span><br><span class=\"line\">      phone1.close();</span><br><span class=\"line\">      </span><br><span class=\"line\">      System.out.println(&quot;=======================&quot;);</span><br><span class=\"line\">      </span><br><span class=\"line\">      Phone phone2 = new FoldedPhone(new Vivo());</span><br><span class=\"line\">      </span><br><span class=\"line\">      phone2.open();</span><br><span class=\"line\">      phone2.call();</span><br><span class=\"line\">      phone2.close();</span><br><span class=\"line\">      </span><br><span class=\"line\">      System.out.println(&quot;==============&quot;);</span><br><span class=\"line\">      </span><br><span class=\"line\">      UpRightPhone phone3 = new UpRightPhone(new XiaoMi());</span><br><span class=\"line\">      </span><br><span class=\"line\">      phone3.open();</span><br><span class=\"line\">      phone3.call();</span><br><span class=\"line\">      phone3.close();</span><br><span class=\"line\">      </span><br><span class=\"line\">      System.out.println(&quot;==============&quot;);</span><br><span class=\"line\">      </span><br><span class=\"line\">      UpRightPhone phone4 = new UpRightPhone(new Vivo());</span><br><span class=\"line\">      </span><br><span class=\"line\">      phone4.open();</span><br><span class=\"line\">      phone4.call();</span><br><span class=\"line\">      phone4.close();</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<blockquote>\n<p>这种简单的demo例子可能比较好理解桥接模式，下面来看看原理和实际应用</p>\n</blockquote>\n<h2 id=\"桥接模式的原理解析\"><a href=\"#桥接模式的原理解析\" class=\"headerlink\" title=\"桥接模式的原理解析\"></a>桥接模式的原理解析</h2><ol>\n<li>桥接模式，也叫作桥梁模式，英文是Bridge Design Pattern。这个模式可以说是 23 种设计模式中最难理解的模式之一了。我查阅了比较多的书籍和资料之后发现，对于这个模式有两种不同的理解方式。</li>\n<li>当然，这其中“最纯正”的理解方式，当属 GoF 的《设计模式》一书中对桥接模式的定义。毕竟，这 23 种经典的设计模式，最初就是由这本书总结出来的。在 GoF 的《设计模式》一书中，桥接模式是这么定义的：“Decouple an abstraction from its implementation so that the two can vary independently。”翻译成中文就是：“将抽象和实现解耦，让它们可以独立变化。”</li>\n<li>关于桥接模式，很多书籍、资料中，还有另外一种理解方式：“一个类存在两个（或多个）独立变化的维度，我们通过组合的方式，让这两个（或多个）维度可以独立进行扩展。”通过组合关系来替代继承关系，避免继承层次的指数级爆炸。这种理解方式非常类似于，我们之前讲过的“组合优于继承”设计原则，所以，这里我就不多解释了。我们重点看下 GoF 的理解方式。</li>\n<li>GoF 给出的定义非常的简短，单凭这一句话，估计没几个人能看懂是什么意思。所以，我们通过 JDBC 驱动的例子来解释一下。JDBC 驱动是桥接模式的经典应用。我们先来看一下，如何利用 JDBC 驱动来查询数据库。具体的代码如下所示：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Class.forName(<span class=\"string\">&quot;com.mysql.jdbc.Driver&quot;</span>); <span class=\"comment\">// 加载及注册JDBC驱动程序</span></span><br><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">url</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;jdbc:mysql://localhost:3306/sample_db?user=root&amp;password=your_password&quot;</span>;</span><br><span class=\"line\"><span class=\"type\">Connection</span> <span class=\"variable\">con</span> <span class=\"operator\">=</span> DriverManager.getConnection(url);</span><br><span class=\"line\"><span class=\"type\">Statement</span> <span class=\"variable\">stmt</span> <span class=\"operator\">=</span> con.createStatement();</span><br><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">query</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;select * from test&quot;</span>;</span><br><span class=\"line\"><span class=\"type\">ResultSet</span> <span class=\"variable\">rs</span> <span class=\"operator\">=</span> stmt.executeQuery(query);</span><br><span class=\"line\"><span class=\"keyword\">while</span> (rs.next()) &#123;</span><br><span class=\"line\">  rs.getString(<span class=\"number\">1</span>);</span><br><span class=\"line\">  rs.getInt(<span class=\"number\">2</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<ol>\n<li>如果我们想要把 MySQL 数据库换成 Oracle 数据库，只需要把第一行代码中的 com.mysql.jdbc.Driver 换成 oracle.jdbc.driver.OracleDriver 就可以了。当然，也有更灵活的实现方式，我们可以把需要加载的 Driver 类写到配置文件中，当程序启动的时候，自动从配置文件中加载，这样在切换数据库的时候，我们都不需要修改代码，只需要修改配置文件就可以了。</li>\n<li>不管是改代码还是改配置，在项目中，从一个数据库切换到另一种数据库，都只需要改动很少的代码，或者完全不需要改动代码，那如此优雅的数据库切换是如何实现的呢？</li>\n<li>源码之下无秘密。要弄清楚这个问题，我们先从 com.mysql.jdbc.Driver 这个类的代码看起。我摘抄了部分相关代码，放到了这里，你可以看一下。</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.mysql.jdbc;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.sql.SQLException;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Driver</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">NonRegisteringDriver</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">java</span>.sql.Driver &#123;</span><br><span class=\"line\">  <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      java.sql.DriverManager.registerDriver(<span class=\"keyword\">new</span> <span class=\"title class_\">Driver</span>());</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (SQLException E) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RuntimeException</span>(<span class=\"string\">&quot;Can&#x27;t register driver!&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * Construct a new driver and register it with DriverManager</span></span><br><span class=\"line\"><span class=\"comment\">   * <span class=\"doctag\">@throws</span> SQLException if a database error occurs.</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"title function_\">Driver</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> SQLException &#123;</span><br><span class=\"line\">  <span class=\"comment\">// Required for Class.forName().newInstance()</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<p>结合 com.mysql.jdbc.Driver 的代码实现，我们可以发现，当执行 Class.forName(“com.mysql.jdbc.Driver”) 这条语句的时候，实际上是做了两件事情。第一件事情是要求 JVM 查找并加载指定的 Driver 类，第二件事情是执行该类的静态代码，也就是将 MySQL Driver 注册到 DriverManager 类中。</p>\n<p>现在，我们再来看一下，DriverManager 类是干什么用的。具体的代码如下所示。当我们把具体的 Driver 实现类（比如，com.mysql.jdbc.Driver）注册到 DriverManager 之后，后续所有对 JDBC 接口的调用，都会委派到对具体的 Driver 实现类来执行。而 Driver 实现类都实现了相同的接口（java.sql.Driver ），这也是可以灵活切换 Driver 的原因。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">DriverManager</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span>  CopyOnWriteArrayList&lt;DriverInfo&gt; registeredDrivers =  = <span class=\"keyword\">new</span> <span class=\"title class_\">CopyOnWriteArrayList</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">    loadInitialDrivers();</span><br><span class=\"line\">    println(<span class=\"string\">&quot;JDBC DriverManager initialized&quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title function_\">registerDriver</span><span class=\"params\">(java.sql.Driver driver)</span> <span class=\"keyword\">throws</span> SQLException &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (driver != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      registeredDrivers.addIfAbsent(<span class=\"keyword\">new</span> <span class=\"title class_\">DriverInfo</span>(driver));</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">NullPointerException</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Connection <span class=\"title function_\">getConnection</span><span class=\"params\">(String url, String user, String password)</span></span><br><span class=\"line\">      <span class=\"keyword\">throws</span> SQLException &#123;</span><br><span class=\"line\">    java.util.<span class=\"type\">Properties</span> <span class=\"variable\">info</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">java</span>.util.Properties();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (user != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      info.put(<span class=\"string\">&quot;user&quot;</span>, user);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (password != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      info.put(<span class=\"string\">&quot;password&quot;</span>, password);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> (getConnection(url, info, Reflection.getCallerClass()));</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<p>桥接模式的定义是“将抽象和实现解耦，让它们可以独立变化”。那弄懂定义中“抽象”和“实现”两个概念，就是理解桥接模式的关键。那在 JDBC 这个例子中，什么是“抽象”？什么是“实现”呢？</p>\n<p>实际上，JDBC 本身就相当于“抽象”。注意，这里所说的“抽象”，指的并非“抽象类”或“接口”，而是跟具体的数据库无关的、被抽象出来的一套“类库”。具体的 Driver（比如，com.mysql.jdbc.Driver）就相当于“实现”。注意，这里所说的“实现”，也并非指“接口的实现类”，而是跟具体数据库相关的一套“类库”。JDBC 和 Driver 独立开发，通过对象之间的组合关系，组装在一起。JDBC 的所有逻辑操作，最终都委托给 Driver 来执行。</p>\n<img src=\"https://npm.elemecdn.com/youthlql@1.0.0/design_patterns/structural_type/04.01/0002.png\">\n\n\n\n<h2 id=\"桥接模式的应用举例\"><a href=\"#桥接模式的应用举例\" class=\"headerlink\" title=\"桥接模式的应用举例\"></a>桥接模式的应用举例</h2><p>在前面，我们讲过一个 API 接口监控告警的例子：根据不同的告警规则，触发不同类型的告警。告警支持多种通知渠道，包括：邮件、短信、微信、自动语音电话。通知的紧急程度有多种类型，包括：SEVERE（严重）、URGENCY（紧急）、NORMAL（普通）、TRIVIAL（无关紧要）。不同的紧急程度对应不同的通知渠道。比如，SERVE（严重）级别的消息会通过“自动语音电话”告知相关人员。</p>\n<p>在当时的代码实现中，关于发送告警信息那部分代码，我们只给出了粗略的设计，现在我们来一块实现一下。我们先来看最简单、最直接的一种实现方式。代码如下所示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">enum</span> <span class=\"title class_\">NotificationEmergencyLevel</span> &#123;</span><br><span class=\"line\">  SEVERE,</span><br><span class=\"line\">  URGENCY,</span><br><span class=\"line\">  NORMAL,</span><br><span class=\"line\">  TRIVIAL</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Notification</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> List&lt;String&gt; emailAddresses;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> List&lt;String&gt; telephones;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> List&lt;String&gt; wechatIds;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"title function_\">Notification</span><span class=\"params\">()</span> &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setEmailAddress</span><span class=\"params\">(List&lt;String&gt; emailAddress)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.emailAddresses = emailAddress;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setTelephones</span><span class=\"params\">(List&lt;String&gt; telephones)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.telephones = telephones;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setWechatIds</span><span class=\"params\">(List&lt;String&gt; wechatIds)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.wechatIds = wechatIds;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">notify</span><span class=\"params\">(NotificationEmergencyLevel level, String message)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (level.equals(NotificationEmergencyLevel.SEVERE)) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// ...自动语音电话</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (level.equals(NotificationEmergencyLevel.URGENCY)) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// ...发微信</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (level.equals(NotificationEmergencyLevel.NORMAL)) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// ...发邮件</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (level.equals(NotificationEmergencyLevel.TRIVIAL)) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// ...发邮件</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 在API监控告警的例子中，我们如下方式来使用Notification类：</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ErrorAlertHandler</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">AlertHandler</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"title function_\">ErrorAlertHandler</span><span class=\"params\">(AlertRule rule, Notification notification)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">super</span>(rule, notification);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">check</span><span class=\"params\">(ApiStatInfo apiStatInfo)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (apiStatInfo.getErrorCount()</span><br><span class=\"line\">        &gt; rule.getMatchedRule(apiStatInfo.getApi()).getMaxErrorCount()) &#123;</span><br><span class=\"line\">      notification.notify(NotificationEmergencyLevel.SEVERE, <span class=\"string\">&quot;...&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<ol>\n<li>Notification 类的代码实现有一个最明显的问题，那就是有很多 if-else 分支逻辑。实际上，如果每个分支中的代码都不复杂，后期也没有无限膨胀的可能（增加更多 if-else 分支判断），那这样的设计问题并不大，没必要非得一定要摒弃 if-else 分支逻辑。</li>\n<li>不过，Notification 的代码显然不符合这个条件。因为每个 if-else 分支中的代码逻辑都比较复杂，发送通知的所有逻辑都扎堆在 Notification 类中。我们知道，类的代码越多，就越难读懂，越难修改，维护的成本也就越高。很多设计模式都是试图将庞大的类拆分成更细小的类，然后再通过某种更合理的结构组装在一起。</li>\n<li>针对 Notification 的代码，我们将不同渠道的发送逻辑剥离出来，形成独立的消息发送类（MsgSender 相关类）。其中，Notification 类相当于抽象，MsgSender 类相当于实现，两者可以独立开发，通过组合关系（也就是桥梁）任意组合在一起。所谓任意组合的意思就是，不同紧急程度的消息和发送渠道之间的对应关系，不是在代码中固定写死的，我们可以动态地去指定（比如，通过读取配置来获取对应关系）。</li>\n</ol>\n<p>按照这个设计思路，我们对代码进行重构。重构之后的代码如下所示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">MsgSender</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">void</span> <span class=\"title function_\">send</span><span class=\"params\">(String message)</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">TelephoneMsgSender</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">MsgSender</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> List&lt;String&gt; telephones;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"title function_\">TelephoneMsgSender</span><span class=\"params\">(List&lt;String&gt; telephones)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.telephones = telephones;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">send</span><span class=\"params\">(String message)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">EmailMsgSender</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">MsgSender</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 与TelephoneMsgSender代码结构类似，所以省略...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">WechatMsgSender</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">MsgSender</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 与TelephoneMsgSender代码结构类似，所以省略...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Notification</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">protected</span> MsgSender msgSender;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"title function_\">Notification</span><span class=\"params\">(MsgSender msgSender)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.msgSender = msgSender;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title function_\">notify</span><span class=\"params\">(String message)</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">SevereNotification</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Notification</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"title function_\">SevereNotification</span><span class=\"params\">(MsgSender msgSender)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">super</span>(msgSender);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">notify</span><span class=\"params\">(String message)</span> &#123;</span><br><span class=\"line\">    msgSender.send(message);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">UrgencyNotification</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Notification</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 与SevereNotification代码结构类似，所以省略...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">NormalNotification</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Notification</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 与SevereNotification代码结构类似，所以省略...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">TrivialNotification</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Notification</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 与SevereNotification代码结构类似，所以省略...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"桥接模式的注意事项和细节\"><a href=\"#桥接模式的注意事项和细节\" class=\"headerlink\" title=\"桥接模式的注意事项和细节\"></a>桥接模式的注意事项和细节</h2><ol>\n<li>实现了抽象和实现部分的分离，从而极大的提供了系统的灵活性，让抽象部分和实现部分独立开来，这有助于系统进行分层设计，从而产生更好的结构化系统。 </li>\n<li>对于系统的高层部分，只需要知道抽象部分和实现部分的接口就可以了，其它的部分由具体业务来完成。</li>\n<li>桥接模式替代多层继承方案，可以减少子类的个数，降低系统的管理和维护成本</li>\n<li>桥接模式的引入增加了系统的理解和设计难度，由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设计和编程 </li>\n<li>桥接模式要求**正确识别出系统中两个独立变化的维度(抽象、和实现)**，因此其使用范围有一定的局限性，即需要有这样的应用场景。</li>\n</ol>\n<h1 id=\"装饰器模式【常用】\"><a href=\"#装饰器模式【常用】\" class=\"headerlink\" title=\"装饰器模式【常用】\"></a>装饰器模式【常用】</h1><p>我们学习了桥接模式，桥接模式有两种理解方式。第一种理解方式是“将抽象和实现解耦，让它们能独立开发”。这种理解方式比较特别，应用场景也不多。另一种理解方式更加简单，类似“组合优于继承”设计原则，这种理解方式更加通用，应用场景比较多。不管是哪种理解方式，它们的代码结构都是相同的，都是一种类之间的组合关系。</p>\n<p>今天，我们通过剖析 Java IO 类的设计思想，再学习一种新的结构型模式，装饰器模式。它的代码结构跟桥接模式非常相似，不过，要解决的问题却大不相同。</p>\n<blockquote>\n<p>不过还是先看一个简单的demo案例，会比较好理解</p>\n</blockquote>\n<h2 id=\"Demo案例-咖啡订单项目\"><a href=\"#Demo案例-咖啡订单项目\" class=\"headerlink\" title=\"Demo案例-咖啡订单项目\"></a>Demo案例-咖啡订单项目</h2><h3 id=\"星巴克咖啡订单项目\"><a href=\"#星巴克咖啡订单项目\" class=\"headerlink\" title=\"星巴克咖啡订单项目\"></a>星巴克咖啡订单项目</h3><ol>\n<li>咖啡种类&#x2F;单品咖啡：Espresso(意大利浓咖啡)、ShortBlack、LongBlack(美式咖啡)、Decaf(无因咖啡) </li>\n<li>调料：Milk、Soy(豆浆)、Chocolate </li>\n<li>要求在扩展新的咖啡种类时，具有良好的扩展性、改动方便、维护方便 </li>\n<li>使用 OO 的来计算不同种类咖啡的费用: 客户可以点单品咖啡，也可以单品咖啡+调料组合。</li>\n</ol>\n<h3 id=\"方案一\"><a href=\"#方案一\" class=\"headerlink\" title=\"方案一\"></a>方案一</h3><img src=\"https://npm.elemecdn.com/youthlql@1.0.0/design_patterns/structural_type/04.01/0003.png\"/>\n\n\n\n<ol>\n<li>Drink 是一个抽象类，表示饮料 </li>\n<li>des 就是对咖啡的描述, 比如咖啡的名字 </li>\n<li>cost() 方法就是计算费用，Drink 类中做成一个抽象方法. </li>\n<li>Decaf 就是单品咖啡， 继承 Drink, 并实现 cost </li>\n<li>Espress &amp;&amp; Milk 就是单品咖啡+调料， 这个组合很多</li>\n<li>问题：<strong>这样设计，会有很多类，当我们增加一个单品咖啡，或者一个新的调料，类的数量就会倍增，就会出现类爆炸</strong></li>\n</ol>\n<h3 id=\"方案二\"><a href=\"#方案二\" class=\"headerlink\" title=\"方案二\"></a>方案二</h3><p>前面分析到方案 1 因为咖啡单品+调料组合会造成类的倍增，因此可以做改进，将调料内置到 Drink 类，这样就不会造成类数量过多。从而提高项目的维护性(如图)</p>\n<img src=\"https://npm.elemecdn.com/youthlql@1.0.0/design_patterns/structural_type/04.01/0004.png\">\n\n\n\n<ol>\n<li>方案 2 可以控制类的数量，不至于造成很多的类 </li>\n<li>在增加或者删除调料种类时，代码的维护量很大 </li>\n<li>考虑到用户可以添加多份 调料时，可以将 hasMilk 返回一个对应 int </li>\n<li>考虑使用 <strong>装饰者</strong> 模式</li>\n</ol>\n<blockquote>\n<p>注意：装饰器模式是对功能的增强，而不是附加新的功能。代理模式才是附加新的功能。</p>\n</blockquote>\n<h3 id=\"装饰器模式代码\"><a href=\"#装饰器模式代码\" class=\"headerlink\" title=\"装饰器模式代码\"></a>装饰器模式代码</h3><img src=\"https://npm.elemecdn.com/youthlql@1.0.0/design_patterns/structural_type/04.01/0005.png\"/>\n\n<h4 id=\"Drink【抽象类-主体Component】\"><a href=\"#Drink【抽象类-主体Component】\" class=\"headerlink\" title=\"Drink【抽象类-主体Component】\"></a>Drink【抽象类-主体Component】</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Drink</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">public</span> String des; <span class=\"comment\">// 描述</span></span><br><span class=\"line\">   <span class=\"keyword\">private</span> <span class=\"type\">float</span> <span class=\"variable\">price</span> <span class=\"operator\">=</span> <span class=\"number\">0.0f</span>;</span><br><span class=\"line\">   <span class=\"keyword\">public</span> String <span class=\"title function_\">getDes</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> des;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setDes</span><span class=\"params\">(String des)</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.des = des;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"keyword\">public</span> <span class=\"type\">float</span> <span class=\"title function_\">getPrice</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> price;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setPrice</span><span class=\"params\">(<span class=\"type\">float</span> price)</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.price = price;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   </span><br><span class=\"line\">   <span class=\"comment\">//计算费用的抽象方法</span></span><br><span class=\"line\">   <span class=\"comment\">//子类来实现</span></span><br><span class=\"line\">   <span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"type\">float</span> <span class=\"title function_\">cost</span><span class=\"params\">()</span>;</span><br><span class=\"line\">   </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"Decorator\"><a href=\"#Decorator\" class=\"headerlink\" title=\"Decorator\"></a>Decorator</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Decorator</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Drink</span> &#123;</span><br><span class=\"line\">   <span class=\"keyword\">private</span> Drink obj;</span><br><span class=\"line\">   </span><br><span class=\"line\">   <span class=\"keyword\">public</span> <span class=\"title function_\">Decorator</span><span class=\"params\">(Drink obj)</span> &#123; <span class=\"comment\">//组合</span></span><br><span class=\"line\">      <span class=\"comment\">// TODO Auto-generated constructor stub</span></span><br><span class=\"line\">      <span class=\"built_in\">this</span>.obj = obj;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   </span><br><span class=\"line\">   <span class=\"meta\">@Override</span></span><br><span class=\"line\">   <span class=\"keyword\">public</span> <span class=\"type\">float</span> <span class=\"title function_\">cost</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// TODO Auto-generated method stub</span></span><br><span class=\"line\">      <span class=\"comment\">// getPrice 自己价格</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"built_in\">super</span>.getPrice() + obj.cost();</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   </span><br><span class=\"line\">   <span class=\"meta\">@Override</span></span><br><span class=\"line\">   <span class=\"keyword\">public</span> String <span class=\"title function_\">getDes</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// TODO Auto-generated method stub</span></span><br><span class=\"line\">      <span class=\"comment\">// obj.getDes() 输出被装饰者的信息</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> des + <span class=\"string\">&quot; &quot;</span> + getPrice() + <span class=\"string\">&quot; &amp;&amp; &quot;</span> + obj.getDes();</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Coffee\"><a href=\"#Coffee\" class=\"headerlink\" title=\"Coffee\"></a>Coffee</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Coffee extends Drink &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  @Override</span><br><span class=\"line\">  public float cost() &#123;</span><br><span class=\"line\">    // TODO Auto-generated method stub</span><br><span class=\"line\">    return super.getPrice();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"ShortBlack\"><a href=\"#ShortBlack\" class=\"headerlink\" title=\"ShortBlack\"></a>ShortBlack</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ShortBlack</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Coffee</span>&#123;</span><br><span class=\"line\">   </span><br><span class=\"line\">   <span class=\"keyword\">public</span> <span class=\"title function_\">ShortBlack</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">      setDes(<span class=\"string\">&quot; shortblack &quot;</span>);</span><br><span class=\"line\">      setPrice(<span class=\"number\">4.0f</span>);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"LongBlack\"><a href=\"#LongBlack\" class=\"headerlink\" title=\"LongBlack\"></a>LongBlack</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">LongBlack</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Coffee</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">public</span> <span class=\"title function_\">LongBlack</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">      setDes(<span class=\"string\">&quot; longblack &quot;</span>);</span><br><span class=\"line\">      setPrice(<span class=\"number\">5.0f</span>);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"DeCaf\"><a href=\"#DeCaf\" class=\"headerlink\" title=\"DeCaf\"></a>DeCaf</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">DeCaf</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Coffee</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">public</span> <span class=\"title function_\">DeCaf</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">      setDes(<span class=\"string\">&quot; 无因咖啡 &quot;</span>);</span><br><span class=\"line\">      setPrice(<span class=\"number\">1.0f</span>);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Espresso\"><a href=\"#Espresso\" class=\"headerlink\" title=\"Espresso\"></a>Espresso</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Espresso</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Coffee</span> &#123;</span><br><span class=\"line\">   </span><br><span class=\"line\">   <span class=\"keyword\">public</span> <span class=\"title function_\">Espresso</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">      setDes(<span class=\"string\">&quot; 意大利咖啡 &quot;</span>);</span><br><span class=\"line\">      setPrice(<span class=\"number\">6.0f</span>);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Chocolate\"><a href=\"#Chocolate\" class=\"headerlink\" title=\"Chocolate\"></a>Chocolate</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//具体的Decorator， 这里就是调味品</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Chocolate</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Decorator</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">public</span> <span class=\"title function_\">Chocolate</span><span class=\"params\">(Drink obj)</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">super</span>(obj);</span><br><span class=\"line\">      setDes(<span class=\"string\">&quot; 巧克力 &quot;</span>);</span><br><span class=\"line\">      setPrice(<span class=\"number\">3.0f</span>); <span class=\"comment\">// 调味品 的价格</span></span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Milk\"><a href=\"#Milk\" class=\"headerlink\" title=\"Milk\"></a>Milk</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Milk</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Decorator</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">public</span> <span class=\"title function_\">Milk</span><span class=\"params\">(Drink obj)</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">super</span>(obj);</span><br><span class=\"line\">      <span class=\"comment\">// TODO Auto-generated constructor stub</span></span><br><span class=\"line\">      setDes(<span class=\"string\">&quot; 牛奶 &quot;</span>);</span><br><span class=\"line\">      setPrice(<span class=\"number\">2.0f</span>); </span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Soy\"><a href=\"#Soy\" class=\"headerlink\" title=\"Soy\"></a>Soy</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Soy</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Decorator</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">public</span> <span class=\"title function_\">Soy</span><span class=\"params\">(Drink obj)</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">super</span>(obj);</span><br><span class=\"line\">      <span class=\"comment\">// TODO Auto-generated constructor stub</span></span><br><span class=\"line\">      setDes(<span class=\"string\">&quot; 豆浆  &quot;</span>);</span><br><span class=\"line\">      setPrice(<span class=\"number\">1.5f</span>);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"CoffeeBar\"><a href=\"#CoffeeBar\" class=\"headerlink\" title=\"CoffeeBar\"></a>CoffeeBar</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">CoffeeBar</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// TODO Auto-generated method stub</span></span><br><span class=\"line\">      <span class=\"comment\">// 装饰者模式下的订单：2份巧克力+一份牛奶的LongBlack</span></span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// 1. 点一份 LongBlack</span></span><br><span class=\"line\">      <span class=\"type\">Drink</span> <span class=\"variable\">order</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">LongBlack</span>();</span><br><span class=\"line\">      System.out.println(<span class=\"string\">&quot;费用1=&quot;</span> + order.cost());</span><br><span class=\"line\">      System.out.println(<span class=\"string\">&quot;描述=&quot;</span> + order.getDes());</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// 2. order 加入一份牛奶</span></span><br><span class=\"line\">      order = <span class=\"keyword\">new</span> <span class=\"title class_\">Milk</span>(order);</span><br><span class=\"line\"></span><br><span class=\"line\">      System.out.println(<span class=\"string\">&quot;order 加入一份牛奶 费用 =&quot;</span> + order.cost());</span><br><span class=\"line\">      System.out.println(<span class=\"string\">&quot;order 加入一份牛奶 描述 = &quot;</span> + order.getDes());</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// 3. order 加入一份巧克力</span></span><br><span class=\"line\"></span><br><span class=\"line\">      order = <span class=\"keyword\">new</span> <span class=\"title class_\">Chocolate</span>(order);</span><br><span class=\"line\"></span><br><span class=\"line\">      System.out.println(<span class=\"string\">&quot;order 加入一份牛奶 加入一份巧克力  费用 =&quot;</span> + order.cost());</span><br><span class=\"line\">      System.out.println(<span class=\"string\">&quot;order 加入一份牛奶 加入一份巧克力 描述 = &quot;</span> + order.getDes());</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// 3. order 加入一份巧克力</span></span><br><span class=\"line\"></span><br><span class=\"line\">      order = <span class=\"keyword\">new</span> <span class=\"title class_\">Chocolate</span>(order);</span><br><span class=\"line\"></span><br><span class=\"line\">      System.out.println(<span class=\"string\">&quot;order 加入一份牛奶 加入2份巧克力   费用 =&quot;</span> + order.cost());</span><br><span class=\"line\">      System.out.println(<span class=\"string\">&quot;order 加入一份牛奶 加入2份巧克力 描述 = &quot;</span> + order.getDes());</span><br><span class=\"line\">   </span><br><span class=\"line\">      System.out.println(<span class=\"string\">&quot;===========================&quot;</span>);</span><br><span class=\"line\">      </span><br><span class=\"line\">      <span class=\"type\">Drink</span> <span class=\"variable\">order2</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">DeCaf</span>();</span><br><span class=\"line\">      </span><br><span class=\"line\">      System.out.println(<span class=\"string\">&quot;order2 无因咖啡  费用 =&quot;</span> + order2.cost());</span><br><span class=\"line\">      System.out.println(<span class=\"string\">&quot;order2 无因咖啡 描述 = &quot;</span> + order2.getDes());</span><br><span class=\"line\">      </span><br><span class=\"line\">      order2 = <span class=\"keyword\">new</span> <span class=\"title class_\">Milk</span>(order2);</span><br><span class=\"line\">      </span><br><span class=\"line\">      System.out.println(<span class=\"string\">&quot;order2 无因咖啡 加入一份牛奶  费用 =&quot;</span> + order2.cost());</span><br><span class=\"line\">      System.out.println(<span class=\"string\">&quot;order2 无因咖啡 加入一份牛奶 描述 = &quot;</span> + order2.getDes());</span><br><span class=\"line\"></span><br><span class=\"line\">   </span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"装饰者模式原理\"><a href=\"#装饰者模式原理\" class=\"headerlink\" title=\"装饰者模式原理\"></a>装饰者模式原理</h2><ol>\n<li>装饰者模式就像打包一个快递</li>\n</ol>\n<p>主体：比如：陶瓷、衣服 (Component) &#x2F;&#x2F; 被装饰者 </p>\n<p>包装：比如：报纸填充、塑料泡沫、纸板、木板(Decorator) </p>\n<ol start=\"2\">\n<li><p>Component 主体：比如类似前面的 Drink </p>\n</li>\n<li><p>ConcreteComponent 和 Decorator</p>\n</li>\n</ol>\n<p>ConcreteComponent：具体的主体， 比如前面的各个单品咖啡 </p>\n<ol start=\"4\">\n<li>Decorator: 装饰者，比如各调料.</li>\n</ol>\n<p>在Component 与 ConcreteComponent 之间，如果 ConcreteComponent 类很多,还可以设计一个缓冲层，将 共有的部分提取出来，抽象层一个类</p>\n<h2 id=\"Java-IO-类的“奇怪”用法\"><a href=\"#Java-IO-类的“奇怪”用法\" class=\"headerlink\" title=\"Java IO 类的“奇怪”用法\"></a>Java IO 类的“奇怪”用法</h2><p>Java IO 类库非常庞大和复杂，有几十个类，负责 IO 数据的读取和写入。如果对 Java IO 类做一下分类，我们可以从下面两个维度将它划分为四类。具体如下所示：</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>字节流</th>\n<th>字符流</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>输入流</td>\n<td>InputStream</td>\n<td>Reader</td>\n</tr>\n<tr>\n<td>输出流</td>\n<td>OutputStream</td>\n<td>Writer</td>\n</tr>\n</tbody></table>\n<p>针对不同的读取和写入场景，Java IO 又在这四个父类基础之上，扩展出了很多子类。具体如下所示：</p>\n<img src=\"https://npm.elemecdn.com/youthlql@1.0.0/design_patterns/structural_type/04.01/0006.png\"/>\n\n\n\n<blockquote>\n<p>说明</p>\n<ol>\n<li>InputStream 是抽象类, 类似我们前面讲的 Drink</li>\n<li>FileInputStream 是  InputStream 子类，类似我们前面的 DeCaf, LongBlack</li>\n<li>FilterInputStream  是  InputStream 子类：类似我们前面 的 Decorator 修饰者</li>\n<li>DataInputStream 是 FilterInputStream 子类，具体的修饰者，类似前面的 Milk, Soy 等</li>\n<li>FilterInputStream 类 有  protected volatile InputStream in; 即含被装饰者</li>\n<li>分析得出在jdk 的io体系中，就是使用装饰者模式</li>\n</ol>\n</blockquote>\n<p>在我初学 Java 的时候，曾经对 Java IO 的一些用法产生过很大疑惑，比如下面这样一段代码。我们打开文件 test.txt，从中读取数据。其中，InputStream 是一个抽象类，FileInputStream 是专门用来读取文件流的子类。BufferedInputStream 是一个支持带缓存功能的数据读取类，可以提高数据读取的效率。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">InputStream</span> <span class=\"variable\">in</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">FileInputStream</span>(<span class=\"string\">&quot;/user/test.txt&quot;</span>);</span><br><span class=\"line\"><span class=\"type\">InputStream</span> <span class=\"variable\">bin</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">BufferedInputStream</span>(in);</span><br><span class=\"line\"><span class=\"type\">byte</span>[] data = <span class=\"keyword\">new</span> <span class=\"title class_\">byte</span>[<span class=\"number\">128</span>];</span><br><span class=\"line\"><span class=\"keyword\">while</span> (bin.read(data) != -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>初看上面的代码，我们会觉得 Java IO 的用法比较麻烦，需要先创建一个 FileInputStream 对象，然后再传递给 BufferedInputStream 对象来使用。我在想，Java IO 为什么不设计一个继承 FileInputStream 并且支持缓存的 BufferedFileInputStream 类呢？这样我们就可以像下面的代码中这样，直接创建一个 BufferedFileInputStream 类对象，打开文件读取数据，用起来岂不是更加简单？</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">InputStream</span> <span class=\"variable\">bin</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">BufferedFileInputStream</span>(<span class=\"string\">&quot;/user/test.txt&quot;</span>);</span><br><span class=\"line\"><span class=\"type\">byte</span>[] data = <span class=\"keyword\">new</span> <span class=\"title class_\">byte</span>[<span class=\"number\">128</span>];</span><br><span class=\"line\"><span class=\"keyword\">while</span> (bin.read(data) != -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h2 id=\"基于继承的设计方案\"><a href=\"#基于继承的设计方案\" class=\"headerlink\" title=\"基于继承的设计方案\"></a>基于继承的设计方案</h2><p>如果 InputStream 只有一个子类 FileInputStream 的话，那我们在 FileInputStream 基础之上，再设计一个孙子类 BufferedFileInputStream，也算是可以接受的，毕竟继承结构还算简单。但实际上，继承 InputStream 的子类有很多。我们需要给每一个 InputStream 的子类，再继续派生支持缓存读取的子类。</p>\n<p>除了支持缓存读取之外，如果我们还需要对功能进行其他方面的增强，比如下面的 DataInputStream 类，支持按照基本数据类型（int、boolean、long 等）来读取数据。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">FileInputStream</span> <span class=\"variable\">in</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">FileInputStream</span>(<span class=\"string\">&quot;/user/test.txt&quot;</span>);</span><br><span class=\"line\"><span class=\"type\">DataInputStream</span> <span class=\"variable\">din</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">DataInputStream</span>(in);</span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"variable\">data</span> <span class=\"operator\">=</span> din.readInt();</span><br></pre></td></tr></table></figure>\n\n<p>在这种情况下，如果我们继续按照继承的方式来实现的话，就需要再继续派生出 DataFileInputStream、DataPipedInputStream 等类。如果我们还需要既支持缓存、又支持按照基本类型读取数据的类，那就要再继续派生出 BufferedDataFileInputStream、BufferedDataPipedInputStream 等 n 多类。这还只是附加了两个增强功能，如果我们需要附加更多的增强功能，那就会导致组合爆炸，类继承结构变得无比复杂，代码既不好扩展，也不好维护。这也是我们不推荐使用继承的原因。</p>\n<h2 id=\"基于装饰器模式的设计方案\"><a href=\"#基于装饰器模式的设计方案\" class=\"headerlink\" title=\"基于装饰器模式的设计方案\"></a>基于装饰器模式的设计方案</h2><p>在前面，我们还讲到“组合优于继承”，可以“使用组合来替代继承”。针对刚刚的继承结构过于复杂的问题，我们可以通过将继承关系改为组合关系来解决。下面的代码展示了 Java IO 的这种设计思路。不过，我对代码做了简化，只抽象出了必要的代码结构，如果你感兴趣的话，可以直接去查看 JDK 源码。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.io.IOException;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">class</span> <span class=\"title class_\">InputStream</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">read</span><span class=\"params\">(<span class=\"type\">byte</span> b[])</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> read(b, <span class=\"number\">0</span>, b.length);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">read</span><span class=\"params\">(<span class=\"type\">byte</span> b[], <span class=\"type\">int</span> off, <span class=\"type\">int</span> len)</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"type\">long</span> <span class=\"title function_\">skip</span><span class=\"params\">(<span class=\"type\">long</span> n)</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">available</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">close</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title function_\">mark</span><span class=\"params\">(<span class=\"type\">int</span> readlimit)</span> &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title function_\">reset</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IOException</span>(<span class=\"string\">&quot;mark/reset not supported&quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">markSupported</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">BufferedInputStream</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">InputStream</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">protected</span> <span class=\"keyword\">volatile</span> InputStream in;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">protected</span> <span class=\"title function_\">BufferedInputStream</span><span class=\"params\">(InputStream in)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.in = in;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// ...实现基于缓存的读数据接口...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">DataInputStream</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">InputStream</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">protected</span> <span class=\"keyword\">volatile</span> InputStream in;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">protected</span> <span class=\"title function_\">DataInputStream</span><span class=\"params\">(InputStream in)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.in = in;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// ...实现读取基本类型数据的接口</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>看了上面的代码，你可能会问，那装饰器模式就是简单的“用组合替代继承”吗？当然不是。从 Java IO 的设计来看，装饰器模式相对于简单的组合关系，还有两个比较特殊的地方。</p>\n<p><strong>第一个比较特殊的地方是：装饰器类和原始类继承同样的父类，这样我们可以对原始类“嵌套”多个装饰器类。</strong>比如，下面这样一段代码，我们对 FileInputStream 嵌套了两个装饰器类：BufferedInputStream 和 DataInputStream，让它既支持缓存读取，又支持按照基本数据类型来读取数据。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">InputStream</span> <span class=\"variable\">in</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">FileInputStream</span>(<span class=\"string\">&quot;/user/test.txt&quot;</span>);</span><br><span class=\"line\"><span class=\"type\">InputStream</span> <span class=\"variable\">bin</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">BufferedInputStream</span>(in);</span><br><span class=\"line\"><span class=\"type\">DataInputStream</span> <span class=\"variable\">din</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">DataInputStream</span>(bin);</span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"variable\">data</span> <span class=\"operator\">=</span> din.readInt();</span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>第二个比较特殊的地方是：装饰器类是对功能的增强，这也是装饰器模式应用场景的一个重要特点。</strong>实际上，符合“组合关系”这种代码结构的设计模式有很多，比如之前讲过的代理模式、桥接模式，还有现在的装饰器模式。尽管它们的代码结构很相似，但是每种设计模式的意图是不同的。就拿比较相似的代理模式和装饰器模式来说吧，代理模式中，代理类附加的是跟原始类无关的功能，而在装饰器模式中，装饰器类附加的是跟原始类相关的增强功能。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 代理模式的代码结构(下面的接口也可以替换成抽象类)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">IA</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">f</span><span class=\"params\">()</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">A</span> impelements IA &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">f</span><span class=\"params\">()</span> &#123; </span><br><span class=\"line\">        <span class=\"comment\">//... </span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AProxy</span> impements IA &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> IA a;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">AProxy</span><span class=\"params\">(IA a)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.a = a;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">f</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 新添加的代理逻辑</span></span><br><span class=\"line\">        a.f();</span><br><span class=\"line\">        <span class=\"comment\">// 新添加的代理逻辑</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 装饰器模式的代码结构(下面的接口也可以替换成抽象类)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">IA</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">f</span><span class=\"params\">()</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">A</span> impelements IA &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">f</span><span class=\"params\">()</span> &#123; </span><br><span class=\"line\">        <span class=\"comment\">//... </span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ADecorator</span> impements IA &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> IA a;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">ADecorator</span><span class=\"params\">(IA a)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.a = a;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">f</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 功能增强代码</span></span><br><span class=\"line\">        a.f();</span><br><span class=\"line\">        <span class=\"comment\">// 功能增强代码</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<ol>\n<li>实际上，如果去查看 JDK 的源码，你会发现，BufferedInputStream、DataInputStream 并非继承自 InputStream，而是另外一个叫 FilterInputStream 的类。那这又是出于什么样的设计意图，才引入这样一个类呢？</li>\n<li>我们再重新来看一下 BufferedInputStream 类的代码。InputStream 是一个抽象类而非接口，而且它的大部分函数（比如 read()、available()）都有默认实现，按理来说，我们只需要在 BufferedInputStream 类中重新实现那些需要增加缓存功能的函数就可以了，其他函数继承 InputStream 的默认实现。但实际上，这样做是行不通的。</li>\n<li>对于即便是不需要增加缓存功能的函数来说，BufferedInputStream 还是必须把它重新实现一遍，简单包裹对 InputStream 对象的函数调用。具体的代码示例如下所示。如果不重新实现，那 BufferedInputStream 类就无法将最终读取数据的任务，委托给传递进来的 InputStream 对象来完成。这一部分稍微有点不好理解，你自己多思考一下。</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">BufferedInputStream</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">InputStream</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">volatile</span> InputStream in;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"title function_\">BufferedInputStream</span><span class=\"params\">(InputStream in)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.in = in;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// f()函数不需要增强，只是重新调用一下InputStream in对象的f()</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">f</span><span class=\"params\">()</span> &#123; </span><br><span class=\"line\">        in.f();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>实际上，DataInputStream 也存在跟 BufferedInputStream 同样的问题。为了避免代码重复，Java IO 抽象出了一个装饰器父类 FilterInputStream，代码实现如下所示。InputStream 的所有的装饰器类（BufferedInputStream、DataInputStream）都继承自这个装饰器父类。这样，装饰器类只需要实现它需要增强的方法就可以了，其他方法继承装饰器父类的默认实现。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">FilterInputStream</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">InputStream</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">volatile</span> InputStream in;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"title function_\">FilterInputStream</span><span class=\"params\">(InputStream in)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.in = in;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">read</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> in.read();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">read</span><span class=\"params\">(<span class=\"type\">byte</span> b[])</span> <span class=\"keyword\">throws</span> IOException &#123; </span><br><span class=\"line\">        <span class=\"keyword\">return</span> read(b, <span class=\"number\">0</span>, b.length);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">read</span><span class=\"params\">(<span class=\"type\">byte</span> b[], <span class=\"type\">int</span> off, <span class=\"type\">int</span> len)</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> in.read(b, off, len);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">long</span> <span class=\"title function_\">skip</span><span class=\"params\">(<span class=\"type\">long</span> n)</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> in.skip(n);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">available</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> in.available();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">close</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">        in.close();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title function_\">mark</span><span class=\"params\">(<span class=\"type\">int</span> readlimit)</span> &#123;</span><br><span class=\"line\">        in.mark(readlimit);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title function_\">reset</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">        in.reset();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">markSupported</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> in.markSupported();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h1 id=\"适配器模式【常用】\"><a href=\"#适配器模式【常用】\" class=\"headerlink\" title=\"适配器模式【常用】\"></a>适配器模式【常用】</h1><ol>\n<li>前面我们学了代理模式、桥接模式、装饰器模式，今天，我们再来学习一个比较常用的结构型模式：适配器模式。这个模式相对来说还是比较简单、好理解的，应用场景也很具体，总体上来讲比较好掌握。</li>\n<li>关于适配器模式，今天我们主要学习它的两种实现方式，类适配器和对象适配器，以及 5 种常见的应用场景。同时，我还会通过剖析 slf4j 日志框架，来给你展示这个模式在真实项目中的应用。除此之外，在文章的最后，我还对代理、桥接、装饰器、适配器，这 4 种代码结构非常相似的设计模式做简单的对比，对这几节内容做一个简单的总结。</li>\n<li>适配器模式(Adapter Pattern)将某个类的接口转换成客户端期望的另一个接口表示，<strong>主的目的是兼容性</strong>，让原本因接口不匹配不能一起工作的两个类可以协同工作。其别名为包装器(Wrapper) 。适配器模式属于结构型模式。主要分为三类：<strong>类适配器模式、对象适配器模式、接口适配器模</strong>式</li>\n</ol>\n<h2 id=\"Demo案例-充电器\"><a href=\"#Demo案例-充电器\" class=\"headerlink\" title=\"Demo案例-充电器\"></a>Demo案例-充电器</h2><p>基本介绍：Adapter 类，通过继承 src 类，实现 dst 类接口，完成 src-&gt;dst 的适配。</p>\n<ul>\n<li>以生活中充电器的例子来讲解适配器，充电器本身相当于 Adapter，220V 交流电相当于 src (即被适配者)，我们 的目 dst(即 目标)是 5V 直流电</li>\n</ul>\n<h3 id=\"类适配器代码实现\"><a href=\"#类适配器代码实现\" class=\"headerlink\" title=\"类适配器代码实现\"></a>类适配器代码实现</h3><h4 id=\"Voltage220V\"><a href=\"#Voltage220V\" class=\"headerlink\" title=\"Voltage220V\"></a>Voltage220V</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//被适配的类</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Voltage220V</span> &#123;</span><br><span class=\"line\">   <span class=\"comment\">//输出220V的电压</span></span><br><span class=\"line\">   <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">output220V</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">      <span class=\"type\">int</span> <span class=\"variable\">src</span> <span class=\"operator\">=</span> <span class=\"number\">220</span>;</span><br><span class=\"line\">      System.out.println(<span class=\"string\">&quot;电压=&quot;</span> + src + <span class=\"string\">&quot;伏&quot;</span>);</span><br><span class=\"line\">      <span class=\"keyword\">return</span> src;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"IVoltage5V\"><a href=\"#IVoltage5V\" class=\"headerlink\" title=\"IVoltage5V\"></a>IVoltage5V</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//适配接口</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">IVoltage5V</span> &#123;</span><br><span class=\"line\">   <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">output5V</span><span class=\"params\">()</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Phone\"><a href=\"#Phone\" class=\"headerlink\" title=\"Phone\"></a>Phone</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Phone</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">//充电</span></span><br><span class=\"line\">   <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">charging</span><span class=\"params\">(IVoltage5V iVoltage5V)</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(iVoltage5V.output5V() == <span class=\"number\">5</span>) &#123;</span><br><span class=\"line\">         System.out.println(<span class=\"string\">&quot;电压为5V, 可以充电~~&quot;</span>);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (iVoltage5V.output5V() &gt; <span class=\"number\">5</span>) &#123;</span><br><span class=\"line\">         System.out.println(<span class=\"string\">&quot;电压大于5V, 不能充电~~&quot;</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"VoltageAdapter\"><a href=\"#VoltageAdapter\" class=\"headerlink\" title=\"VoltageAdapter\"></a>VoltageAdapter</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//适配器类</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">VoltageAdapter</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Voltage220V</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">IVoltage5V</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"meta\">@Override</span></span><br><span class=\"line\">   <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">output5V</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// TODO Auto-generated method stub</span></span><br><span class=\"line\">      <span class=\"comment\">//获取到220V电压</span></span><br><span class=\"line\">      <span class=\"type\">int</span> <span class=\"variable\">srcV</span> <span class=\"operator\">=</span> output220V();</span><br><span class=\"line\">      <span class=\"type\">int</span> <span class=\"variable\">dstV</span> <span class=\"operator\">=</span> srcV / <span class=\"number\">44</span> ; <span class=\"comment\">//转成 5v</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> dstV;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Client-1\"><a href=\"#Client-1\" class=\"headerlink\" title=\"Client\"></a>Client</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Client</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// TODO Auto-generated method stub</span></span><br><span class=\"line\">      System.out.println(<span class=\"string\">&quot; === 类适配器模式 ====&quot;</span>);</span><br><span class=\"line\">      <span class=\"type\">Phone</span> <span class=\"variable\">phone</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Phone</span>();</span><br><span class=\"line\">      phone.charging(<span class=\"keyword\">new</span> <span class=\"title class_\">VoltageAdapter</span>());</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"对象适配器实现\"><a href=\"#对象适配器实现\" class=\"headerlink\" title=\"对象适配器实现\"></a>对象适配器实现</h3><p>基本思路和类的适配器模式相同，只是将 Adapter 类作修改，不是继承 src 类，而是持有 src 类的实例，以解决 兼容性的问题。 即：持有 src 类，实现 dst 类接口，完成 src-&gt;dst 的适配 ，在系统中尽量使用<strong>关联关系（聚合，组合）来替代继承</strong>关系。</p>\n<p>上面的例子代码基本没用什么改变，改变的只有以下两个类</p>\n<h4 id=\"VoltageAdapter-1\"><a href=\"#VoltageAdapter-1\" class=\"headerlink\" title=\"VoltageAdapter\"></a>VoltageAdapter</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 适配器类</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">VoltageAdapter</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">IVoltage5V</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> Voltage220V voltage220V; <span class=\"comment\">// 关联关系-聚合</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 通过构造器，传入一个 Voltage220V 实例</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"title function_\">VoltageAdapter</span><span class=\"params\">(Voltage220V voltage220v)</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.voltage220V = voltage220v;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">output5V</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">dst</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"literal\">null</span> != voltage220V) &#123;</span><br><span class=\"line\">      <span class=\"type\">int</span> <span class=\"variable\">src</span> <span class=\"operator\">=</span> voltage220V.output220V(); <span class=\"comment\">// 获取220V 电压</span></span><br><span class=\"line\">      System.out.println(<span class=\"string\">&quot;使用对象适配器，进行适配~~&quot;</span>);</span><br><span class=\"line\">      dst = src / <span class=\"number\">44</span>;</span><br><span class=\"line\">      System.out.println(<span class=\"string\">&quot;适配完成，输出的电压为=&quot;</span> + dst);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> dst;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Client-2\"><a href=\"#Client-2\" class=\"headerlink\" title=\"Client\"></a>Client</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Client</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// TODO Auto-generated method stub</span></span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot; === 对象适配器模式 ====&quot;</span>);</span><br><span class=\"line\">    <span class=\"type\">Phone</span> <span class=\"variable\">phone</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Phone</span>();</span><br><span class=\"line\">    phone.charging(<span class=\"keyword\">new</span> <span class=\"title class_\">VoltageAdapter</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">Voltage220V</span>()));</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h2 id=\"适配器模式的原理与实现\"><a href=\"#适配器模式的原理与实现\" class=\"headerlink\" title=\"适配器模式的原理与实现\"></a>适配器模式的原理与实现</h2><p>顾名思义，这个模式就是用来做适配的，它将不兼容的接口转换为可兼容的接口，让原本由于接口不兼容而不能一起工作的类可以一起工作。对于这个模式，有一个经常被拿来解释它的例子，就是 USB 转接头充当适配器，把两种不兼容的接口，通过转接变得可以一起工作。</p>\n<p>原理很简单，我们再来看下它的代码实现。适配器模式有两种实现方式：类适配器和对象适配器。其中，类适配器使用继承关系来实现，对象适配器使用组合关系来实现。具体的代码实现如下所示。其中，ITarget 表示要转化成的接口定义。Adaptee 是一组不兼容 ITarget 接口定义的接口，Adaptor 将 Adaptee 转化成一组符合 ITarget 接口定义的接口。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 类适配器: 基于继承</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">ITarget</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">f1</span><span class=\"params\">()</span>;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">f2</span><span class=\"params\">()</span>;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">fc</span><span class=\"params\">()</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Adaptee</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">fa</span><span class=\"params\">()</span> &#123; </span><br><span class=\"line\">        <span class=\"comment\">//... </span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">fb</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//... </span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">fc</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//... </span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Adaptor</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Adaptee</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">ITarget</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">f1</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">super</span>.fa();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">f2</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//...重新实现f2()...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 这里fc()不需要实现，直接继承自Adaptee，这是跟对象适配器最大的不同点</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 对象适配器：基于组合</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">ITarget</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">f1</span><span class=\"params\">()</span>;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">f2</span><span class=\"params\">()</span>;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">fc</span><span class=\"params\">()</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Adaptee</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">fa</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//... </span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">fb</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//... </span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">fc</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//... </span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Adaptor</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">ITarget</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Adaptee adaptee;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">Adaptor</span><span class=\"params\">(Adaptee adaptee)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.adaptee = adaptee;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">f1</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        adaptee.fa(); <span class=\"comment\">//委托给Adaptee</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">f2</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//...重新实现f2()...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">fc</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        adaptee.fc();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>针对这两种实现方式，在实际的开发中，到底该如何选择使用哪一种呢？判断的标准主要有两个，一个是 Adaptee 接口的个数，另一个是 Adaptee 和 ITarget 的契合程度。</p>\n<ul>\n<li>如果 Adaptee 接口并不多，那两种实现方式都可以。</li>\n<li>如果 Adaptee 接口很多，而且 Adaptee 和 ITarget 接口定义大部分都相同，那我们推荐使用类适配器，因为 Adaptor 复用父类 Adaptee 的接口，比起对象适配器的实现方式，Adaptor 的代码量要少一些。</li>\n<li>如果 Adaptee 接口很多，而且 Adaptee 和 ITarget 接口定义大部分都不相同，那我们推荐使用对象适配器，因为组合结构相对于继承更加灵活。</li>\n</ul>\n<h2 id=\"适配器模式应用场景总结\"><a href=\"#适配器模式应用场景总结\" class=\"headerlink\" title=\"适配器模式应用场景总结\"></a>适配器模式应用场景总结</h2><ol>\n<li><p>原理和实现讲完了，都不复杂。我们再来看，到底什么时候会用到适配器模式呢？</p>\n</li>\n<li><p>一般来说，适配器模式可以看作一种“补偿模式”，用来补救设计上的缺陷。应用这种模式算是“无奈之举”。如果在设计初期，我们就能协调规避接口不兼容的问题，那这种模式就没有应用的机会了。</p>\n</li>\n<li><p>前面我们反复提到，适配器模式的应用场景是“接口不兼容”。那在实际的开发中，什么情况下才会出现接口不兼容呢？我建议你先自己思考一下这个问题，然后再来看下面的总结 。</p>\n</li>\n</ol>\n<h3 id=\"封装有缺陷的接口设计\"><a href=\"#封装有缺陷的接口设计\" class=\"headerlink\" title=\"封装有缺陷的接口设计\"></a>封装有缺陷的接口设计</h3><ol>\n<li><p>假设我们依赖的外部系统在接口设计方面有缺陷（比如包含大量静态方法），引入之后会影响到我们自身代码的可测试性。为了隔离设计上的缺陷，我们希望对外部系统提供的接口进行二次封装，抽象出更好的接口设计，这个时候就可以使用适配器模式了。</p>\n</li>\n<li><p>具体我还是举个例子来解释一下，你直接看代码应该会更清晰。具体代码如下所示：</p>\n</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">CD</span> &#123; <span class=\"comment\">//这个类来自外部sdk，我们无权修改它的代码</span></span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">staticFunction1</span><span class=\"params\">()</span> &#123; <span class=\"comment\">//... &#125;</span></span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">uglyNamingFunction2</span><span class=\"params\">()</span> &#123; <span class=\"comment\">//... &#125;</span></span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">tooManyParamsFunction3</span><span class=\"params\">(<span class=\"type\">int</span> paramA, <span class=\"type\">int</span> paramB, ...)</span> &#123; <span class=\"comment\">//... &#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">lowPerformanceFunction4</span><span class=\"params\">()</span> &#123; <span class=\"comment\">//... &#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用适配器模式进行重构</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ITarget</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">function1</span><span class=\"params\">()</span>;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">function2</span><span class=\"params\">()</span>;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">fucntion3</span><span class=\"params\">(ParamsWrapperDefinition paramsWrapper)</span>;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">function4</span><span class=\"params\">()</span>;</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 注意：适配器类的命名不一定非得末尾带Adaptor</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">CDAdaptor</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">CD</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">ITarget</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">function1</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">super</span>.staticFunction1();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">function2</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">super</span>.uglyNamingFucntion2();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">function3</span><span class=\"params\">(ParamsWrapperDefinition paramsWrapper)</span> &#123; </span><br><span class=\"line\">        <span class=\"built_in\">super</span>.tooManyParamsFunction3(paramsWrapper.getParamA(), ...);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">function4</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//...reimplement it...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"统一多个类的接口设计\"><a href=\"#统一多个类的接口设计\" class=\"headerlink\" title=\"统一多个类的接口设计\"></a>统一多个类的接口设计</h3><ol>\n<li>某个功能的实现依赖多个外部系统（或者说类）。通过适配器模式，将它们的接口适配为统一的接口定义，然后我们就可以使用多态的特性来复用代码逻辑。具体我还是举个例子来解释一下。</li>\n<li>假设我们的系统要对用户输入的文本内容做敏感词过滤，为了提高过滤的召回率，我们引入了多款第三方敏感词过滤系统，依次对用户输入的内容进行过滤，过滤掉尽可能多的敏感词。但是，每个系统提供的过滤接口都是不同的。这就意味着我们没法复用一套逻辑来调用各个系统。这个时候，我们就可以使用适配器模式，将所有系统的接口适配为统一的接口定义，这样我们可以复用调用敏感词过滤的代码。</li>\n<li>你可以配合着下面的代码示例，来理解我刚才举的这个例子。</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.ArrayList;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.List;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ASensitiveWordsFilter</span> &#123; <span class=\"comment\">// A敏感词过滤系统提供的接口</span></span><br><span class=\"line\">  <span class=\"comment\">// text是原始文本，函数输出用***替换敏感词之后的文本</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> String <span class=\"title function_\">filterSexyWords</span><span class=\"params\">(String text)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> String <span class=\"title function_\">filterPoliticalWords</span><span class=\"params\">(String text)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">BSensitiveWordsFilter</span> &#123; <span class=\"comment\">// B敏感词过滤系统提供的接口</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> String <span class=\"title function_\">filter</span><span class=\"params\">(String text)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">CSensitiveWordsFilter</span> &#123; <span class=\"comment\">// C敏感词过滤系统提供的接口</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> String <span class=\"title function_\">filter</span><span class=\"params\">(String text, String mask)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 未使用适配器模式之前的代码：代码的可测试性、扩展性不好</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">RiskManagement</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"type\">ASensitiveWordsFilter</span> <span class=\"variable\">aFilter</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ASensitiveWordsFilter</span>();</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"type\">BSensitiveWordsFilter</span> <span class=\"variable\">bFilter</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">BSensitiveWordsFilter</span>();</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"type\">CSensitiveWordsFilter</span> <span class=\"variable\">cFilter</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">CSensitiveWordsFilter</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> String <span class=\"title function_\">filterSensitiveWords</span><span class=\"params\">(String text)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">maskedText</span> <span class=\"operator\">=</span> aFilter.filterSexyWords(text);</span><br><span class=\"line\">    maskedText = aFilter.filterPoliticalWords(maskedText);</span><br><span class=\"line\">    maskedText = bFilter.filter(maskedText);</span><br><span class=\"line\">    maskedText = cFilter.filter(maskedText, <span class=\"string\">&quot;***&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> maskedText;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用适配器模式进行改造</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">ISensitiveWordsFilter</span> &#123; <span class=\"comment\">// 统一接口定义</span></span><br><span class=\"line\">  String <span class=\"title function_\">filter</span><span class=\"params\">(String text)</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ASensitiveWordsFilterAdaptor</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">ISensitiveWordsFilter</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> ASensitiveWordsFilter aFilter;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> String <span class=\"title function_\">filter</span><span class=\"params\">(String text)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">maskedText</span> <span class=\"operator\">=</span> aFilter.filterSexyWords(text);</span><br><span class=\"line\">    maskedText = aFilter.filterPoliticalWords(maskedText);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> maskedText;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ...省略BSensitiveWordsFilterAdaptor、CSensitiveWordsFilterAdaptor...</span></span><br><span class=\"line\"><span class=\"comment\">// 扩展性更好，更加符合开闭原则，如果添加一个新的敏感词过滤系统，</span></span><br><span class=\"line\"><span class=\"comment\">// 这个类完全不需要改动；而且基于接口而非实现编程，代码的可测试性更好。</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">RiskManagement</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> List&lt;ISensitiveWordsFilter&gt; filters = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">addSensitiveWordsFilter</span><span class=\"params\">(ISensitiveWordsFilter filter)</span> &#123;</span><br><span class=\"line\">    filters.add(filter);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> String <span class=\"title function_\">filterSensitiveWords</span><span class=\"params\">(String text)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">maskedText</span> <span class=\"operator\">=</span> text;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (ISensitiveWordsFilter filter : filters) &#123;</span><br><span class=\"line\">      maskedText = filter.filter(maskedText);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> maskedText;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"替换依赖的外部系统\"><a href=\"#替换依赖的外部系统\" class=\"headerlink\" title=\"替换依赖的外部系统\"></a>替换依赖的外部系统</h3><p>当我们把项目中依赖的一个外部系统替换为另一个外部系统的时候，利用适配器模式，可以减少对代码的改动。具体的代码示例如下所示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 外部系统A</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>  <span class=\"keyword\">interface</span>  <span class=\"title class_\">IA</span>  &#123;</span><br><span class=\"line\"><span class=\"comment\">//...</span></span><br><span class=\"line\">  <span class=\"keyword\">void</span>  <span class=\"title function_\">fa</span><span class=\"params\">()</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span>  <span class=\"keyword\">class</span>  <span class=\"title class_\">A</span>  <span class=\"keyword\">implements</span>  <span class=\"title class_\">IA</span>  &#123;</span><br><span class=\"line\"><span class=\"comment\">//...</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span>  <span class=\"keyword\">void</span>  <span class=\"title function_\">fa</span><span class=\"params\">()</span>  &#123; </span><br><span class=\"line\">    <span class=\"comment\">//... </span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 在我们的项目中，外部系统A的使用示例</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>  <span class=\"keyword\">class</span>  <span class=\"title class_\">Demo</span>  &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> IA a;</span><br><span class=\"line\">  <span class=\"keyword\">public</span>  <span class=\"title function_\">Demo</span><span class=\"params\">(IA a)</span>  &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.a = a;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//... </span></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">Demo</span> <span class=\"variable\">d</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Demo</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">A</span>());</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 将外部系统A替换成外部系统B</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>  <span class=\"keyword\">class</span>  <span class=\"title class_\">BAdaptor</span>  implemnts  IA  &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> B b;</span><br><span class=\"line\">  <span class=\"keyword\">public</span>  <span class=\"title function_\">BAdaptor</span><span class=\"params\">(B b)</span>  &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.b= b;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span>  <span class=\"keyword\">void</span>  <span class=\"title function_\">fa</span><span class=\"params\">()</span>  &#123;</span><br><span class=\"line\">  <span class=\"comment\">//...</span></span><br><span class=\"line\">    b.fb();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 借助BAdaptor，Demo的代码中，调用IA接口的地方都无需改动，</span></span><br><span class=\"line\"><span class=\"comment\">// 只需要将BAdaptor如下注入到Demo即可。</span></span><br><span class=\"line\"><span class=\"type\">Demo</span> <span class=\"variable\">d</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Demo</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">BAdaptor</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">B</span>()));</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"兼容老版本接口\"><a href=\"#兼容老版本接口\" class=\"headerlink\" title=\"兼容老版本接口\"></a>兼容老版本接口</h3><ol>\n<li>在做版本升级的时候，对于一些要废弃的接口，我们不直接将其删除，而是暂时保留，并且标注为 deprecated，并将内部实现逻辑委托为新的接口实现。这样做的好处是，让使用它的项目有个过渡期，而不是强制进行代码修改。这也可以粗略地看作适配器模式的一个应用场景。同样，我还是通过一个例子，来进一步解释一下。</li>\n<li>JDK1.0 中包含一个遍历集合容器的类 Enumeration。JDK2.0 对这个类进行了重构，将它改名为 Iterator 类，并且对它的代码实现做了优化。但是考虑到如果将 Enumeration 直接从 JDK2.0 中删除，那使用 JDK1.0 的项目如果切换到 JDK2.0，代码就会编译不通过。为了避免这种情况的发生，我们必须把项目中所有使用到 Enumeration 的地方，都修改为使用 Iterator 才行。</li>\n<li>单独一个项目做 Enumeration 到 Iterator 的替换，勉强还能接受。但是，使用 Java 开发的项目太多了，一次 JDK 的升级，导致所有的项目不做代码修改就会编译报错，这显然是不合理的。这就是我们经常所说的不兼容升级。为了做到兼容使用低版本 JDK 的老代码，我们可以暂时保留 Enumeration 类，并将其实现替换为直接调用 Itertor。代码示例如下所示：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span>  <span class=\"keyword\">class</span>  <span class=\"title class_\">Collections</span>  &#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span>  <span class=\"keyword\">static</span> Emueration <span class=\"title function_\">emumeration</span><span class=\"params\">(<span class=\"keyword\">final</span> Collection c)</span>  &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>  <span class=\"keyword\">new</span> <span class=\"title class_\">Enumeration</span>() &#123;</span><br><span class=\"line\">      <span class=\"type\">Iterator</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> c.iterator();</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">hasMoreElments</span><span class=\"params\">()</span>  &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> i.hashNext();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">public</span> Object <span class=\"title function_\">nextElement</span><span class=\"params\">()</span>  &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> i.next():</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"适配不同格式的数据\"><a href=\"#适配不同格式的数据\" class=\"headerlink\" title=\"适配不同格式的数据\"></a>适配不同格式的数据</h3><p>前面我们讲到，适配器模式主要用于接口的适配，实际上，它还可以用在不同格式的数据之间的适配。比如，把从不同征信系统拉取的不同格式的征信数据，统一为相同的格式，以方便存储和使用。再比如，Java 中的 Arrays.asList() 也可以看作一种数据适配器，将数组类型的数据转化为集合容器类型。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;String&gt; stooges = Arrays.asList(<span class=\"string\">&quot;Larry&quot;</span>, <span class=\"string\">&quot;Moe&quot;</span>, <span class=\"string\">&quot;Curly&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h3 id=\"剖析适配器模式在-Java-日志中的应用\"><a href=\"#剖析适配器模式在-Java-日志中的应用\" class=\"headerlink\" title=\"剖析适配器模式在 Java 日志中的应用\"></a>剖析适配器模式在 Java 日志中的应用</h3><ol>\n<li>Java 中有很多日志框架，在项目开发中，我们常常用它们来打印日志信息。其中，比较常用的有 log4j、logback，以及 JDK 提供的 JUL(java.util.logging) 和 Apache 的 JCL(Jakarta Commons Logging) 等。</li>\n<li>大部分日志框架都提供了相似的功能，比如按照不同级别（debug、info、warn、erro……）打印日志等，但它们却并没有实现统一的接口。这主要可能是历史的原因，它不像 JDBC 那样，一开始就制定了数据库操作的接口规范。</li>\n<li>如果我们只是开发一个自己用的项目，那用什么日志框架都可以，log4j、logback 随便选一个就好。但是，如果我们开发的是一个集成到其他系统的组件、框架、类库等，那日志框架的选择就没那么随意了。</li>\n<li>比如，项目中用到的某个组件使用 log4j 来打印日志，而我们项目本身使用的是 logback。将组件引入到项目之后，我们的项目就相当于有了两套日志打印框架。每种日志框架都有自己特有的配置方式。所以，我们要针对每种日志框架编写不同的配置文件（比如，日志存储的文件地址、打印日志的格式）。如果引入多个组件，每个组件使用的日志框架都不一样，那日志本身的管理工作就变得非常复杂。所以，为了解决这个问题，我们需要统一日志打印框架。</li>\n<li>如果你是做 Java 开发的，那 Slf4j 这个\b日志框架你肯定不陌生，它相当于 JDBC 规范，提供了一套打印日志的统一接口规范。不过，它只定义了接口，并没有提供具体的实现，需要配合其他日志框架（log4j、logback……）来使用。</li>\n<li>不仅如此，Slf4j 的出现晚于 JUL、JCL、log4j 等日志框架，所以，这些日志框架也不可能牺牲掉版本兼容性，将接口改造成符合 Slf4j 接口规范。Slf4j 也事先考虑到了这个问题，所以，它不仅仅提供了统一的接口定义，还提供了针对不同日志框架的适配器。对不同日志框架的接口进行二次封装，适配成统一的 Slf4j 接口定义。具体的代码示例如下所示：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// slf4j统一的接口定义</span></span><br><span class=\"line\"><span class=\"keyword\">package</span> org.slf4j;</span><br><span class=\"line\"><span class=\"keyword\">public</span>  <span class=\"keyword\">interface</span> <span class=\"title class_\">Logger</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span>  <span class=\"type\">boolean</span> <span class=\"title function_\">isTraceEnabled</span><span class=\"params\">()</span>;</span><br><span class=\"line\">  <span class=\"keyword\">public</span>  <span class=\"keyword\">void</span> <span class=\"title function_\">trace</span><span class=\"params\">(String msg)</span>;</span><br><span class=\"line\">  <span class=\"keyword\">public</span>  <span class=\"keyword\">void</span> <span class=\"title function_\">trace</span><span class=\"params\">(String format, Object arg)</span>;</span><br><span class=\"line\">  <span class=\"keyword\">public</span>  <span class=\"keyword\">void</span> <span class=\"title function_\">trace</span><span class=\"params\">(String format, Object arg1, Object arg2)</span>;</span><br><span class=\"line\">  <span class=\"keyword\">public</span>  <span class=\"keyword\">void</span> <span class=\"title function_\">trace</span><span class=\"params\">(String format, Object[] argArray)</span>;</span><br><span class=\"line\">  <span class=\"keyword\">public</span>  <span class=\"keyword\">void</span> <span class=\"title function_\">trace</span><span class=\"params\">(String msg, Throwable t)</span>;</span><br><span class=\"line\">  <span class=\"keyword\">public</span>  <span class=\"type\">boolean</span> <span class=\"title function_\">isDebugEnabled</span><span class=\"params\">()</span>;</span><br><span class=\"line\">  <span class=\"keyword\">public</span>  <span class=\"keyword\">void</span> <span class=\"title function_\">debug</span><span class=\"params\">(String msg)</span>;</span><br><span class=\"line\">  <span class=\"keyword\">public</span>  <span class=\"keyword\">void</span> <span class=\"title function_\">debug</span><span class=\"params\">(String format, Object arg)</span>;</span><br><span class=\"line\">  <span class=\"keyword\">public</span>  <span class=\"keyword\">void</span> <span class=\"title function_\">debug</span><span class=\"params\">(String format, Object arg1, Object arg2)</span>;</span><br><span class=\"line\">  <span class=\"keyword\">public</span>  <span class=\"keyword\">void</span> <span class=\"title function_\">debug</span><span class=\"params\">(String format, Object[] argArray)</span>;</span><br><span class=\"line\">  <span class=\"keyword\">public</span>  <span class=\"keyword\">void</span> <span class=\"title function_\">debug</span><span class=\"params\">(String msg, Throwable t)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//...省略info、warn、error等一堆接口</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// log4j日志框架的适配器</span></span><br><span class=\"line\"><span class=\"comment\">// Log4jLoggerAdapter实现了LocationAwareLogger接口，</span></span><br><span class=\"line\"><span class=\"comment\">// 其中LocationAwareLogger继承自Logger接口，</span></span><br><span class=\"line\"><span class=\"comment\">// 也就相当于Log4jLoggerAdapter实现了Logger接口。</span></span><br><span class=\"line\"><span class=\"keyword\">package</span> org.slf4j.impl;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Log4jLoggerAdapter</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">MarkerIgnoringBase</span></span><br><span class=\"line\">        <span class=\"keyword\">implements</span> <span class=\"title class_\">LocationAwareLogger</span>, Serializable &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">final</span> <span class=\"keyword\">transient</span> org.apache.log4j.Logger logger; <span class=\"comment\">// log4j</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span>  <span class=\"type\">boolean</span> <span class=\"title function_\">isDebugEnabled</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> logger.isDebugEnabled();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span>  <span class=\"keyword\">void</span> <span class=\"title function_\">debug</span><span class=\"params\">(String msg)</span> &#123;</span><br><span class=\"line\">    logger.log(FQCN, Level.DEBUG, msg, <span class=\"literal\">null</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span>  <span class=\"keyword\">void</span> <span class=\"title function_\">debug</span><span class=\"params\">(String format, Object arg)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class=\"line\">      <span class=\"type\">FormattingTuple</span> <span class=\"variable\">ft</span> <span class=\"operator\">=</span> MessageFormatter.format(format, arg);</span><br><span class=\"line\">      logger.log(FQCN, Level.DEBUG, ft.getMessage(), ft.getThrowable());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span>  <span class=\"keyword\">void</span> <span class=\"title function_\">debug</span><span class=\"params\">(String format, Object arg1, Object arg2)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class=\"line\">      <span class=\"type\">FormattingTuple</span> <span class=\"variable\">ft</span> <span class=\"operator\">=</span> MessageFormatter.format(format, arg1, arg2);</span><br><span class=\"line\">      logger.log(FQCN, Level.DEBUG, ft.getMessage(), ft.getThrowable());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span>  <span class=\"keyword\">void</span> <span class=\"title function_\">debug</span><span class=\"params\">(String format, Object\\[\\] argArray)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class=\"line\">      <span class=\"type\">FormattingTuple</span> <span class=\"variable\">ft</span> <span class=\"operator\">=</span> MessageFormatter.arrayFormat(format, argArray);</span><br><span class=\"line\">      logger.log(FQCN, Level.DEBUG, ft.getMessage(), ft.getThrowable());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span>  <span class=\"keyword\">void</span> <span class=\"title function_\">debug</span><span class=\"params\">(String msg, Throwable t)</span> &#123;</span><br><span class=\"line\">    logger.log(FQCN, Level.DEBUG, msg, t);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//...省略一堆接口的实现...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<ol>\n<li>所以，在开发业务系统或者开发框架、组件的时候，我们统一使用 Slf4j 提供的接口来编写打印日志的代码，具体使用哪种日志框架实现（log4j、logback……），是可以动态地指定的（使用 Java 的 SPI 技术，这里我不多解释，你自行研究吧），只需要将相应的 SDK 导入到项目中即可。</li>\n<li>不过，你可能会说，如果一些老的项目没有使用 Slf4j，而是直接使用比如 JCL 来打印日志，那如果想要替换成其他日志框架，比如 log4j，该怎么办呢？实际上，Slf4j 不仅仅提供了从其他日志框架到 Slf4j 的适配器，还提供了反向适配器，也就是从 Slf4j 到其他日志框架的适配。我们可以先将 JCL 切换为 Slf4j，然后再将 Slf4j 切换为 log4j。经过两次适配器的转换，我们能就成功将 log4j 切换为了 logback。</li>\n</ol>\n<h2 id=\"代理、桥接、装饰器、适配器-4-种设计模式的区别\"><a href=\"#代理、桥接、装饰器、适配器-4-种设计模式的区别\" class=\"headerlink\" title=\"代理、桥接、装饰器、适配器 4 种设计模式的区别\"></a>代理、桥接、装饰器、适配器 4 种设计模式的区别</h2><ol>\n<li><p>代理、桥接、装饰器、适配器，这 4 种模式是比较常用的结构型设计模式。它们的代码结构非常相似。笼统来说，它们都可以称为 Wrapper 模式，也就是通过 Wrapper 类二次封装原始类。</p>\n</li>\n<li><p>尽管代码结构相似，但这 4 种设计模式的用意完全不同，也就是说要解决的问题、应用场景不同，这也是它们的主要区别。这里我就简单说一下它们之间的区别。</p>\n</li>\n</ol>\n<ul>\n<li>代理模式：在不改变原始类接口的条件下，为原始类定义一个代理类，主要目的是控制访问，而非加强功能，这是它跟装饰器模式最大的不同。</li>\n<li>桥接模式：目的是将接口部分和实现部分分离，从而让它们可以较为容易、也相对独立地加以改变。</li>\n<li>装饰者模式：在不改变原始类接口的情况下，对原始类功能进行增强，并且支持多个装饰器的嵌套使用。</li>\n<li>适配器模式：是一种事后的补救策略。适配器提供跟原始类不同的接口，而代理模式、装饰器模式提供的都是跟原始类相同的接口。</li>\n</ul>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cly2c4k3g0001qsvd5x9u92qd","category_id":"cly2c4k3i0002qsvd8i56ajpj","_id":"cly2c4k3o0009qsvd291ah5fj"},{"post_id":"cly2c4k3k0004qsvd0r0bgq6a","category_id":"cly2c4k3n0007qsvdhh89brbl","_id":"cly2c4k3p000dqsvdb4f4awy5"},{"post_id":"cly2c4k3b0000qsvd8a0xd2z1","category_id":"cly2c4k3i0002qsvd8i56ajpj","_id":"cly2c4k3p000hqsvdg4ohewjy"},{"post_id":"cly2c4k3b0000qsvd8a0xd2z1","category_id":"cly2c4k3o000aqsvdeeva25uc","_id":"cly2c4k3p000jqsvd2qdz9fl0"},{"post_id":"cly2c4k3s000tqsvd8obm795n","category_id":"cly2c4k3u000vqsvdhhd87p2i","_id":"cly2c4k3x0019qsvd9wsqejv9"},{"post_id":"cly2c4k3s000tqsvd8obm795n","category_id":"cly2c4k3w0013qsvd8q10f75g","_id":"cly2c4k3x001dqsvd8lv8536k"},{"post_id":"cly2c4k3t000uqsvd9if07q1c","category_id":"cly2c4k3u000vqsvdhhd87p2i","_id":"cly2c4k3y001eqsvdf60nc2nf"},{"post_id":"cly2c4k3t000uqsvd9if07q1c","category_id":"cly2c4k3w0016qsvdgiwq2yu5","_id":"cly2c4k3y001gqsvd8gm255rf"},{"post_id":"cly2c4k3u000xqsvd4tr9564x","category_id":"cly2c4k3u000vqsvdhhd87p2i","_id":"cly2c4k3y001hqsvd8nrw09as"},{"post_id":"cly2c4k3u000xqsvd4tr9564x","category_id":"cly2c4k3x001bqsvdgqto5pbi","_id":"cly2c4k3y001jqsvdg9uhdsg5"},{"post_id":"cly2c4k3z001oqsvde8fb61mu","category_id":"cly2c4k3u000vqsvdhhd87p2i","_id":"cly2c4k41001qqsvdfe9r4psb"},{"post_id":"cly2c4k3z001oqsvde8fb61mu","category_id":"cly2c4k3x001bqsvdgqto5pbi","_id":"cly2c4k41001rqsvdbddlgg4l"},{"post_id":"cly2c4k41001uqsvd120ugq8t","category_id":"cly2c4k3u000vqsvdhhd87p2i","_id":"cly2c4k42001yqsvdb1sj92jz"},{"post_id":"cly2c4k41001uqsvd120ugq8t","category_id":"cly2c4k42001wqsvd51enb43z","_id":"cly2c4k430020qsvdc7104o4t"}],"PostTag":[{"post_id":"cly2c4k3b0000qsvd8a0xd2z1","tag_id":"cly2c4k3k0003qsvdagfh0eyc","_id":"cly2c4k3p000cqsvd5iuyax0q"},{"post_id":"cly2c4k3b0000qsvd8a0xd2z1","tag_id":"cly2c4k3l0006qsvd3ob8dpnq","_id":"cly2c4k3p000eqsvder295gsp"},{"post_id":"cly2c4k3b0000qsvd8a0xd2z1","tag_id":"cly2c4k3n0008qsvd3ph87362","_id":"cly2c4k3p000gqsvd3zwhbvjy"},{"post_id":"cly2c4k3g0001qsvd5x9u92qd","tag_id":"cly2c4k3o000bqsvd98lbdr81","_id":"cly2c4k3q000lqsvdhk6871vg"},{"post_id":"cly2c4k3g0001qsvd5x9u92qd","tag_id":"cly2c4k3p000fqsvd4ddrcql8","_id":"cly2c4k3q000mqsvd6mwzh0a4"},{"post_id":"cly2c4k3g0001qsvd5x9u92qd","tag_id":"cly2c4k3p000iqsvdgay0cqwc","_id":"cly2c4k3q000oqsvdeeve82sy"},{"post_id":"cly2c4k3k0004qsvd0r0bgq6a","tag_id":"cly2c4k3o000bqsvd98lbdr81","_id":"cly2c4k3r000qqsvddchc3fa3"},{"post_id":"cly2c4k3k0004qsvd0r0bgq6a","tag_id":"cly2c4k3q000nqsvd1fpddgm5","_id":"cly2c4k3r000rqsvdada89lo4"},{"post_id":"cly2c4k3k0004qsvd0r0bgq6a","tag_id":"cly2c4k3q000pqsvdau5w3lbr","_id":"cly2c4k3r000sqsvd6hln2bme"},{"post_id":"cly2c4k3s000tqsvd8obm795n","tag_id":"cly2c4k3u000wqsvd7etehpni","_id":"cly2c4k3w0012qsvdahqmgg19"},{"post_id":"cly2c4k3s000tqsvd8obm795n","tag_id":"cly2c4k3v000zqsvdgc9834oq","_id":"cly2c4k3w0014qsvdg87qaee6"},{"post_id":"cly2c4k3t000uqsvd9if07q1c","tag_id":"cly2c4k3u000wqsvd7etehpni","_id":"cly2c4k3x0018qsvd0yngf53a"},{"post_id":"cly2c4k3t000uqsvd9if07q1c","tag_id":"cly2c4k3w0015qsvdao4yexa1","_id":"cly2c4k3x001aqsvdf4wzf9fh"},{"post_id":"cly2c4k3u000xqsvd4tr9564x","tag_id":"cly2c4k3u000wqsvd7etehpni","_id":"cly2c4k3y001kqsvd8ne35s90"},{"post_id":"cly2c4k3u000xqsvd4tr9564x","tag_id":"cly2c4k3x001cqsvdh1emh1f5","_id":"cly2c4k3y001lqsvdccilbrgr"},{"post_id":"cly2c4k3u000xqsvd4tr9564x","tag_id":"cly2c4k3y001fqsvdaj517r5u","_id":"cly2c4k3y001mqsvd3yub0np1"},{"post_id":"cly2c4k3u000xqsvd4tr9564x","tag_id":"cly2c4k3y001iqsvd4ou429ay","_id":"cly2c4k3z001nqsvdcjor42kd"},{"post_id":"cly2c4k3z001oqsvde8fb61mu","tag_id":"cly2c4k3u000wqsvd7etehpni","_id":"cly2c4k41001sqsvd6ptl21ab"},{"post_id":"cly2c4k3z001oqsvde8fb61mu","tag_id":"cly2c4k40001pqsvdfwktbrad","_id":"cly2c4k41001tqsvd2kse70s0"},{"post_id":"cly2c4k41001uqsvd120ugq8t","tag_id":"cly2c4k3u000wqsvd7etehpni","_id":"cly2c4k430022qsvd4do7673r"},{"post_id":"cly2c4k41001uqsvd120ugq8t","tag_id":"cly2c4k42001vqsvddz5d16nn","_id":"cly2c4k430023qsvd0v6y73v3"},{"post_id":"cly2c4k41001uqsvd120ugq8t","tag_id":"cly2c4k42001xqsvda85dg2r5","_id":"cly2c4k430024qsvdhgph8oco"},{"post_id":"cly2c4k41001uqsvd120ugq8t","tag_id":"cly2c4k43001zqsvd3xjjb1po","_id":"cly2c4k430025qsvdey9ac9i3"},{"post_id":"cly2c4k41001uqsvd120ugq8t","tag_id":"cly2c4k430021qsvd2jmigsvf","_id":"cly2c4k430026qsvd5l9xd50n"}],"Tag":[{"name":"Java8","_id":"cly2c4k3k0003qsvdagfh0eyc"},{"name":"JDK8","_id":"cly2c4k3l0006qsvd3ob8dpnq"},{"name":"新特性","_id":"cly2c4k3n0008qsvd3ph87362"},{"name":"Java","_id":"cly2c4k3o000bqsvd98lbdr81"},{"name":"并发","_id":"cly2c4k3p000fqsvd4ddrcql8"},{"name":"CompletableFuture","_id":"cly2c4k3p000iqsvdgay0cqwc"},{"name":"对象储存","_id":"cly2c4k3q000nqsvd1fpddgm5"},{"name":"Minio","_id":"cly2c4k3q000pqsvdau5w3lbr"},{"name":"设计模式","_id":"cly2c4k3u000wqsvd7etehpni"},{"name":"设计思想","_id":"cly2c4k3v000zqsvdgc9834oq"},{"name":"设计原则","_id":"cly2c4k3w0015qsvdao4yexa1"},{"name":"工厂","_id":"cly2c4k3x001cqsvdh1emh1f5"},{"name":"建造者","_id":"cly2c4k3y001fqsvdaj517r5u"},{"name":"原型","_id":"cly2c4k3y001iqsvd4ou429ay"},{"name":"单例","_id":"cly2c4k40001pqsvdfwktbrad"},{"name":"代理模式","_id":"cly2c4k42001vqsvddz5d16nn"},{"name":"桥接模式","_id":"cly2c4k42001xqsvda85dg2r5"},{"name":"装饰器模式","_id":"cly2c4k43001zqsvd3xjjb1po"},{"name":"适配器模式","_id":"cly2c4k430021qsvd2jmigsvf"}]}}